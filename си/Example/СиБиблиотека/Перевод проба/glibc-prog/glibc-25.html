<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Пользователи и Группы</TITLE>
 <LINK HREF="glibc-26.html" REL=next>
 <LINK HREF="glibc-24.html" REL=previous>
 <LINK HREF="glibc.html#toc25" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-26.html">Вперед</A>
<A HREF="glibc-24.html">Назад</A>
<A HREF="glibc.html#toc25">Содержание</A>
<HR>
<H2><A NAME="s25">25. Пользователи и Группы</A></H2>

<P>
<P>
<P>Каждый пользователь, кто может войти в систему, идентифицирован 
уникальным числом называемым пользовательский ID.
<P>Каждый процесс имеет эффективный пользовательский ID, который 
говорит, какие права доступа пользователя он имеет.
<P>Пользователи классифицированы в группы для целей управления 
доступом. Каждый процесс имеет одно или большее количество значений 
ID группы, которые говорят, которую группу процесс может 
использовать для доступа к файлам.
<P>Эффективные пользовательский ID и групповой ID процесса 
формируют persona(владельца) процесса. Он определяет, к которым 
файлам процесс может обращаться. Обычно, процесс наследует persona 
из родительского процесса, но при специальных обстоятельствах, 
процесс может изменять persona и таким образом изменять права 
доступа.
<P>Каждый файл в системе также имеет пользовательский ID и ID 
группы. Управление доступом работает,  сравнивая ID пользователя и 
группы файла с таковыми выполняющегося процесса.
<P>Система хранит базу данных всех зарегистрированных 
пользователей, и другую базу данных всех определенных групп. 
Имеются библиотечные функции, которые Вы можете использовать, чтобы 
исследовать эти базы данных.
<P>
<H2><A NAME="ss25.1">25.1 ID пользователя и группы</A>
</H2>

<P>
<P>
<P>Каждый пользователь компьютерной системы идентифицирован именем 
пользователя (или именем входа в систему) и пользовательским ID. 
Обычно, каждое имя пользователя имеет уникальный пользовательский 
ID, но возможно для отдельных имен входа в систему, иметь тот же 
самый пользовательский ID. Пользовательские имена и соответствующий 
пользовательский IDS сохранены в базе данных, к которой Вы можете 
обращаться как описано в Разделе 25.12 [База Данных Пользователей].
<P>Пользователи классифицированы на группы. Каждое имя пользователя 
также принадлежит одной или большему количеству групп, и имеет одну 
заданную по умолчанию группу. Пользователи - элементы той же самой 
группы, могут совместно использовать ресурсы (типы файлов) которые
не доступны для пользователей - не элементов этой группы. Каждая 
группа имеет имя группы и ID группы. См. Раздел 25.13 [База Данных 
Групп], для того, как найти информацию относительно ID группы или 
имени группы.
<P>
<H2><A NAME="ss25.2">25.2 Persona Процесса</A>
</H2>

<P>
<P>
<P>В любое время, каждый процесс имеет отдельный пользовательский 
ID и ID группы, которые определяют привилегии процесса. Они 
коллективно называются persona процесса, потому что они определяют 
" кто это " для целей управления доступом. Эти ID также называются 
эффективным пользовательским ID и эффективным ID группы процесса.
<P>Ваша оболочка входа в систему начинается с persona, который 
состоит из вашего пользовательского ID и вашего значения ID группы 
по умолчанию. В нормальных обстоятельствах, все ваши другие 
процессы наследуют эти значения.
<P>Процесс также имеет реальный пользовательский ID, который 
идентифицирует пользователя, который создал процесс, и реальный ID 
группы, который идентифицирует заданную по умолчанию группу этого 
пользователя. Эти значения не играют роль в управлении доступом, 
так что мы не рассматриваем их частью persona. Но они - также 
важны.
<P>И реальный и эффективный пользовательский ID может быть изменен 
в течение срока службы процесса. См. Раздел 25.3 [Почему Изменяется 
Persona].
<P>Кроме того, пользователь может принадлежать многим группам, так 
что persona включает дополнительные ID группы, которые также 
относятся к правам.
<P>Пользовательский ID процесса также управляет правами для посылки 
сигналов, используя функцию kill. См. Раздел 21.6.2 [Передача 
сигналов Другому Процессу].
<P>
<H2><A NAME="ss25.3">25.3 Почему Изменяется Persona Процесса?</A>
</H2>

<P>
<P>
<P>Наиболее очевидная ситуация, когда процессу необходимо изменить
пользователя и/или ID группы - программа входа в систему. Когда 
вход в систему начинает выполняться, пользовательский ID корневой. 
Работа должна начать оболочку, чей ID пользователя и группы 
являются таковыми регистрируемого пользователя. (Чтобы выполнять 
это полностью, вход в систему должен установить реальный ID 
пользователя и группы также как persona. Но это - частный случай.)
<P>Более общий случай изменения persona - когда обычный 
пользователь программирует потребности доступа к ресурсу, который 
обычно не доступен для пользователя, фактически выполняющего это.
<P>Например, Вы можете иметь файл, который управляется вашей 
программой, но он не должен читаться или изменяться непосредственно 
другими пользователями, потому что он осуществляет некоторый 
протокол блокировки, или потому что Вы хотите сохранять целостность 
или секретность информации, которую он содержит. Этот вид 
ограниченного доступа может быть выполнен при наличии программы, 
изменяющей эффективного пользователя или ID группы соответствующего 
таковому ресурса.
<P>Таким образом, вообразите готовую программу, которая сохраняет 
очки в файле. Готовая программа непосредственно должна быть 
способной модифицировать этот файл независимо из того, кто
выполняет ее, но если пользователи могут записывать в файл без 
того, чтобы пройти игру, они могут давать себе любое количество 
очков, которое они находят приятным. Некоторые люди рассматривают 
этот нежелательным, или даже предосудительным. Это может быть 
предотвращено, созданием нового пользовательского ID и имени входа 
в систему (напр. games) чтобы обладать файлом, и сделать файл 
перезаписываемым только этим пользователем. Когда готовая
программа хочет модифицировать этот файл, она может изменять 
эффективный пользовательский ID на games. В действительности, 
программа должна принять persona games, чтобы она могла писать в 
этот файл.
<P>
<H2><A NAME="ss25.4">25.4 Как Приложение Может Изменить Persona</A>
</H2>

<P>
<P>
<P>Способность изменять persona процесса может быть источником 
ненамеренных нарушений секретности, или даже намеренного 
неправильного обращения. Из-за потенциальных проблем, замена 
persona ограничена специальными обстоятельствами.
<P>Вы не можете произвольно устанавливать ваш пользовательский ID 
или ID группы; только привилегированные процессы могут делать это. 
Взамен, нормальный способ для программы, чтобы изменить persona 
состоит в том, чтобы было установлено заранее соглашение изменения 
специфического пользователя или группы. Это делают функции setuid и 
setgid битов режима доступа файла. См. Раздел 9.8.5 [Биты Прав].
<P>Когда setuid бит исполняемого файла установлен, выполнение этого 
файла автоматически изменяет эффективный пользовательский ID на 
пользователя, который обладает файлом. Аналогично, при выполнении 
файла, чей setgid бит установлен изменяется эффективный ID группы 
на группу файла. См. Раздел 23.5 [Выполнение Файла]. Создание 
файла, который изменяется к специфическому ID пользователz или ID 
группы таким образом, требует полного доступа к этому пользователю 
или группе.
<P>См. Раздел 9.8 [Атрибуты Файла], для более общего обсуждения 
режимов файла и достижимости.
<P>Процесс может всегда изменять эффективный пользовательский (или 
групповой) ID обратно реальному ID. Программы делают это, чтобы 
выключить их специальные привилегии, когда они ненужны, что 
делается для большей ошибкоустойчивости. 
<P>
<P>
<P>
<P>
<H2><A NAME="ss25.5">25.5 Чтение Persona Процесса</A>
</H2>

<P>
<P>
<P>Имеются детализированные описания функций для чтения ID 
пользователя и группы процесса, и реального и эффективного. Чтобы 
использовать эти средства, Вы должны включить заглавные файлы
" sys/types.h " и " unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       uid_t  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это - целочисленный тип данных, используемый, чтобы представить 
пользовательский ID. В библиотеке GNU, это - побочный результат 
исследования для unsigned int.
<BLOCKQUOTE><CODE>
<PRE>
       gid_t                              (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это - целочисленный тип данных, используемый, чтобы представить 
ID группы. В библиотеке GNU, это - побочный результат исследования 
для unsigned int.
<BLOCKQUOTE><CODE>
<PRE>
       uid_t getuid (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
      Getuid функция возвращает реальный пользовательский ID процесса.
<BLOCKQUOTE><CODE>
<PRE>
       gid_t getgid (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Getgid функция возвращает реальный ID группы процесса.
<BLOCKQUOTE><CODE>
<PRE>
       uid_t geteuid (void)  (функция) 
</PRE>
</CODE></BLOCKQUOTE>
       Geteuid функция возвращает эффективный пользовательский ID 
процесса.
<BLOCKQUOTE><CODE>
<PRE>
       gid_t getegid (void)  (функция) 
</PRE>
</CODE></BLOCKQUOTE>
       Getegid функция возвращает эффективный ID группы процесса.
<BLOCKQUOTE><CODE>
<PRE>
       int getgroups (int count, gid_t *groups)  (функция) 
</PRE>
</CODE></BLOCKQUOTE>
      Getgroups функция используется, чтобы запросить относительно ID 
дополнительные группы процесса. До count этих ID групп сохранено в
массиве groups; возвращаемое значение из функции - число групп, 
фактически сохраненных. Если count меньше чем общее число 
дополнительных групп, то getgroups возвращает значение -1, и errno 
установлена как EINVAL.
<P>Если count - 0, то getgroups только возвращает общее число
дополнительных групп. Для систем, которые не поддерживают
дополнительные группы, это будет всегда 0.
<P>Вот как использовать getgroups для чтения вся ID дополнительных 
групп:
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                gid_t *
                read_all_groups (void)
                {
                        int ngroups = getgroups (NULL, 0);
                        gid_t *groups = (gid_t *) xmalloc                       
                (ngroups * sizeof (gid_t));
                        int val = getgroups (ngroups, groups);
                        if (val &lt; 0)
                        {
                                free (groups);
                                return NULL;
                        }
                        return groups;
                }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss25.6">25.6 Установка Пользовательского ID</A>
</H2>

<P>
<P>
<P>Этот раздел описывает функции для изменения пользовательского ID 
(реального и/или эффективного) процесса.
<P>Чтобы использовать эти средства, Вы должны включить заглавные 
файлы " sys/types.h " и " unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int setuid (uid_t newuid)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция устанавливает, и реальный и эффективный 
пользовательский ID процесса как newuid, если процесс имеет 
соответствующие привилегии.
<P>Если процесс не привилегирован, то newuid, должен быть равен 
реальному пользовательскому ID или сохраненному пользовательскому ID
(если система поддерживает возможность _POSIX_SAVED_IDS). В этом 
случае, setuid устанавливает только эффективный пользовательский 
ID, а не реальный пользовательский ID.
<P>Setuid функция возвращает значение 0, чтобы указать успешное 
завершение, и значение -1, чтобы указать ошибку. Следующие errno 
условия ошибки определены для этой функции:
<DL>
<DT><B>EINVAL    </B><DD><P>
<P>Значение newuid аргумента недопустимо.
<DT><B>EPERM     </B><DD><P>
<P>Процесс не имеет соответствующих привилегий.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       int setreuid (uid_t ruid, uid_t euid)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция устанавливает реальный пользовательский ID процесса 
как ruid и эффективный пользовательский ID как euid. Если ruid -1, 
это означает, что реальный пользовательский ID не изменился;
аналогично, если euid -1, это означает, чтобы не изменился 
эффективный пользовательский ID.
<P>Setreuid функция существует для совместимости с 4.3 UNIX BSD, 
который не поддерживает сохранение ID. Вы можете использовать эту 
функцию, чтобы изменять эффективного и реального пользователя 
процесса. (Привилегированные процессы не ограничены этим 
специфическим использованием.) если сохраненный ID обеспечивается, 
Вы должны использовать эту возможность вместо этой функции. См. 
раздел 25.8 [ВКЛЮЧЕНИЕ/ОТКЛЮЧЕНИЕ Setuid].
<P>Возвращаемое значение - 0 при успехе и -1 при отказе. Следующие 
errno условия ошибки определены для этой функции:
<DL>
<DT><B>EPERM     </B><DD><P>
<P>Процесс не имеет соответствующих привилегий; Вы не имеете прав 
изменить на заданный ID.
</DL>
<H2><A NAME="ss25.7">25.7 Установка ID Группы</A>
</H2>

<P>
<P>
<P>Этот раздел описывает функции для изменения ID группы (реальный 
и эффективный) процесса. Чтобы использовать эти средства, Вы должны 
включить заглавные файлы " sys/types.h " и " unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int setgid (gid_t newgid)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция устанавливает, и реальный и эффективный ID группы 
процесса как newgid, если процесс имеет соответствующие привилегии.
<P>Если процесс не привилегирован, то newgid, должен также быть 
равен реальному ID группы или сохраненному ID группы. В этом 
случае, setgid устанавливает только эффективный ID группы, а не 
реальный ID группы.
<P>Возвращаемые значения и условия ошибки для setgid - такие же как 
для setuid.
<BLOCKQUOTE><CODE>
<PRE>
       int setregid (gid_t rgid, fid_t egid)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция устанавливает реальный ID группы процесса как rgid, 
а эффективный ID группы как egid. Если rgid -1, это означает, чтобы 
реальный ID группы не изменялся; аналогично, если egid -1, это 
означает, чтобы не изменялся эффективный ID группы.
<P>Setregid функция предусмотрена для совместимости с 4.3 UNIX BSD, 
который не поддерживает сохраненные ID. Вы можете использовать эту 
функцию, чтобы изменять эффективный и реальный ID группы процесса. 
(Привилегированные процессы не ограничены этим использованием.) 
если сохраненные ID обеспечиваются, Вы должны использовать эту 
возможность вместо того, чтобы использовать эту функцию. См. раздел 
25.8 [ВКЛЮЧЕНИЕ/ОТКЛЮЧЕНИЕ Setuid].
<P>Возвращаемые значения и условия ошибки для setregid - такие же 
как для setreuid.
<P>Система GNU также допускает привилегированным процессам, 
изменять их дополнительные ID группы. Чтобы использовать setgroups 
или initgroups, ваши программы должны включить заглавный файл " 
grp.h ".
int setgroups (size_t count, gid_t *groups)  (функция)
<P>Эта функция устанавливает дополнительный ID группы процесса. Она 
может вызываться только из привилегированных процессов. Аргумент 
count определяет число ID групп в массиве groups.
<P>Эта функция возвращает 0 в случае успеха и -1 при ошибке. 
Следующие errno условия ошибки определены для этой функции:
<DL>
<DT><B>EPERM </B><DD><P>Вызывающий процесс не привилегирован.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       int initgroups (const char *user, gid_t gid)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Initgroups функция вызывает setgroups, чтобы установить 
дополнительный ID группы. ID группы gid также включен.
<P>
<H2><A NAME="ss25.8">25.8 Предоставление и Отключение Setuid</A>
</H2>

<P>
<P>
<P>Типичная программа setuid не нуждается в специальном доступе все 
время. Хорошая идея выключить этот доступ, когда он ненужен, так 
что она возможно не может давать непривелегированный доступ.
<P>Если система поддерживает сохраненный пользовательский ID, Вы 
можете выполнить это с setuid. Когда стартует программа game, ее 
реальный пользовательский ID - jdoe, эффективный пользовательский 
ID - games, и сохраненный пользовательский ID - также games. 
Программа должна записать оба значения пользовательских ID один раз 
в начале, примерно так:
<BLOCKQUOTE><CODE>
<PRE>
                user_user_id = getuid ();
                game_user_id = geteuid ();
</PRE>
</CODE></BLOCKQUOTE>

Теперь она может выключить доступ к файлу game 
<BLOCKQUOTE><CODE>
<PRE>
                setuid (user_user_id);
</PRE>
</CODE></BLOCKQUOTE>

И и включить его
<BLOCKQUOTE><CODE>
<PRE>
                setuid (game_user_id);
</PRE>
</CODE></BLOCKQUOTE>

Во время этого процесса, реальный пользовательский ID остается 
jdoe, и сохраненный пользовательский ID остается games, так что 
программа может всегда устанавливать эффективный пользовательский
ID как любой из них.
<P>На других системах, которые не поддерживают сохраненный 
пользовательский ID, Вы можете переключать доступ setuid   
используя setreuid, чтобы менять реального и эффективного 
пользователя процесса, следующим образом:
<BLOCKQUOTE><CODE>
<PRE>
                setreuid (geteuid (), getuid ());
</PRE>
</CODE></BLOCKQUOTE>

Этот частный случай не может терпеть неудачу.
<P>Почему это имеет эффект переключения доступа setuid? 
Предположите, что программа game только что началась, и реальный 
пользовательский ID - jdoe, в то время как эффективный 
пользовательский ID - games. В этом состоянии, game может запись 
файл scores (очков). Если она меняет два универсальных 
идентификатора, реальный, становится games, а эффективный 
становится jdoe; теперь программа имеет только jdoe доступ. Другая 
перестановка приводит games обратно к эффективному 
пользовательскому ID и восстанавливает доступ к файлу scores.
<P>Чтобы обрабатывать оба вида систем, проверьте сохранение 
пользовательского ID условным выражением препроцессора, примерно 
так:
<BLOCKQUOTE><CODE>
<PRE>
                #ifdef _POSIX_SAVED_IDS
                        setuid (user_user_id);
                #else
                        setreuid (geteuid (), getuid ());
                #endif
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss25.9">25.9 Пример Setuid Программы</A>
</H2>

<P>
<P>
<P>Имеется пример, показывающий, как установить программу, которая 
изменяет эффективный пользовательский ID.
<P>Это - часть программы game, которая манипулирует файлом " scores 
" который должен быть перезаписываем только программой game 
непосредственно. Программа считает, что исполняемый файл будет 
установлен с set-user-ID набором битов и принадлежать тому же 
самому пользователю как " scores " файл. 
<P>Исполняемому файлу дается режим 4755, при выполнении его " ls -l 
" производится вывод подобно:
<BLOCKQUOTE><CODE>
<PRE>
        -rwsr-xr-x   1 games   184422 Jul 30 15:17 caber-toss
</PRE>
</CODE></BLOCKQUOTE>
       Set-user-ID бит обнаруживается в режимах файла как " s'.
<P>Файл scores имеет режим 644:
<BLOCKQUOTE><CODE>
<PRE>
        -rw-r--r--  1 games         0 Jul 31 15:33 scores
</PRE>
</CODE></BLOCKQUOTE>

Имеются части программы, которые показывают, как установить 
измененный пользовательский ID. Эта программа - сделана так, чтобы 
она использовала возможность сохранения ID, если она 
обеспечивается, и иначе использует setreuid, чтобы изменять 
эффективного и реального пользователя.
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stdio.h&gt;
                #include &lt;sys/types.h&gt;
                #include &lt;unistd.h&gt;
                #include &lt;stdlib.h&gt;
                static uid_t euid, ruid;
                void
                do_setuid (void)
                {
                        int status;
                #ifdef _POSIX_SAVED_IDS
                        status = setuid (euid);
                #else
                        status = setreuid (ruid, euid);
                #endif
                        if (status &lt; 0) {
                                fprintf (stderr, "Couldn't set uid.\n");
                                exit (status);
                        }
                }
                void
                undo_setuid (void)
                {
                        int status;
                #ifdef _POSIX_SAVED_IDS
                        status = setuid (ruid);
                #else
                        status = setreuid (euid, ruid);
                #endif
                        if (status &lt; 0) {
                                fprintf (stderr, "Couldn't set uid.\n");
                                exit (status);
                        }
                }
                int
                main (void)
                {
                        ruid = getuid ();
                        euid = geteuid ();
                        undo_setuid ();
                        . . .
                }
</PRE>
</CODE></BLOCKQUOTE>

Когда программа должна открыть файл scores она включает обратно 
оригинальный эффективный пользовательский ID, примерно так:
<BLOCKQUOTE><CODE>
<PRE>
                int
                record_score (int score)
                {
                        FILE *stream;
                        char *myname;
                        do_setuid ();
                        stream = fopen (SCORES_FILE, "a");
                        undo_setuid ();
                        if (stream)
                        {
                                myname = cuserid (NULL);
                                if (score &lt; 0)
                                        fprintf (stream, "%10s: Couldn't        
                                        lift the caber.\n", myname);
                                else
                                        fprintf (stream, "%10s: %d              
                                feet.\n", myname, score);
                                fclose (stream);
                                return 0;
                        }
                        else
                                return -1;
                }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss25.10">25.10 Советы для Написания Программы Setuid</A>
</H2>

<P>
<P>
<P>Для программ setuid возможно дать доступ пользователю, который 
не предусмотрен фактически, если Вы хотите избежать этого, Вы 
должны быть внимательны. Имеются некоторые руководящие принципы для 
предотвращения непредназначенного доступа и уменьшения следствий, 
когда он происходит:
<UL>
<LI>         Не Иметь программы setuid с привилегированным пользовательским 
ID типа root, если это не абсолютно необходимо. Если ресурс 
является специфическим для вашей специфической программы, это лучше 
определить новый, непривилегированный пользовательский ID или ID 
группы для управления этим ресурсом.</LI>
<LI>         Быть осторожным относительно использования системы и функций 
exec в комбинации с изменением эффективного пользовательского ID. 
Не допускайте пользователем вашей программы выполнять произвольные 
программы под измененным пользовательским ID. 

Если Вы должны запустить другую программу под измененным ID, 
определяйте абсолютное имя файла для выполнимой программы, и 
удостоверитесь, что защиты на выполнимой программе и каталогах 
являются такими, что обычные пользователи не могут заменять ее на 
некоторую другую программу.</LI>
<LI>         Используйте пользовательский ID управления ресурсами только в 
части программы, которая фактически использует тот ресурс. Когда вы 
закончили с этим, восстановите эффективный пользовательский ID 
обратно фактическому пользователю.</LI>
<LI>         Если часть setuid вашей программы должна обратиться к другим 
файлам кроме управляемого ресурса, она должна проверить, что 
реальный пользователь имел бы право обратиться к этим файлам. Вы 
можете использовать функцию access (см. Раздел 9.8.6 [Право 
Доступа]) чтобы проверить это; она использует реальный ID 
пользователя и группы, а не эффективные ID.</LI>
</UL>
<P>
<P>
<P>
<H2><A NAME="ss25.11">25.11 Идентификация, кто Регистрируется</A>
</H2>

<P>
<P>
<P>Вы можете использовать функции, перечисленные в этом разделе, 
чтобы определить имя входа в систему пользователя, который 
выполняет процесс, и имя пользователя, который зарегистрирован в 
текущем сеансе. См. также функцию getuid (см. Раздел 25.5 [Чтение 
Persona]).
<P>Getlogin функция объявлена в " unistd.h ", в то время как 
cuserid и L_cuserid объявлены в " stdio.h ".
<BLOCKQUOTE><CODE>
<PRE>
       char * getlogin (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Getlogin функция возвращает указатель на строку, содержащую имя 
пользователя, зарегистрированного на терминале управления процесса, 
или пустой указатель, если эта информация не может быть определена. 
Строка статически размещена и могла бы быть записана поверх при 
последующих обращениях к этой функции или к cuserid.
<BLOCKQUOTE><CODE>
<PRE>
       char * cuserid (char *string)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Cuserid функция возвращает указатель на строку, содержащую имя 
пользователя, связанное с эффективным ID процесса. Если это - не 
пустой указатель, это должен быть массив, который может содержать 
по крайней мере L_cuserid символов; строка возвращается в этом 
массиве. Иначе, возвращается указатель на строку в статической 
области. Эта строка статически размещена и может быть записана 
поверх при последующих обращениях к этой функции или к getlogin.
<BLOCKQUOTE><CODE>
<PRE>
       int L_cuserid  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Целочисленная константа, которая указывает какой длины массив 
Вам нужен чтобы сохранить имя пользователя.
<P>Эти функции допускают вашей программе идентифицировать 
положительно пользователя, кто выполняется или пользователь, кто 
зарегистрирован в этом сеансе. (Они могут отличиться, когда 
программы setuid включаются; См. Раздел 25.2 [Процесс Persona].) 
пользователь не может сделать ничего, чтобы ввести в заблуждение 
эти функции.
<P>Для большинства целей более полезно использовать переменную 
среды LOGNAME, чтобы выяснить, кто пользователь. Это более гибко  
потому что пользователь может устанавливать LOGNAME произвольно. 
См. Раздел 22.2.2 [Стандартная Среда].
<P>
<P>
<H2><A NAME="ss25.12">25.12 База данных Пользователей</A>
</H2>

<P>
<P>
<P>Этот раздел описывает все относительно поиска и просмотра базы 
данных зарегистрированных пользователей. База данных 
непосредственно сохраняется в файле " /etc/passwd " на большинстве 
систем, но на некоторых системах специальный сетевой сервер дает 
доступ к этому.
<P>
<H3>Структура Данных, которая Описывает Пользователя</H3>

<P>
<P>
<P>Функции и структуры данных для доступа к базе данных 
пользователей системы объявлены в заглавном файле " pwd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       struct passwd  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>
       Passwd структуры данных используется, чтобы содержать информацию
относительно входов в базу данных пользователя системы. Она имеет
по крайней мере следующие элементы:
<BLOCKQUOTE><CODE>
<PRE>
                char *pw_name
</PRE>
</CODE></BLOCKQUOTE>

Имя входа в систему пользователя.
<BLOCKQUOTE><CODE>
<PRE>
                char *pw_passwd.
</PRE>
</CODE></BLOCKQUOTE>

Шифрованная строка пароля.
<BLOCKQUOTE><CODE>
<PRE>
                uid_t pw_uid
</PRE>
</CODE></BLOCKQUOTE>

Пользовательский ID.
<BLOCKQUOTE><CODE>
<PRE>
                gid_t pw_gid
</PRE>
</CODE></BLOCKQUOTE>

Значение по умолчанию ID группы.
<BLOCKQUOTE><CODE>
<PRE>
                char *pw_gecos
</PRE>
</CODE></BLOCKQUOTE>

Строка, обычно содержащая реальное имя пользователя, и возможно 
другую информацию типа номера телефона.
<BLOCKQUOTE><CODE>
<PRE>
                char *pw_dir
</PRE>
</CODE></BLOCKQUOTE>

Исходный каталог пользователя, или начальный рабочий каталог. 
Это может быть пустой указатель, когда интерпретация зависима от 
системы.
<BLOCKQUOTE><CODE>
<PRE>
                char *pw_shell
</PRE>
</CODE></BLOCKQUOTE>

Оболочка пользователя по умолчанию, или начальная выполненная 
программа, когда пользователь регистрируется. Это может быть пустой 
указатель, указывая, что должно использоваться системное значение 
по умолчанию.
<P>
<P>
<H3>Поиск Одного Пользователя</H3>

<P>
<P>
<P>Вы можете искать специфического пользователя, используюя 
getpwuid или getpwnam. Эти функции объявлены в " pwd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       struct passwd * getpwuid (uid_t uid)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает указатель на статически размещенную 
структуру, содержащую информацию относительно пользователя, чей 
пользовательский ID является uid. Эта структура может быть записана 
поверх на последующих обращениях к getpwuid.
<P>Пустое значение указателя указывает, что не имеется никакого 
пользователя в базе данных с пользовательским ID uid.
<BLOCKQUOTE><CODE>
<PRE>
       struct passwd * getpwnam (const char *name)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает указатель на статически размещенную 
структуру, содержащую информацию относительно пользователя, чье имя 
пользователя является name. Эта структура может быть записана 
поверх при последующих обращениях к getpwnam.
<P>Пустое значение указателя указывает, что не имеется никакого 
пользователя, именованного name.
<P>
<H3>Просмотр Списка Всех Пользователей</H3>

<P>
<P>
<P>Этот раздел объясняет, как программа может читать список всех 
пользователей в системе, по одному пользователю одновременно. 
Функции, описанные здесь объявлены в " pwd.h ".
<P>Вы можете использовать fgetpwent функцию для чтения входов 
пользователя  из специфического файла.
<BLOCKQUOTE><CODE>
<PRE>
       struct passwd * fgetpwent (FILE *stream)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция читает следующий вход пользователя из потока и 
возвращает указатель на вход. Структура статически размещена и 
перезаписываема при последующих обращениях к fgetpwent. Вы должны 
копировать содержимое структуры, если Вы желаете сохранить 
информацию.
<P>Этот поток должен соответствовать файлу в том же самом формате 
как стандартный файл базы данных паролей. Эта функция исходит из 
System V.
<P>Способ просматривать все входы в базе данных пользователей - с 
setpwent, getpwent, и endpwent.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       void setpwent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция инициализирует поток, который getpwent использует 
для read базу данных пользователей.
<BLOCKQUOTE><CODE>
<PRE>
       struct passwd * getpwent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
      Getpwent функция читает следующий вход из потока, 
инициализированного setpwent.
<P>Она возвращает указатель на вход. Структура статически размещена 
и перезаписываема при последующих обращениях к getpwent. Вы должны 
копировать содержимое структуры, если Вы желаете сохранить 
информацию.
<BLOCKQUOTE><CODE>
<PRE>
       void endpwent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция закрывает внутренний поток, используемый getpwent.
<P>
<H3>Запиись Входа Пользователя</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int putpwent (const struct passwd *p, FILE *stream)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция записывает вход пользователя *p в указанный поток, в 
формате, используемом для стандартного файла базы данных 
пользователей. Возвращаемое значение - 0 при успехе и отличное
от нуля при отказе.
<P>Эта функция существует для совместимости с SVID. Мы рекомендуем, 
чтобы Вы избегали использовать ее, потому что она имеет смысл 
только при условии, что структура struct passwd не имеет никаких 
элементов за исключением стандартных; на системе, которая 
обьединяет традиционную базу данных UNIX с другой расширенной 
информацией относительно пользователей, эта функция неизбежно не 
учла бы многое из важной информации.
<P>Функция putpwent объявлена в " pwd.h ".
<P>
<H2><A NAME="ss25.13">25.13 База данных Групп</A>
</H2>

<P>
<P>
<P>Этот раздел описывает все относительно того, как искать и 
просмотреть базу данных зарегистрированных групп. База данных 
непосредственно сохраняется в файле " /etc/group " на большинстве 
систем, но на некоторых системах,  специальное сетевое обслуживание 
обеспечивает доступ к ней.
<P>
<P>
<H3>Структура Данных для Группы</H3>

<P>
<P>
<P>Функции и структуры данных для доступа к базе данных групп 
системы объявлены в заглавном файле " grp.h ".
<BLOCKQUOTE><CODE>
<PRE>
       struct group  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Структура group используется, чтобы содержать информацию 
относительно входа в базе данных групп системы. Она имеет по 
крайней мере следующие элементы:
<BLOCKQUOTE><CODE>
<PRE>
                char *gr_name
</PRE>
</CODE></BLOCKQUOTE>

Имя группы.
<BLOCKQUOTE><CODE>
<PRE>
                gid_t gr_gid
</PRE>
</CODE></BLOCKQUOTE>
       ID группы.
<BLOCKQUOTE><CODE>
<PRE>
                char **gr_mem
</PRE>
</CODE></BLOCKQUOTE>

Вектор указателей на имена пользователей в группе. Каждое имя 
пользователя - строка с нулевым символом в конце, и вектор 
непосредственно завершен пустым указателем.
<P>
<H3>Поиск Одной Группы</H3>

<P>
<P>
<P>Вы можете искать специфическую группу, используя getgrgid или 
getgrnam. Эти функции объявлены в " grp.h ".
<BLOCKQUOTE><CODE>
<PRE>
       struct group * getgrgid (gid_t gid)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает указатель на статически размещенную 
структуру, содержащую информацию относительно группы, чей ID группы 
является gid. Эта структура может быть записана поверх последующими 
обращениями к getgrgid.
<P>Пустой указатель указывает, что не имеется никакой группы с ID 
gid.
<BLOCKQUOTE><CODE>
<PRE>
       struct group * getgrnam (const char *name)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает указатель на статически размещенную 
структуру, содержащую информацию относительно группы, чье имя 
группы является name. Эта структура может быть записана поверх 
последующими обращениями к getgrnam.
<P>Пустой указатель указывает, что нет никакой группы,
именованной name.
<P>
<P>
<P>
<P>
<H3>Просмотр Списка Всех Групп</H3>

<P>
<P>
<P>Этот раздел объясняет, как программа может читать список всех 
групп в системе, по одной группе одновременно. Функции, описанные 
здесь объявлены в " grp.h ".
<P>Вы можете использовать fgetgrent функцию, чтобы читать входы 
группы из специфического файла.
<BLOCKQUOTE><CODE>
<PRE>
       struct group * fgetgrent (FILE *stream)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Fgetgrent функция читает следующий вход из потока. Она 
возвращает указатель на вход. Структура статически размещена и 
перезаписываема при последующих обращениях к fgetgrent. Вы должны 
копировать содержимое структуры, если Вы желаете сохранить 
информацию.
<P>Поток должен соответствовать файлу в том же самом формате как 
стандартный файл базы данных групп.
<P>Способ просматривать все входы в базе данных групп - с setgrent, 
getgrent, и endgrent.
<BLOCKQUOTE><CODE>
<PRE>
       void setgrent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция инициализирует поток для чтения из базы данных 
групп. Вы используете этот поток, вызывая getgrent.
<BLOCKQUOTE><CODE>
<PRE>
       struct group * getgrent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
      Getgrent функция читает следующий вход из потока, 
инициализированного setgrent.
<P>Она возвращает указатель на вход. Структура статически размещена 
и перезаписываема при последующих обращениях к getgrent. Вы должны 
копировать содержимое структуры, если Вы желаете сохранить 
информацию.
<BLOCKQUOTE><CODE>
<PRE>
       void endgrent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция закрывает внутренний поток, используемый getgrent.
<P>
<H2><A NAME="ss25.14">25.14 Пример Базы данных Пользователей и Групп</A>
</H2>

<P>
<P>
<P>Вот пример программы, показывающий использование функций запроса 
базы данных системы. Программа печатает некоторую информацию 
относительно пользователя, выполняющего программу.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;grp.h&gt;
                #include &lt;pwd.h&gt;
                #include &lt;sys/types.h&gt;
                #include &lt;unistd.h&gt;
                #include &lt;stdlib.h&gt;
                int
                main (void)
                {
                        uid_t me;
                        struct passwd *my_passwd;
                        struct group *my_group;
                        char **members;
                        me = getuid ();
                        my_passwd = getpwuid (me);
                        if (!my_passwd)
                        {
                                printf ("Couldn't find out about                
                                user %d.\n", (int) me); 
                                exit (EXIT_FAILURE);
                        }
                        printf ("I am %s.\n", my_passwd-&gt;pw_gecos);
                        printf ("My login name is %s.\n",                       
                my_passwd-&gt;pw_name); 
                        printf ("My uid is %d.\n", (int)                        
                (my_passwd-&gt;pw_uid)); 
                        printf ("My home directory is %s.\n",           
                        my_passwd-&gt;pw_dir); 
                        printf ("My default shell is %s.\n",            
                        my_passwd-&gt;pw_shell);
                        my_group = getgrgid (my_passwd-&gt;pw_gid);
                        if (!my_group)
                        {
                                printf ("Couldn't find out about 
                                                group %d.\n",
                                                (int) my_passwd-&gt;pw_gid);
                                exit (EXIT_FAILURE);
                        }
                        printf ("My default group is %s (%d).\n",       
                                my_group-&gt;gr_name,                           
        (int) (my_passwd-&gt;pw_gid));
                        printf ("The members of this group are:\n");
                        members = my_group-&gt;gr_mem;
                        while (*members)
                        {
                                printf ("  %s\n", *(members)); 
                                members++;
                        }
                        return EXIT_SUCCESS;
                }
</PRE>
</CODE></BLOCKQUOTE>

Вот некоторый вывод этой программы:
<BLOCKQUOTE><CODE>
<PRE>
                I am Throckmorton Snurd.
                My login name is snurd.
                My uid is       31093.
                My home directory is /home/fsg/snurd.
                My default shell is /bin/sh.
                My default group is guest (12).
        The members of this group are:
                friedman
                tami
</PRE>
</CODE></BLOCKQUOTE>
<P>
<HR>
<A HREF="glibc-26.html">Вперед</A>
<A HREF="glibc-24.html">Назад</A>
<A HREF="glibc.html#toc25">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
