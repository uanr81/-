<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Национальные и Международные Стандарты</TITLE>
 <LINK HREF="glibc-20.html" REL=next>
 <LINK HREF="glibc-18.html" REL=previous>
 <LINK HREF="glibc.html#toc19" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-20.html">Вперед</A>
<A HREF="glibc-18.html">Назад</A>
<A HREF="glibc.html#toc19">Содержание</A>
<HR>
<H2><A NAME="s19">19. Национальные и Международные Стандарты</A></H2>

<P>
<P>
<P>Различные страны имеют изменяющиеся стандарты.
Эти стандарты содержит преобразования от очень простых, типа формата
для представления дат и времени, до очень сложных, типа
разговорного языка.
<P>Межнационализация программного обеспечения означает способность к
адаптированию программирования для соглашений предпочитаемых
пользователем. В ANSI C, межнационализация работает посредством
стандартов. Каждый стандарт определяет набор соглашений, одно
соглашение для каждой цели. Пользователь выбирает набор соглашений,
определяя стандарт (через переменные среды).
<P>Все программы наследуют выбранный стандарт как часть их среды.
<P>
<H2><A NAME="ss19.1">19.1 Какие Эффекты Стандарта Имеет Каждый Стандарт ?</A>
</H2>

<P>
<P>Это определяет соглашения для отдельных целей, включая
следующие:
<UL>
<LI>        Какие многобайтовые символьные последовательности являются
допустимыми, и как они интерпретируются (см. Главу 18 [Расширенные
Символы]).</LI>
<LI>        Классификация того, какие символы местного набора 
являются буквенными, верхнего и нижнего регистра (см. Главу
4 [Обработка Символов]).</LI>
<LI>        Последовательность объединений для местного языка и набора
символов (см. Раздел 5.6 [Функции Объединения]).</LI>
<LI>        Форматирование чисел (см. Раздел 19.6 [Числовое
Форматирование]).
</LI>
<LI>        Форматирование дат и времени (см. Раздел 17.2.4
[Форматирование Даты и времени]).</LI>
<LI>        Какой язык использовать для вывода, включая сообщения об
ошибках. (Библиотека C однако не позволяет Вам выполнить это.)</LI>
<LI>        Какой язык использовать для ответов пользователя на вопросы
типа "да" или "нет".</LI>
<LI>        Какой язык использовать для более сложного ввода пользователя.
Некоторые аспекты адаптации к заданному стандарту обрабатываются
автоматически библиотечными подпрограммами. Например, все ваши
программы должны использовать последовательность объединений
выбранного стандарта, т. е. использовать strcoll или strxfrm, чтобы
сравнить строки.</LI>
</UL>

Другие аспекты стандартов - вне компетенции библиотеки.
Например, библиотека не может автоматически транслировать сообщения
вывода вашей программы на другие языки. Единственый способ, которым
Вы можете поддерживать вывод на языке пользователя, должен
программироваться более или менее вручную. (В конечном счете, мы
надеемся обеспечить средства, чтобы делать этот проще.)
<P>Эта глава обсуждает механизм, которым Вы можете изменять текущий
стандарт. Эффекты текущего стандарта на специфических библиотечных
функциях обсуждены более подробно в описаниях самих функций.
<P>
<H2><A NAME="ss19.2">19.2 Выбор Стандарта</A>
</H2>

<P>
<P>Самый простой способ для пользователя, чтобы выбрать стандарт
состоит в том, чтобы установить переменную среды LANG. Она
определяет один стандарт для всех целей. Например, пользователь мог
бы определить гипотетический стандарт, именованный " espana&shy;
castellano " чтобы использовать стандартные соглашения  Испании.
<P>Набор обеспечиваемых стандартов зависит от операционной системы,
которую Вы используете. Мы не можем делать ни каких обещаний
относительно того, что стандарты будут существовать, кроме одного
стандартного стандарта, называемого " C " или " POSIX ".
<P>Пользователь также имеет опцию определения различных стандартов
для различных целей, выбирая смесь многих стандартов.
<P>
<P>
<P>
<P>
<H2><A NAME="ss19.3">19.3 Категории Действий, на которые Воздействуют Стандарты</A>
</H2>

<P>
<P>Цели, которые стандарты обслуживают, сгруппированы в категории
так, чтобы пользователь или программа мог выбирать стандарт для
каждого класса независимо. Вот таблица категорий: каждое имя
является и переменной среды, которую пользователь может
устанавливать, и именем макрокоманды, которую Вы можете использовать
как аргумент setlocale.
<BLOCKQUOTE><CODE>
<PRE>
       LC_COLLATE
</PRE>
</CODE></BLOCKQUOTE>

Этот класс применяется для объединения строк (функции strcoll и
strxfrm); см. Раздел 5.6 [Функции Объединения].
<BLOCKQUOTE><CODE>
<PRE>
       LC_CTYPE
</PRE>
</CODE></BLOCKQUOTE>

Этот класс применяется для классификации и преобразований
символов, и в многобайтовые и в расширенные символы; см. Главу 4
[Обработка Символов] и Главу 18 [Расширенные Символы].
<BLOCKQUOTE><CODE>
<PRE>
       LC_MONETARY
</PRE>
</CODE></BLOCKQUOTE>

Этот класс применяется к форматированию валютных значений; см.
Раздел 19.6 [Числовое форматирование].
<BLOCKQUOTE><CODE>
<PRE>
       LC_NUMERIC
</PRE>
</CODE></BLOCKQUOTE>

Этот класс применяется к форматированию числовых значений; см.
раздел 19.6 [Числовое Форматирование].
<BLOCKQUOTE><CODE>
<PRE>
       LC_TIME
</PRE>
</CODE></BLOCKQUOTE>

Этот класс применяется для форматирования значений даты и
времени; см. Раздел 17.2.4 [Форматирование Даты и времени].
<BLOCKQUOTE><CODE>
<PRE>
       LC_ALL
</PRE>
</CODE></BLOCKQUOTE>

Это - не переменная среды, это - только макрокоманда, которую Вы
можете использовать с setlocale, чтобы установить одиночный
стандарт для всех целей.
<BLOCKQUOTE><CODE>
<PRE>
       LANG
</PRE>
</CODE></BLOCKQUOTE>

Если эта переменная среды определена, значение определяет
стандарт, используемый для всех целей за исключением того, как
отменено переменными выше.
<P>
<H2><A NAME="ss19.4">19.4 Как Программы Устанавлиают Стандарт</A>
</H2>

<P>
<P>Программа на Си наследует переменные среды стандарта, когда она
начинается. Это случается автоматически. Однако, эти переменные
автоматически не управляют стандартом, используемым в соответствии
c библиотечными функциями, потому что ANSI C говорит, что все
программы начинаются по умолчанию в стандарте " C ". Чтобы
использовать стандарты, заданные средой, Вы должны вызвать
setlocale. Вызовите ее следующим образом:
<BLOCKQUOTE><CODE>
<PRE>
                 setlocale (LC_ALL, "");
</PRE>
</CODE></BLOCKQUOTE>
       чтобы выбрать стандарт, основанный на соответствующих переменных
среды.
<P>Вы можете также использовать setlocale, чтобы определить
специфический стандарт, для общего использования или для
специфического класса.
<P>Символы в этом разделе определены в заглавном файле " locale.h".
<BLOCKQUOTE><CODE>
<PRE>
       char * setlocale (int category, const char *locale) 
</PRE>
</CODE></BLOCKQUOTE>

Функция setlocale устанавливает текущий стандарт для указанного
класса.
<P>Если класс - LC_ALL, то она определяет стандарт для всех целей.
Другие возможные значения класса определяют индивидуальную цель
(см. Раздел 19.3 [Категории Стандарта] ).
<P>Вы можете также использовать эту функцию, чтобы выяснить текущий
стандарт, передавая пустой указатель как аргумент стандарта. В
этом случае, setlocale возвращает строку, которая является именем
стандарта, в настоящее время выбранного для класса class.
<P>Строка, возвращенная setlocale может быть записана поверх
последующими обращениями, так что Вы должны делать копию строки
(см. Раздел 5.4 [Копирование и Конкатенация]) если Вы хотите
сохранять ее после любых дальнейших обращений к setlocale.
(Стандартная библиотека, как гарантируют, никогда не вызовет
setlocale непосредственно.)
<P>Вы не должны изменять строку, возвращенную setlocale. Это может
быть та же самая строка, которая была передана как аргумент в
предыдущем обращении к setlocale.
<P>Когда Вы читаете текущий стандарт для класса LC_ALL, значение
кодирует всю комбинацию выбранных стандартов для всех категорий. В
этом случае, значение не только одиночное имя стандарта.
Фактически, мы не делаем ни каких обещаний относительно того, на
что это походит. Но если Вы определяете то же самое " имя стандарта" 
LC_ALL в последующем обращении к setlocale, она восстанавливает
ту же самую комбинацию выборов стандарта.
<P>Когда аргумент locale - не пустой указатель, строка,
возвращенная setlocale отражает изменяемый стандарт.
<P>Если Вы определяете пустую строку для стандарта, это означает, что 
нужно читать соответствующую переменную среды и использовать ее значение
для установки стандарта указанного класса.
<P>Если Вы определяете недопустимое имя стандарта, setlocale,
возвращает пустой указатель и оставляет текущий стандарт
неизмененным.
<P>Вот пример, показывающий, как Вы могли бы использовать
setlocale, чтобы временно включить к новый стандарт.
<BLOCKQUOTE><CODE>
<PRE>
                 #include &lt;stddef.h&gt;
                 #include &lt;locale.h&gt;
                 #include &lt;stdlib.h&gt;
                 #include &lt;string.h&gt;
                 void
                 with_other_locale (char *new_locale,
                                         void (*subroutine) (int),
                                         int argument)
                 {
                         char *old_locale, *saved_locale;
                         old_locale = setlocale (LC_ALL, NULL);
                         saved_locale = strdup (old_locale);
                         if (old_locale == NULL)
                                 fatal ("Out of memory");
                         setlocale (LC_ALL, new_locale);
                         (*subroutine) (argument);
                         setlocale (LC_ALL, saved_locale);
                         free (saved_locale);
                 }
</PRE>
</CODE></BLOCKQUOTE>

Примечание о переносимости: Некоторые системы ANSI C могут
определять дополнительные категории стандарта. Для переносимости,
запомните, что любой символ, начинающийся с " LC_ " мог бы быть
определен в "locale.h".
<P>
<H2><A NAME="ss19.5">19.5 Стандартные Стандарты</A>
</H2>

<P>
<P>Единственые имена стандартов, которые Вы можете находить во всех
операционных системах - это три стандартных:
"C" Это - стандартный стандарт Cи. Атрибуты и поведение, которое
он обеспечивает определены в стандарте ANSI C. Когда ваша программа
начинается, она первоначально использует этот стандарт по
умолчанию.
" POSIX " Это - стандартный стандарт POSIX. В настоящее время,
это - побочный результат исследования для стандартного стандарта
Cи.
"" Пустое имя говорит о том, что нужно выбрать стандарт, основанный 
на переменных среды. См. Раздел 19.3 [Категории Стандарта].
<P>Определение и установка стандартов - обязаность вашего
администратора системы (или человека, который установил библиотеку
GNU C). Некоторые системы могут позволять пользователям создавать
стандарты, но мы не обсуждаем это здесь.
<P>Если ваша программа должна использовать кое-что отличное от "C" 
стандарт, она будет более переносимой, если Вы используете
стандарт, который пользователь определяет со средой, а не пробуя
определить некоторый ненормативный стандарт явно именем. Помните,
что различные машины могут иметь различные наборы устанавливаемых
стандартов.
<P>
<H2><A NAME="ss19.6">19.6 Числовое Форматирование</A>
</H2>

<P>
<P>Когда Вы хотите форматировать число или количество валюты,
используя соглашения текущего стандарта, Вы можете использовать
функцию localeconv, чтобы получить данные относительно того, как
делать это. Функция localeconv объявлена в заглавном файле "locale.h ".
<BLOCKQUOTE><CODE>
<PRE>
       struct lconv * localeconv  
</PRE>
</CODE></BLOCKQUOTE>

Функция localeconv возвращает указатель на структуру, чьи
компоненты содержат информацию относительно того, как числовые и
валютные значения должны форматироваться в текущем стандарте.
<P>Вы не должны измениять структуру или ее содержимое. Структура
может быть записана поверх последующими обращениями к localeconv,
или обращениями к setlocale, но никакая другая функция в библиотеке
не записывает поверх этого значения.
<BLOCKQUOTE><CODE>
<PRE>
       struct lconv 
</PRE>
</CODE></BLOCKQUOTE>

Это - тип данных значения, возвращенного localeconv.
<P>Если элемент структуры struct lconv имеет тип char, и значение &shy;
CHAR_MAX, это означает что текущий стандарт не имеет никакого
значения для этого параметра.
<P>
<P>
<P>
<P>
<H3>Обобщенные Параметры Числового Форматирования</H3>

<P>
<P>Это - стандартные элементы struct lconv; хотя могут иметься и
другие.
<BLOCKQUOTE><CODE>
<PRE>
       char *decimal_point
       char *mon_decimal_point
</PRE>
</CODE></BLOCKQUOTE>

Это - разделители Десятичных точек, используемые в
форматировании невалютных и валютных чисел, соответственно. В "C" стандарте, 
значение decimal_point - ".", а значение
mon_decimal_point - "".
<BLOCKQUOTE><CODE>
<PRE>
       char *thousands_sep
       char *mon_thousands_sep
</PRE>
</CODE></BLOCKQUOTE>

Это - разделители, используемые, чтобы разграничить группы цифр
налево от десятичной точки при форматировании невалютных и
валютных чисел, соответственно. В "C" стандарте, оба элемента
имеет значение "" (пустая строка).
<BLOCKQUOTE><CODE>
<PRE>
       char *grouping
       char *mon_grouping
</PRE>
</CODE></BLOCKQUOTE>

Это - строки, которые определяют, как группировать цифры налево
от десятичной точки. Группировка grouping применяется к невалютным
количествам, а mon_grouping применяется к валютным числам.
Используются или thousands_sep или mon_thousands_sep, чтобы
отделить группы цифры.
<P>Каждая строка состоит из десятичных чисел, отделяемых точками с
запятой. Последовательные числа (слева направо) дают размеры
последовательных групп (справа налево, начиная с десятичной
точки). Последнее число в строке используется много раз для всех
оставшихся групп.
<P>Если последним целым числом является -1, это означает, что любые
остающиеся цифры формируются в одну большую группу без
разделителей.
<P>Например, при - "4;3;2", правильная группировка для числа
123456787654321 будет  " 12 ", " 34 ", " 56 ", " 78 ", " 765 ", "
4321 ". С разделителем ",", число было бы напечатано как "
12,34,56,78,765,4321 ".
<P>Значение "3" указывает повторение группы из трех цифр, как
обычно используется в США.
<P>В стандарте " C ", и grouping и mon_grouping имеют значения "".
Это значение не определяет никакой группировки вообще.
<BLOCKQUOTE><CODE>
<PRE>
       char int_frac_digits
       char frac_digits
</PRE>
</CODE></BLOCKQUOTE>

Это - целые, указывающие, сколько дробных цифр (направо от
десятичной точки) должны отобразиться в валютном значении в
международных и местных форматах, соответственно. (Наиболее часто,
оба элемента имеют то же самое значение.)
<P>В стандарте " C ", оба этих элемента имеют значение CHAR_MAX,
означая "неопределенный".
<P>Мы рекомендуем не печатать никаких дробных цифр. (Этот стандарт
также определяет  пустую строку для mon_decimal_point, так печать
любых дробных цифр только путала бы!)
<P>
<H3>Печать Символа Валюты</H3>

<P>
<P>Эти элементы структуры struct lconv определяют, как печатать
символ, чтобы идентифицировать валютное значение международный
аналог " $ ".
<P>Каждая страна имеет два стандартных символа валюты. Местный
символ валюты используется обычно внутри страны, в то время как
международный символ валюты используется всемирно, чтобы обратиться
к валюте этой страны, когда необходимо указать страну
недвусмысленно.
<P>Например, многие страны используют доллар в качестве денежной единицы,
но для международных валют важно определить, что мы имеем дело
с Канадскими долларами, вместо Американских долларов или
Австралийских долларов. Но когда контекст известен, не имеется
никакой потребности объявлять эти явные долларовые количества в
Канадских долларах.
<BLOCKQUOTE><CODE>
<PRE>
       char *currency_symbol
</PRE>
</CODE></BLOCKQUOTE>

Местный символ валюты для выбранного стандарта.
<P>В стандарте " C ", этот элемент имеет значение "" (пустая
строка), означая "неопределенный". Стандарт ANSI не говорит, что
делать, когда Вы находите это значение; мы рекомендуем, чтобы Вы
просто печатали пустую строку, как Вы печатали бы любую другую
строку, найденную в соответствующем элементе.
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       char *int_curr_symbol
</PRE>
</CODE></BLOCKQUOTE>

Международный символ валюты для выбранного стандарта.
<P>Значение int_curr_symbol должно обычно состоять из трех&shy;
символьного сокращения, определенного Международной организацией по
стандартизации международного эталона как один из 4217 Кодов для
Представления Валюты и Фондов, сопровождаемых разделителем (часто
пробел).
<P>В стандарте " C ", этот элемент имеет значение "" (пустая
строка), означая "неопределенный". Мы рекомендуем, чтобы Вы просто
печатали пустую строку, как Вы печатали бы любую другую строку,
найденную в соответствующем элементе.
<BLOCKQUOTE><CODE>
<PRE>
       char p_cs_precedes
       char n_cs_precedes
</PRE>
</CODE></BLOCKQUOTE>

Эти элементы равны 1, если currency_symbol строка предшествует
значению валютного количества, или 0, если строка следует за
значением. P_cs_precedes лемент применяется к положительным
значениям (или нулю), а n_cs_precedes элемент применяется к
отрицательным значениям.
<P>В стандарте " C ", оба этих элемента имеют значение CHAR_MAX,
означая "неопределенный". Стандарт ANSI не говорит, что делать,
когда Вы находите это значение, но мы рекомендуем печатать символ
валюты перед числом. Это - правильно для большинства стран. Другими
словами, обработайте все значения отличные от нуля подобно этим
элементам.
<P>Стандарт POSIX говорит, что эти два элемента обращаются к
int_curr_symbol также как currency_symbol. Стандарт ANSI C,
кажется,  подразумевает, что они должны применяться только к
currency_symbol_so,  int_curr_symbol должен всегда предшествовать
количеству.
<P>Мы можем только предполагать, которое из этих соответствует
обычному соглашению для печати международных символов валюты. Наше
предположение - то, что они должны всегда предшествовать
количеству. Если мы выясим точный ответ, мы поместим его здесь.
<BLOCKQUOTE><CODE>
<PRE>
       char p_sep_by_space
       char n_sep_by_space
</PRE>
</CODE></BLOCKQUOTE>

Эти элементы равны 1, если между currency_symbol строкой и количеством
ставится пробел, или 0, если никакого пробела не ставится.
P_sep_by_space элемент применяется к положительным количествам (или
нулю), и n_sep_by_space элемент применяется к отрицательным
количествам.
<P>В стандарте "C", оба этих элемента имеют значение CHAR_MAX,
означая "неопределенный". Стандарт ANSI не говорит, что Вы должны
делать, когда Вы находите это значение; мы предлагаем, чтобы Вы
обрабатывали это как 1 (печатайте пробел). Другими словами,
обрабатывайте все значения отличные от нуля подобно этому элементу.
<P>Эти элементы применяются только к currency_symbol. Когда Вы
используете int_curr_symbol, Вы никогда не печатаете дополнительный
пробел, потому что int_curr_symbol непосредственно содержит
соответствующий разделитель.
<P>Стандарт POSIX говорит, что эти два элемента обращаются к
int_curr_symbol также как currency_symbol. Но пример в стандарте
ANSI C ясно подразумевает, что они должны применяться только к
currency_symbol_that, int_curr_symbol содержит любой
соответствующий разделитель, так что Вы никогда не должны печатать
дополнительный пробел.
<P>Мы рекомендуем, чтобы Вы игнорировали эти элементы при печати
международных символов валюты и не печатали никаких дополнительных
пробелов.
<P>
<H3>Печать Значения Количества Денег</H3>

<P>
<P>Эти элементы структуры struct lconv определяют, как печатать
знак в валютном значении.
<BLOCKQUOTE><CODE>
<PRE>
       char *positive_sign
       char *negative_sign
</PRE>
</CODE></BLOCKQUOTE>

Это - строки, используемые, чтобы указать положительное (или
нуль) и отрицательное (соответственно) валютные количества.
<P>В стандарте "C", оба этих элемента имеет значение "" (пустая
строка), означая "неопределенный".
<P>Стандарт ANSI не говорит, что делать, когда Вы находите это
значение; мы рекомендуем печатать positive_sign. Для отрицательного
значения, печатайте negative_sign, если Вы находите его, если оно и
positive_sign пусты, тогда печатайте "-" взамен. (Не указывать знак
вообще - кажется довольно неблагоразумным.)
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       char p_sign_posn
       char n_sign_posn
</PRE>
</CODE></BLOCKQUOTE>

Эти элементы имеют значения типа integer и указывают, как 
позиционировать знак для неотрицательных и
отрицательных валютных количеств, соответственно. (Строка,
используется знаком определенным в positive_sign или
negative_sign.) возможные значения следующие:
<BLOCKQUOTE><CODE>
<PRE>
       0 Символ валюты и количество должны быть окружены круглыми скобками.
       1 Печатает строку перед символом валюты и количеством.
       2 Печатает строку после символа валюты и количества.
       3 Печатает строку сразу перед символом валюты.
       4 Печатает строку сразу за символом валюты.
</PRE>
</CODE></BLOCKQUOTE>

CHAR_MAX "Неопределен". Оба элемента имеют это значение в
стандарте " C ". Стандарт ANSI не говорит, что Вы должны делать,
когда значение - CHAR_MAX. Мы рекомендуем, чтобы Вы печатали знак
после символа валюты.
<P>
<P>
<HR>
<A HREF="glibc-20.html">Вперед</A>
<A HREF="glibc-18.html">Назад</A>
<A HREF="glibc.html#toc19">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
