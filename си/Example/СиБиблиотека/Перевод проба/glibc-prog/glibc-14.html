<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Арифметические функции низкого уровня</TITLE>
 <LINK HREF="glibc-15.html" REL=next>
 <LINK HREF="glibc-13.html" REL=previous>
 <LINK HREF="glibc.html#toc14" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-15.html">Вперед</A>
<A HREF="glibc-13.html">Назад</A>
<A HREF="glibc.html#toc14">Содержание</A>
<HR>
<H2><A NAME="s14">14. Арифметические функции низкого уровня</A></H2>

<P>
<P>Эта глава содержит информацию относительно функций предназначенных для
выполнения базисных арифметических операций, типа разбивания float
на целую и дробную части. Эти функции объявлены в заголовочном файле "math.h ".
<P>
<H2><A NAME="ss14.1">14.1 "Не Числовые" Значения</A>
</H2>

<P>
<P>Формат ИИЭР с плавающей запятой используемый наиболее
современными компьютерами, поддерживает значения, которые являются
"не числами". Эти значения называются NaN. Эти значения следуют из
некоторых операций, которые не имеют никакого значимого числового
результата, типа нуля, деленого на нуль или бесконечности, деления
на бесконечность.
<P>Одна примечательная особенность NaN'ов заключается в том, что они не равны
себе. Таким образом, x == x может быть 0, если значение x - NaN. Вы
можете использовать это, чтобы проверить является ли значение NaN
или нет: если оно не равно себе, то это - NaN. Но рекомендуемый
способ проверять NaN - isnan функцией (см. Раздел 14.2 [Предикаты
на Значениях с Плаваюшей точкой]).
<P>Почти любая арифметическая операция, в которой аргумент является
NaN, возвращает NaN.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double NAN  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Выражение, представляющее значение, которое является "не числом". Эта
макрокоманда является расширением GNU, доступное только на машинах, которые
поддерживают значения "not a number" то есть на всех машинах поддерживающих
формат с плавающей запятой.
<P>Вы можете использовать " #ifdef NAN " чтобы проверить,
поддерживает ли машина NaN. (Конечно, Вы должны принять меры, чтобы
расширения GNU были видимыми, определяя _GNU_SOURCE, и  Вы должны
включить " math.h ".)
<P>
<H2><A NAME="ss14.2">14.2 Предикаты на Float</A>
</H2>

<P>
<P>Этот раздел описывает некоторые разнообразные функции-тесты
double значений. Прототипы для этих функций появляются в "math.h". Это функции
BSD, и таким образом доступны, если Вы определяете _BSD_SOURCE или _GNU_SOURCE.
<P>
<BLOCKQUOTE><CODE>
<PRE>
   int isinf (double x)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает -1, если x представляет отрицательную 
бесконечность, 1, если x представляет положительную бесконечность,
и 0 иначе.
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int isnan (double x)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает значение отличное от нуля, если x - 
значение " not a number ", и нуль иначе. (Вы можете точно также 
использовать x!= x, чтобы получить тот же самый результат).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int finite (double x)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает значение отличное от нуля, если x конечен 
или значение " not a number ", и нуль иначе.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double infnan (int error)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция предусмотрена для совместимости с BSD. Другие 
математические функции используют infnan, чтобы решить, что 
возвратить в случае ошибки. Аргумент - код ошибки, EDOM или ERANGE; 
infnan возвращает подходящее значение, чтобы указать ошибку. &shy;
ERANGE также допустим как аргумент, и соответствует -HUGE_VAL как
значение.
<P>В библиотеке BSD, на некоторых машинах, infnan вызывает 
фатальный сигнал во всех случаях. Библиотека GNU не делает 
аналогично, потому что это не удовлетворяет спецификации ANSI C.
<P>Примечание Переносимости: функции, перечисленные в этом разделе 
- расширения BSD.
<P>
<H2><A NAME="ss14.3">14.3 Абсолютное значение</A>
</H2>

<P>
<P>Эти функции предусмотрены для получения абсолютного значения 
(или величины) числа. Абсолютное значение вещественного числа x - x 
если x положителен, -x, если x отрицателен. Для комплексного числа 
z, чья вещественная часть является x и чья мнимая часть является y,
абсолютное значение - sqrt (x * x + y * y).
<P>Прототипы для abs и labs находятся в " stdlib.h "; fabs и cabs 
объявлены в " math.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int abs (int number)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает абсолютное значение числа.
<P>Большинство компьютеров использует двоичное дополнение 
представления integer, в котором абсолютное значение INT_MIN (самый 
маленький возможный int) не может представляться; таким образом, 
abs (INT_MIN) не определен.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    long int labs (long int number) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Подобна abs, за исключением того, что и аргумент и результат 
имеют тип long int а не int.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double fabs (double number)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает абсолютное значение числа с плавающей 
запятой.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double cabs (struct { double real, imag; } z)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция cabs возвращает абсолютное значение комплексного числа 
z, чья вещественная часть является z.real и чья мнимая часть 
является z.imag. (См. также функцию hypot в Разделе 13.4 
[Экспоненты и Логарифмы].); значение:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sqrt (z.real*z.real + z.imag*z.imag)
</PRE>
</CODE></BLOCKQUOTE>
      
<H2><A NAME="ss14.4">14.4 Функции Нормализации</A>
</H2>

<P>
<P>Функциям, описанные в этом разделе прежде всего обеспечивают 
способ эффективно выполнить некоторые манипулирования низкого 
уровня на числах с плавающей запятой, которые представляются, 
внутренне используя двоичную систему счисления. Эти функции 
требуются, чтобы реализовать эквивалентное поведение, даже если
представление не использует основание системы счисления 2, но 
конечно они, вряд ли, будут особенно эффективны в тех случаях.
<P>Все эти функции объявлены в " math.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double frexp (double value, int *exponent)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Frexp функция используется, чтобы разбивать значение числа на 
нормализованную дробь и экспоненту.
<P>Если значение аргумента value - не нуль, возвращаемое значение 
value - число степеней двойки, и всегда в диапазоне от 1/2 (включ.) 
до 1 (исключ.). Соответствующая экспонента сохранена в *exponent; 
возвращаемое значение, умноженное на 2 возведенное в эту 
экспоненту, равняется первоначальному значению числа.
<P>Например, frexp (12.8, &amp;exponent) возвращает 0.8 и сохраняет 4 в 
exponent.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double ldexp (double value, int exponent)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает результат умножения значения числа с 
плавающей запятой на 2 в степени exponent. (Это может 
использоваться, чтобы повторно транслировать числа с плавающей 
запятой, которые были демонтированы frexp.)
<P>Например, ldexp (0.8, 4) Возвращает 12.8.
<P>Следующие функции, которые исходят ИЗ BSD, обеспечивают 
эквиваленты средств ldexp и frexp:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double scalb (double value, int exponent)
</PRE>
</CODE></BLOCKQUOTE>

Scalb функция - BSD имя для ldexp.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double logb (double x)
</PRE>
</CODE></BLOCKQUOTE>

Эта BSD функция возвращает целочисленную часть логарифма x по 
осн. 2, целочисленное значение представляется в double. Знак x 
игнорируется. Например, logb (3.5) = 1.0 и logb (4.0) = 2.0.
<P>Когда 2 в этой степени разделена на x, это дает частное между 1 
(включ.) и 2 (исключ.).
<P>Если x - нуль, значение - минус бесконечность (если машина
поддерживает такое значение), или очень малое число. Если x - 
бесконечность, значение - бесконечность.
<P>Значение, возвращенное logb на один меньше чем то что frexp 
сохранил бы в *exponent.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double copysign (double value, double sign) Function
</PRE>
</CODE></BLOCKQUOTE>

Copysign функция возвращает значение, чье абсолютное значение 
равно указанному значению, и чей знака противоположен исходному. 
Это - функция BSD.
<P>
<H2><A NAME="ss14.5">14.5 Функции Округления и Остаточного члена</A>
</H2>

<P>
<P>Функции, перечисленные здесь выполняют операции типа округления,
усечения, и взятия остаточного члена от деления чисел с плавающей 
запятой. Некоторые из этих функций преобразовывают числа с 
плавающей запятой в целочисленные значения. Они все объявлены в " 
math.h ".
<P>Вы можете также преобразовывать числа с плавающей запятой в 
integer просто, приводя их к int. Это отбрасывает дробную часть, 
действительно округляя к нулю. Однако, это работает только, если 
результат может фактически представляться как int и для очень 
больших чисел, это невозможно. Функции, перечисленные здесь 
возвращают результат как double, чтобы обойти эту проблему.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double ceil (double x)
</PRE>
</CODE></BLOCKQUOTE>

Ceil функция округляет x вверх к самому близкому целому числу, 
возвращая это значение как double. Таким образом, ceil (1.5) = 2.0.
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double floor (double x)
</PRE>
</CODE></BLOCKQUOTE>

floor функция округляет x вниз к самому близкому целому числу,
возвращая это значение как double. Таким образом, floor (1.5) = 
1.0, а floor (-1.5) = -2.0.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double rint (double x)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция округляет x к целочисленному значению согласно 
текущему режиму округления.
<P>Режим округления значения по умолчанию к самому близкому целому 
числу; некоторые машины поддерживают другие режимы, но этот не 
всегда используется если Вы явно выбираете другой.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double modf (double value, double *integer_part)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция разбивает значение аргумента на целочисленную часть 
и дробную часть (между -1 и 1, не включ.). Их сумма равняется 
значению. Каждая из частей имеет тот же самый знак как значение, 
так что округление целочисленной части - к нулю.
<P>Modf сохраняет целочисленную часть в *integer_part, и возвращает
дробную часть. Например, modf (2.5, &amp;intpart) возвращает 0.5 и 
сохраняет 2.0 в integer_part.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double fmod (double numerator, double denominator)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция вычисляет остаточный член от деления numerator yf 
denominator. Специально, возвращаемое значение - numerator - n * 
denominator, где n - частное numerator/denominator, округленное к 
целому числу. Таким образом, fmod (6.5, 2.3) возвращает 1.9, 
который является 6.5-4.6.
<P>Результат имеет тот же самый знак как numerator и имеет величину 
меньше чем величина denominator.
<P>
<P>Если denominator - нуль, fmod сбоит и устанавливает errno как 
EDOM.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double drem (double numerator, double denominator)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция drem - подобна fmod за исключением того, что она
округляет внутреннее частное n к самому близкому целому числу а не 
к целому числу в сторону нуля. Например, drem (6.5, 2.3) возвращает 
-0.4, который является 6.5-6.9.
<P>Абсолютное значение результата - меньше или равно половине
абсолютного значения denominator. Различие между fmod (numerator, 
denominator) и drem (numerator, denominator) - всегда либо 
denominator, либо -denominator, либо нуль.
<P>Если denominator - нуль, drem сбоит и устанавливает errno как 
EDOM.
<P>
<H2><A NAME="ss14.6">14.6 Целочисленное деление</A>
</H2>

<P>
<P>Этот раздел описывает функции для выполнения деления целых 
чисул. Эти функции избыточны в библиотеке GNU C, с тех пор в GNU C,  
оператор ` / ' всегда округляется к нулю. Но в других реализациях 
C, " / " может поступать по-другому с отрицательными аргументами. 
div и ldiv полезны, потому что они определяют как округляется 
частное: к нулю. Остаточный член имеет тот же самый знак как
числитель.
<P>Эти функции определены, чтобы возвратить результат r такой, что 
значение r.quot*denominator+r.rem равняется numerator.
<P>Чтобы использовать эти средства, Вы должны включить заглавный 
файл " stdlib.h " в вашей программе.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    div_t                 (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это - структура, используемая, чтобы содержать результат, 
возвращенный функцией div. Она имеет следующие элементы:
<UL>
<LI>    Int quot частное от деления.</LI>
<LI>    Int rem остаточный член от деления.</LI>
</UL>

<BLOCKQUOTE><CODE>
<PRE>
    div_t div (int numerator, int denominator)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция вычисляет частное и остаточный член от деления 
numerator на denominator, возвращая результат в структуре типа
div_t.
<P>Если результат не может представляться (напр. деление на нуль), 
поведение не определено.
<P>Вот пример, хотя и не очень полезный.
<P>
<BLOCKQUOTE><CODE>
<PRE>
                        div_t result;
                        result = div (20, -6);
</PRE>
</CODE></BLOCKQUOTE>

Теперь result.quot = -3, а result.rem = 2.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       ldiv_t             (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это - структура, используемая, чтобы содержать результат, 
возвращенный функцией ldiv. Она имеет следующие элементы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    long int quot
</PRE>
</CODE></BLOCKQUOTE>

Частное от деления.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    long int rem
</PRE>
</CODE></BLOCKQUOTE>

Остаточный член от деления. (идентично div _t за исключением 
того, что компоненты имеют тип long int а не int.)
<P>
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    ldiv_t ldiv (long int numerator, long int denominator)   (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция ldiv подобна div, за исключением того, что аргументы 
имеют тип long int, и результат возвращается как структура ldiv 
типа.
<P>
<H2><A NAME="ss14.7">14.7 Синтаксический анализ Чисел</A>
</H2>

<P>
<P>Этот раздел описывает функции для "чтения" целого числа и чисел 
с плавающей запятой из строки. Может быть более удобно в некоторых 
случаях использовать sscanf или одну из подобных функций; см. 
раздел 7.11 [Форматируемый Ввод]. Но часто Вы можете делать 
программу более надежной,  находя лексемы в строке вручную, и
преобразуя их в числа один за другим.
<P>
<H3>Последовательный Синтаксический анализ</H3>

<P>
<P>
<P>Эти функции объявлены в " stdlib.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    long int strtol (const char *string, char **tailptr, int base)   (функция)
</PRE>
</CODE></BLOCKQUOTE>

Strtol ("string-to-long") функция преобразовывает начальную 
часть строки в целое число со знаком, которое возвращено как 
значение long int.
<P>Если строка является пустой, содержит только пропуск(и), или не 
содержит начальную подстроку, которая имеет ожидаемый синтаксис для 
целого числа с заданным base, никакое преобразование не 
выполняется. В этом случае, strtol возвращает нулевое значение, а 
значение, сохраненное в *tailptr - значение строки.
<P>Если строка имеет допустимый синтаксис для целого числа, но 
значения не представимы из-за переполнения, strtol возвращает или 
LONG_MAX или LONG_MIN (см. Раздел A. 5.2 [Диапазон Типа]),  
соответствующее знаку значения. Она также устанавливает errno как 
ERANGE, чтобы указать, что имелось переполнение.
<P>См. пример в конце этого раздела.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int strtoul (const char *string, char **tailptr, int base)
</PRE>
</CODE></BLOCKQUOTE>

Strtoul ("string-to-unsigned-long") функция - подобна strtol за 
исключением того, что она возвращает значение с типа long unsigned 
int. Значение, возвращенное в случае переполнения - ULONG_MAX (см. 
Раздел A. 5.2 [Диапазон Типа]).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    long int atol (const char *string)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция подобна strtol функции с аргументом base 10, за 
исключением того, что ей не требуется обнаруживать ошибки
переполнения. Atol функция обеспечивается обычно для совместимости 
с существующим кодом; использование strtol более надежно.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int atoi (const char *string)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - подобна atol, за исключением того, что она 
возвращает значение int а не long int. Atoi функция также 
рассматривается устаревшей; используйте strtol.
<P>Вот функция, которая анализирует строку как последовательность 
целых и возвращает их сумму:
<BLOCKQUOTE><CODE>
<PRE>
                int
                sum_ints_from_string (char *string)
                {
                        int sum = 0;
                        while (1) {
                                char *tail;
                                int next;
                                while (isspace (*string)) string++;
                                if (*string == 0)
                                        break;
                                errno = 0;
                                next = strtol (string, &amp;tail, 0);
                                if (errno)
                                        printf ("Overflow\n");
                                else
                                        sum += next;
                                string = tail;
                        }
                        return sum;
                }
</PRE>
</CODE></BLOCKQUOTE>
       
<H3>Синтаксический анализ Float</H3>

<P>
<P>Эти функции объявлены в " stdlib.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double strtod (const char *string, char **tailptr)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Strtod ("string-to-double") функция преобразовывает начальную
часть строки в число с плавающей запятой, которое возвращается как 
значение double.
<P>Эта функция пытается разлагать строку следующим образом:
<UL>
<LI>     (Возможно пустая) последовательность символов пропуска. 
Символы пропуска определяются isspace функцией (см. Раздел 4.1 
[Классификация Символов]). Они отброшены.
</LI>
<LI>     Не обязательный "плюс" или "минус" (" + " или " - ").
</LI>
<LI>     Непустая последовательность цифр, необязательно содержащих 
десятичную точку ".", но это зависит от стандарта (см. Раздел 19.6 
[Числовое Форматирование].
</LI>
<LI>     Не обязательная часть экспоненты, состоящая из символа " e " 
или " E ", знака, и последовательности цифр.
</LI>
<LI>     Если tailptr - не пустой указатель, указатель на этот хвост 
списка строки сохранен в *tailptr.</LI>
</UL>

Если строка является пустой, содержит только пропуски, или не 
содержит начальную подстроку, которая имеет ожидаемый синтаксис для 
числа с плавающей запятой, никакое преобразование не выполняется.
<P>В этом случае, strtod возвращает нуль, а значение, возвращенное 
в *tailptr - значение строки.
<P>В стандарте отличном от стандарта "C", эта функция может 
распознавать дополнительный синтаксис.
<P>Если строка имеет допустимый синтаксис для числа с плавающей 
запятой, но значения,  не представимы из-за переполнения, strtod 
возвращает или положительный или отрицательный HUGE_VAL (см. Главу 
13 [Математика]), в зависимости от знака значения. Аналогично, если 
значение не представимо из-за близости к нулю, strtod возвращает 
нуль. Она также устанавливает errno как ERANGE, если имелось 
переполнение или обнуление.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    double atof (const char *string)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция подобна функции strtod, за исключением того, что ей 
не требуется обнаруживать ошибки переполнения. Atof  обеспечивают 
обычно для совместимости с существующим кодом; использование strtod 
более надежно.
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR>
<A HREF="glibc-15.html">Вперед</A>
<A HREF="glibc-13.html">Назад</A>
<A HREF="glibc.html#toc14">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
