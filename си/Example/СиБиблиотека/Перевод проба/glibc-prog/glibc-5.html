<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Утилиты для работы со строками и массивами.</TITLE>
 <LINK HREF="glibc-6.html" REL=next>
 <LINK HREF="glibc-4.html" REL=previous>
 <LINK HREF="glibc.html#toc5" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-6.html">Вперед</A>
<A HREF="glibc-4.html">Назад</A>
<A HREF="glibc.html#toc5">Содержание</A>
<HR>
<H2><A NAME="s5">5. Утилиты для работы со строками и массивами.</A></H2>

<P>
<P>Операции на строках (или массивах символов) - важная часть многих
программ. Библиотека C GNU обеспечивает большой набор строковых
сервисных функций, включая функции для копирования, связывания,
сравнения, и поиска строк. Многие из этих функций могут также
функционировать на произвольных областях памяти; например, функция
memcpy может использоваться, чтобы копировать содержимое любого вида
массива.
<P>Для начинающихся С программистов довольно обычно "повторно
изобретать колесо", дублируя эти функциональные возможности в их
собственном коде, но знакомому с библиотечными функциями выгодно
использовать их, так как это дает выгоды в эффективности и
переносимости.
<P>Например, Вы можете легко сравнивать одну строку с другим в двух
строках кода C, но если Вы используете встроенную функцию strcmp, менее
вероятно, что Вы сделаете ошибку. И, так как эти библиотечные функции
обычно сильно оптимизированы, ваша программа может выполняться быстрее.
<P>
<H2><A NAME="ss5.1">5.1 Представление строк</A>
</H2>

<P>
<P>Этот раздел - быстрый обзор строковых понятий для начинающих
программистов. Он описывает, как символьные строки представляются на C.
Если Вы уже знакомы с этим материалом, Вы можете пропустить этот раздел.
<P>Строка - массив объектов char. Но строковые переменные, обычно
объявляется, как указатели типа char *. Такие переменные не включают
пространство для текста строки; он должен быть сохранен где-нибудь в
переменной типа массив, строковой константе, или динамически размещенной
памяти (см. Главу 3 [Распределение памяти]). Это позволяет Вам сохранить
адрес выбранного пространства памяти в переменнуюуказатель. В качестве
альтернативы Вы можете сохранять пустой указатель в переменной. Пустой
указатель никуда не указывает, так что попытка сослаться на строку, на
которую он указывает, получит ошибку.
<P>Обычно, пустой символ, "\0", отмечает конец строки. Например, в
тестировании, чтобы видеть, что переменная p указывает на пустой символ,
отмечающий конец строки, Вы можете написать ! * P или * p == "\0".
<P>Пустой символ - совершенно отличен от пустого указателя, хотя, и
представляется целым числом 0.
<P>Строковые литералы появляются в C программе как строки символов
между символами кавычек ('"'). В ANSI C, строковые литералы могут также
быть сформированы строковой конкатенацией: "a" "b" - то же что "ab".
Изменение строковых литералов не допускается GNU С компилятором, потому
что литералы помещены в памяти только для чтения.
<P>Символьные массивы, которые являются объявленным const, также не
могут изменяться. Это - вообще хороший стиль, объявить, что
немодифицируемые строковые указатели будут типа const char *, так как
это часто позволяет компилятору C обнаружить случайные изменения, также
как обеспечение некоторого количества документации относительно того,
что ваша программа предполагает делать со строкой.
<P>Объем памяти, размещенный для символьного массива может
простираться после пустого символа, который обычно отмечает конец
строки. В этом документе термин размер резервирования всегда
используется, чтобы обратиться к общей сумме памяти, размещенной для
строки, в то время как термин длина относится к числу символов до (но
не, включая) пустого символа завершения.
<P>
<P>Известным источником ошибок является то, что программа пробует
помещать большее количество символов в строку чем позволяет размещенный
размер. При написании кода, который расширяет строки или перемещает
символы в массив, Вы должны быть очень осторожны, чтобы следить за
длиной текста и делать явную проверку переполнения массива. Многие из
библиотечных функций не делают это для Вас! Не забудьте также, что Вы
должны зарезервировать дополнительный байт, чтобы содержать пустой
символ, который отмечает конец строки.
<P>
<H2><A NAME="ss5.2">5.2 Соглашения относительно строк и массивов</A>
</H2>

<P>
<P>Эта глава описывает функции, которые работают над произвольными
массивами или блоками памяти, и функции, которые являются специфическими
для массивов с нулевым символом в конце.
<P>Функции, которые функционируют на произвольных блоках памяти, имеют
имена, начинающиеся "mem" (типа memcpy) и неизменно имеют аргумент,
который определяет размер (в байтах) блока рабочей памяти. Аргументы
массива и возвращаемые значения для этих функций имеют тип void*, и как
стиль, элементы этих массивов упоминаются как "байты". Вы можете
передавать любой вид указателя на эти функции, а оператор sizeof полезен
при вычислении значения аргумента size.
<P>Напротив, функции, которые функционируют специально на строках,
имеют имена, начинающиеся "str" (типа strcpy) и ищут пустой символ,
чтобы завершить строку вместо того, чтобы требовать, чтобы был передан
явный аргумент размера. (Некоторые из этих функций принимают заданную
максимальную длину, но они также проверяют преждевременное окончание с
пустым символом.) аргументы массива и возвращаемые значения для этих
функций имеют тип char *, и элементы массива упоминаются как "символы".
<P>В многих случаях, имеется, и "mem" и "str" версии функции. Которая
является более подходящей, зависит от контекста. Когда ваша программа
манипулирует произвольными массивами или блоками памяти, Вы должны
всегда использовать "mem" функции. С другой стороны, когда Вы
манипулируете строками с нулевым символом в конце, обычно более удобно
использовать "str" функции, если Вы не знаете длину строки заранее.
<P>
<H2><A NAME="ss5.3">5.3 Длина строки</A>
</H2>

<P>
<P>Вы можете получить длину строки, используя функцию strlen. Эта
функция объявлена в заголовочном файле "string.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t strlen (const char * s) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strlen возвращает длину строки с нулевым символом в конце.
(Другими словами, она возвращает смещение пустого символа завершения
внутри массива.) Например,
<P>strlen ("привет, мир")
=&gt;12
<P>Когда функция strlen применяется к символьному массиву, она
возвращает длину сохраненной строки, а не размер резервирования. Вы
можете получить размер резервирования символьного массива, который
содержит строку, используя оператор sizeof:
<P>char string[32] = "привет, мир";
sizeof (string)
=&gt; 32
strlen (string)
=&gt; 12
<P>
<H2><A NAME="ss5.4">5.4 Копирование и конкатенация</A>
</H2>

<P>
<P>Вы можете использовать функции, описанные в этом разделе, чтобы
копировать содержимое строк и массивов, или конкатенировать содержимое
одной строки c другой. Эти функции объявлены в заголовочном файле
"string.h".
<P>Все эти функции возвращают адрес целевого массива.
<P>Большинство этих функций не работает правильно, если исходный и
целевой массивы накладываются. Например, если начало массива адресата
накладывается на конец исходного массива, первоначальное содержимое той
части исходного массива может стать записанным поверх прежде, чем это
скопировано. Даже хуже, в случае строковых функций, пустой символ,
отмечающий конец строки можно потерять, и функция копирования может
эастревать в цикле, просматривая всю память зарезервированную для вашей
программы.
<P>Все функции, которые имеют проблемы при копировании между
накладывающимися массивами, явно идентифицированы в этом руководстве. В
дополнение к функциям в этом разделе, имеется несколько, других например
sprintf (см. раздел 7.9.7 [Форматируемые функции вывода]) и scanf (см.
раздел 7.11.8 [Форматируемые функции ввода]).
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * memcpy (void *to, void const *from, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция memcpy копирует size байт из объекта, начинающегося в from
в объект, начинающийся в to. Поведение этой функции неопределено если
два массива перекрываются; используйте memmove взамен, если возможно
перекрывание.
<P>Значение, возвращенное memcpy - значение to.
<P>Вот пример того, как Вы могли бы использовать memcpy, чтобы
копировать содержимое массива:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct foo *oldarray, *newarray;
      int arraysize;
      ...
      memcpy (new, old, arraysize * sizeof (struct foo));

      void * memmove (void *to, void const *from, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

memmove копирует size байт из from в size в to, даже если те два
блока памяти перекрываются.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * memccpy (void *to, void const *from, int C, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция копирует не больше, чем size байт из from в to,
останавливая если найден байт соответствующий C. Возвращаемое значение &shy;
указатель в to на первый байт после C, или пустой указатель, если
никакой байт, соответствующий C не появился в первых size байтах from.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * memset (void * block, int C, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция копирует значение C (преобразованный в char без знака)
в каждый из первых size байтов объекта, начинающегося с block. Она
возвращает значение block.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      сhar * strcpy (char *to, const char *from) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Она копирует символы из строки from (включая пустой символ
завершения) в строку to. Подобно memcpy, эта функция имеет
неопределенные результаты, если строки накладываются. Возвращаемое
значение - значение to.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * strncpy (char *to, const char *from, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция подобна strcpy, но всегда копирует точно size символов
в to.
<P>Если длина from - больше чем size, то strncpy копирует только
первые size символов.
<P>Если длина from меньше чем size, то strncpy, копирует все from,
сопровождая его достаточным количеством пустых символов, чтобы получить
всего size символов. Это редко полезно, но зато определено в
соответствии c ANSI стандартом.
<P>Поведение strncpy неопределено, если строки накладываются.
<P>Использование strncpy в противоположность strcpy - способ избежать
ошибок в отношении соглашения о записи после конца размещенного
пространства для to. Однако, это может также сделать вашу программу
намного медленнее в одном общем случае: копирование строки, которая
является возможно малой в потенциально большой буфер. В этом случае,
size может быть большой, и когда это, strncpy будет тратить впустую
значительное количество времени, копируя пустые символы.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * strdup (const char * s) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция копирует строку с нулевым символом в конце в недавно
размещенную строку. Строка размещена, используя malloc; см. раздел 3.3
[Беспрепятственное резервирование].
<P>Если malloc не может зарезервировать пространство для новой строки,
strdup возвращает пустой указатель. Иначе она возвращает указатель на
новую строку.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * stpcpy (char *to, const char *from) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - подобно strcpy, за исключением того, что она
возвращает указатель на конец строки to (то есть адрес пустого символа
завершения) а не на начало.
<P>Например, эта программа использует stpcpy, чтобы конкатенировать
"foo" и "bar" и печатает "foobar".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;string.h&gt;
      #include &lt;stdio.h&gt;
      intmain (void)
      {
       char buffer[10];
       char *to = buffer;
       to = stpcpy (to, "foo");
       to = stpcpy (to, "bar");
       puts (buffer);
       return 0;
      }
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - не часть ANSI или POSIX стандартов, и не обычна в
системах UNIX, но мы не изобретали ее. Возможно она исходит из MS-DOS.
<P>Поведение неопределено, если строки накладываются.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      сhar * strcat (char * to, const char *from) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strcat подобна strcpy, за исключением того, что символы из
from добавляются или конкатенируются к концу to, вместо того, чтобы
записывать поверх него. То есть первый символ из from накладывается на
пустой символ, отмечающий конец to.
<P>Эквивалентное определение для strcat было бы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * strcat (char *to, const char *from)
      {
       strcpy (to + strlen to, from);
       return to;
      }
</PRE>
</CODE></BLOCKQUOTE>

Эта функция имеет неопределенные результаты, если строки
накладываются.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * strncat (char *to, const char *from, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - подобнa strcat за исключением того, что не больше чем
size символов из from конкатенируются к концу to. Одиночный пустой
символ также всегда конкатенируется к to, так что общая конечая длина to
должна быть по крайней мере на size + 1 байт больше чем начальная длина.
<P>Функция strncat могла быть выполнена примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * strncat (char *to, const char *from, size_t size)
      {
       strncpy (to + strlen (to), from, size);
       return to;
      }
</PRE>
</CODE></BLOCKQUOTE>

Поведение strncat неопределено, если строки накладываются.
<P>Вот пример, показывающий использование strncpy и strncat. Обратите
внимание, как вычислен параметр size, в обращении к strncat, чтобы
избежать переполнять символьный массив buffer.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;string.h&gt;
      #include &lt;stdio.h&gt;
      #define SIZE 10
      static char buffer[SIZE];
      main ()
      {
       strncpy (buffer, "hello", SIZE);
       puts (buffer);
       strncat (buffer, ", world", SIZE - strlen (buffer) - 1);
       puts (buffer);
      }
</PRE>
</CODE></BLOCKQUOTE>

Вывод, произведенный этой программой будет:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      hellohello, wo

      void * bcopy (void *from, void const *to, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Она является частично устаревшим вариантом для memmove, и
происходит от BSD. Обратите внимание, что она не совершенно эквивалентна
memmove, потому что аргументы не в том же самом порядке.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * bzero (void *block, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Она является частично устаренным аналогом memset, и происходит от
BSD. Обратите внимание, что она не такая общая как memset, потому что
единственое значение, которое она может сохранять - нуль. Некоторые
машины имеют специальные команды для установки на нуль памяти, так что
bzero может быть более эффективна чем memset.
<P>
<H2><A NAME="ss5.5">5.5 Сравнение строк/массивов</A>
</H2>

<P>
<P>Вы можете использовать функции в этого раздела, чтобы выполнить
сравнение на содержимое строк и массивов. Также как для проверки
равенства, эти функции могут использоваться как функции упорядочения для
операций сортировки. См. Главу 15 [Поиск и сортировка].
<P>В отличие от большинства операций сравнения в C, строковые функции
сравнения возвращают значение отличное от нуля, если строки - не
эквивалентны. Знак значения указывает относительное упорядочение первых
символов в строках, которые - не эквивалентны: отрицательное значение
указывает, что первая строка - "меньше" чем вторая, в то время как
положительное значение указывает, что первая строка "больше".
<P>Если Вы используете эти функции только, чтобы проверить равенство,
для большей чистоты программы, лучше задать их как макроопределения,
примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #define str_eq (s1, s2) (! Strcmp ((s1), (s2)))
</PRE>
</CODE></BLOCKQUOTE>

Все эти функции объявлены в заголовочном файле "string.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int memcmp (void const * a1, void const * a2, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция memcmp сравнивает size байт памяти, начинающиеся в a1 с
size байтами памяти, начинающимися в a2. Возвращенное значение имеет тот
же самый знак как разность между первой отличающейся парой байтов
(интерпретируемых как объекты char без знака).
<P>Если содержимое двух блоков равно, memcmp, возвращает 0.
<P>На произвольных массивах, функция memcmp обычно полезна для
тестирования равенства. Обычно не имеет смысла делать байтовое сравнение
упорядочения на не байтовых массивах. Например, байтовое сравнение на
байтах, которые составляют числа с плавающей запятой не должно
правдоподобно сообщить Вам что - нибудь относительно связи между
значениями чисел с плавающей запятой.
<P>Вы должны также быть внимательны при использовании memcmp, для
сравнения объектов, которые могут содержать "дырки", типа дополнения,
вставленного в объекты структуры, чтобы предписать требования
выравнивания, дополнительного пространства в конце объединений, и
дополнительных символов в концах строк, чьи длины меньше чем затребовано
при размещении.
<P>Содержимое этих "дырок" неопределено и может вызывать странное
поведение при выполнении байтового сравнения. Для более предсказуемых
результатов, выполните явное покомпонентное сравнение.
<P>Например, пусть дано определение типов структуры подобно:
<BLOCKQUOTE><CODE>
<PRE>
      struct foo {
       unsigned char tag;
       union{double f; long i; char *p;}
       value;
      };
</PRE>
</CODE></BLOCKQUOTE>

Вам лучше написать специализированные функции сравнения, чтобы
сравнить объекты struct foo вместо того, чтобы сравнить их memcmp.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int strcmp (const char * s1, const char * s2) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strcmp сравнивает строку s1 c s2, возвращая значение,
которое имеет тот же самый знак как различие между первой отличающейся
парой символов (интерпретируемых как объекты char без знака).
<P>Если две строки равны, strcmp, возвращает 0.
<P>Следствие упорядочения, используемого strcmp - то, что, если s1
является начальной подстрокой s2, то s1 "меньше чем" s2.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int strcasecmp (const char * s1, const char * s2) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция подобна strcmp, за исключением того, что разногласия
игнорируются.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      strcasecmp происходит от BSD.
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      int strncasecmp (const char * s1, const char * s2) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - подобна strncmp, за исключением того, что разногласия
игнорируются.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      strncasecmp - расширение GNU.
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      int strncmp (const char * s1, const char * s2, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция подобна strcmp, за исключением того, что сравниваются
не больше, чем size символов. Другими словами, если две строки совпадают
в их первых size символах, возвращаемое значение - нуль.
<P>Имеются некоторые примеры, показывающие использование strcmp и
strncmp. Эти примеры подразумевают использование набора символов ASCII.
(Если используется некоторый другой набор символов скажем, расширенный
двоично-десятичный код обмена информацией, взамен, то glyphs связаны с
различными числовыми кодами, и возвращаемые значения, и порядок могут
отличиться.)
<P>
<BLOCKQUOTE><CODE>
<PRE>
      strcmp ("привет", "привет")
      =&gt; 0 /* Эти две строки одинаковы. */
      strcmp ("привет", "Привет")
      =&gt; 33 /* Сравнение чувствительно к регистру. */
      strcmp ("привет", "мир")
      =&gt; -2 /* символ "п" меньше чем "м". */
      strcmp ("привет", "привет, мир")
      =&gt; -44 /* Сравнение пустого символа с запятой. */
      strncmp ("привет", "привет, мир", 5)
      =&gt; 0 /* начальные 5 символов - те же самые. */
      strncmp ("привет, мир","привет, глупый мир!!!", 5)
      =&gt; 0 /* начальные 5 символов - те же самые. */
      int bcmp (void const * a1, void const * a2, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Это - устаревший побочный результат исследования для memcmp,
происходит от BSD.
<P>
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss5.6">5.6 Функции для объединений</A>
</H2>

<P>
<P>В некоторых местах соглашения лексикографического упорядочения
отличаются от строгого числового упорядочения символьных кодов.
Например, в Испании большинство букв с диакритическими знаками, но буквы
с диакритическими знаками не считаются различными символами в целях
объединения. С другой стороны, последовательность с двумя символами "ll"
обрабатывается как одна буква, которая объединена с "l".
<P>Вы можете использовать функции strcoll и strxfrm (объявленные в
заголовочном файле "string.h") чтобы сравнивать строки, использующие
объединение упорядочивания соответствующее для данной местности.
Стандарт, используемое этими функциями в частности может быть
определено, устанавливая стандарт для класса LC_COLLATE; см. Главу 19
[Стандарты].
<P>В стандартном расположении C, последовательность объединений для
strcoll - таже что для strcmp.
<P>Действительно, способ, которым эта функция работает применяя
отображение, чтобы трансформировать символы в строку, в
последовательность байтов которая представляет позицию строки в
последовательности объединений текущего расположения. Сравнение двух
таких последовательностей байтов в простом режиме эквивалентно сравнению
строк с последовательностью объединений расположения.
<P>Функция strcoll выполняет эту трансляцию неявно, чтобы делать одно
сравнение. А, strxfrm выполняет отображение явно. Если Вы делаете
многократное сравнение, используя ту же самую строку или набор строк, то
более эффективноиспользовать strxfrm, чтобы трансформировать все строки
только один раз, и впоследствии сравнивать преобразованные строки
strcmp.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int strcoll (const char * s1, const char * s2) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strcoll подобна strcmp, но использует последовательность
объединений данного расположения для объединения (LC_COLLATE стандарт).
<P>Вот пример сортировки массива строк, с использованием strcoll,
чтобы сравнить их. Фактический алгоритм сортировки здесь не написан; он
исходит из qsort (см. раздел 15.3 [Функции сортировки массива]). Работа
кода показанного здесь, говорит, как сравнивать строки при их
сортировке. (Позже в этом разделе, мы покажем способ делать это, более
эффективно используя strxfrm.)
<P>
<BLOCKQUOTE><CODE>
<PRE>
      /* Это - функция сравнения, используемая в qsort. */
      intcompare_elements (char **p1, char **p2)
      {
       return strcoll (*p1,*p2);
      }

      /* Это - точка входа к функции сортировки строк, использующей
 последовательность объединений расположения. */
      void sort_strings (char **array, int nstrings)
      { /* Сортировка временного массива, сравнивая строки. */
       qsort (array, sizeof (char *), nstrings, compare_elements);
      }
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      size _t strxfrm (char *to, const char *from, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strxfrm трансформирует строку, используя преобразование
объединения, определенное стандартом, в настоящее время выбранным для
объединения, и сохраняет преобразованную строку в массиве to.
<P>Поведение неопределено если строки to и from перекрываются; см.
раздел 5.4 [Копирование и конкатенация].
<P>Возвращаемое значение - длина всей преобразованной строки. На это
значение не воздействует значение size, но если она большее чем size,
это означает, что преобразованная строка полностью не поместилась в
массиве to.
<P>Чтобы получать целую преобразованную строку, вызовите strxfrm снова
с большим массивом вывода.
<P>Преобразованная строка может быть больше чем первоначальная строка,
а может также быть более короткой.
<P>Если size - нуль, никакие символы не сохранены в to. В этом случае,
strxfrm просто возвращает число символов, которое было бы длиной
преобразованной строки. Это полезно для определения какую строку
зарезервировать. Не имеет значение, что будет в to, если size - нуль;
может быть даже пустой указатель.
<P>Вот пример того, как Вы можете использовать strxfrm когда Вы
планируете делать много сравнений. Он делает то же самое что и
предыдущий пример, но намного быстрее, потому что он должен
трансформировать каждую строку только один раз, независимо от того
сколько раз она сравнивается с другими строками. Даже времени для
резервирования и освобождения памяти нужно намного меньше чем, когда
имеются много строк.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct sorter { char *input; char *transformed; };
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      /* Это - функция сравнения, используемая qsort для сортировки
 массива структур. */
      int compare_elements (struct sorter *p1, struct sorter *p2)
      {
       return strcmp (p1-&gt;transformed, p2-&gt;transformed);
      }

      /* Это - точка входа функции сортировки строк, использующей
 последовательность объединений расположения. */
      void sort_strings_fast (char **array, int nstrings)
      {
       struct sorter temp_array[nstrings];
       int i;
      /* Устанавливает temp_array. Каждый элемент содержит одну входную
 строку и преобразованную строку. */
       for (i = 0; i &lt; nstrings; i++)
       {
        size_t length = strlen (array[i]) * 2;
        temp_array[i].input = array[i];
      /* Трансформирует array[i] . Сначала, пробует буфер, возможно
 достаточно большой. */
        while (1)
        {
         char *transformed = (char *) xmalloc (length);
         if (strxfrm (transformed, array[i], length) &lt; length)
         {
          temp_array[i].transformed = transformed;
          break;
         } /* Попытка снова с еще большим буфером. */
         free (transformed); length *= 2;
        }
       }
      }

      /* Сортировка temp_array, сравнивая преобразованные строки. */
      qsort (temp_array, sizeof (struct sorter), nstrings,
 compare_elements);

      /* Помещает элементы обратно в постоянный массив в их сортированном
 порядке. */
      for (i = 0; i &lt; nstrings; i++) array[i] = temp_array[i].input;

      /* Освобождают строки, которые мы зарезервировали. */
      for (i = 0; i &lt; nstrings; i++) free (temp_array[i].transformed);}
</PRE>
</CODE></BLOCKQUOTE>

Примечание относительно совместимости: функции объединения строк &shy;
новая возможность ANSI C., более старые диалекты C не имеют никакой
эквивалентной возможности.
<P>
<H2><A NAME="ss5.7">5.7 Функции поиска</A>
</H2>

<P>
<P>Этот раздел описывает библиотечные функции, которые выполняют
различные виды операций поиска в строках и массивах. Эти функции
объявлены в заголовочном файле "string.h".
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * memchr (void const *block, int с, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция находит первое вхождение байта с (преобразованного в
char без знака) в начальных size байтах объекта, начинающегося в block.
Возвращаемое значение - указатель на размещенный байт, или пустой
указатель, если не было найдено никакого соответствия.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      сhar * strchr (const char *string, int c) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strchr находит первое вхождение символа с (преобразованного
в char) в строке с нулевым символом в конце, начинающейся в string.
Возвращаемое значение - указатель на размещенный символ, или пустой
указатель, если никакое соответствие не было найдено.
<P>Например,
<BLOCKQUOTE><CODE>
<PRE>
      strchr ("привет, мир", "в")
      =&gt; "вет, мир"
      strchr ("привет, мир", "?")
      =&gt; NULL
</PRE>
</CODE></BLOCKQUOTE>

Пустой символ завершения является частью строки, так что Вы можете
использовать эту функцию, для получения указателя на конец строки,
определяя пустой символ как значение аргумента с.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * index (const char *string, int c) (функция) - другое имя для strchr.
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      сhar * strrchr (const char *string, int c) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strrchr - подобна strchr, за исключением того, что она ищет
в обратном направлении, с конца строки (а не сначала).
<P>Например,
<BLOCKQUOTE><CODE>
<PRE>
      strrchr ("привет, мир", "и")
      =&gt; "ир"
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * rindex (const char *string, int c) (функция)
</PRE>
</CODE></BLOCKQUOTE>

rindex - другое имя для strrchr.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * strstr (const char * haystack, const char * needle) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Она подобна strchr, за исключением того, что она ищет в haystack
подстроку needle, а не только одиночный символ. Она возвращает указатель
в строку haystack, который является первым символом подстроки, или
пустой указатель, если никакого соответствия не было найдено. Если
needle - пустая строка, то функция возвращает haystack.
<P>Например,
<BLOCKQUOTE><CODE>
<PRE>
      strstr ("привет, мир","в")
      =&gt; "вет, мир"
      trstr ("привет, мир","ми")
      =&gt; "мир"
</PRE>
</CODE></BLOCKQUOTE>

void * memmem (const void *needle, size_t needle_len, const void
*haystack, size_t haystack_len) (функция)
<P>Она подобна strstr, но needle и haystack байтовые массивы, а не
строки с нулевым символом в конце. needle_len - длина needle, а
haystack_len - длина haystack.
<P>Эта функция - расширение GNU.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t strspn (const char *string, const char *skipset) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strspn ("строковый диапазон") возвращает длину начальной
подстроки строки, которая состоит полностью из символов, которые
являются элементами набора, заданного строкой skipset. Порядок символов
в skipset не важен.
<P>Например,
<BLOCKQUOTE><CODE>
<PRE>
      strspn ("привет, мир","абвгдежзийклмнопрстуфхцчшщъыьэюя"))
      =&gt; 6
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      size_t strcspn (const char *string, const char *stopset) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция strcspn ("строковый диапазон дополнения") возвращает длину
начальной подстроки строки, которая состоит полностью из символов,
которые - не элементы набора, заданного строкой stopset. (Другими
словами, она возвращает смещение первого символа в строке, которая
является элементом набора stopset.)
<P>Например,
<BLOCKQUOTE><CODE>
<PRE>
      strcspn ("привет, мир","\t\n,.;!?")
      =&gt; 6
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      char * strpbrk (const char *string, const char *stopset) (функция)
</PRE>
</CODE></BLOCKQUOTE>

strpbrk ("строковое прерывание указателя") то же что strcspn, за
исключением того, что она возвращает указатель на первый символ в
строке, который является элементом набора stopset вместо длины начальной
подстроки. Это возвращает пустой указатель, если никакой символ из
stopset не найден.
<P>Например,
<BLOCKQUOTE><CODE>
<PRE>
      strpbrk ("привет, мир","\t\n,.;!?")
      =&gt; ",мир"
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss5.8">5.8 Поиск лексем в строке</A>
</H2>

<P>
<P>В программах довольно часто возникает потребность сделать некоторые
простые виды лексического и синтаксического анализа, типа разбивания
командной строки в лексемы. Вы можете делать это функцией strtok,
объявленной в заголовочном файле "string.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * strtok (char *newstring, const char *delimiters) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Строку можно разбить в лексемы, делая ряд обращений к функции
strtok.
<P>
<P>Строка, которую нужно разбивать передается как newstring только при
первом обращении. Функция strtok использует ее, чтобы установить
некоторую внутреннюю информацию о состоянии. Последующие обращения,
чтобы получить дополнительные лексемы из той же самой строки
обозначаются передачей пустого указателя как аргумента. Вызов strtok с
другим не-пустым символом newstring повторно инициализирует информацию о
состоянии. Гарантируется, что никакая другая библиотечная функция
(которая смешала бы эту внутреннюю информацию о состоянии) никогда не
вызовет strtok.
<P>Аргумент delimiters - строка, которая определяет набор
разделителей, которые могут окружать извлекаемую лексему. Все начальные
символы, которые являются элементами этого набора, отбрасываются. Первый
символ, который не является элементом этого набора разделителей,
отмечает начало следующей лексемы. Конец лексемы находится, как
следующий символ, который является элементом набора разделителей. Этот
символ в первоначальной строке newstring зменяется пустым символом, и
возвращается указатель на начало лексемы в newstring.
<P>При следующем обращении к strtok, поиск начинается со следующего
символа после того который отмечен концом предыдущей лексемы. Обратите
внимание, что набор разделителей не должен быть тем же самым при каждом
вызове strtok.
<P>Если конец строки newstring достигнут, или если остаточный член от
строки состоит только из символов - разделителей, strtok, возвращает
пустой указатель.
<P>Предупреждение: С тех пор как strtok изменит строку, которую она
анализирует, всегда копируйте строку во временный буфер перед
синтаксическим ее анализом strtok. Если Вы разрешаете, чтобы strtok
изменил строку, которая исходила из другой части вашей программы, Вы
создаете проблему; та строка может быть частью структуры данных, которая
могла использоваться для других целей в течение синтаксического анализа,
в то время как чередование strtok делает структуру данных, временно
неточной.
<P>
<P>Строка, на которой Вы действуете, могла быть и константой. И, когда
strtok попробует изменять ее, ваша программа получит фатальный сигнал о
записи в память распределенную тоько для чтения. См. раздел 21.2.1
[Сигналы ошибки в программе].
<P>Это - частный случай общего принципа: если часть программы не имеет
цели изменить некоторую структуру данных, то ошибочно изменять структуру
данных даже временно.
<P>Функция strtok не повторно используема. См. раздел 21.4.6
[Неповторная входимость], для обсуждения где и почему повторная
входимость важна.
<P>Вот простой пример, показывающий использование strtok.
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;string.h&gt;
      #include &lt;stddef.h&gt;
      . . .
      char string[] = "words separated by spaces -- and, punctuation!";
      const char delimiters[] = " .,;:!-";
      char *token;
      . . .
      token = strtok (string, delimiters);  /* token =&gt; "words" */
      token = strtok (NULL, delimiters);   /* token =&gt; "separated" */
      token = strtok (NULL, delimiters);   /* token =&gt; "by" */
      token = strtok (NULL, delimiters);   /* token =&gt; "spaces" */
      token = strtok (NULL, delimiters);   /* token =&gt; "and" */
      token = strtok (NULL, delimiters);   /* token =&gt; "punctuation" */
      token = strtok (NULL, delimiters);   /* token =&gt; NULL */
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR>
<A HREF="glibc-6.html">Вперед</A>
<A HREF="glibc-4.html">Назад</A>
<A HREF="glibc.html#toc5">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
