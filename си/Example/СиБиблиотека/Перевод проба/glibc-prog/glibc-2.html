<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Сообщения об ошибках</TITLE>
 <LINK HREF="glibc-3.html" REL=next>
 <LINK HREF="glibc-1.html" REL=previous>
 <LINK HREF="glibc.html#toc2" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-3.html">Вперед</A>
<A HREF="glibc-1.html">Назад</A>
<A HREF="glibc.html#toc2">Содержание</A>
<HR>
<H2><A NAME="s2">2. Сообщения об ошибках</A></H2>

<P>
<P>Много функций в GNU C библиотеке обнаруживают и выводят ошибки
условий, и иногда ваши программы должны проверить эти ошибки условий.
Например, когда Вы открываете входной файл, Вы должны проверить, что
файл был фактически открыт правильно, и печатать сообщение об ошибках
или выполнять другое соответствующее действие, если обращение к
библиотечной функции потерпело неудачу.
<P>Эта глава описывает, как работают средства сообщений об ошибках.
Чтобы использовать эти средства, ваша программа должна включить
заголовочный файл "errno.h".
<P>
<H2><A NAME="ss2.1">2.1 Проверка Ошибок</A>
</H2>

<P>
<P>Большинство библиотечных функций возвращает специальное значение,
чтобы указать, что они потерпели неудачу. Специальное значение типично &shy;
1, нулевой указатель, или константа типа EOF, которая определена для той
цели. Но это значение возврата сообщает Вам только то, что ошибка
произошла. Чтобы выяснять что это было, Вы должны рассмотреть код
ошибки, сохраненный в переменной errno. Эта переменная объявлена в
заголовочном файле "errno.h".
<P>Переменная errno содержит номер ошибки системы. Вы можете изменять
значение errno.
<P>С тех пор как errno объявлена изменяемой, она может быть асинхронно
изменена драйвером сигнала; см. раздел 21.4 [Определение драйверов].
Однако, правильно написанный драйвер сигнала сохраняет и восстанавливает
значение errno, так что Вы вообще не должны волноваться относительно
этой возможности, разве что при нааписании драйверов сигнала.
<P>Начальное значение errno при запуске программы - нуль. Большинство
библиотечных функций, когда они сталкиваются с некоторыми видами ошибок,
помещают туда некоторое отличное от нуля значение. Эти ошибки условий
перечислены для каждой функции. Если эти функции успешно выполняются они
не изменяют errno; таким образом, значение errno после успешного
обращения не обязательно нулевое, и Вы не должны использовать errno,
чтобы определить, потерпело ли обращение неудачу. Соответствующий способ
проверки зарегистрирован для каждой функции. Если обращение неудачно, Вы
может исследовать errno.
<P>Многие библиотечные функции могут устанавливать errno отличным от
нуля в результате вызова других библиотечных функций, которые возможно и
установили ошибку. Т. е. если функция возвращает ошибку, то любая
библиотечная функция могла изменять errno.
<P>Примечание относительно переносимоси: ANSI C определяет errno
скорее как "модифицируемое именуемое выражение", чем как переменную,
разрешая ему выполняться как макрокоманде. Например, его расширение
может включать обращение к функции, подобно * _errno (). Фактически, это
встроено систему GNU непосредственно. GNU библиотека, на не-GNU
системах, делает то, что правильно для этой специфической системы.
<P>Имеются несколько библиотечных функций, подобно sqrt и atan,
которые в случае ошибки возвращают ожидаемое значение, устанавивая также
errno. Для этих функций, если Вы хотите выяснить, произошла ли ошибка,
рекомендуется обнулить errno перед вызовом функции, и затем проверить
значение позже.
<P>Все коды ошибки имеют символические имена; т. е. это макрокоманды,
определенные в "errno.h". Имена начинаются с "E" и символа верхнего
регистра или цифры; Вы должны рассмотривать имена такой формы, как
зарезервированные имена. См. раздел 1.3.3 [Зарезервированные имена].
<P>Значения кода ошибки - это различные положительные целые числа, с
одним исключением: EWOULDBLOCK и EAGAIN - имеют одинаковый код. Так как
значения отличны, Вы можете использовать их как метки в утверждении
выбора; только не используйте, и EWOULDBLOCK и EAGAIN. Ваша программа не
должна иметь никаких сомнений относительно специфических значений этих
символических констант.
<P>Значение errno не обязательно должно соответствовать одной из этих
макрокоманд, так как некоторые библиотечные функции могут возвращать
другие их собственные коды ошибки для других ситуаций. Единственные
значения, которые будут важны для специфической библиотечной функции &shy;
это списки кодов ошибок для этой функции.
<P>На не-GNU системах, почти любой системный вызов может возвратить
EFAULT, если как параметр задан недопустимый указатель. Так как это
могло случиться только в результате ошибки в вашей программе, и так как
этого не будет в системе GNU, мы сэкономили место не упоминая EFAULT в
описаниях индивидуальных функций.
<P>
<H2><A NAME="ss2.2">2.2 Коды ошибок</A>
</H2>

<P>
<P>Макрокоманды кода ошибки определены в заголовочном файле "errno.h".
Каждая из них преобразуется в константное целое значение. Некоторые из
этих ошибок не могут произойти в системе GNU, но они могут происходить
при использовании библиотеки GNU в других системах.
<DL>
<DT><B>int EPERM (макрос) </B><DD><P>
<P>Не разрешенная операция; только владелец файла (или другого
обьекта) или процессы со специальными привилегиями могут выполнять эту
операцию.
<P>
<DT><B>int ENOENT (макрос) </B><DD><P>
<P>Нет такого файла или каталога. Это - ошибка типа "файл не
существует" для обычных файлов, которые вызваны в контекстах, где они,
как ожидается, уже существуют.
<P>
<DT><B>int ESRCH (макрос) </B><DD><P>
<P>Нет процесса соответствующего заданному.
<P>
<DT><B>int EINTR (макрос) </B><DD><P>
<P>Прерванное обращение к функции; асинхронный сигнал предотвратил
завершение обращения. Когда это случается, Вы должны попробовать снова
вызвать функцию.
<P>Вы можете выбрать показ резюме функций после сигнала EINTR; см.
раздел 21.5 [Прерванные Примитивы] .
<P>
<DT><B>int EIO (макрос) </B><DD><P>
<P>Ошибка ввода-вывода, обычно используется для ошибок физического
чтения или записи.
<P>
<DT><B>int ENXIO (макрос) </B><DD><P>
<P>Нет такого устройства или адреса. Система попробовала использовать
устройство, указанное файлом, который Вы определили, и не смогло найти
это устройство. Это может означать, что файл устройства был установлен
неправильно, или физическое устройство отсутствует или не правильно
присоединено к компьютеру.
<P>
<DT><B>int E2BIG (макрос) </B><DD><P>
<P>Список параметров слишком длинный; используется, когда параметры,
переданные одной из функций (см. раздел 23.5 [Выполнение файла] )
занимают слишком много пространства памяти. Это условие никогда не
возникает в системе GNU.
<P>
<DT><B>int ENOEXEC (макрос) </B><DD><P>
<P>Недопустимый формат исполняемого файла. Это условие обнарживается
запускаемыми функциями; см. раздел 23.5 [Выполнение файла].
<P>
<DT><B>int EBADF (макрос) </B><DD><P>
<P>Плохой описатель файла; например, ввод - вывод на описателе,
который был закрыт или чтение из описателя, открытого только для записи
(или наоборот).
<P>
<DT><B>int ECHILD (макрос) </B><DD><P>
<P>Не имеется никаких порожденнных процессов. Эта ошибка случается при
операциях, которые, как предполагается, управляют порожденнными
процессами, когда не имеется ни каких процессов, для управления.
<P>
<DT><B>int EDEADLK (макрос) </B><DD><P>
<P>Тупик; распределение ресурсов системы оценено как ситуация тупика.
Система не гарантирует, что она будет обращать внимание на все такие
ситуации. Эта ошибка означает, что Вам повезло; система могла зависнуть.
См. раздел 8.11 [Блокировки файла].
<P>
<DT><B>int ENOMEM (макрос) </B><DD><P>
<P>Нет доступной памяти. Система не может распределять виртуальную
память, потому она полна.
<P>
<DT><B>int EACCES (макрос) </B><DD><P>
<P>Отклоненное право; права файла не позволяют предпринятую операцию.
<P>
<DT><B>int EFAULT (макрос) </B><DD><P>
<P>Плохой адрес; был обнаружен недопустимый указатель.
<P>
<DT><B>int ENOTBLK (макрос) </B><DD><P>
<P>Не специальный файл, был дан в ситуации, которая требует блок
файов. Например, при попытке установить обычный файл как файловую
систему в UNIX дает эту ошибку.
<P>
<DT><B>int EBUSY (макрос) </B><DD><P>
<P>Ресурсы заняты; ресурс системы, который не может быть разделен уже
используется. Например, если Вы пробуете удалить файл, который является
корнем установленной в настоящее время файловой системы, Вы получаете
эту ошибку.
<P>
<P>
<P>
<P>
<DT><B>int EEXIST (макрос) </B><DD><P>
<P>Файл существует; существующий файл был определен в контексте, где
имеет смысл определять только новый файл.
<P>
<DT><B>int EXDEV (макрос) </B><DD><P>
<P>Была обнаружена попытка, сделать неподходящую компоновку файловой
системы. Это случается не только, когда Вы используете связи (см.
раздел 9.3 [Сложные связи]) но также, когда Вы переименовываете файл
(см. раздел 9.6 [Переименование файлов]).
<P>
<DT><B>int ENODEV (макрос) </B><DD><P>
<P>Функции, которая ожидает специфический тип устройства, был дан
неправильный тип устройства.
<P>
<DT><B>int ENOTDIR (макрос) </B><DD><P>
<P>Был определен файл, а не каталог, когда требуется каталог.
<P>
<DT><B>int EISDIR (макрос) </B><DD><P>
<P>Указан каталог; попытка открыть каталог для записи дает эту ошибку.
<P>
<DT><B>int EINVAL (макрос) </B><DD><P>
<P>Недопустимый параметр. Используется, чтобы указать различные виды
проблем с указанием неправильного параметра для библиотечной функции.
<P>
<DT><B>int EMFILE (макрос) </B><DD><P>
<P>Текущий процесс имеет слишком много открытых файлов и не может
открыть больше. Двойные описатели приводят к этому ограничению.
<P>
<P>
<P>
<P>
<DT><B>int ENFILE (макрос) </B><DD><P>
<P>Имеется слишком много различных открытых экземпляров файла во всей
системе. Обратите внимание, что любое число связанных каналов считается
только одним открытым экземпляром файла; см. раздел 8.5.1 [Связанные
каналы]. Эта ошибка никогда не происходит в системе GNU.
<P>
<DT><B>int ENOTTY (макрос) </B><DD><P>
<P>Несоответствующая операция управления ввода - вывода, типа попытки
устанавливать режимы терминала в обычном файле.
<P>
<DT><B>int ETXTBSY (макрос) </B><DD><P>
<P>Попытка выполнить файл, который является в настоящее время открытым
для записи, или записи в файл который в настоящее время выполняется. Это
не является ошибкой в системе GNU; текст по мере необходимости
копируется.
<P>
<DT><B>int EFBIG (макрос) </B><DD><P>
<P>Файл слишком большой; размер файла больше чем позволено системой.
<P>
<DT><B>int ENOSPC (макрос) </B><DD><P>
<P>Нет места на устройстве; операция записи в файл потерпела неудачу,
потому что диск полон.
<P>
<DT><B>int ESPIPE (макрос) </B><DD><P>
<P>Недопустимая операция установки.
<P>
<DT><B>int EROFS (макрос) </B><DD><P>
<P>Была сделана попытка изменить что - нибудь в файловой системе
только для чтения.
<P>
<P>
<DT><B>int EMLINK (макрос) </B><DD><P>
<P>Слишком много связей; число связей одиночного файла слишком велико.
Переименование может вызывать эту ошибку, если переименовываемый файл
уже имеет максимальное число связей (см. раздел 9.6 [Переименование
файлов]).
<P>
<DT><B>int EPIPE (макрос) </B><DD><P>
<P>Разрушенный канал; не имеется процесса читающего с другого конца
канала. Каждая библиотечная функция, которая возвращает этот код ошибки
также генерирует сигнал SIGPIPE; если этот сигнал не обработан или не
блокирован, то он завершает программу . Таким образом, ваша программа
фактически не будет никогда видеть EPIPE, если она не обработала или не
блокировала SIGPIPE.
<P>
<DT><B>int EDOM (макрос) </B><DD><P>
<P>Ошибка области; использование математических функций, когда
значение параметра не относится к области над которой функция
определена.
<P>
<DT><B>int ERANGE (макрос) </B><DD><P>
<P>Ошибка диапазона; использование математических функций, когда
значение результата не представимо из-за переполнения.
<P>
<DT><B>int EAGAIN (макрос) </B><DD><P>
<P>Ресурс временно недоступен; обращение может работать, если Вы
пробуете позже.
<P>
<DT><B>int EWOULDBLOCK (макрос) </B><DD><P>
<P>Операция, которая бы была блокировала предпринята на объекте,
который имеет выбранный режим не-блокирования.
<P>
<P>Примечание относительно переносимости: В 4.4BSD и GNU, EWOULDBLOCK
и EAGAIN - совпадают. Более ранние версии BSD (см. раздел 1.2.3
[Berkeley UNIX]) имеют два различных кода, и используют EWOULDBLOCK,
чтобы указать операцию ввода-вывода, которая блокировала бы объект с
набором режимов неблокирования, а EAGAIN для других видов ошибок.
<P>
<DT><B>int EINPROGRESS (макрос) </B><DD><P>
<P>Операция, которая не может завершаться немедленно, была
инициализирована в объекте, который имеет выбранный режим
неблокирования. Некоторые функции, которые должны всегда блокировать
(типа, connect ; см., раздел 11.8.1 [Соединение] ) никогда не возвращает
EWOULDBLOCK. Взамен, они возвращают EINPROGRESS, чтобы указать, что
операция начата и займет некоторое время. Попытайтесь управлять объектом
прежде, чем обращение завершится возвратив EALREADY.
<P>
<DT><B>int EALREADY (макрос) </B><DD><P>
<P>Операция уже выполняется в объекте, который имеет выбранный режим
неблокирования.
<P>
<DT><B>int ENOTSOCK (макрос) </B><DD><P>
<P>Был определен файл,а не гнездо, когда требуется гнездо.
<P>
<DT><B>int EDESTADDRREQ (макрос) </B><DD><P>
<P>Нет был обеспечен адрес адресата для операции гнезда.
<P>
<DT><B>int EMSGSIZE (макрос) </B><DD><P>
<P>Размер сообщения, посланного на гнездо был больше чем
обеспечиваемый максимальный размер.
<P>
<DT><B>int EPROTOTYPE (макрос) </B><DD><P>
<P>Тип гнезда не поддерживает запрашиваемый протокол связи.
<P>
<DT><B>int ENOPROTOOPT (макрос) </B><DD><P>
<P>Вы определили опцию гнезда, которая не имеет смысла для
специфического протокола, используемого гнездом. См. раздел 11.11 [Опции
гнезда].
<P>
<DT><B>int EPROTONOSUPPORT (макрос) </B><DD><P>
<P>Область гнезда не поддерживает запрашиваемый протокол связи
(возможно, потому что запрашиваемый протокол полностью недопустим.) См.
раздел 11.7.1 [Создание гнезда].
<P>
<DT><B>int ESOCKTNOSUPPORT (макрос) </B><DD><P>
<P>Тип гнезда не установлен.
<P>
<DT><B>int EOPNOTSUPP (макрос) </B><DD><P>
<P>Операция, которую Вы запросили, не обеспечивается. Некоторые
функции гнезда не имеют смысла для всех типов гнезд, а другие не имеют
права выполнения для всех протоколов связи.
<P>
<DT><B>int EPFNOSUPPORT (макрос) </B><DD><P>
<P>Семейство протоколов связи гнезда, которое Вы запросили, не
обеспечивается.
<P>
<DT><B>int EAFNOSUPPORT (макрос) </B><DD><P>
<P>Семейство адресов, заданное для гнезда несогласованно с протоколом,
используемым на гнезде. См. Главу 11 [Гнезда].
<P>
<DT><B>int EADDRINUSE (макрос) </B><DD><P>
<P>Запрашиваемый адрес гнезда - уже используется. См. раздел 11.3
[Адреса гнезда].
<P>
<P>
<DT><B>int EADDRNOTAVAIL (макрос) </B><DD><P>
<P>Запрашиваемый адрес гнезда не доступен; например, Вы попробовали
дать гнезду имя, которое не соответствует местному главному имени. См.
раздел 11.3 [Адрес Гнезда].
<P>
<DT><B>int ENETDOWN (макрос) </B><DD><P>
<P>Операция с гнездом потерпела неудачу, потому что нет сети.
<P>
<DT><B>int ENETUNREACH (макрос) </B><DD><P>
<P>Операция гнезда потерпела неудачу, потому что подсеть, содержащая
главную ЭВМ была недоступна.
<P>
<DT><B>int ENETRESET (макрос) </B><DD><P>
<P>Сетевое соединение было сброшено, потому что отдаленная главная ЭВМ
умерла.
<P>
<DT><B>int ECONNABORTED (макрос) </B><DD><P>
<P>Сетевое соединение было прервано локально.
<P>
<DT><B>int ECONNRESET (макрос) </B><DD><P>
<P>Сетевое соединение было закрыто по внешним причинам контроля над
местной главной ЭВМ, например из-за неисправимого нарушения протокола.
<P>
<DT><B>int ENOBUFS (макрос) </B><DD><P>
<P>Буфера ядра для операций ввода - вывода занят весь.
<P>
<DT><B>int EISCONN (макрос) </B><DD><P>
<P>Вы пытаетесь соединить гнездо, которое уже соединено. См. раздел
11.8.1 [Соединение].
<P>
<DT><B>int ENOTCONN (макрос) </B><DD><P>
<P>Гнездо не соединено с чем - нибудь. Вы получаете эту ошибку, когда
Вы пробуете передавать данные на гнездо, без первого определения
адресата для данных.
<P>
<DT><B>int ESHUTDOWN (макрос) </B><DD><P>
<P>Гнездо уже было закрыто.
<P>
<DT><B>int ETIMEDOUT (макрос) </B><DD><P>
<P>Операция гнезда с заданной блокировкой по времени не получила
никакого ответа в течение периода блокировки по времени.
<P>
<DT><B>int ECONNREFUSED (макрос) </B><DD><P>
<P>Отдаленная главная ЭВМ отказала в сетевом соединении (обычно из-за
того, что не запущено запрашиваемое обслуживание).
<P>
<DT><B>int ELOOP (макрос) </B><DD><P>
<P>При поиске имени файла столкнулись со слишком многими уровнями
символических связей. Часто это указывает на цикл символических связей.
<P>
<DT><B>int ENAMETOOLONG (макрос) </B><DD><P>
<P>Имя файла слишком длинное (больше чем PATH_MAX; см. раздел 27.6
[Ограничения для файлов]) или главное имя слишком длинное (в gethostname
или sethostname; см. раздел 26.1 [Главная идентификация]).
<P>
<DT><B>int EHOSTDOWN (макрос) </B><DD><P>
<P>Отдаленная главная ЭВМ для запрашиваемого сетевого соединения не
реагирует.
<P>
<P>
<P>
<DT><B>int EHOSTUNREACH (макрос) </B><DD><P>
<P>Отдаленная главная ЭВМ для запрашиваемого сетевого соединения не
доступна.
<P>
<DT><B>int ENOTEMPTY (макрос) </B><DD><P>
<P>Каталог, не пустой, а ожидался пустой каталог. Обычно эта ошибка
происходит, когда Вы пробуете удалять каталог.
<P>
<DT><B>int EUSERS (макрос) </B><DD><P>
<P>Файловая система спутана, потому что имеется слишком много
пользователей.
<P>
<DT><B>int EDQUOT </B><DD><P>
<P>Пользовательское дисковое пространство превышено.
<P>
<DT><B>int ESTALE (макрос) </B><DD><P>
<P>Просроченная NFS программа обработки файла. Это указывает на
внутренний беспорядок в NFS системе, который появляется из-за
перестановок файловой системы на главной ЭВМ станции. Восстановление
этого условия обычно требует переустановки файловой системы NFS на
местной главной ЭВМ.
<P>
<DT><B>int EREMOTE (макрос) </B><DD><P>
<P>Была сделана попытка NFS-подсоединения удаленной файловой системой
с именем файла, которое уже определяет установленный файл NFS. (Эта
ошибка воникает на некоторых операционных системах, но мы думаем что это
будет работать правильно на системе GNU, делающей этот код ошибки
невозможным.)
<P>
<P>
<P>
<P>
<DT><B>int ENOLCK (макрос) </B><DD><P>
<P>Нет доступной блокировки. Это используется средствами закрытия
файла; см. раздел 8.11 [Блокировки файла]. Эта ошибка никогда не
происходит в системе GNU.
<P>
<DT><B>int ENOSYS (макрос) </B><DD><P>
<P>Функция не выполнена. Некоторые функции имеют команды или
определяющие их опции, которые не могут обеспечиваться во всех
реализациях, и это - ошибка, которую Вы получаете, если Вы запрашиваете
то, что не обеспечивается.
<P>
<DT><B>int EBACKGROUND (макрос) </B><DD><P>
<P>В системе GNU, станции, обеспечивающие протокол терминала
возвращают эту ошибку для некоторых операций, когда вызывающий оператор
не входит в группу приоритетного процесса терминала. Пользователи обычно
не видят эту ошибку, потому что функции типа чтения и записи транслируют
ее в SIGTTIN или SIGTTOU сигнал. См. Главу 24 [Управление заданиями],
для уточнения информации относительно групп процессов и этих сигналов.
<P>
<DT><B>int ED(макрос) </B><DD><P>
<P>Опытный пользователь будет знать, что неправильно.
<P>
<DT><B>int EGREGIOUS (макрос) </B><DD><P>
<P>Что Вы делаете?!!!
<P>
<DT><B>int EIEIO (макрос) </B><DD><P>
<P>Идите домой и выпейте стакан теплого молока.
<P>
<DT><B>int EGRATUITOUS (макрос) </B><DD><P>
</DL>

Этот код ошибки не имеет никакой цели.
<P>
<H2><A NAME="ss2.3">2.3 Сообщения об ошибках</A>
</H2>

<P>
<P>Библиотека имеет функции и переменные, разработанные, чтобы
облегчить для вашей программы вывод информативных сообщений об ошибках в
обычном формате. Функции strerror и perror дают Вам стандартное
сообщение об ошибках для данного кода ошибки; переменная
program_invocation_short_name дает Вам удобный доступ к имени программы,
которая столкнулась с ошибкой.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      сhar * strerror ( int errnum) (функция)
</PRE>
</CODE></BLOCKQUOTE>

функция strerror отображает код ошибки (см. раздел 2.1 [Прверка Ошибок])
заданный параметром errnum в описательную строку сообщения об ошибках.
Значение возврата - указатель на эту строку.
<P>Значение errnum обычно исходит из переменной errno.
<P>Вы не должны изменять строку, возвращаемую strerror. Также, если Вы
делаете последующие обращения к strerror, новая строка могла быть
записана поверх старой. (Но гарантируется, что никакая библиотечная
функция не вызовет strerror за вашей спиной.) Функция strerror объявлена
в "string.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void perror (const char * message) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция печатает сообщение об ошибках в поток stderr; см.
раздел 7.2 [Стандартные Потоки].
<P>Если Вы вызываете perror с сообщением, которое является или нулевым
указателем или пустой строкой, perror печатает сообщение об ошибках,
соответствуя errno, добавляя конечный символ перевода строки.
<P>Если Вы обеспечиваете не-нулевой параметр сообщения, то perror
начинает вывод с этой строки. Она добавляет двоеточие и пробел, чтобы
отделить сообщение от строки ошибки, соответствующей errno.
<P>Функция perror объявлена в "stdio.h".
<P>strerror и perror производят точно то же самое сообщение для любого
данного кода ошибки; точный текст изменяется от системы до системы. На
системе GNU, сообщения довольно коротки; не имеются никаких
многострочных сообщений или вложенных символов перевода строки. Каждое
сообщение об ошибках начинается заголовочной буквой и не включает ни
какой пунктуации завершения.
<P>Примечание относительно совместимости: функция strerror - новая
особенность ANSI C, многие более старые C системы не поддерживают эту
функцию.
<P>Множество программ, которые не читают ввод с терминала,
разработаны, чтобы выйти, если любой системный вызов терпит неудачу. В
соответствии c соглашением, сообщение об ошибках из такой программы
должно начаться с имени программы. Вы можете найти это имя в переменной
program_invocation_short_name; полное имя файла сохранено в переменной
program_invocation_name:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      сhar * program_invocation_name (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Значение этой переменной - имя, которое использовалось, чтобы
вызвать программу, выполняющуюся в текущем процессе. Аналогично argv
[0]. Обратите внимание, что это не обязательно какое-то полезное имя
файла; часто она не содержит никаких имен. См. раздел 22.1 [Аргументы
программы].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      сhar * program_invocation_short_name (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Значение этой переменной - имя, которое использовалось, чтобы
вызвать программу, выполняющуюся в текущем процессе, без имен каталогов.
(То есть то-же что и в program_invocation_name минус все до последней
наклонной черты вправо, если что-то есть в наличии.)
<P>Библиотечные код инициализации устанавливает обе из этих переменных
перед вызовом main.
<P>Примечание относительно переносимости: Эти две переменные &shy;
расширения GNU. Если Вы хотите, чтобы ваша программа работала с
библиотеками, не относящимися к GNU, Вы должны сохранить значение argv
[0] в main (основной программе), и удалить имена каталогов
самостоятельно. Мы добавили эти расширения, чтобы сделать возможной
написание замкнутых сообщений об ошибках подпрограммы, которые не
требуют никакого явного сотрудничества с основной программой.
<P>Имеется пример, показывающий, как обработать отказ открывать файл.
Функция open_ sesame пробует открывать указанный файл для чтения и
возвращает поток. Библиотечная функция fopen возвращает нулевой
указатель, если она не может открыть файл по некоторым причинам. В той
ситуации, open_sesame создает соответствующее сообщение об ошибках,
используя функцию strerror, и завершает программу. Если мы хотим сделать
другие вызовы из библиотек перед передачей кода ошибки к strerror, мы
должны сохранить его в местной переменной, потому что те другие
библиотечные функции могут записывать поверх errno.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       #include &lt;errno.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt; stdlib.h &gt;
       #include &lt;string.h&gt;
       FILE * open_sesame (char *name)
        {
          FILE *stream;
          errno = 0;
          stream = fopen (name, "r");
          if (stream == NULL)
           {
             fprintf (stderr, "%s: Couldn't open file %s; %s\n",
               program_invocation_short_name, name, strerror (errno));
             exit (EXIT_FAILURE);
           }
         else return stream;
       }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<P>
<P>
<HR>
<A HREF="glibc-3.html">Вперед</A>
<A HREF="glibc-1.html">Назад</A>
<A HREF="glibc.html#toc2">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
