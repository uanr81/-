<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Поиск и Сортировка</TITLE>
 <LINK HREF="glibc-16.html" REL=next>
 <LINK HREF="glibc-14.html" REL=previous>
 <LINK HREF="glibc.html#toc15" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-16.html">Вперед</A>
<A HREF="glibc-14.html">Назад</A>
<A HREF="glibc.html#toc15">Содержание</A>
<HR>
<H2><A NAME="s15">15. Поиск и Сортировка</A></H2>

<P>
<P>Эта глава описывает функции для поиска и сортировки массивов 
произвольных объектов. Вы определяете соответствующую функцию 
сравнения, которую нужно применить как аргумент, наряду с размером 
объектов в массиве и общим числом элементов.
<P>
<H2><A NAME="ss15.1">15.1 Определение Функции Сравнения</A>
</H2>

<P>
<P>Чтобы использовать библиотечные функции сортировки массива, Вы 
должны описать, как сравнить элементы массива.
<P>Чтобы сделать это, Вы обеспечиваете функцию сравнения, для 
сравнения двух элементов массива. Библиотека вызовет эту функцию,
передавая как указатели на аргументы два элемента массива, которые 
нужно сравнить. Ваша функция сравнения должна возвратить значение 
как strcmp (см. Раздел 5.5 [Сравнение СТРОКИ/МАССИВА]): 
отрицательное, если первый аргумент - "меньше" чем второй, нуль, 
если они "равны", и положительное если первый аргумент "больше".
<P>Вот пример функции сравнения, которая работает с массивом чисел 
типа double:
<P>
<BLOCKQUOTE><CODE>
<PRE>
                int
                compare_doubles (const double *a, const double *b)
                {
                        return (int) (*a - *b);
                }
</PRE>
</CODE></BLOCKQUOTE>

Заглавный файл " stdlib.h " определяет имя для типа данных 
функций сравнения. Этот тип - расширение GNU.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int comparison_fn_t (const void *, const void *);
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<P>
<P>
<H2><A NAME="ss15.2">15.2 Функция Поиска в Массиве</A>
</H2>

<P>
<P>Чтобы искать в сортируемом массиве элемент, соответствующий 
ключу, используйте bsearch функцию. Прототип для этой функции 
находится в заглавном файле " stdlib.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void * bsearch (const void *key, const void *array, size_t  count, size_t size, comparison_fn_t compare)
</PRE>
</CODE></BLOCKQUOTE>

Bsearch функция ищет в сортируемом массиве объект, который 
является эквивалентным key. Массив содержит count элементов, каждый 
из которых имеет байты размера sise.
<P>Возвращаемое значение - указатель на соответствующий элемент 
массива, или пустой указатель, если никакое соответствие не 
найдено. Если массив содержит больше чем один подходящий элемент, 
неопределено который же возвращается.
<P>Эта функция получила имя из предположения, что она выполнена, 
используя двоичный алгоритм поиска.
<P>
<H2><A NAME="ss15.3">15.3 Функция Сортировки Массива</A>
</H2>

<P>
<P>Для сортировки массива, используюя произвольную функцию 
сравнения, используйте qsort функцию. Прототип для этой функции
находится в " stdlib.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void qsort (void *array, size_t count, size_t size, comparison_fn_t compare)
</PRE>
</CODE></BLOCKQUOTE>

Qsort функция сортирует заланный массив. Массив содержит count 
элементов, каждый из которых имеет размер size.
<P>Функция compare используется, чтобы выполнить сравнение на 
элементах массива. Эта функция вызывается с двумя аргументами 
указателями и должна возвратить целое число меньше , равное, или 
больше нуля, если первый аргумент меньше , равен, или больше чем 
второй аргумент.
<P>Предупреждение: если, два объекта сравниваются как равные, их
порядок после сортировки, непредсказуем. То есть сортировка не 
устойчива. Она может делать различие, когда сравнение рассматривает 
только часть элементов. А также, два элемента с тем же самым ключом 
сортировки могут отличиться в других отношениях.
<P>Вот простой пример сортировки массива double значений в числовом 
порядке используя функцию сравнения, определенную выше (см. Раздел 
15.1 [Функции Сравнения]):
<P>
<BLOCKQUOTE><CODE>
<PRE>
        {
                double *array;
                int size;
                . . .
                qsort(array,size,sizeof(double),compare_doubles);
        }
</PRE>
</CODE></BLOCKQUOTE>

Qsort функция получила имя из предположения, что она была 
первоначально выполнена, используя алгоритм "быстрой сортировки".
<P>
<H2><A NAME="ss15.4">15.4 Пример Поиска и Сортировки</A>
</H2>

<P>
<P>Вот пример, показывающий использование qsort и bsearch с 
массивом структур. Объекты в массиве сортируются, сравнивнением их 
name полей функцией strcmp.
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stdlib.h&gt;
                #include &lt;stdio.h&gt;
                #include &lt;string.h&gt;
                struct critter
                {
                        const char *name;
                        const char *species;
                };
                struct critter muppets[] =
                {
                        {"Kermit", "frog"},
                        {"Piggy", "pig"},
                        {"Gonzo", "whatever"},
                        {"Fozzie", "bear"},
                        {"Sam", "eagle"},
                        {"Robin", "frog"},
                        {"Animal", "animal"},
                        {"Camilla", "chicken"},
                        {"Sweetums", "monster"},
                        {"Dr. Strangepork", "pig"},
                        {"Link Hogthrob", "pig"},
                        {"Zoot", "human"},
                        {"Dr. Bunsen Honeydew", "human"},
                        {"Beaker", "human"},
                        {"Swedish Chef", "human"}
                };
                int count=sizeof(muppets)/sizeof(struct critter);
                int
                critter_cmp (const struct critter *c1,                  
                const struct critter *c2)
                {
                        return strcmp (c1-&gt;name, c2-&gt;name);
                }
                void
                print_critter (const struct critter *c)
                {
                        printf ("%s, the %s\n", c-&gt;name,                     
                c-&gt;species);
                }
                void
                find_critter (const char *name)
                {
                        struct critter target, *result;
                        target.name = name;
                        result = bsearch (&amp;target, muppets, count,  
                        sizeof (struct critter), critter_cmp);
                        if (result)
                                print_critter (result);
                        else
                                printf ("Couldn't find %s.\n", name);
                }
                int
                main (void)
                {
                        int i;
                        for (i = 0; i &lt; count; i++)
                                print_critter (&amp;muppets[i]);
                        printf ("\n");
                        qsort (muppets, count, sizeof (struct           
                        critter), critter_cmp);
                        for (i = 0; i &lt; count; i++)
                                print_critter (&amp;muppets[i]);
                        printf ("\n");
                        find_critter ("Kermit"); 
                        find_critter ("Gonzo");
                        find_critter ("Janice");
                        return 0;
                }
</PRE>
</CODE></BLOCKQUOTE>

Вывод этой программы: 
<BLOCKQUOTE><CODE>
<PRE>
                Kermit, the frog
                Piggy, the pig
                Gonzo, the whatever
                Fozzie, the bear
                Sam, the eagle
                Robin, the frog
                Animal, the animal
                Camilla, the chicken
                Sweetums, the monster
                Dr. Strangepork, the pig
                Link Hogthrob, the pig
                Zoot, the human
                Dr. Bunsen Honeydew, the human
                Beaker, the human
                Swedish Chef, the human
                Animal, the animal
                Beaker, the human
                Camilla, the chicken
                Dr. Bunsen Honeydew, the human
                Dr. Strangepork, the pig
                Fozzie, the bear
                Gonzo, the whatever
                Kermit, the frog
                Link Hogthrob, the pig
                Piggy, the pig
                Robin, the frog
                Sam, the eagle
                Swedish Chef, the human
                Sweetums, the monster
                Zoot, the human
                Kermit, the frog
                Gonzo, the whatever
                Couldn't find Janice.
</PRE>
</CODE></BLOCKQUOTE>
<P>
<HR>
<A HREF="glibc-16.html">Вперед</A>
<A HREF="glibc-14.html">Назад</A>
<A HREF="glibc.html#toc15">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
