<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Краткий обзор ввода-вывода</TITLE>
 <LINK HREF="glibc-7.html" REL=next>
 <LINK HREF="glibc-5.html" REL=previous>
 <LINK HREF="glibc.html#toc6" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-7.html">Вперед</A>
<A HREF="glibc-5.html">Назад</A>
<A HREF="glibc.html#toc6">Содержание</A>
<HR>
<H2><A NAME="s6">6. Краткий обзор ввода-вывода</A></H2>

<P>
<P>Большинство программ должно делать некоторый ввод (чтение данных)
или вывод, или наиболее часто оба, чтобы сделать что-нибудь полезное.
Библиотека GNU С обеспечивает такой большой выбор функций ввода и
функций вывода, что самая трудная часть решить, которая функция является
наиболее подходящей!
<P>Эта глава представляет понятия и терминологию, имеющие отношение к
вводу и выводу. Другие главы, имеющие отношение к средствам ввода-вывода
GNU:
<UL>
<LI>       Глава 7 [Ввод-вывод на потоках], которая описывает функции
выоского уровня, функционирующие на потоках, включая форматируемый ввод
и выводит.
</LI>
<LI>       Глава 8 [Ввод-вывод низкого уровня], которая описывает базисный
ввод-вывод и функции управления на описателях файла.
</LI>
<LI>       Глава 9 [Интерфейс файловой системы], которая описывает функции
для операций на каталогах и для управления атрибутами файла, режимами
доступа и монопольного использования.
</LI>
<LI>       Глава 10 [Трубопроводы и FIFO (первый зашел - первый вышел)],
которая включает информацию относительно базисных межпроцессорных
средств связи.
</LI>
<LI>       Глава 11 [Гнезда], которая описывает более сложное
межпроцессорное средство связи с поддержкой для работы с сетями.
</LI>
<LI>       Глава 12 [Интерфейс терминала низкого уровня], которая описывает
функции для изменения как ввода так и вывода на терминал или другое
последовательное устройство.</LI>
</UL>
<P>
<P>
<P>
<P>
<H2><A NAME="ss6.1">6.1 Понятия ввода-вывода</A>
</H2>

<P>
<P>Прежде, чем Вы сможете читать или писать содержимое файла, Вы
должны установить соединение или канал связи с файлом. Этот процесс
называется открытием файла. Вы можете открывать файл для чтения, записи,
или для того и другого.
<P>Соединение с открытым файлом представляется или как поток или как
описатель файла. Вы передаете его как аргумент функциям, которые делают
фактическое чтение или операции записи. Некоторые функции ожидают
потоки, а некоторые разработаны для взаимодействия с описателями файла.
<P>Когда Вы закончили читать из или писать в файл, Вы можете завершать
соединение, закрывая файл. Если только Вы закрыли поток или описатель
файла, Вы не можете больше делать операции ввода-вывода на нем.
<P>
<H3>Потоки и описатели файла</H3>

<P>
<P>Когда Вы хотите осуществлять ввод или выводить в файл, Вы имеете
выбор из двух базисных механизмов для представления соединения между
вашей программой и файлом. Это описатели файла и потоки. Описатели файла
представляются как объекты типа int, в то время как потоки
представляются как объекты FILE* (указатели).
<P>Описатели файла обеспечивают примитивный интерфейс низкого уровня
для операций ввода и вывода. И описатели файла, и потоки могут
представлять соединение с устройством (типа терминала), или с
трубопрводом или с гнездом для сообщения с другим процессом, также как с
нормальным файлом. Но, если Вы хотите осуществлять операции управления,
которые являются специфическими для специфического вида устройства, Вы
должны использовать описатель файла; не имеется никаких средств, чтобы
использовать для этого потоки. Вы должны также использовать описатели
файла, если ваша программа должна делать ввод или выводить в специальных
режимах, типа неблокированный (или опрошенный) ввод (см. раздел 8.10
[Флаги состояния файла]).
<P>Потоки обеспечивают интерфейс более высокого уровня, основанный на
примитивных средствах описателя файла. Интерфейс потока хорошо
обрабатывает все виды файлов, единственная сложность - три стиля
буферизации, которую Вы можете выбирать (см. раздел 7.17 [Буферизация
потока]).
<P>Основное преимущество использования интерфейса потока - то, что
набор функций для выполнения фактического ввода и вывода (в
противоположность операциям управления) на потоках является намного
более богатым и более мощным чем соответствующие средства для описателей
файла. Интерфейс описателя файла обеспечивает только простые функции для
пересылки блоков символов, а интерфейс потока обеспечивает мощный
форматируемый ввод и вывода (printf и scanf) также как функции для
символьно- и строко- ориентированного ввода и вывода.
<P>Так как потоки выполнены в терминах описателей файла, Вы можете
извлекать описатель файла из потока и выполнять операции низкого уровня
непосредственно на описателе файла. Вы можете также первоначально
открывать соединение как описатель файла, а потом делать поток,
связанный с этим описателем файла.
<P>Вообще, Вы должны ограничиться использованием потоков, если не
имеется некоторой специфической операции, которая может быть выполнена
только на описателе файла. Если Вы - начинающий программист и не
уверены, какие функции использовать, мы предлагаем Вам концентрироваться
на форматируемых функциях (см. раздел 7.11 [Форматируемый ввод] и раздел
7.9 [Форматируемый вывод]).
<P>Если Вы думаете о переносимости ваших программ на не-GNU системы,
Вы должны также осознавать, что описатели файла не так переносимы как
потоки. Вы можете ожидать что любая ANSI система поддерживает потоки, но
не-GNU системы не могут поддерживать описатели файла вообще или могут
выполнять только подмножество функций GNU, которые функционируют на
описателях файла. Большинство функций описателя файла в библиотеке GNU
включено в стандарт POSIX.1.
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Позиция файла</H3>

<P>
<P>Один из атрибутов открытого файла - позиция файла, которая следит,
где в файле следующий символ должен прочитаться или написаться. В
системе GNU, и всех POSIX.1 системах, позиция файла - просто целое
число, представляющее число байтов от начала файла.
<P>Позиция файла обычно устанавливается в начало файла, когда он
открыт, и каждый раз когда символ читается или пишется, позиция файла
увеличивается. Другими словами, доступ к файлу обычно последователен.
<P>Обычные файлы разрешают чтение или запись в любую позицию внутри
файла. Некоторые другие виды файлов могут также разрешать это. Файлы,
которые разрешают это иногда упоминаются как файлы прямого доступа. Вы
можете изменять позицию файла, используя функцию fseek на потоке (см.
раздел 7.15 [Позиционирование файла]) или функцию lseek на описателе
файла (см. раздел 8.2 [Примитивы ввода - вывода]). Если Вы пробуете
изменять позицию файла в файле, который не поддерживает произвольный
доступ, Вы получите ошибку ESPIPE.
<P>Потоки и описатели, которые открыты для дописывания обрабатываются
особенно для вывода: вывод в такие файлы всегда конкатенируется
последовательно к концу файла, независимо от позиции файла. Но, позиция
файла все еще используется, чтобы управлять, где в файле производить
выполняемое чтение.
<P>Если Вы подумаете относительно этого, вы поймете, что несколько
программ могут читать данный файл в то же самое время. Каждая программа
должна иметь собственный указатель файла, на который не воздействует
ничего из того, что делают другие программы.
<P>Фактически, каждое открытие файла создает отдельную позицию файла.
Таким образом, если Вы открываете файл дважды даже в той же самой
программе, Вы получаете два потока или описатели с независимыми
позициями файла.
<P>Напротив, если Вы открываете описатель а потом дублируете его,
чтобы получить другой описатель, эти два описателя совместно используют
ту же самую позицию файла: изменение позиции файла одного описателя
будет воздействовать на другой.
<P>
<H2><A NAME="ss6.2">6.2 Имена файла</A>
</H2>

<P>
<P>Чтобы открывать соединение с файлом, или выполнять другие операции
типа удаления файла, Вы нуждаетесь в некотором способе обращения к
файлу. Почти все файлы имеют имена, которые представляются строками.
<P>Эти строки называются именами файла. Вы определяете имя файла,
чтобы указывать, который файл Вы хотите открыть или обработать.
<P>Этот раздел описывает соглашения для имен файла и как операционная
система работает с ними.
<P>
<H3>Каталоги</H3>

<P>
<P>Чтобы понимать синтаксис имен файла, Вы должны понять, как файловая
система организована посредством иерархии каталогов.
<P>Каталог - это файл, который содержит информацию, связыывающую имена
других файлов; эти ассоциации называются выходами каталога или узами.
Иногда, люди говорят "файлы в каталоге", но фактически, каталог только
содержит указатели на файлы, а не файлы непосредственно.
<P>Имя каталога содержащего файл, называется компонентом имени файла.
Вообще, имя файла это последовательность из одного или большего
количества таких компонентов, отделяемых символом наклонной черты вправо
("/").
<P>Некоторые другие документы, типа POSIX стандарта, используют термин
путь для того, что мы называем имя файла, и компонент пути для того, что
это руководство вызывает компонент имени файла. Мы не используем эту
терминологию, потому что "путь" - это что-нибудь полностью отличное
(список каталогов для поиска), и мы думаем, что "имя пути", используемое
для чего-нибудь еще будет запутывать пользователей. В документации GNU
мы всегда используем "имя файла" и "компонент имени файла" (или иногда
только "компонент", где контекст очевиден).
<P>Вы можете найти более детализированную информацию относительно
операций с каталогами в Главе 9 [Интерфейс файловой системы].
<P>
<H3>Назначение имени файла</H3>

<P>
<P>Имя файла состоит из компонентов имени файла, отделяемых наклонной
чертой вправо ("/"). В системах, которые поддерживает библиотека GNU С,
многократные последовательные символы `/' эквивалентны одиночному
символу `/'.
<P>Процесс определения, к какому файлу относится имя файла называется
назначение имени файла. Это реализуется, исследованием компонентов,
которые составляют имя файла слева направо, и размещением каждого
последовательныого компонента в каталоге, именованном предыдущим
компонентом. Конечно, каждый из файлов, которые названы каталогами,
должен фактически существовать, и быть каталогом вместо регулярного
файла, и иметь соответствующие права, чтобы быть доступным различным
процессам; иначе неправильно назначено имя файла.
<P>Если, имя файла начинается с "/", первым компонентом в имени файла
принимается корневой каталог процесса (обычно все процессы в системе
имеют тот же самый корневой каталог). Такое имя файла называется
абсолютным именем файла.
<P>Иначе, первый компонент в имени файла есть текущий рабочий каталог
(см. раздел 9.1 [Рабочий каталог]). Этот вид имени файла называется
именем файла прямого доступа.
<P>Компоненты имени файла "." ("точка") и ".." ("точка - точка") имеют
специальные значения. Каждый каталог имеет входы для этих компонентов
имени файла. Компонент имени файла "." относится к каталогу
непосредственно, в то время как компонент имени файла ".." относится к
каталогу предыдущего уровня (каталог, который содержит связь для
рассматриваемого каталога). Как частный случай, ".." в корневом каталоге
относится к корневому каталогу непосредственно, так как он не имеет
никакого родителя; таким образом "/.." тоже что и "/".
<P>Вот несколько примеров имен файла:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      "/a"    файл, с именем "а", в корневом каталоге.
      "/a/b"   файл, с именем "b", в каталоге с именем "а" в корневом каталоге.
      "а"      файл, с именем "а" в текущем рабочем каталоге.
      "/a/./b" Это то же, что и "/a/b".
      "./a"    файл с именем "а", в текущем рабочем каталоге.
      "../a"   файл с именем "а", в директории предыдущего уровня текущего
               рабочего каталога.
</PRE>
</CODE></BLOCKQUOTE>

Имя файла, которое есть имя каталога может необязательно
заканчиваться на "/". Вы можете определять имя файла "/" чтобы
обратиться к корневому каталогу, но пустая строка - не имя файла. Если
Вы хотите обратиться к текущему рабочему каталогу, используйте имя файла
"." или "./".
<P>В отличие от некоторых других операционных систем, система GNU не
имеет ни какой встроенной поддержки типов файлов (или расширений) или
версий как частей синтаксиса имени файла. Много программ и утилит
использют соглашения для имен файлов, например, файлы, содержащие
исходный текст C обычно имеют имена, с прибавленным ".c" но
непосредственно в файловой системе не имеется ничего, что предписывает
этот вид соглашения.
<P>
<H3>Ошибки, связанные с именами файлов</H3>

<P>
<P>Функции, которые принимают как аргументы имена файлов обычно,
обнаруживают эти errno - условия ошибки в отношении синтаксиса имени
файла. Эти ошибки упоминаются в этом руководство как обычные
синтаксические ошибки имени файла.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      EACCES
</PRE>
</CODE></BLOCKQUOTE>

Процесс не имеет права поиска для каталога - компонента имени
файла.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ENAMETOOLONG
</PRE>
</CODE></BLOCKQUOTE>

Эта ошибка используется, когда или общая длина имени файла большае
чем PATH_МАX, или когда индивидуальный компонент имени файла имеет длину
больше чем NAME_MAX. См. раздел 27.6 [Ограничения для файлов].
<P>В системе GNU, не имеется никакого наложенного ограничения полной
длины имени файла, но некоторые файловые системы могут иметь ограничения
длины компонента.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ENOENT
</PRE>
</CODE></BLOCKQUOTE>

Об этой ошибке сообщается, когда файл, вызванный как каталог &shy;
компонент в имени файла не существует, или когда компонент есть
символическая связь, чей выходной файл не существует. См. раздел 9.4
[Символические связи].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ENOTDIR
</PRE>
</CODE></BLOCKQUOTE>

Файл, который вызван как, каталог - компонент имени файла
существует, но это не каталог.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ELOOP
</PRE>
</CODE></BLOCKQUOTE>

Слишком много символических связей было рассмотрено при попытке
поиска имени файла. Система имеет произвольное ограничение числа
символических связей, которые могут быть запомнены при поиске одиночного
имени файла, как примитивный способ обнаружить циклы. См. раздел 9.4
[Символические связи].
<P>
<P>
<P>
<P>
<H3>Переносимость имен файла</H3>

<P>
<P>Правила для синтаксиса имен файла обсуждаемые в разделе 6.2 [Имена
файла], являются правилами, обычно используемыми системой GNU и другими
POSIX системами. Однако, другие операционные системы могут использовать
другие соглашения.
<P>Имеются две причины, почему для Вас важно осознавать проблемы
переносимости имени файла:
<UL>
<LI>       Если ваша программа делает предположения относительно синтаксиса
имени файла, или содержит внедренные литеральные строки имени файла, то
более трудно выполнить ее под управлением других операционных систем,
которые используют различные соглашения синтаксиса.
</LI>
<LI>       Даже если Вы не думаете о выполнении вашей программы на машинах,
которые поддерживают другие операционные системы, Вы можете обращаться к
файлам, которые используют различные соглашения наименования. Например,
Вможете обратиться к файловым системам на другом компьютере,
поддерживающем другую операционную систему, или читать и писать на диски
в форматах, используемых другими операционными системами.</LI>
</UL>

ANSI стандарт имеет очень немного ограничений относительно
синтаксиса имени файла, только что имена файла являются строками. В
дополнение к изменяющимся ограничениям на длину имен файла и какие
символы могут законно появляться в имени файла, различные операционные
системы, используют различные соглашения и синтаксис для понятий типа
структурных каталогов и файловых типов или расширений. Некоторые понятия
такие как версии файла обеспечиваются одними операционными системами и
не обеспечиваются другими.
<P>Стандарт POSIX.1 разрешает, чтобы реализации поместили
дополнительные ограничения на синтаксис имени файла, относительно того,
какие символы разрешаются в именах файла и на длину имени файла и строк
компонентов имени файла. Однако, в системе GNU, Вы не должны волноваться
относительно этих ограничений; любой символ за исключением пустого
символа допускается в строке имени файла, и не имеется никаких
ограничений на длины строк имени файла.
<P>
<HR>
<A HREF="glibc-7.html">Вперед</A>
<A HREF="glibc-5.html">Назад</A>
<A HREF="glibc.html#toc6">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
