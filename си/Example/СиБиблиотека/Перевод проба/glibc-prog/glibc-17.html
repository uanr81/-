<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Дата и время</TITLE>
 <LINK HREF="glibc-18.html" REL=next>
 <LINK HREF="glibc-16.html" REL=previous>
 <LINK HREF="glibc.html#toc17" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-18.html">Вперед</A>
<A HREF="glibc-16.html">Назад</A>
<A HREF="glibc.html#toc17">Содержание</A>
<HR>
<H2><A NAME="s17">17. Дата и время</A></H2>

<P>
<P>
<P>Эта глава описывает функции для управления датой и временем,
включая функции для определения текущего времени и преобразование
между различными представлениями времени.
<P>Функции времени относятся к трем категориям:
<UL>
<LI>        Функции для измерения прошедшего времени CPU обсуждены в
Разделе 17.1 [Время Процессора].</LI>
<LI>        Функции календарного времени обсуждены в Разделе 17.2
[Календарное Время].</LI>
<LI>        Функции для установки будильников и таймеров обсуждены в
Разделе 17.3 [Установка Сигнализации].</LI>
</UL>
<P>
<H2><A NAME="ss17.1">17.1 Время Процессора</A>
</H2>

<P>
<P>Если вы пробуете оптимизировать вашу программу или измерять
эффективность, очень полезно знать, сколько времени процессора или
CPU времени она использовала в любой заданной точке. Процессорное
время является отличным от фактических часов, потому что оно не
включает все потраченное время на ожидание ввода-вывода или когда
выполняется некоторый другой процесс. Процессорное время
представляется типом данных clock_t, и дано как ряд импульсов
времени относительно произвольного базового времени, отмечающего
начало одиночного вызова программы.
<P>
<P>
<H3>Запрос Основного Времени CPU</H3>

<P>
<P>Чтобы получить прошедшее CPU время, используемое процессом, Вы
можете использовать функцию clock. Это средство объявлено в
заглавном файле " time.h ".
<P>Обычно, Вы вызываете функцию clock в начале и конца интервала,
который Вы хотите измерить, вычитаете значения, и тогда делите на
CLOCKS_PER_SEC (число импульсов времени clock в секунду), примерно
так:
<BLOCKQUOTE><CODE>
<PRE>
                         #include &lt;time.h&gt;
                         clock_t start, end;
                         double elapsed;
                         start = clock();
                         . . . /* Do the work. */
                         end = clock();
                         elapsed=((double)(end-start))/CLOCKS_PER_SEC;
</PRE>
</CODE></BLOCKQUOTE>

Различные компьютеры и операционные системы сильно отличаются в
том, как они следят за процессорным временем. Общее для внутренних
часов процессора то, что разрешающая способность где-то между
тысячной и милионной долей секунды.
<P>В системе GNU, clock _t эквивалентен long int, а CLOCKS_PER_SEC
- целочисленное значение. Но в других системах, и clock _t и тип
макрокоманды CLOCKS_PER_SEC может быть или целое число, или с
плавающей точкой. Приведением значения времени процессора к double,
см. пример выше, удостоверяется, что нужные операции работают
правильно и последовательно независимо от того, каково основное
представление.
<BLOCKQUOTE><CODE>
<PRE>
       int CLOCKS_PER_SEC
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - число импульсов времени в секунду,
измеряемое функцией clock.
<BLOCKQUOTE><CODE>
<PRE>
       int CLK_TCK
</PRE>
</CODE></BLOCKQUOTE>

Это - устаревшее имя для CLOCKS_PER_SEC.
<BLOCKQUOTE><CODE>
<PRE>
       clock_t     (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это - тип значения, возвращенного функцией clock. Значения типа
clock_t измеряются в единицах импульсов сигналов времени clock.
<BLOCKQUOTE><CODE>
<PRE>
       clock_t clock (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает прошедшее процессорное время. Базовое
время произвольно, но не изменяется внутри одиночного процесса.
Если процессорное время не доступно или не может представляться,
clock возвращает значение (clock_t) (-1).
<P>
<H3>Детализированный Запрос Времени CPU</H3>

<P>
<P>Функция times возвращает более детализированную информацию
относительно прошедшего процессорного времени в struct tmsobject.
Вы должны включить заглавный файл " sys/times.h " чтобы
использовать это средство.
<BLOCKQUOTE><CODE>
<PRE>
       struct tms          (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Структура tms используется, чтобы возвратить информацию
относительно времени процесса. Она содержит по крайней мере
следующие элементы:
<BLOCKQUOTE><CODE>
<PRE>
       clock_t tms_utime
</PRE>
</CODE></BLOCKQUOTE>

Это - процессорное время, используемое при выполнении команд вызывающего
процесса.
<BLOCKQUOTE><CODE>
<PRE>
       clock_t tms_stime
</PRE>
</CODE></BLOCKQUOTE>

Это - процессорное время, используемое системой от имени вызываюлщего
процесса.
<BLOCKQUOTE><CODE>
<PRE>
       clock_t tms_cutime
</PRE>
</CODE></BLOCKQUOTE>

Это - сумма значений tms_utime и значений tms_cutime всех
завершенных дочерних процессов данного процесса. Другими словами,
она представляет общее процессорное время, используемое при выполнении
команд всех завершенных дочерних процессов вызывающего процесса.
<BLOCKQUOTE><CODE>
<PRE>
       clock_t tms_cstime
</PRE>
</CODE></BLOCKQUOTE>

Подобно tms_cutime, но представляет общее процессорное время,
используемое системой от имени всех завершенных дочерних процессов.
<P>Все времена даны в импульсах сигналов времени. Они - абсолютные
значения; в новом процессе, они - все нуль. См. Раздел 23.4
[Создание Процесса].
<BLOCKQUOTE><CODE>
<PRE>
       clock_t times (struct tms *buffer)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция times сохраняет процессорное время для вызывающего
процесса в buffer.
<P>Возвращаемое значение - также как значение clock (): прошедшее
реальное время относительно произвольной основы. Основа - константа
внутри специфического процесса, и обычно представляет время начиная
с запуска системы. Значение (clock_t) (-1) возвращается, чтобы
указать отказ.
<P>Примечание Переносимости: функция clock, описанная в Разделе
17.1.1 [Базисное процессорное Время], определена в соответствии c стандартом
ANSI C. Функция times - возможность POSIX.1. В системе GNU,
значение, возвращенное функцией clock эквивалентно сумме tms_utime
и tms_stime полей, возвращенных times.
<P>
<H2><A NAME="ss17.2">17.2 Календарное Время</A>
</H2>

<P>
<P>Этот раздел описывает средства для слежения за датами и временем
согласно Грегорианскому календарю.
<P>Имеются три представления информации даты и времени:
<UL>
<LI>        Календарное время (time_t тип данных) - компактное
представление, обычно дает число секунд, истекающих начиная с
некоторого основного времени.</LI>
<LI>        Имеется также представление времени с высоким разрешением
(struct timeval тип данных) которое включает доли секунды.
Используйте это представление времени вместо обычного календарного
времени, когда нужна большая точность.</LI>
<LI>        Местное время (struct tm тип данных) представляет дату и время
как набор компонентов, определяющих год, месяц, и так далее, для
специфического часового пояса. Это представление обычно
используется вместе с форматированием значений даты и времени.</LI>
</UL>
<P>
<H3>Простое Календарное Время</H3>

<P>
<P>Этот раздел описывает time_t тип данных для представления
календарного времени, и функции, которые используют объекты
календарного времени. Эти средства объявлены в заглавном файле "
time.h ".
<BLOCKQUOTE><CODE>
<PRE>
       time_t 
</PRE>
</CODE></BLOCKQUOTE>

Это - тип данных, используемый, чтобы представить календарное
время. В библиотеке GNU C и других POSIX-реализациях, time_t
эквивалентен long int. Он интерпретируется как абсолютное значение
времени и представляет число секунд, истекающих с  00:00:00 1
января, 1970, Координированного Универсального Времени. (Эта дата
иногда упоминается как эпоха.)
<P>В других системах, time_t может быть или целым числом или с
плавающей запятой.
<BLOCKQUOTE><CODE>
<PRE>
       double difftime (time_t time1, time_t time0)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция difftime возвращает число секунд, между временем time1 и
временем time0, как значение типа double.
<P>В системе GNU, Вы можете просто вычитать значения time_t. Но в
других системах, time_t тип данных может использовать некоторое
другое кодирование, где вычитание не работает непосредственно.
<BLOCKQUOTE><CODE>
<PRE>
       time_t time (time_t *result) 
</PRE>
</CODE></BLOCKQUOTE>

Функция time возвращает текущее время как значение типа time_t.
Если аргумент result - не пустой указатель, значение time, также
будет сохранено в *result. Если календарный time не доступен,
возвращается значение (time_t) (-1).
<P>
<H3>Календарь с высоким разрешением</H3>

<P>
<P>Тип данных time_t, используемый, чтобы представить календарное
вермя имеет разрешающую способность только в одну секунду.
<P>Некоторые приложения нуждаются в большей точности.
<P>Так, библиотека GNU C также содержит функции, которые способны
представить календарь с более высокой разрешающей способностью чем
одна секунда. Функции и связанные типы данных, описанные в этом
разделе объявлены в " sys/time.h ".
<BLOCKQUOTE><CODE>
<PRE>
       struct timeval  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Структура struct timeval представляет календарное время. Она
имеет следующие элементы:
<BLOCKQUOTE><CODE>
<PRE>
       long int tv_sec
</PRE>
</CODE></BLOCKQUOTE>

Этот представляет число секунд начиная с зпохи. Это эквивалентно
нормальному значению time_t.
<BLOCKQUOTE><CODE>
<PRE>
       long int tv_usec
</PRE>
</CODE></BLOCKQUOTE>

Это - дробное второе значение, представляемое как число
микросекунд.
<P>Некоторые значения struct timeval - используются для временных
интервалов. Тогда tv_sec элемент - число секунд в интервале, а
tv_usec - число микросекунд.
<BLOCKQUOTE><CODE>
<PRE>
       struct timezone  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Структура struct timezone используется, чтобы содержать
минимальную информацию относительно зоны местного времени. Она
имеет следующие элементы:
<BLOCKQUOTE><CODE>
<PRE>
       int tz_minuteswest
</PRE>
</CODE></BLOCKQUOTE>

Это - число минут к западу от ГРИНВИЧа.
<BLOCKQUOTE><CODE>
<PRE>
       int tz_dsttime
</PRE>
</CODE></BLOCKQUOTE>

Если отличен от нуля, сдвинутое время применяется в течение
некоторой части года.
Struct timezone устаревший тип и не должен использоваться.
Вместо этого, используйте средства, описанные в Разделе 17.2.6 [Функции
Часового пояса].
<P>Часто необходимо вычесть два значения типа struct timeval. Вот
самый лучший способ делать это. Он работает даже на некоторых
специфических операционных системах, где tv_sec элемент имеет тип
unsigned.
<BLOCKQUOTE><CODE>
<PRE>
         int
         timeval_subtract (result, x, y)
                         struct timeval *result, *x, *y;
         {
                 if (x-&gt;tv_usec &lt; y-&gt;tv_usec) {
                         int nsec = (y-&gt;tv_usec-x-&gt;tv_usec)/1000000+1;
                         y-&gt;tv_usec -= 1000000 * nsec;
                         y-&gt;tv_sec += nsec;
                 }
                 if (x-&gt;tv_usec - y-&gt;tv_usec &gt; 1000000) {
                         int nsec = (y-&gt;tv_usec-x-&gt;tv_usec)/1000000;
                         y-&gt;tv_usec += 1000000 * nsec;
                         y-&gt;tv_sec -= nsec;
                 }
                 result-&gt;tv_sec = x-&gt;tv_sec - y-&gt;tv_sec;
                 result-&gt;tv_usec = x-&gt;tv_usec - y-&gt;tv_usec;
                 return x-&gt;tv_sec &lt; y-&gt;tv_sec;
         }
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
       int gettimeofday (struct timeval *tp, struct timezone *tzp) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция gettimeofday возвращает текущую дату и время в структуре
struct timeval, обозначенной tp. Информация относительно часового
пояса возвращается в структуре, указанной в tzp. Если аргумент tzp 
является пустым указателем, информация часового пояса,
игнорируется.
<P>Возвращаемое значение - 0 при успехе и -1 при отказе. Следующее
errno условие ошибки определено для этой функции:
<DL>
<DT><B>ENOSYS </B><DD><P>операционная система не поддерживает получение информации
часового пояса, и tzp - не пустой указатель. Операционная система
GNU не поддерживает использование struct timezoneto для
представления информации часового пояса; это - устаревшая
возможность 4.3 BSD. Вместо этого, используйте средства, описанные в
Разделе 17.2.6 [Функции Часового пояса].
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       int settimeofday (const struct timeval *tp, const struct timezone *tzp)
</PRE>
</CODE></BLOCKQUOTE>

Функция settimeofday устанавливает текущую дату и время согласно
аргументам. Что касается gettimeofday, информация часового пояса
игнорируется, если tzp - пустой указатель.
<P>Вы должны быть привилегированным пользователем, чтобы
использовать settimeofday.
<P>Возвращаемое значение - 0 при успехе и -1 при отказе. Следующие
errno условия ошибки определены для этой функции:
<DL>
<DT><B>EPERM </B><DD><P>Этот процесс не может устанавливать время, потому что он
не привилегированный.
<DT><B>ENOSYS </B><DD><P>операционная система не поддерживает установку информации
часового пояса, и tzp - не пустой указатель.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       int adjtime (const struct timeval *delta, struct timeval *olddelta)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция ускоряет или замедляет часы системы, чтобы делать
постепенные корректировки текущего времени. Она гарантирует, что
время, сообщенное часами системы всегда монотонно увеличивается,
чего не могло случаться, если Вы просто устанавливаете текущее
время.
<P>Аргумент delta определяет относительную корректировку, которая
будет сделана относительно текущего времени. Если он отрицателен,
часы системы замедляются. Если положителен, часы системы
ускоряются.
<P>Если аргумент olddelta - не пустой указатель, функция adjtime,
возвращает информацию относительно любой предыдущей корректировки,
которая еще не завершилась.
<P>Эта функция обычно используется, чтобы синхронизировать часы
компьютеров в местной сети.
<P>Вы должны быть привилегированным пользователем, чтобы
использовать ее. Возвращаемое значение - 0 при успехе и -1 при
отказе. Следующее errno условие ошибки определено для этой функции:
<DL>
<DT><B>EPERM </B><DD><P>Вы не имеют привилегий, чтобы установить время.
</DL>

Примечание Переносимости: функции gettimeofday, settimeofday, и
adjtime - из BSD.
<P>
<P>
<H3>Разделенное Время</H3>

<P>
<P>Календарное время представляется как число секунд. Это удобно
для вычисления, но не имеет никакого отношения к способу, которым
люди обычно представляют даты и время. Нпротив, разделенное время &shy;
двоичное представление, разделенное на год, месяц, день, и так
далее.
<P>Разделенное время всегда зависит от выбора зоны местного
времени, и оно также указывает, какой часовой пояс использовался.
<P>Символы в этом разделе объявлены в заглавном файле " time.h ".
<BLOCKQUOTE><CODE>
<PRE>
       struct tm  
</PRE>
</CODE></BLOCKQUOTE>

Это - тип данных, используемый, чтобы представить разделенное
время. Структура содержит по крайней мере следующие элементы,
которые могут появляться в любом порядке:
<BLOCKQUOTE><CODE>
<PRE>
       int tm_sec
</PRE>
</CODE></BLOCKQUOTE>

Это - число секунд, обычно в диапазоне от 0 до 59. (Фактическое
верхнее ограничение 61, учитывая " прыгающие секунды ".)
<BLOCKQUOTE><CODE>
<PRE>
       int tm_min
</PRE>
</CODE></BLOCKQUOTE>

Это - число минут, в диапазоне от 0 до 59.
<BLOCKQUOTE><CODE>
<PRE>
       int tm_hour
</PRE>
</CODE></BLOCKQUOTE>

Это - число часов после полуночи, в диапазоне от 0 до 23.
<BLOCKQUOTE><CODE>
<PRE>
       int tm_mday
</PRE>
</CODE></BLOCKQUOTE>

Это - день месяца, в диапазоне от 1 до 31.
<BLOCKQUOTE><CODE>
<PRE>
       int tm_mon
</PRE>
</CODE></BLOCKQUOTE>

Это - число месяцев начиная с января, в диапазоне от 0 до 11.
<BLOCKQUOTE><CODE>
<PRE>
       int tm_year
</PRE>
</CODE></BLOCKQUOTE>

Это - число лет начиная с 1900.
<BLOCKQUOTE><CODE>
<PRE>
       int tm_wday
</PRE>
</CODE></BLOCKQUOTE>

Это - число дней начиная с воскресенья, в диапазоне от 0 до 6.
<BLOCKQUOTE><CODE>
<PRE>
       int tm_yday
</PRE>
</CODE></BLOCKQUOTE>

Это - число дней начиная с 1 января, в диапазоне от 0 до 365.
<BLOCKQUOTE><CODE>
<PRE>
       int tm_isdst
</PRE>
</CODE></BLOCKQUOTE>

Это - флаг, который указывает действует ли Смещение светового
дня (или было, или будет) на описанное время. Значение
положительно, если Смещение светового дня включено, нуль, если
нет, и отрицательно, если информация не доступна.
<BLOCKQUOTE><CODE>
<PRE>
       long int tm_gmtoff
</PRE>
</CODE></BLOCKQUOTE>

Это поле описывает часовой пояс, который использовался, чтобы
вычислить разделенное значение времени; это значение Вы должны
добавить к местному времени в этой зоне, чтобы получить время ПО
ГРИНВИЧУ, в секундах. Значение анологично переменной timezone (см.
Раздел 17.2.6 [Функции Часового пояса]).
<P>Tm_gmtoff поле &shy;
расширение библиотеки GNU.
<BLOCKQUOTE><CODE>
<PRE>
       const char *tm_zone
</PRE>
</CODE></BLOCKQUOTE>

Это поле - трехсимвольное имя для часового пояса, который
использовался, чтобы вычислить разделенное время. Это - расширение
библиотеки GNU.
<BLOCKQUOTE><CODE>
<PRE>
       struct tm * localtime (const time_t *time)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
      Localtime функция преобразовывает календарное время, указываемое
TIME в разделенное представление времени, выраженное относительно
заданного часового пояса.
<P>Возвращаемое значение - указатель на статическую структуру
разделенного времени, которая могла бы быть записана поверх
последующими обращениями к любой из функций date и time. (Но
никакая другая библиотечная функция не записывает поверх
содержимого этого объекта.)
<P>Вызов localtime имеет и другой эффект: она устанавливает
переменную tzname с информацией относительно текущего часового
пояса. См. Раздел 17.2.6 [Функции Часового пояса].
<BLOCKQUOTE><CODE>
<PRE>
       struct tm * gmtime (const time_t *time)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция подобна localtime, за исключением того, что
разделенное время выражено как Координированное Универсальное Время
(UTC) то есть как Время ПО ГРИНВИЧУ а не относительно зоны местного
времени.
<P>Вспомните, что календарное время всегда выражается в
координированном универсальном времени.
<BLOCKQUOTE><CODE>
<PRE>
       time_t mktime (struct tm *brokentime)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Mktime функция используется, чтобы преобразовать структуру
разделенного времени в календарное время. Она также "нормализует"
содержимое структуры разделенного времени, внося день недели и день
года, основываясь на других компонентах даты и времени.
<P>Mktime функция игнорирует заданное содержимое tm_wday и tm_yday
элементов структуры разделенного времени. Она использует значения
других компонентов, чтобы вычислить календарное время; для этих
компонентов допустимо иметь ненормализованные значения вне их
нормальных диапазонов. Еще mktime корректирует компоненты структуры
brokentime (включая tm_wday и tm_yday).
<P>Если заданное разделенное время не может представляться как
календарное время, mktime, возвращает значение (time_t) (-1) и не
изменяет содержимое brokentime.
<P>Вызов mktime также устанавливает переменную tzname с информацией
относительно текущего часового пояса. См. Раздел 17.2.6 [Функции
Часового пояса].
<P>
<H3>Форматирование Даты и времени</H3>

<P>
<P>Функции, описанные в этом разделе форматирнуют значения времени
как строки. Эти функции объявлены в заглавном файле " time.h ".
<BLOCKQUOTE><CODE>
<PRE>
       char * asctime (const struct tm *brokentime)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция asctime преобразовывает значение разделенного времени,
на которое указывает brokentime в строку в стандартном формате:
<BLOCKQUOTE><CODE>
<PRE>
                 "Tue May 21 13:46:22 1991\n"
</PRE>
</CODE></BLOCKQUOTE>

Сокращения для дней недели:  `Sun', `Mon', `Tue', `Wed', `Thu',
`Fri', and `Sat'.
<P>Сокращения для месяцев: `Jan', `Feb', `Mar', `Apr', `May',
`Jun', `Jul', `Aug', `Sep', `Oct', `Nov', and `Dec'.
<P>Возвращаемое значение указывает на статически размещенную
строку, которая могла бы быть записана поверх последующими
обращениями к любой из функций date и time. (Но никакая другая
библиотечная функция не записывает поверх содержимого этой строки.)
<BLOCKQUOTE><CODE>
<PRE>
       char * ctime (const time_t *time) 
</PRE>
</CODE></BLOCKQUOTE>
       Ctime функция подобна asctime, за исключением того, что значение
времени определено в календарном времени (не местное время). Она
эквивалентна asctime (localtime (time)) . ctime устанавливает
переменную tzname, потому что так делает localtime. См. Раздел
17.2.6 [Функции Часового пояса].
<BLOCKQUOTE><CODE>
<PRE>
       size_t strftime (char *s, size_t size, const char *template, const struct tm *brokentime)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция подобна sprintf функции (см. Раздел 7.11
[Форматируемый Ввод]), но спецификации преобразования, которые
могут появляться в шаблоне формата, специализированы для печати
компонентов даты и времени brokentime согласно стандарту, в
настоящее время заданному для преобразования времени (см. Главу 19
[Стандарты]).
<P>Обычные символы, появляющиеся в шаблоне копируются в строку
вывода s; она может включать многобайтовые символы. Спецификаторы
Преобразования представляются символом ` % ', и заменяются в строке
вывода следующим образом:
<UL>
<LI>       %a сокращенный день недели согласно текущему стандарту.</LI>
<LI>       %A полный день недели согласно текущему стандарту.</LI>
<LI>       %b сокращенный месяц согласно текущему стандарту.</LI>
<LI>       %B полное название месяца согласно текущему стандарту.</LI>
<LI>       %c привилегированное представление даты и времени для текущего стандарта.</LI>
<LI>       %d день месяца как десятичное число (от 01 до 31).</LI>
<LI>       %H час как десятичное число, используя 24-часовые часы (от 00 до 23).</LI>
<LI>       %I час как десятичное число, используя 12-часовые часы (от 01 до 12).</LI>
<LI>       %j день года как десятичное число (от 001 до 366).</LI>
<LI>       %m месяц как десятичное число (от 01 до 12).</LI>
<LI>       %M минуты как десятичное число.</LI>
<LI>       %p Или "am" или "pm", согласно данному значению времени; или
соответствующие строки для текущего стандарта.</LI>
<LI>       %S секунды как десятичное число.</LI>
<LI>       %U число недель текущего года как десятичное число, начинающееся
с первого воскресенья как первый день первой недели.</LI>
<LI>       %W число недель текущего года как десятичное число, начинающееся
с первого понедельника как первый день первой недели.</LI>
<LI>       %w день недели как десятичное число, воскресенье - 0.</LI>
<LI>       %x привилегированное представление даты для текущего стандарта,
но без времени.</LI>
<LI>       %X привилегированное представление времени для текущего
стандарта, но без даты.</LI>
<LI>       %y год как десятичное число, но без столетия (от 00 до 99).</LI>
<LI>       %Y год как десятичное число, включая столетие.</LI>
<LI>       %Z часовой пояс или имя или сокращение (пусто, если часовой пояс
не может быть определен).</LI>
<LI>       %% литеральный символ ` % '.</LI>
</UL>

Параметр size может использоваться, чтобы определить
максимальное число символов, которое будет сохранено в массиве s,
включая пустой символ завершения. Если форматируемое время требует
больше чем size символов, лишние символы отбрасываются.
Возвращаемое значение из strftime - число символов, помещенное в
массив s, не включая пустой символ завершения. Если значение
равняется размеру, это означает что массив s был слишком мал; Вы
должны повторить обращение, обеспечивая больший массив.
<P>Если s - пустой указатель, strftime не делает фактической записи
чего-нибудь, но взамен возвращает число символов, которое она
написала бы.
<P>Для примера strftime, см. Раздел 17.2.7 [Пример Функции
Времени].
<P>
<H3>Определение Часового пояса с TZ</H3>

<P>
<P>В системе GNU, пользователь может определять часовой пояс
посредством TZ переменной среды.
<P>Для уточнения инфрмации относительно того, как устанавливать
переменные среды, см. Раздел 22.2 [Переменные среды]. Функции для
доступа к часовому поясу объявлены в " time.h ".
<P>Значение TZ переменной может иметь один из трех форматов. Первый
формат используется, когда не имеется никакого Смещения светового
дня (или в летнее время) в зоне местного времени:
<BLOCKQUOTE><CODE>
<PRE>
       std offset
</PRE>
</CODE></BLOCKQUOTE>
       Std строка определяет имя часового пояса. Эта строка должна состоять
из трех или большего количества символов и не должно содержать первым
символом двоеточие, и цифры, запятые, плюс или минус внутри.
<P>Смещение определяет значение которое нужно добавить к местному
времени, чтобы получить значение Координированного Универсального
времени. Она имеет синтаксис подобно [+ | -] hh [: mm [: ss]]. Она
положительно, если зона местного времени - к западу от Главного
меридиана и отрицательно, если она восточнее. Час должен быть от 0
до 24, а минуты и секунды от 0 до 59.
<P>Например, вот, как мы определили бы Восточное Стандартное Время,
но без любых Смещений Светового дня:
<BLOCKQUOTE><CODE>
<PRE>
       EST+5
</PRE>
</CODE></BLOCKQUOTE>

Второй формат используется, когда имеется Смещение светового
дня:
<BLOCKQUOTE><CODE>
<PRE>
       std offset dst [offset],start[/time],end[/time]
</PRE>
</CODE></BLOCKQUOTE>

Начальные std и offset определяют стандартный часовой пояс, как
описано выше. Dst строка и offset определяет имя и смещение для
соответствующего Смещения Дня этого часового пояса; если смещение
опущено, это значения по умолчанию равно одному часу перед
стандартным временем.
<P>Остаточный член от спецификации описывает, когда смещение
светового дня действует. Поле start - то, когда смещение светового
дня входит в силу, а поле end - то, когда изменение будет сделано
обратно к стандартному времени. Следующие форматы распознаваемы для
этих полей:
Jn определяет Юлианский день, с n между 1 и 365. 29 февраля
никогда не рассчитывается, даже в високосные годы.
N определяет Юлианский день, с n между 0 и 365. 29 февраля
рассчитан в високосные годы.
Mm.w.d определяет день d недели w месяца m. день d должен быть
между 0 (воскресеньем) и 6. Неделя w должна быть между 1 и 5;
неделя 1 - первая неделя, в которой есть день d , а неделя 5
определяет последний d день в месяце. Месяц m должен быть между 1 и
12.
<P>Поля time определяют, когда, по местному времени происходит
изменение к другому времени. Значение по умолчанию - 02:00:00.
<P>Например, вот, как можно определить Восточный часовой пояс в
Соединенных Штатах, включая соответствующее смещение светового дня
и даты применимости. Нормальное смещение ПО ГРИНВИЧУ - 5 часов; так
как это - к западу от главного меридиана, знак положителен. Летний
период начинается в первое воскресенье апреля в 2:00am, и кончается
в последнее воскресенье октября в 2:00am.
<BLOCKQUOTE><CODE>
<PRE>
       EST+5EDT,M4.1.0/M10.5.0
</PRE>
</CODE></BLOCKQUOTE>

План смещения светового дня в любой юрисдикции не
изменяется годами.
<P>Чтобы быть строго правильным, преобразование дат и времени
должно быть основано на действующем плане. Однако, система не имеет
никаких средств, чтобы допустить Вам определять, как план
изменился. Наибольшее что Вы может сделать - определить один
специфический план обычно план текущего дня.
<P>Третий формат походит на:
<BLOCKQUOTE><CODE>
<PRE>
                 :characters
</PRE>
</CODE></BLOCKQUOTE>

Каждая операционная система интерпретирует этот формат по&shy;
разному; в библиотеке GNU C, characters - имя файла, который
описывает часовой пояс.
<P>Если переменная среды TZ не имеет значения, операция выбирает
часовой пояс по умолчанию. Каждая операционная система имеет
собственные правила для выбора заданного по умолчанию часового
пояса, так что относительно этого мы можем сказать совсем немного.
<P>
<H3>Функции и Переменные для Часовых поясов</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
       char * tzname [2]  (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Массив tzname содержит две строки, которые являются стандартными
трех-символьными именами пары часовых поясов (стандартный и
смещения светового дня) которые пользователь выбрал. Tzname [0] &shy;
имя стандартного часового пояса (например, "EST"), а tzname [1] &shy;
имя для часового пояса, когда смещение светового дня находится в
использовании (например, "EDT"). Они соответствуют к std и dst
строкам (соответственно) из TZ переменной среды.
Tzname массив инициализируется из переменной среды TZ всякий
раз, когда tzset, ctime, strftime, mktime, или localtime
вызывается.
<BLOCKQUOTE><CODE>
<PRE>
       void tzset (void) 
</PRE>
</CODE></BLOCKQUOTE>
      Tzset функция инициализирует переменную tzname из значения
переменной среды TZ. Обычно вашей программе не нужно вызывать эту
функцию, потому что она вызывается автоматически, когда Вы
используете другие функции преобразования времени, которые зависят
от часового пояса.
<P>Следующие переменные определены для совместимости с System V
Unix. Эти переменные устанавливаются вызоввом localtime.
<BLOCKQUOTE><CODE>
<PRE>
       long int timezone  
</PRE>
</CODE></BLOCKQUOTE>

Эта переменная содержит различие между временем ПО ГРИНВИЧУ и местным
стандартным временем, в секундах. Например, в США в Восточном
часовом поясе значение - 5*60*60.
<BLOCKQUOTE><CODE>
<PRE>
       int daylight  
</PRE>
</CODE></BLOCKQUOTE>

Эта переменная имеет значение отличное от нуля, если применяются
стандартные американские правила смещения светового дня.
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Пример Функции Времени</H3>

<P>
<P>Вот пример программы, показывающий использование некоторых
функций местного и календарного времени.
<BLOCKQUOTE><CODE>
<PRE>
                 #include &lt;time.h&gt;
                 #include &lt;stdio.h&gt;
                 #define SIZE 256
                 int
                 main (void)
                 {
                         char buffer[SIZE];
                         time_t curtime;
                         struct tm *loctime;
                         curtime = time (NULL);
                         loctime = localtime (&amp;curtime);
                         fputs (asctime (loctime), stdout);
                         strftime (buffer, SIZE,
         "Today is %A, %B %d.\n", loctime);
                         fputs (buffer, stdout);
                         strftime (buffer, SIZE,
         "The time is %I:%M %p.\n", loctime);
                         fputs (buffer, stdout);
                         return 0;
                 }
</PRE>
</CODE></BLOCKQUOTE>

Она производит примерно такой вывод:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       Wed Jul 31 13:02:36 1991
       Today is Wednesday, July  31.
       The time is 01:02 PM.
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss17.3">17.3 Установка Сигнализаций</A>
</H2>

<P>
<P>Функции alarm и setitimer обеспечивают механизм прерывания процесса,
в некоторое время. Они делают это,
устанавливая таймер; когда время таймер истекает, процесс получает
сигнал.
<P>
<P>
<P>
<P>Каждый процесс имеет три доступных независимых таймера
интервала:
<UL>
<LI>        Таймер в реальном времени, который считает время как часы.
Этот таймер посылает сигнал SIGALRM процессу, когда время истекает.</LI>
<LI>        Виртуальный таймер, который считает процессорное время, используемое
процессом. Этот таймер посылает сигнал SIGVTALRM процессу, когда
время истекает.</LI>
<LI>        Таймер профилирования, который считает оба: процессорное время,
используемое процессом, и процессорное время, потраченное в системных
вызовах от имени процесса. Этот таймер посылает сигнал SIGPROF
процессу, когда время истекает.</LI>
</UL>

Вы можете иметь только один таймер каждого вида в любое заданное
время. Если Вы устанавливаете таймер, который еще не истек, этот
таймер будет сброшен в новое значение.
<P>Вы должны установить обработчик для соответствующего сигнала
alarm, используюя signal или sigaction перед обращением к setitimer
или alarm. Иначе, необычная цепочка событий может заставлить таймер
исчерпать время прежде, чем ваша программа установит обработчик, и в этом
случае она будет завершена, так как это - заданное по умолчанию
действие для сигналов alarm. См. Главу 21 [Обработка Сигнала].
<P>Функция setitimer - первичный способ для установки будильника.
Это средство объявлено в заглавном файле " sys/time.h ". Функция
alarm, объявленная в " unistd.h ", обеспечивает несколько более
простой интерфейс для установки таймера в реальном времени.
<BLOCKQUOTE><CODE>
<PRE>
       struct itimerval  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Эта структура используется, чтобы определить, когда таймер
должен истечь. Она содержит следующие элементы:
<BLOCKQUOTE><CODE>
<PRE>
       struct timeval it_interval
</PRE>
</CODE></BLOCKQUOTE>

Это - интервал между последовательными прерываниями по таймеру.
Значение - нуль, если сигнал будет только послан один раз.
<BLOCKQUOTE><CODE>
<PRE>
       struct timeval it_value
</PRE>
</CODE></BLOCKQUOTE>

Это - интервал до первого прерывания по таймеру. Значение - нуль если, он
заблокирован.
<P>Тип данных Struct timeval описан в Разделе 17.2.2 [Календарь с
высоким разрешением].
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int setitimer (int which, struct itimerval *old, struct itimerval *new)
</PRE>
</CODE></BLOCKQUOTE>

Функция setitimer устанавливает таймер, заданный как which
согласно new. Аргумент which может иметь значение ITIMER_REAL,
ITIMER_VIRTUAL, или ITIMER_PROF.
<P>Если old - не пустой указатель, setitimer возвращает информацию
относительно любого предыдущего неистекшего таймера того же самого
вида в структуре, на которую он указывает.
<P>Возвращаемое значение - 0 при успехе и -1 при отказе. Следующие
errno условия ошибки определены для этой функции:
<DL>
<DT><B>EINVAL </B><DD><P>интервал таймера был слишком большой.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       int getitimer (int which, struct itimerval *old)
</PRE>
</CODE></BLOCKQUOTE>
      Getitimer функция сохраняет информацию относительно таймера,
заданного which в структуре, указанной в old.
<P>Возвращаемое значение и условия ошибки - такие же как для
setitimer.
<BLOCKQUOTE><CODE>
<PRE>
       ITIMER_REAL
</PRE>
</CODE></BLOCKQUOTE>

Эта константа может использоваться как аргумент which для
setitimer и getitimer функций, чтобы определить таймер в реальном
времени.
<BLOCKQUOTE><CODE>
<PRE>
       ITIMER_VIRTUAL
</PRE>
</CODE></BLOCKQUOTE>

Эта константа может использоваться как аргумент which для
setitimer и getitimer, чтобы определить виртуальный таймер.
<BLOCKQUOTE><CODE>
<PRE>
       ITIMER_PROF
</PRE>
</CODE></BLOCKQUOTE>

Эта константа может использоваться как аргумент which для
setitimer и getitimer, чтобы определить таймер профилирования.
<BLOCKQUOTE><CODE>
<PRE>
       unsigned int alarm (unsigned int seconds) 
</PRE>
</CODE></BLOCKQUOTE>

Функция alarm устанавливает таймер в реальном времени, с
периодом в second секунд. Если Вы хотите отменить любой
существующий таймер, Вы может сделать это, вызывая alarm с
аргументом 0.
<P>Возвращаемое значение указывает, сколько секунд оставалось
прежде, чем предыдущий сигнал был бы послан. Если не было никакого
предыдущего сигнала, alarm возвращает нуль.
<P>
<P>
<P>
<P>
<P>Функция alarm могла бы быть определена в терминах setitimer
примерно так:
<BLOCKQUOTE><CODE>
<PRE>
                 unsigned int
                 alarm (unsigned int seconds)
                 {
                         struct itimerval old, new;
                         new.it_interval.tv_usec = 0;
                         new.it_interval.tv_sec = 0;
                         new.it_value.tv_usec = 0;
                         new.it_value.tv_sec = (long int) seconds;
                         if (setitimer (ITIMER_REAL, &amp;new, &amp;old) &lt; 0)
                                 return 0;
                         else
                                 return old.it_value.tv_sec;
                 }
</PRE>
</CODE></BLOCKQUOTE>

Имеется пример, показывающий использование функции alarm в
Разделе 21.4.1 [Возврат Обработчика].
<P>Если Вы просто хотите, чтобы ваш процесс ждал данное число
секунд, Вы должен использовать функцию sleep. См. Раздел 17.4
[Sleep].
<P>Вы не должны рассчитать на сигнал, прибывающий точно, когда
таймер истекает. В многопроцессорной среде имеется обычно некоторая
задержка.
<P>Примечание Переносимости: setitimer и getitimer - функции UNIX
BSD, в то время как функция alarm определена POSIX.1 стандартом.
Setitimer более мощная чем alarm, но alarm более широко
используется.
<P>
<H2><A NAME="ss17.4">17.4 Sleep</A>
</H2>

<P>Sleep дает простой способ заставить программу ждать некоторый
период времени. Если ваша программа не использует сигналы (за
исключением завершения), то Вы можете расчитывать, что sleep будет
ждать заданное количество времени. Иначе, sleep может возвращаться,
если прибывает сигнал; если Вы хотите ждать данный период
независимо от сигналов, используйте select (см. Раздел 8.6 [Ждущий
ввод - вывод] ) и не определяйте ни каких описателей ожидания.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       unsigned int sleep (unsigned int seconds) 
</PRE>
</CODE></BLOCKQUOTE>

Функция sleep ждет seconds секунд или пока не получен сигнал.
<P>Если функция sleep возвращает значение по истечении времени, то
это значение нуль. Если она возвращается после сигнала, возвращаемое
значение - остающееся время ожидания sleep.
<P>Функция sleep объявлена в " unistd.h ".
<P>Вы можете использовать select и делать период ожидания,
совершенно точным. (Конечно, загрузка системы может
вызывать неизбежные дополнительные задержки, если машина не
специализирована одному приложению, не имеется никакого способа,
которым Вы можете избежать этого.)
<P>
<H2><A NAME="ss17.5">17.5 Использование Ресурсов</A>
</H2>

<P>
<P>Функция getrusage и тип данных struct rusage используется для
исследования типа использования процесса. Они объявлены в "
sys/resource.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int getrusage (int processes, struct rusage *rusage) 
</PRE>
</CODE></BLOCKQUOTE>

Эта функция сообщает общее использование для процессов, заданных
в processes, сохраняя информацию в *rusage.
<P>В большинстве систем, processes имеет только два допустимых
значения:
<BLOCKQUOTE><CODE>
<PRE>
       RUSAGE_SELF
</PRE>
</CODE></BLOCKQUOTE>

Только текущий процесс.
<BLOCKQUOTE><CODE>
<PRE>
       RUSAGE_CHILDREN
</PRE>
</CODE></BLOCKQUOTE>

Все дочерние процессы (прямые и косвенные) которые уже
завершились.
<P>В системе GNU, Вы можете также запрашивать относительно
специфического дочернего процесса, определяя ID процесса.
<P>Возвращаемое значение getrusage - нуль при успехе, и -1 при
отказе.
<P>Аргумент EINVAL processes не допустим.
<P>Еще один способ получения типа использования для специфического
дочернего процесса - функцией wait4, которая возвращает общие
количества для дочернего процесса при его завершении. См. Раздел
23.8 [BSD Функции Ожидания].
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       struct rusage
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных записывает величину использования различного
рода ресурсов. Он имеет следующие элементы (возможны другие):
<BLOCKQUOTE><CODE>
<PRE>
       struct timeval ru_utime
</PRE>
</CODE></BLOCKQUOTE>

Использованное пользовательское время.
<BLOCKQUOTE><CODE>
<PRE>
       struct timeval ru_stime
</PRE>
</CODE></BLOCKQUOTE>

Использованное системное время.
<BLOCKQUOTE><CODE>
<PRE>
       long ru_majflt
</PRE>
</CODE></BLOCKQUOTE>

Число страниц.
<BLOCKQUOTE><CODE>
<PRE>
       long ru_inblock
</PRE>
</CODE></BLOCKQUOTE>

Число блокировок операций ввода.
<BLOCKQUOTE><CODE>
<PRE>
       long ru_oublock
</PRE>
</CODE></BLOCKQUOTE>

Число блокировок операций вывода.
<BLOCKQUOTE><CODE>
<PRE>
       long ru_msgsnd
</PRE>
</CODE></BLOCKQUOTE>

Число посланных сообщений.
<BLOCKQUOTE><CODE>
<PRE>
       long ru_msgrcv
</PRE>
</CODE></BLOCKQUOTE>

Число полученных сообщений.
<BLOCKQUOTE><CODE>
<PRE>
       long ru_nsignals
</PRE>
</CODE></BLOCKQUOTE>

Число полученных сигналов.
<P>Дополнительная историческая функция для исследования типов
использования, vtimes, обеспечивается но здесь не описана. Она
объявлена в " sys/vtimes.h ".
<P>
<H2><A NAME="ss17.6">17.6 Ограничение Использования Ресурсов</A>
</H2>

<P>
<P>Вы можете определять ограничения использования ресурса для
процесса. Когда процесс пробует превышать ограничение, он может
терпеть неудачу, в зависимости от ограничения. Каждый процесс
первоначально наследует значения ограничений от родителя, но он
может впоследствии изменять их.
<P>Символы в этом разделе определены в " sys/resource.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int getrlimit (int resource, struct rlimit *rlp)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Читает текущее значение и максимальное значение ресурса
resource, и сохраняет их в *rlp.
<P>Возвращаемое значение - 0 при успехе и -1 при отказе.
Единственое возможное errno условие ошибки - EFAULT.
<BLOCKQUOTE><CODE>
<PRE>
       int setrlimit (int resource, struct rlimit *rlp)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Сохраняет текущее значение и максимальное значение ресурса в
*rlp.
<P>Возвращаемое значение - 0 при успехе и -1 при отказе. Следующее
errno условие ошибки возможно:
<DL>
<DT><B>EPERM </B><DD><P>Вы пробовали изменять максимально допустимое значение
ограничения, но Вы не имеете привилегий, чтобы сделать это.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       struct rlimit  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Эта структура используется с getrlimit, чтобы получить значения
ограничений, и с setrlimit, чтобы определить значения ограничений.
Она имеет два поля:
<P>Rlim_cur Текущее значение рассматриваемого ограничения.
<P>Rlim_max Максимально допустимое значение рассматриваемого
ограничения. Вы не можете устанавливать текущее значение
ограничения больше чем этот максимум. Только root может изменять
максимально допустимое значение.
<P>В getrlimit, эта структура - вывод; она получает текущие
значения. В setrlimit она определяет новые значения.
<P>Вот список ресурсов, для которых Вы можете определять
ограничения.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       RLIMIT_CPU
</PRE>
</CODE></BLOCKQUOTE>

Максимальное количество времени центрального процессора которое
процесс может использовать. Если он выполняется дольше чем это
время, он получает сигнал: SIGXCPU. Значение измеряется в секундах.
См. Раздел 21.2.7 [Нестандартные Сигналы].
<BLOCKQUOTE><CODE>
<PRE>
       RLIMIT_FSIZE
</PRE>
</CODE></BLOCKQUOTE>

Максимальный размер файла котоый процесс может создать. При
попытке записать больший файл вызывается сигнал: SIGXFSZ. См.
Раздел 21.2.7 [Нестандартные Сигналы].
<BLOCKQUOTE><CODE>
<PRE>
       RLIMIT_DATA
</PRE>
</CODE></BLOCKQUOTE>

Максимальный размер памяти данных для процесса. Если процесс
пробует зарезервировать память больше этого количества,
функции резервирования выдает ошибку.
<BLOCKQUOTE><CODE>
<PRE>
       RLIMIT_STACK
</PRE>
</CODE></BLOCKQUOTE>

Максимальный размер стека для процесса. Если процесс пробует
расширять стек больше этого размера, он получает сигнал SIGSEGV.
См. Раздел 21.2.1 [Сигналы Ошибки в программе].
<BLOCKQUOTE><CODE>
<PRE>
       RLIMIT_CORE
</PRE>
</CODE></BLOCKQUOTE>

Максимальный размер core-файла, который этот процесс может
создавать. Если процесс завершается и этот максимальный размер не
достаточен для core-файла, файл будет усечен.
<BLOCKQUOTE><CODE>
<PRE>
       RLIMIT_RSS
</PRE>
</CODE></BLOCKQUOTE>

Максимальное количество физической памяти, которое этот процесс
может получить. Этот параметр - руководство для планировщика
системы и программы распределения памяти; система может давать
процессу большее количество памяти, когда имеется излишек.
<BLOCKQUOTE><CODE>
<PRE>
       RLIMIT_OPEN_FILES
</PRE>
</CODE></BLOCKQUOTE>

Максимальное число файлов, которые процесс может открывать. Если
он пробует открывать большее количество файлов, он получает код
ошибки EMFILE. См. Раздел 2.2 [Коды Ошибки].
<BLOCKQUOTE><CODE>
<PRE>
       RLIM_NLIMITS
</PRE>
</CODE></BLOCKQUOTE>

Число различных ограничений ресурсов. Любой допустимый операнд
ресурса должен быть меньше чем RLIM_NLIMITS.
<BLOCKQUOTE><CODE>
<PRE>
       int RLIM_INFINITY  
</PRE>
</CODE></BLOCKQUOTE>

Эта константа замещает значение "бесконечности" когда
обеспечивается как значение ограничения в setrlimit.
<P>Две исторических функции для установки ограничений ресурса,
ulimit и vlimit, не зарегистрированы здесь. Они объявлены в "
sys/vlimit.h " и исходят ИЗ BSD.
<P>
<H2><A NAME="ss17.7">17.7 Приоритет Процесса</A>
</H2>

<P>
<P>Когда отдельные процессы выполняются, их приоритеты
определяют то, какую часть ресурсов CPU каждый процесс получает.
Этот раздел описывает, как Вы можете читать и устанавливать
приоритет процесса. Все эти функции и макрокоманды объявлены в "
sys/resource.h ".
<P>Промежуток допустимых значений зависит от операционной системы,
но обычно он выполняется от -20 до 20. Меньшее значение приоритета
означает что процесс выполняет чаще. Эти константы описывают
некоторые значения:
PRIO_MIN самое маленькое допустимое значение приоритета.
PRIO_MAX самое большое допустимое значение приоритета.
<BLOCKQUOTE><CODE>
<PRE>
       int getpriority (int class, int id)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Читает приоритет класса процессов, задаваемого class и id (см.
ниже).
<P>Возвращаемое значение - значение приоритета при успехе, и -1 при
отказе. Следующее errno условие ошибки возможно для этой функции:
<DL>
<DT><B>ESRCH </B><DD><P>комбинация class и id не соответствует никакому
существующему процессу.
<DT><B>EINVAL </B><DD><P>значение class не допустимо.
</DL>

Когда возвращаемое значение -1, это может указывать отказ, или
значение приоритета.
<P>Единственый способ различить состоит в том, чтобы установить
errno = 0 перед вызовом getpriority, и тогда использовать errno!= 0
позже как критерий для отказа.
<BLOCKQUOTE><CODE>
<PRE>
       int setpriority (int class, int id, int priority)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Устанавливает приоритет класса процессов, задаваемого class и id
(см. ниже).
<P>Возвращаемое значение - 0 при успехе и -1 при отказе. Следующее
errno условие ошибки определено для этой функции:
<DL>
<DT><B>ESRCH </B><DD><P>комбинация class и id не соответствует никакому
существующему процессу.
<DT><B>EINVAL </B><DD><P>значение класса не допустимо.
<DT><B>EPERM </B><DD><P>Вы пробовали устанавливать приоритет процесса некоторого
другого пользователя, и Вы не имеете привилегий для этого.
<DT><B>EACCES </B><DD><P>Вы пробовали понизить приоритет процесса, и Вы не имеете
привилегий для этого.
</DL>

Аргументы class и id вместе определяет набор процессов, которыми
Вы заинтересованы. Вот возможные значения для class:
<BLOCKQUOTE><CODE>
<PRE>
       PRIO_PROCESS
</PRE>
</CODE></BLOCKQUOTE>

Читает или устанавливает приоритет одного процесса. id аргумент
- ID процесс.
<BLOCKQUOTE><CODE>
<PRE>
       PRIO_PGRP
</PRE>
</CODE></BLOCKQUOTE>

Читает или устанавливает приоритет одной группы процесса.
Аргумент id - ID группы процесса.
<BLOCKQUOTE><CODE>
<PRE>
       PRIO_USER
</PRE>
</CODE></BLOCKQUOTE>

Читает или устанавливает приоритет процессов одного
пользователя. Аргумента id - ID пользователя.
<P>Если id аргумент - 0, то обрабатывается текущий процесс, текущая
группа процесса, или текущий пользователь, согласно классу.
<BLOCKQUOTE><CODE>
<PRE>
       int nice (int increment)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Увеличьте приоритет текущего процесса приращением. Возвращаемое
значение не важно.
<P>
<P>
<P>
<P>
<P>Вот эквивалентное определение для nice:
<BLOCKQUOTE><CODE>
<PRE>
                 int
                 nice (int increment)
                 {
                         int old = getpriority (PRIO_PROCESS, 0);
                         setpriority (PRIO_PROCESS,0,old+increment);
                 }
</PRE>
</CODE></BLOCKQUOTE>
<HR>
<A HREF="glibc-18.html">Вперед</A>
<A HREF="glibc-16.html">Назад</A>
<A HREF="glibc.html#toc17">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
