<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Ввод-вывод на потоках</TITLE>
 <LINK HREF="glibc-8.html" REL=next>
 <LINK HREF="glibc-6.html" REL=previous>
 <LINK HREF="glibc.html#toc7" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-8.html">Вперед</A>
<A HREF="glibc-6.html">Назад</A>
<A HREF="glibc.html#toc7">Содержание</A>
<HR>
<H2><A NAME="s7">7. Ввод-вывод на потоках</A></H2>

<P>
<P>Эта глава описывает функции для создания потоков и выполнения ввода
и вывода на них. Как обсждается в Главе 6 [Краткий обзор ввода-вывода],
поток - довольно абстрактное понятие, представляющее канал связи с
файлом, устройством, или процессом.
<P>
<H2><A NAME="ss7.1">7.1 Потоки</A>
</H2>

<P>
<P>По историческим причинам, С тип структуры данных, которая
представляет поток называется FILE,а не "поток". Так как большинство
библиотечных функций имеет дело с объектами типа FILE *, иногда термина
указатель на файл также используется, чтобы обозначить "поток". Это
ведет к беспорядку терминологии во многих книгах о C, это руководство,
однако, использует термины "файл" и "поток" только в техническом смысле.
<P>Тип FILE объявлен в заголовочном файле "stdio.h".
<P>FILE (тип_данных) - это тип данных, используемый, чтобы представить
объекты потока. Объект FILE содержит всю внутреннюю информацию о
состоянии относительно соединения со связанным файлом, включая такие
вещи как индикатор позиции файла и информация буферизации. Каждый поток
также имеет индикаторы ошибки и состояния конца файла, которые могут
быть проверены функциями feof и ferror; см. раздел 7.13 [EOF и ошибки].
<P>Объекты FILE размещены и управляются внутренне в соответствии c
библиотечными функциями ввода -вывода. Не пробуйте создавать ваши
собственные объекты типа FILE; пусть библиотеки, делают это. Ваши
программы должны иметь дело только с указателями на эти объекты (то есть
FILE*).
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss7.2">7.2 Стандартные потоки</A>
</H2>

<P>
<P>Когда основная функция вашей программы вызывается, уже существуют
три предопределенных потока. Они представляют "стандартные" входные и
выходные каналы, которые были установлены для процесса.
<P>Эти потоки объявлены в заголовочном файле "stdio.h".
<DL>
<DT><B>FILE * stdin (переменная)  </B><DD><P>стандартный входной поток, который
является нормальным источником ввода для программы.
<P>
<DT><B>FILE * stdout (переменная)  </B><DD><P>поток стандартного вывода, который
используется для нормального вывода программы.
<P>
<DT><B>FILE * stderr (переменная)  </B><DD><P>стандартный поток ошибки, который
используется для сообщений об ошибках и диагностики, выданной
программой.
</DL>

В системе GNU, Вы можете определять то, какие файлы или процессы
соответствуют этим потокам, использующим трубопровод и средства
переадресации, обеспеченные оболочкой. (Использование примитивов
оболочки описано в Главе 9 [Интерфейс файловой системы]) Большинство
других операционных систем обеспечивает подобные механизмы, но
подробности того, как их использовать могут изменяться.
<P>В библиотеке GNU C, stdin, stdout, и stderr - обычные переменные,
которые Вы можете устанавливать точно так же как любые другие. Например,
чтобы переназначить стандартный вывод файла, нужно выполнить:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      fclose (stdout);
      stdout = fopen ("standard-output-file","w");
</PRE>
</CODE></BLOCKQUOTE>

Обратите внимание, что в других системах stdin, stdout, и stderr
являются макрокомандами, которые Вы не можете назначать обычным
способом. Но Вы можете использовать freopen, чтобы получить эффект
закрытия того и повторного открытия этого. См. раздел 7.3 [Открытие
потоков].
<P>
<H2><A NAME="ss7.3">7.3 Открытие потоков</A>
</H2>

<P>
<P>Открытие файла функцией fopen создает новый поток и устанавливает
соединение между потоком и файлом, возможно включая создание нового
файла.
<P>Все описанное в этом разделе объявлено в заголовочном файле
"stdio.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      FILE * fopen (const char *filename , const char * opentype) (функция)
</PRE>
</CODE></BLOCKQUOTE>

функция fopen открывает поток для ввода - вывода в файл, и
возвращает указатель на поток.
<P>оpentype аргумент - это строка, которая управляет открытием файла и
определяет атрибуты возникающего в результате потока. Она должна
начинаться с одной из следующих последовательностей символов:
<P>"r" Открывает существующий файл для чтения.
<P>"w" Открывает файл для записи. Если файл уже существует, его длина
обнуляется. Иначе создается новый файл.
<P>"а" Открывает файл для добавления; то есть записи в конец файла.
Если файл уже существует начальное содержимое неизменяется, и вывод
потока добавляется в конец файла. Иначе, создается новый пустой файл.
<P>"r+" Открывает существующий файл, и для чтения и для заипси.
Начальное содержимое файла неизменяется, и начальная позиция файла - в
начале файла.
<P>"w+" Открывает файл, и для чтения и для запмси. Если файл уже
существует, он усекается, чтобы обнулить длину. Иначе, создается новый
файл.
<P>"а+" Открывает или создают файл, и для чтения и для добавления в
конец. Если файл существует, начальное содержимое неизменяется. Иначе,
создается новый файл. Начальная позиция файла для чтения - в начале
файла, но вывод всегда добавляется к концу файла.
<P>Вы видите, что "а+" запрашивает поток, который может делать и ввод
и вывод. Стандарт ANSI говорит, что при использовании такого потока, Вы
должны вызвать fflush (см. раздел 7.17 [Буферизация потока]) или
позиционирующую файл функцию типа fseek (см. раздел 7.15
[Позиционирование файла]) при переключении чтения на запись или
наоборот. Иначе, внутренние буфера не будут освобождены правильно.
Библиотека GNU С не имеет этого ограничения; Вы можете делать
произвольное чтение и запись на потоке в любом порядке.
<P>Библиотека GNU С определяет один дополнительный символ для
использования в opentype: символ "x" настаивает на создании нового
файла, если имя файла уже существует, fopen выдаст ошибку. Это
эквивалентно O_EXCL опции открыавющей функции (см. раздел 8.10 [Флаги
состояния файла]).
<P>Символ "b" в opentype имеет стандартное значение; он запрашивает
двоичный поток, а не текстовый поток. Но это не имеет никакое значения в
POSIX системах (включая систему GNU). Если и "+" и "b" определен, они
могут применяться в любом порядке. См. раздел 7.14 [Двоичные потоки].
<P>Любые другие символы в opentype просто игнорируются. Они могут быть
значимы в других системах.
<P>Ели происходит ошибка , fopen возвращает пустой указатель.
<P>Вы можете иметь многократные потоки (или описатели файла)
указывающие на тот же самый файл, открытый в то же самое время. Если Вы
только вводите, это работает правильно, но Вы должны быть внимательны
если какой-то поток выходной. См. раздел 8.5 [Предосторожности,
связанные с потоком/описателем].
<P>Это верно в равной степени, в зависимости от того, находятся ли
потоки в одной программе или в отдельных программах (что может легко
случиться). Может оказаться более безопасным использование средств
закрытия файла, для того, чтобы избежать одновременного доступа. См.
раздел 8.11 [Блокировки файла].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int FOPEN_MAX (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - целочисленное постоянное выражение,
которое представляет минимальное число потоков, что могут быть открыты
одновременно. Значение этой константы - по крайней мере восемь, включая
три стандартных потока stdin, stdout, и stderr.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      FILE * freopen (const char *filename, const char * opentype, FILE *stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - подобна комбинации fclose и fopen. Она сначала
закрывает упоминаемый поток, игнорируя любые ошибки, которые обнаружены
в процессе. (Т.к. ошибки игнорируются, Вы не должны использовать freopen
на выходном потоке, если Вы фактически выполнили вывод, используя
поток.) А затем открывает файл filename с режимом opentype как в fopen,
и связывает его с тем же самым потоком.
<P>Если, если операция терпит неудачу, возвращается пустой указатель;
иначе, freopen возвращает поток.
<P>freopen традиционно используется, чтобы соединить стандартный поток
типа stdin с файлом вашего собственного выбора. Это полезно в
программах, в которых использование стандартного потока для некоторых
целей является жестко закодированным. В библиотеке GNU С, Вы можете
просто закрывать стандартные потоки и открывать новые через fopen. Но
другие системы испытывают недостаток этой способности, так что
использование freopen более переносимо.
<P>
<H2><A NAME="ss7.4">7.4 Закрытие потоков</A>
</H2>

<P>
<P>Когда поток закрывается с помощью fclose, соединение между потоком
и файлом отменяется. После того, как Вы закрыли поток, Вы не можете
выполнять какие-нибудь дополнительные операции на нем.
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int fclose (FILE *stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция заркыает поток и прерывает соединение с соответствующим
файлом. Любой буферизированный вывод дописывается, и любой
буферизированный ввод отбрасывается. Функция fclose возвратит значение
0, если файл будет закрыт успешно, и EOF, если будет обнаружена ошибка.
<P>Важно проверить ошибки, когда Вы вызываете fclose, чтобы закрыть
выходной поток, потому что в это время могут быть обнаружены реальные,
каждодневные ошибки. Например, когда fclose допишет остающийся
буферизированный вывод, это мжет вызвать ошибку, потому что диск полон.
Даже если Вы знаете, что буфер пуст, ошибки могут происходить при
закрытии файла, если Вы используете NFS.
<P>Функция fclose объявлена в "stdio.h".
<P>Если ваша программа завершается, или если Вы вызываете функцию
выхода (см. 22.3.1 [Нормальное окончание]), все открытые потоки
автоматически закрываются.
<P>Если ваша программа завершается каким-нибудь другим способом, типа,
вызыва функции аварийного прекращения работы (см. раздел 22.3.4
[Прерывание выполнения программы]) или фатального сигнала (см. Главу 21
[Обработка сигналов]), открытые потоки могут быть закрыты неправильно.
Буферизированный вывод может быть не дописан. Для подробной информации
относительно буферизации потоков, см. раздел 7.17 [Буферизация потока].
<P>
<H2><A NAME="ss7.5">7.5 Простой вывод символами или строками</A>
</H2>

<P>
<P>Этот раздел описывает функции для выполнения символьно- и
строчноориентированного вывода.
<P>Эти функции объявлены в заголовочном файле "stdio.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int fputc ( int C, FILE *stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция fputc преобразовывает символ C, чтобы напечатать char без
знака, и запишет его в поток stream. EOF возвращается, если происходит
ошибка; иначе возвращается символ C.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int putc ( int C, FILE *stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Это аналог fputc, за исключением того, что большинство систем
выполняет ее как макрокоманду, делая это быстрее. Одно из следствий - то,
что она может оценивать аргумент потока больше чем один раз. putc &shy;
обычно лучшая функция, для записи одиночного символа.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int putchar ( int c) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция putchar эквивалентна putc со stdout как значением аргумента
потока.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int fputs (const char * s, FILE *stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция fputs запишет строку s в поток stream. Пустой символ
завершения не пишется. Эта функция так же не добавляет символ перевода
строки.
<P>Эта функция возвращает EOF, если происходит оибк записи, а иначе
неотрицательное значение.
<P>Например:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      fputs ("Are ", stdout);
      fputs ("you ", stdout);
      puts ("hungry?\n", stdout);
</PRE>
</CODE></BLOCKQUOTE>

Выводит текст `Are you hungry?' сопровождаемый символом перевода
строки.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int puts (const char * s) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция запишет строку s в поток stdout сопровождая ее символом
перевода строки. Пустой символ завершения строки не запишет.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      puts - наиболее удобная функция для печати простых сообщений.
</PRE>
</CODE></BLOCKQUOTE>

Например:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      puts ("Это - сообщение.");
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      int putw ( int w, FILE *stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция напишет w (int) в поток stream. Она предусматривает
совместимость с SVID, но мы рекомендуем, чтобы Вы использовали fwrite
взамен (см. раздел 7.12 [Блочный ввод-вывод]).
<P>
<H2><A NAME="ss7.6">7.6 Символьный ввод</A>
</H2>

<P>
<P>Этот раздел описывает функции для выполнения символьно- и
строчноориентированного ввода. Эти функции объявлены в заголовочном
файле "stdio.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int fgetc (FILE * stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция читает следующий символ как char без знака из потока
stream и возвращает значение, преобразованное в int. Если происходит
условие конца файла или ошибка чтения, возвращается EOF.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int getc (FILE * stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Это - аналог fgetc, за исключением того, что для нее допустимо (и
типично) выполнение как макрокоманды, которая оценивает аргумент stream
больше чем один раз. getc часто сильно оптимизирована, так что это &shy;
обычно лучшая функция, чтобы читать одиночный символ.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int getchar (void) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция getchar эквивалентна getc с stdin вместо аргумента stream.
<P>Вот пример функции, которая вводит используя fgetc. Она работала
бы, точно также используя getc взамен, или используя getchar () вместо
fgetc (stdin).
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int y_or_n_p (const char *question)
      {
       fputs (question, stdout);
       while (1)
       {
        int c, answer; /* Напишем пробел, чтобы отделить ответ от вопроса. */
        fputc (" ", stdout);
      /* Читаем первый символ строки. Это должен быть символ ответа, но
 может и не быть. */
        c = tolower (fgetc (stdin));
        answer = c /* Отбрасываем остальную входную строку. */
        while (c != '\n') c = fgetc (stdin);
      /* Примем ответ, если он был допустим. */
        if (answer == 'y') return 1;
        if (answer == 'n') return 0;
      /* Ответ был недопустим: просим о допустимом ответе. */
        fputs ("Please answer y or n:", stdout);
       }
      }
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      int getw (FILE * stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция читает word (то есть int) из stream. Она
предусматривает совместимость с SVID. Мы рекомендуем, чтобы Вы
использовали вместо этого fread (см. раздел 7.12 [Блочный ввод-вывод]) .
<P>
<H2><A NAME="ss7.7">7.7 Строчно ориетированный ввод</A>
</H2>

<P>
<P>Так как много программ интерпретируют ввод на основе строк, удобно
иметь функции, чтобы читать строку из stream.
<P>Стандартный C имеет функции, чтобы делать это, но они не очень
безопасны: пустые символы и даже длинные строки могут сбивать их.
Библиотека GNU обеспечивает нестандартную функцию getline, которая
позволяет читать строки надежно.
<P>Другое расширение GNU, getdelim, обобщает getline. Она читает
разграниченную запись, определенную как все после следующего вхождения
заданного символа-разделителя.
<P>Все эти функции объявлены в "stdio.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t getline (char ** lineptr, size _t * n, FILE * stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция читает всю строку из stream, сохраняя текст (включая
символ перевода строки и пустой символ завершения) в буфере и хранит
буферный адрес в * lineptr.
<P>Перед вызовом getline, Вы должны поместить в *lineptr адрес буфера
*n байт длиной, размещенный malloc. Если этот буфер достаточно большой
чтобы вместить строку, getline, сохранит строку в этом буфере. Иначе,
getline делает больший буфер используя realloc, сохраняя новый буферный
адрес обратно в *lineptr и увеличенный size обратно в *n. См. раздел 3.3
[Беспрепятственное резервирование].
<P>Если Вы устанавливаете *lineptr как пустой указатель, и обнуляете
*n, перед обращением, то getline, зарезервирует начальный буфер для Вас,
вызывая malloc.
<P>В любом случае, когда getline завершается, *lineptr - это char *
который указывает на текст строки.
<P>Когда getline успешно завершвется, она возвращает число прочитанных
символов (включая символ перевода строки, но не, включая пустой символ
завершения). Это значение дает возможность Вам отличить пустые символы,
которые являются частью строки от пустого символа, вставленного как
признак конца.
<P>Эта функция - расширение GNU, но это - рекомендуемый способ читать
строки из stream. Альтернативные стандартные функции ненадежны.
<P>Если происходитошибка происходит или достигнут конец файла, getline
возвращает -1.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t getdelim (char ** lineptr, size _t * n, int delimiter, FILE * stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - подобна getline за исключением того, что символ,
который сообщает, чтобы она прекратила читать - не обязательно символ
перевода строки. Аргумент delimiter определяет символ - разделитель;
getdelim будет читать, пока не увидит этот символ (или конец файла).
<P>Текст сохраняется в lineptr, включая символ - разделитель и пустой
символ завершения. Подобно getline, getdelim делает lineptr большим,
если он не достаточно большой.
<P>getline фактически реализована в терминах getdelim, как показано
ниже:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t getline (char **lineptr, size_t *n, FILE *stream)
      {
       return getdelim (lineptr, n, '\n', stream);
      }

      сhar * fgets (char * s, int count, FILE * stream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция fgets читает символы из потока stream включая символ
перевода строки и сохраняет их в строке s, добавляя пустой символ, чтобы
отметить конец строки. Вы должны обеспечить место для count символов в
s, но читается count - 1 символов. Дополнительное символьное место
используется, чтобы содержать пустой символ в конце строки.
<P>Если, система уже в конце файла, когда Вы вызываете fgets, то
содержимое массива s, неизменяется, и возвращается пустой указатель.
Пустой указатель также возвращается, если происходит ошибка чтения,
возвращаемое значение - указатель s.
<P>Предупреждение: если входные данные имеют пустой символ, Вы не
может использовать fgets. Так что не используйте fgets, если Вы не
знаете, что данные не могут содержать пустой символ. Не используйте ее,
чтобы читать файлы, отредактированные пользователем, потому что, если
пользователь вставляет пустой символ, Вы должны обработать это правильно
или напечатать сообщение об ошибках. Мы рекомендуем использовать getline
вместо fgets.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      сhar * gets (char * s) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция читает символы из потока stdin до следующего символа
символа перевода строки, и сохраняет их в строке s. Символ перевода
строки отбрасывается (обратите внимание, что это отличает ее от
поведения fgets, которая копирует символ перевода строки в строку). Если
она сталкивается с ошибкой чтения или концом файла, она возвращает
пустой указатель; иначе она возвращает s.
<P>Предупреждение: эта функция очень опасна, потому что она не
обеспечивает никакой защиты против переполнения строки s. Библиотека GNU
включает ее только для совместимости. Вы должны всегда использовать
fgets или getline взамен. Чтобы напомнить Вам это, компоновщик (при
использовании GNU ld) выдаст предупреждение всякий раз, когда Вы
используете gets.
<P>
<H2><A NAME="ss7.8">7.8 Обратное чтение</A>
</H2>

<P>
<P>В программах синтаксического анализатора часто полезно исследовать
следующий символ во входном потокек без того, чтобы удалить его из
потока. Это называется "заглядывание вперед" при вводе, потому что ваша
программа бросает взгляд на то что она затем будет читать.
<P>При использовании потока ввода - вывода, Вы можете заглядывать
вперед при вводе первым чтением и затем обратным чтением (так называемм
выталкиванием обратно в поток). Обратное чтение делает символ доступным
для следующего обращения к fgetc или другой входной функции на этом
потоке.
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Что такое способ обратного чтения</H3>

<P>
<P>Это иллюстрированное объяснение обратного чтения. Предположим, что
Вы имеете поток, читая файл, который содержит только шесть символов,
символы "foobar". Предположите, что Вы пока прочитали три символа.
Ситуация выглядит следующим образом:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      f o o b а r
           ^
</PRE>
</CODE></BLOCKQUOTE>
 так что следующий входной символ будет "b".
<P>Если вместо того, чтобы читать "b" Вы выполняете обратное чтение
символа "o", Вы получаете примерно такую ситуацию:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      f o o b а r
           |
      o&shy;
      ^
</PRE>
</CODE></BLOCKQUOTE>
 так, что следующие входные символы будут "o" и "b".
<P>Если Вы обратно читаете "9" вместо "o", Вы получите это:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      f o o b а r
           |

      9&shy;
      ^
</PRE>
</CODE></BLOCKQUOTE>
 так, что следующие входные символы будут "9" и "b".
<P>
<H3>Использование ungetc для осуществления обратного чтения</H3>

<P>
<P>Функция для чтения символа обратно называется ungetc, потому что
она обращает действие getc.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int ungetc ( int C, FILE *sream) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция ungetc помещает символ C обратно во входной поток. Так что
следующий ввод из потока будет читать C прежде, чем что-нибудь еще.
<P>Если С - EOF, ungetc не делает ничего и только возвращает EOF. Это
позволяет Вам вызывть ungetc с возвращаемым значением getc без проверки
ошибки из getc.
<P>Символ, который Вы помещаете обратно, не обязательно тот который
фактически читался из потока. Т. е. читать какой-нибудь символ из потока
перед его обратным чтением не обязательно! Но это - странный способ
писать программу; обычно ungetc используется только, чтобы читить
обратно символ, который только что читался из того же самого потока.
<P>Библиотека GNU С поддерживает только один символ pushback другими
словами, нельзя вызвать ungetc дважды без ввода между вызовами. Другие
системы могут позволять Вам, помещать обратно много символов; тогда
чтение из потока восстанавливает символы в обратном порядке, от того как
они были помещены.
<P>Выталкивание обратных символов не изменяет файл; и воздействует
только на внутреннюю буферизацию потока. Если вызывается позиционирующая
файл функция (типа fseek или rewind; см. раздел 7.15 [Позиционирование
файла]), все отложенные помещаемые-обратно символы отбрасываются.
<P>Обратное чтение символа в поток, который находится в конце файла,
стирает индикатор конца файла для потока. После того, как Вы читаете тот
символ, пробуя читать снова Вы столкнетесь с концом файла.
<P>Вот пример, показывающий использование getc и ungetc, чтобы
перескочить символы промежутков. Когда эта функция достигает символа
не-промежутка, она читает обратно этот символ, и он будет замечен снова
на следующей операции чтения из потока.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;stdio.h&gt;
      #include &lt;ctype.h&gt;

      void skip_whitespace (FILE * stream)
      {
       int с;
       do
      /* Нет нужды проверять EOF, потому что это - не isspace, а ungetc
 игнорирует EOF. */
        c = getc (stream);
       while (isspace (c));
       ungetc (c, stream);
      }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss7.9">7.9 Форматированный вывод</A>
</H2>

<P>
<P>Функции, описанные в этом разделе (printf и др.) обеспечивают,
удобный способ выполнять форматированный вывод. Вы вызываете printf со
строкой формата или строкой шаблона, которая определяет, как
форматировать значения остающихся аргументов.
<P>Если ваша программа не фильтр, который специально выполняет
строчно- или символьно- ориентированную обработку, использование printf,
или одной из других зависимых функций, описанных в этом разделе - обычно
самый простой и наиболее краткий способ выполнить вывод. Эти функции
особенно полезны для печати сообщений ошибок, таблицы данных, и т.п..
<P>
<H3>Основы форматированного вывода</H3>

<P>
<P>Функция printf может использоваться, чтобы печатать любое число
аргументов. Аргумент строки шаблона, который Вы обеспечиваете в
обращении, обеспечивает информацию не только относительно числа
дополнительных аргументов, но также относительно их типов и какой стиль
должен использоваться для печати.
<P>Обычные символы в строке шаблона просто записываются в выходной
поток как есть, в то время как спецификации преобразования,
представленные символом `%' в шаблоне заставляют последующие аргументы
форматироваться при записи в выходной поток. Например:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int pct = 37;
      char filename[] = "foo.txt";
      printf ("Processing of `%s' is %d%% finished.\nPlease be
 patient.\n", filename, pct);
</PRE>
</CODE></BLOCKQUOTE>

Производит вывод:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      Processing of `foo.txt' is 37% finished. Please be patient.
</PRE>
</CODE></BLOCKQUOTE>

Этот пример показывает использование "%d" преобразования, чтобы
определить, что int аргумент должен быть напечатан в десятичной записи,
"%s" преобразования, чтобы определить печать строкового аргумента, и
"%%" преобразования, чтобы печатать непосредственно символ "%".
<P>Имеются также преобразования для печати целочисленного аргумента
как значения без знака в восьмеричной, десятичной, или шестнадцатеричной
системе счисления ("%o", "%u", или "%x", соответственно); или как
символьного значения ("%c").
<P>Числа с плавающей запятой могут быть напечатаны в нормальной, с
фиксированной запятой записи, используя "%f" преобразование или в
экспоненциальном представлении чисел, используя "%e" преобразование.
"%g" преобразование использует или "%e" или формат "%f", в зависимости
от того что более подходит для заданного числа.
<P>Вы можете управлять форматированием более точно, написав
модификаторы между "%" и символом, который указывает какое
преобразование применить. Они немного изменяют обычное поведение
преобразования. Например, большинство спецификаций преобразования
разрешает Вам определять минимальную ширину поля и флаг, указывающий,
хотите ли Вы чтобы результат выравнивался по правому или по левому краю
поля.
<P>Специфические флаги и модификаторы, которые разрешаются и их
интерпретация, изменяются в зависимости от преобразований. Они все
описаны более подробно в следующих разделах. Не волнуйтесь, если это все
кажется чрезмерно сложным; Вы можете почти всегда получать приемлемый
вывод без использования какого-нибудь из модификаторов вообще.
Модификаторы обычно используются, чтобы делать просмотр вывода в
таблицах.
<P>
<P>
<P>
<H3>Синтаксис преобразования вывода</H3>

<P>
<P>Этот раздел обеспечивает подробности относительно точного
синтаксиса спецификаций преобразования, которые могут появляться в
printf строке шаблона.
<P>Символы в строке шаблона, которые - не часть спецификации
преобразования, печатаются как есть в выходной поток. Последовательности
мультисимволов (см. Главу 18 [Расширенные символы]) разрешены в строке
шаблона.
<P>Спецификации преобразования в строке шаблона имеют общую форму:
<P>% флаги ширины [. точность] тип преобразования
<P>Например, в спецификаторе преобразования "%-10.8ld", "-" является
флагом, "10" определяет ширину поля, точность - "8", символ "l" является
модификатором типа, и "d" определяет стиль преобразования. (Этот
специфический спецификатор типа говорит, что печатается long int
аргумент в десятичной записи, с минимумом 8 цифр, выровненных по левому
краю в поле по крайней мере шириной 10 символов.)
<P>Более подробно, спецификации преобразования вывода состоят из
начального символа `%', сопровождаемого последовательностью:
<UL>
<LI>       Нуль или большее количество символов флага, которые изменяют
нормальное поведение спецификации преобразования.
</LI>
<LI>       Десятичное целое число, определяющее минимальную ширину поля.
Если нормальное преобразование производит меньшее количество символов
чем этот, поле, дополняется пробелами до заданной ширины. Это &shy;
минимальное значение; если нормальное преобразование производит большее
количество символов чем этот, поле не усечено. Обычно, вывод выравнен по
правому краю внутри поля.

Вы можете также определять ширину поля "*". Это означает что
следующий аргумент в списке параметров (до фактического значения,
которое будет напечатано) используется как ширина поля. Значение должно
быть int. Если значение является отрицательным, это означает, установить
"-" флаг (см. ниже) и использовать абсолютное значение как ширину поля.
</LI>
<LI>       Точность, чтобы определить число цифр, которые нужно написать для
числовых преобразований. Если точность определена, она состоит из точки
(".") сопровождаемой необязательно десятичным целым числом (если оно
опущено - значение округляется).</LI>
</UL>

Вы можете также определять точность "*". Это означает что следующий
аргумент в списке параметров (до фактического значения, которое будет
напечатано) используется как точность. Значение должно быть int и
игнорируется, если оно отрицательное. Если Вы определяете "*" и для
ширины и для точности, то аргумент ширны предшествует аргументу
точности. Другие С библиотеки могут не распознавать такой синтаксис.
<P>
<H3>Таблица  форматов  вывода  Эта  таблица содержит различные       форматы вывода:</H3>

<P>
<DL>
<DT><B>'%d', '%i': </B><DD><P>Вывод целого числа как десятичного числа со знаком. См.
Раздел 7.9.4  [Целочисленные Форматы].
<P>'%d' и '%i' являются
синонимами для printf, но отличаются при использовании scanf
для ввода (см. Раздел 7.11.3 [Таблица форматов ввода]).
<DT><B>'%o': </B><DD><P>
<P>Печатает  целое  число  как восьмеричное число без знака.
См. Раздел 7.9.4 [Целочисленные форматы].
<DT><B>'%u': </B><DD><P>
<P>Печатает целое число как десятичное число без знака. См.
Раздел 7.9.4 [Целочисленные форматы].
<DT><B>'%Z': </B><DD><P>
<P>Печатает  целое число как десятичное число без знака,
принимая как   тип   size_t.  Детали  см.  в  Разделе  7.9.4
[Целочисленные Форматы].  Этот формат  является  расширением
GNU.
<DT><B>'%x', '%X': </B><DD><P>Печатают целое число как шестнадцатеричное без знака. '%x'
использует символы   нижнего  регистра  а  '%X'  -  верхнего
регистра. См. Раздел 7.9.4 [Целочисленные форматы].
<DT><B>'%f': </B><DD><P>
<P>Печатает число с плавающей  запятой  в  нормальной  записи
(с фиксированной  запятой).  См.  подробности  в Разделе
7.9.5 [Форматы с плавающей запятой].
<DT><B>'%e', '%E': </B><DD><P>Печатают  число  с плавающей запятой в экспоненциальном
представлении чисел.   '%e'   использует   символы   нижнего
регистра, а '%E' - верхнего регистра.
<DT><B>'%g', '%G': </B><DD><P>Выводят число с плавающей запятой либо в нормальном, либо
в экспоненциальном представлении.  '%g'  использует  символы
нижнего регистра, а '%G' - верхнего регистра.
<DT><B>'%c': </B><DD><P>
<P>Печатает одиночный символ. См. Раздел 7.9.6 [Другие
форматы Вывода].
<DT><B>'%s': </B><DD><P>
<P>Печатает строку. См. Раздел 7.9.6 [Другие форматы Вывода].
<DT><B>'%p': </B><DD><P>
<P>Выводит значение указателя. См. Раздел 7.9.6 [Другие форматы
Вывода].
<DT><B>'%n': </B><DD><P>
<P>Содержит число уже напечатанных символов. См. Раздел 7.9.6
[Другие Форматы  Вывода].   Обратите   внимание,   что   эта
спецификация формата никогда не производит никакого вывода.
<DT><B>'%m': </B><DD><P>
<P>Печатает строку, соответствующую значению errno. (Этот формат
формат является  расширением GNU.) См.  Раздел 7.9.6 [Другие
Форматы Вывода].
<DT><B>'%%': </B><DD><P>
<P>Печатает символ `%'. См. Раздел 7.9.6 [Другие Форматы Вывода].
</DL>
<P>Если синтаксис спецификации формата вывода является  недопустимым,
то результат непредсказуем. Если не достаточно аргументов функции, чтобы
обеспечить  значения  для  всех  спецификаций  преобразования  в  строке
шаблона,    или    если   аргументы   неправильных   типов,   результаты
непредсказуемы.  Если Вы обеспечиваете большее количество аргументов чем
используется  в спецификации формата,  дополнительные аргументы,  просто
игнорируются; это иногда полезно.
<P>
<H3>Целочисленные Форматы </H3>

<P>
<P>Этот  раздел  описывает  опции  для
'%d', '%i', '%o', '%u', '%x',
'%X', и '%Z' спецификаций преобразования. Эти преобразования печата&shy;
ют целых  числа  в  различных  форматах.  Форматы  '%d'  и '%i' печатают
целочисленный аргумент как деся&shy;
тичное число  со  знаком;  в  то время как '%o',  '%u',  и '%x' печатают
аргумент как восьмеричное,  десятичное,  или шестнадцатеричное без знака
соответственно.  Формат  '%X'  -  точно  то же что и '%x' за исключением
того,  что она  использует  символы  'ABCDEF'  в  качестве  цифр  вместо
'abcdef'. '%Z' подобна '%u' но принимает аргумент типа size_t.
<P>Имеют значение следующие флаги:
<DL>
<DT><B>'-' </B><DD><P>Выравнивание  слева  результата  в поле вывода (вместо нор&shy;
мального выравнивания справа).
<P>
<DT><B>'+' </B><DD><P>Для знаковых форматов '%d' и '%i', печатает знак '+', если
значение положительно.
<DT><B>' ' </B><DD><P>Для знаковых форматов '%d' и '%i',  если результат не начи&shy;
нается со знака '+' или знака '-',  то ставит перед ним пробел.
'*'  Для  формата  '%o'  ставит  '0' первой цифрой,  как будто,
увеличивая точность.  Не делает ничего полезного  для  форматов
'%d',  '%i',  или  '%u'.  Использование  этого флага производит
вывод,  который может анализироваться  функциями  strtoul  (см.
Раздел  14.7.1  [Синтаксический  анализ Целых чисел]) и scanf с
форматом '%i' (см. Раздел 7.11.4 [Числовые форматы ввода]).
<DT><B>'0' </B><DD><P>Дополняют поле нулями вместо пробелов. Нули помещаются пос&shy;
ле какой-нибудь  индикации  относительно   знака.   Этот   флаг
игнорируется, если указан флаг '-' , или если указана точность.
</DL>
       Если указана точность,  она определяет минимальное число  цифр;  в
случае  необходимости выводятся дополнительные нули вначале.  Если Вы не
указываете точность,  печатается столько цифр числа,  сколько требуется.
Если  Вы  преобразовываете  значение нуля с явной нулевой точностью,  то
никакие символы не выводятся вообще.
<P>
<P>Без модификатора типа, соответствующий аргумент обрабатывается как
int (для знаковых преобразований '%i' и '%d') или  int  без  знака  (для
преобразований без знака '%o',  '%u', '%x', и '%X'). Заметьте, что т. к.
printf и ее производные  функции,  любой  аргумент  типа  char  и  short
автоматически приводится к типу int аргументами, заданными по умолчанию.
Для  аргументов  других  целочисленных  типов,  Вы  можете  использовать
следующие модификаторы:
<DL>
<DT><B>' H ' </B><DD><P>Определяет, что аргумент - short int или short unsigned int.
<DT><B>' l ' </B><DD><P>Определяет, что аргумент - long int или long unsigned int
<DT><B>' L ' </B><DD><P>Определяет,  что аргумент - long long int. (Этот тип яв&shy;
ляется расширением,  обеспечиваемым  компилятором GNU С.  На
системах,  которые не поддерживают сверхдлинные целые числа,
это - тоже что long int.)
</DL>
       Модификаторы для типа аргумента  не  применимы  к  '%Z',  так  как
единственной целью '%Z' является указать тип данных size_t.
<P>Вот пример использования строки шаблона:
<BLOCKQUOTE><CODE>
<PRE>
        '| %5d| %-5d| %+5d| %+-5d| %5d| %05d| %5.0d| %5.2d| %d|\n '
</PRE>
</CODE></BLOCKQUOTE>
 для печати числа, используя различные опции для преобразования '%d':
<BLOCKQUOTE><CODE>
<PRE>
       | 0    | 0    | + 0    | + 0  | 0    | 00000|      |  00  |  0 |
       | 1    | 1    | + 1    | + 1  | 1    | 00001| 1    |  01  |  1 |
       | -1   | -1   | -1     | -1   | -1   | -0001| -1   | -01  | -1 |
       |100000|100000|+ 100000|100000|100000|100000|100000|100000|...
</PRE>
</CODE></BLOCKQUOTE>
       В частности  обратите  внимание на то,  что получается в последнем
случае,  где аргумент слишком большой,  чтобы поместиться в  минимальной
заданной ширине поля.
<P>Вот еще   несколько   примеров,   показывающих,   как    выводятся
беззнаковые  целые  под  различными  опциями  формата,  используя строку
шаблона:
<BLOCKQUOTE><CODE>
<PRE>
      '| %5u | %5o | %5x | %5X | %*5o | %*5x | %*5X | %*10.8x | \n'
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
  |    0 |    0 |   0 |   0 |     0 |   0x0 |   0X0 |0x00000000|
  |    1 |    1 |   1 |   1 |    01 |   0x1 |   0X1 |0x00000001|
  |100000|303240|186a0|186A0|0303240|0x186a0|0X186A0|0x000186a0|
</PRE>
</CODE></BLOCKQUOTE>
<H3>Преобразования с плавающей запятой</H3>

<P>Этот раздел содержит спецификации форматов вывода чисел с плаваю&shy;
щей запятой:  '%f', '%e', '%E', '%g', и '%G'. Формат '%f' печатает ар&shy;
гумент в формате с фиксированной запятой,  выводя его на экран в  виде
[-]  ddd.ddd,  где число цифр после десятичной точки определяется точ&shy;
ностью, которую Вы указали.
<P>
<P>Формат '%e' печатает аргумент  в  экспоненциальном  представлении,
выводя  его  на  экран  в  виде [-] d.ddde [+ | -] dd.  Число цифр после
десятичной  точки  также  определяется  точностью.   Экспонента   всегда
содержит  по  крайней  мере  две  цифры.  На этот формат похож '%E',  но
экспонента отмечена символом ' E ' вместо ' e '.
<P>
<P>Форматы '%g'  и  '%G'  печатают  аргумент  в  стиле  '%e'  и  '%E'
соответственно,  если экспонента меньше чем -4  или  больше  либо  равна
точности; в противном случае они используют стиль формата '%f'. Конечные
нули из дробной части результата удаляются,  а символ  десятичной  точки
появляется только, если он сопровождается цифрой.
<P>Чтобы изменить  поведение  функции,  могут  применяться   следующие
флаги:
<DL>
<DT><B>'-' </B><DD><P>Выравнивание слева результата в поле вывода. Обычно результат
выравнивается справа.
<P>
<DT><B>'+' </B><DD><P>Всегда выводится знак 'плюс' или 'минус'.
<P>
<DT><B>' ' </B><DD><P>Если результат не начинается со знака 'плюс' или 'минус',
ставит перед ним пробел.
<P>
<DT><B>'#' </B><DD><P>Определяет, что результат должен всегда включать
десятичную точку,  даже если за ней не следует никаких  цифр.  Для
форматов  '%g'  и  '%G',  конечные  нули  после  десятичной  точки
удаляться не будут.
<DT><B>'0' </B><DD><P>Дополняет поле нулями вместо пробелов; нули помещаются после знака.
<P>Этот флаг игнорируется, если указан флаг '-'.
<P>
<P>Точность определяет,  сколько цифр следуют за символом  десятичной
точки для форматов '%f','%e',  и '%E'.  Точность,  заданная по умолчанию
для этих форматов - 6.  Если она явно задана как 0, то символ десятичной
точки подавляется. Для форматов '%g' и '%G', точность определяет сколько
значащих цифр печатать. Значащие цифры это первая цифра перед десятичной
точкой,  и все цифры после нее.  Если для '%g' или '%G' точность - 0 или
не задана,  то она обрабатывается как если бы была 1.  Если напечатанное
значение  не  может  быть  выражено точно заданным количеством цифр,  то
значение округляется до ближайшего подходящего значения.
<P>Без модификатора   типа,  форматы  с  плавающей  запятой  используют
аргумент  двойного  типа.  (По  умолчанию  любой  аргумент  типа   float
автоматически   преобразуется   в   double.)   Поддерживаются  следующие
модификаторы типов:
<P>
<DT><B>'L'   Определяет, что аргумент типа long double.  Вот несколько примеров </B><DD><P>как при выводе используются различные форматы чисел с плавающей запятой.
Все числа были напечатаны, используя следующий шаблон строки:
<BLOCKQUOTE><CODE>
<PRE>
      '|%12.4f|%12.4e|%12.4g|\n'

      |      0.0000|  0.0000e+00|           0|
      |      1.0000|  1.0000e+00|           1|
      |     -1.0000| -1.0000e+00|          -1|
      |    100.0000|  1.0000e+02|         100|
      |   1000.0000|  1.0000e+03|        1000|
      |  10000.0000|  1.0000e+04|       1e+04|
      |  12345.0000|  1.2345e+04|   1.234e+04|
      | 100000.0000|  1.0000e+05|       1e+05|
      | 123456.0000|  1.2346e+05|   1.234e+05|
</PRE>
</CODE></BLOCKQUOTE>

Обратите внимание как формат '%g' выводит конечные нули.
</DL>
<H3>Другие  Форматы  Вывода </H3>

<P>
<P>Этот  раздел  описывает различные
форматы, используемые printf.
<P>Формат '%c' печатает  одиночный  символ.  Аргумент  типа  int  сначала
преобразовывается  в  unsigned  char.  Может использоваться флаг '-' для
задания выравнивания слева в поле вывода,  но точность  или  модификатор
типа не могут быть определены. Например:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       printf ('%c%c%c%c%c', 'h', 'e', 'l', 'l', 'o');
</PRE>
</CODE></BLOCKQUOTE>
 выводит
<BLOCKQUOTE><CODE>
<PRE>
        `hello'.
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        printf ('%3s%-6s', 'no', 'where');
</PRE>
</CODE></BLOCKQUOTE>
 выводит
<BLOCKQUOTE><CODE>
<PRE>
        `nowhere'.
</PRE>
</CODE></BLOCKQUOTE>
<P>Если Вы  случайно  передаете в качестве аргумента для формата '%s'
пустой указатель преобразования,  библиотека GNU  выведет  '(null)'.  Мы
думаем, что это более полезно чем сообщение об ошибке.
<P>
<BLOCKQUOTE><CODE>
<PRE>
     fprintf (stderr,   'can't  open  `%s':  %m\n',  filename);
</PRE>
</CODE></BLOCKQUOTE>
 является эквивалентным:
<BLOCKQUOTE><CODE>
<PRE>
     fprintf (stderr,   'can't   open  `%s':  %s\n',  filename,  strerror (errno));
</PRE>
</CODE></BLOCKQUOTE>

Формат '%m' - расширение библиотеки GNU С.
<P>
<P>Формат '%p' печатает значение указателя.  Соответствующий аргумент
должен  иметь тип void*.  Практически,  Вы можете использовать любой тип
указателя.
<P>
<P>В системе   GNU,   непустые   указатели  печатаются  как  integers
unsigned,  как  при  использовании  формата  '%#x'.   Пустые   указатели
печатаются  как  '(nil)'.  (В других системах указатели могут печататься
по-другому.)
<P>
<P>Например:
<BLOCKQUOTE><CODE>
<PRE>
              printf ('%p',   'testing');
</PRE>
</CODE></BLOCKQUOTE>
 печатает  '0x'  сопровождаемый шестнадцатеричным числом адреса строковой
константы 'testing'.
<P>
<P>Вы можете  добавить  флаг  '-'  к  формату '%p',  чтобы обеспечить
выравнивание слева,  но не должны  определяться  никакие  другие  флаги,
точность, или модификаторы типа.
<P>
<P>Формат '%n'  -  отличается  от  всех  других  форматов вывода.  Он
использует аргумент,  который должен быть указателем на int,  но  вместо
того,  чтобы  печатать  что-нибудь,  он  содержит число уже напечатанных
символов.  Модификаторы типа 'h' и 'l' задают,  что указывается аргумент
типа short int* или long int * вместо int *, но не позволяется указывать
никакие флаги, ширину поля, или точность.
<P>Например,
<BLOCKQUOTE><CODE>
<PRE>
   int nchar; printf ('%d %s%n\n', 3, 'bears', &amp;nchar);
</PRE>
</CODE></BLOCKQUOTE>
 печатает:
<BLOCKQUOTE><CODE>
<PRE>
          3 bears
</PRE>
</CODE></BLOCKQUOTE>
 и устанавливает nchar в значение 7,  потому что  строка '3 bears'
содержит семь символов.
<P>
<P>Формат '%%'  выводит  символ  `%'.  Этот  формат не использует
аргумент.
<P>
<H3>Функции Форматированного Вывода</H3>

<P>Этот раздел описывает, как вызвать printf и относящиеся к ней
функции. Прототипы  для  этих  функций  находятся  в   файле
'stdio.h'.  Т.  к. эти функции принимают переменное число аргументов, Вы
должны объявить прототипы для них перед использованием.  Конечно,  самый
простой  способ удостовериться,  что Ваши прототипы все правильные,  это
включить 'stdio.h'.
<DL>
<DT><B>- Функция: int printf (const char *TEMPLATE, ...) </B><DD><P>Функция printf выводит указываемые аргументы под управлением
шаблона строки  TEMPLATE  в   поток   stdout.   Она   возвращает   число
напечатанных символов, или отрицательное значение при ошибке вывода.
<P>
<DT><B>- Функция:  int  fprintf (FILE *stream,  const char *template,  ...) </B><DD><P>Эта функция - аналог printf, за исключением того, что вывод
записывается в указанный поток вместо stdout.
<P>
<DT><B>- Функция:  int sprintf (char *s, const char *template, ...) </B><DD><P>Она подобна printf, за исключением того, что вывод сохраняется в
символьном массиве s вместо записи в поток. Пустой символ записывается в
конец строки.
<P>
<P>Функция sprintf возвращает число символов,  содержащихся в массиве
s, исключая пустой символ завершения.
<P>
<P>Поведение этой  функции неопределено,  если копирование происходит
между  пересекающимися  объектами.  Например,  если  s  также   является
аргументом,  который выводится под управлением формата '%s'.  См. Раздел
5.4 [Копирование и Конкатенация].
<P>
<P>Предупреждение: функция sprintf может быть опасна, т. к. она может
потенциально  выводить   большее   количество   символов   чем   размер,
зарезервированный для строки s. Не забудьте, что ширина поля, заданная в
спецификации формата - только минимальное значение.
<P>
<P>Чтобы избежать этой проблемы,  Вы можете использовать snprintf или
asprintf, описанные ниже.
<P>
<DT><B>- Функция: int snprintf (char *s, size_t size, const char *TEMPLATE, ...) </B><DD><P>Функция snprintf подобна sprintf, за исключением того, что
аргумент размера  определяет  максимальное  число  выводимых   символов.
Конечный пустой символ подпадает под это ограничение
<P>
<P>Возвращаемое значение - число  сохраненных  символов,  не  включая
пустой  символ  завершения.  Если это значение равняется size-1,  то в s
недостаточно места для всего вывода. Вы должны пробовать снова с большей
строкой вывода. Вот пример такого кода:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
           /* Выдаем сообщение, описывающее значение переменной
              с именем  NAME  и  значением  VALUE  */ char * make_message
           (char *name, char *value) {
             /* Предположим, что нам понадобится не больше чем 100
                символов. */ int size = 100;  char  *buffer  =  (char  *)
             xmalloc (size);

           while (1) {
                 /* Попытаемся напечатать в отведенном пространстве. */
                 int nchars  =  snprintf (buffer,  size,  'value of %s is
                                        %s', name, value);
                 /* If that worked, return the string. */
                 if (nchars &lt; size) return buffer;
                 /* Иначе попытаемся еще раз с удвоенным количеством
                    символов */ size *= 2;  buffer =  (char  *)  xrealloc
                 (size, buffer);
               }
           }
</PRE>
</CODE></BLOCKQUOTE>
</DL>
<P>На деле, часто проще использовать asprintf, см. ниже.
<P>
<H3>Форматируемый Вывод,  Размещаемый  Динамически</H3>

<P>
<P>Функции  в этом разделе форматируют вывод и помещают результаты в
динамически размещенную память.
<DL>
<DT><B>- Функция :  int asprintf (char **ptr,  const char *template, ...) </B><DD><P>Эта функция похожа на sprintf, за исключением того, что она
динамически распределяет строку для вывода (как malloc;  см.  Раздел 3.3
[Беспрепятственное Резервирование],  вместо того, чтобы помещать вывод в
буфер,  определяемый  заранее.  Аргумент ptr должен быть адресом объекта
char*, и asprintf сохраняет в нем указатель на размещенную строку.
<P>
<BLOCKQUOTE><CODE>
<PRE>
   char * make_message (char *name, char *value) {
     char *result;  asprintf (&amp;result, 'value of %s is %s', name,
     value); return result;
   }
</PRE>
</CODE></BLOCKQUOTE>
<DT><B>-Функция: int   obstack_printf(struct   obstack*   obstack,const   char* </B><DD><P>template,...)
<P>
<P>Эта функция подобна asprintf, за исключением того, что она
использует obstack, чтобы  зарезервировать пространство в памяти.
См. Раздел 3.4 [Obstack].
</DL>

Символы дописываются  в  конец  текущего объекта.  Чтобы добраться до
них,  Вы должны закончить объект  функцией  obstack_finish  (см.  Раздел
3.4.6 [Возрастастающие Объекты]).
<P>
<H3>Переменные  Аргументы  Функций  Вывода</H3>

<P>Функции  vprintf и подобные позволяют Вам определять ваши
собственные различные printf-подобные функции,  которые используют ту же
самую внутреннюю организацию  как  и  встроенные  форматирующие  функции
вывода.
<P>
<P>Наиболее естественный  способ  определять  такие функции состоит в
том,  чтобы использовать конструкцию типа 'Вызвать printf и передать ему
этот шаблон плюс все мои аргументы пропуская первые пять.' Но не имеется
никакого способа сделать это на C,  и было бы трудно это сделать, потому
что  на  уровне  Языка  C  не  имеется  никакого способа указать сколько
аргументов получает ваша функция.
<P>
<P>Так как тот метод невозможен, мы поставляем дополнительные функции
типа vprintf,  которые позволяет Вам передавать va_list,  чтобы  описать
'все мои аргументы после первых пяти.'
<P>
<P>Перед вызовом vprintf или других  функций,  перечисленных  в  этом
разделе, Вы должны вызвать va_start (см. Раздел A. 2 [Variadic Функции])
чтобы установить указатель  на  переменные  аргументы.  После  этого  Вы
можете  вызывать  va_arg,  чтобы  выбрать  аргументы,  которые Вы хотели
обработать.
<P>
<P>Если ваш  vуказатель  a_list указывает на аргументы вашего выбора,
Вы можете вызвать vprintf.  Этот аргумент и все  последующие  аргументы,
которые  были  переданы  вашей  функции,  используются  vprintf наряду с
шаблоном, который Вы определили отдельно.
<P>
<P>В некоторых   других   системах,  указатель  va_list  может  стать
недопустимым  после  обращения  к  vprintf,  так  что   Вы   не   должны
использовать va_arg после того,  как Вы вызываете vprintf. Вместо этого,
Вы должны вызвать va_end,  чтобы отменить  указатель.  Затем  Вы  можете
безопасно  вызывать  va_start для другой переменной указателя и начинать
выбирать  аргументы  снова  через  этот  указатель.  Вызов  vprintf   не
разрушает список параметров вашей функции.
<P>GNU C не имеет таких ограничений.  Вы можете  продолжать  выбирать
аргументы из списка va_list после выполнения через vprintf, тогда va_end
- пустая команда.  (Примечание,  последующие обращения va_arg выберут те
же самые аргументы, как и те, что предварительно использованы vprintf.)
<P>
<P>Прототипы для этих функций объявлены в 'stdio.h'.
<DL>
<DT><B>- Функция:  int  vprintf (const char *template,  va_list ap) </B><DD><P>
<P>Эта функция подобна printf за исключением того,  что ей,  вместо
переменной,  содержащей число аргументов,  необходимо передавать
указатель на список параметров.
<P>
<DT><B>- Функция: int vfprintf (FILE *stream, const char *template, va_list ap) </B><DD><P>
<P>Эта функция  -   эквивалент   fprintf   с   переменным   списком
параметров, заданным непосредственно как и для vprintf.
<P>
<DT><B>- Функция:  int vsprintf (char *s, const char *template, va_list ap) </B><DD><P>
<P>Эта функция   -   эквивалент   sprintf   с   переменным  списком
параметров, заданным непосредственно как в vprintf.
<P>
<DT><B>- Функция:  int vsnprintf (char *s,  size_t size,  const char *template, va_list ap) </B><DD><P>Это функция  -  эквивалент   snprintf   с   переменным   списком
параметров, заданным непосредственно как в vprintf.
<P>
<DT><B>- Функция:  int vasprintf (char **ptr, const char *template, va_list ap) </B><DD><P>Функция vasprintf - эквивалент  asprintf  с  переменным  списком
параметров, заданным непосредственно как и для vprintf.
<P>
<DT><B>- Функция:  int obstack_vprintf (struct obstack  *obstack,  const  char* template, va_list ap) </B><DD><P>Функция obstack_vprintf - эквивалент obstack_printf с переменным
списком параметров, заданным непосредственно как для vprintf.
</DL>
<P>Ниже приводится пример, показывающий, как Вы могли бы использовать
vfprintf.  Это - функция,  которая выводит сообщения об ошибках в  поток
stderr,  вместе с префиксом,  указывающим имя программы (см.  Раздел 2.3
[Сообщения об ошибках], описание program_invocation_short_name).
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;stdio.h&gt;
      #include &lt;stdarg.h&gt;

      void
      eprintf (const char *template, ...)
      {
        va_list ap;
        extern char *program_invocation_short_name;

        fprintf (stderr, '%s: ', program_invocation_short_name);
        va_start (ap, count);
        vfprintf (stderr, template, ap);
        va_end (ap);
      }
</PRE>
</CODE></BLOCKQUOTE>
 Вы могли бы  вызывать eprintf например так:
<BLOCKQUOTE><CODE>
<PRE>
      eprintf ('file `%s' does not exist\n', filename);
</PRE>
</CODE></BLOCKQUOTE>
<H3>Синтаксический   разбор   Строки   Шаблона</H3>

<P>
<P>Вы можете использовать  функцию  parse_printf_format,  для  получения
информации  относительно  числа  и  типов аргументов,  которые ожидаются
данной строкой шаблона.  Эта функция  вызывает  интерпретаторы,  которые
обеспечивают  интерфейс  в  printf  во  избежание  передачи недопустимых
аргументов.
<P>
<P>Все символы, описанные в этом разделе объявлены в файле заголовков
'printf.h'.
<DL>
<DT><B>- Функция:  size_t parse_printf_format (const char *template,  size_t n, int* argtypes) </B><DD><P>
<P>
<P>Эта функция  возвращает  информацию  относительно  числа  и  типов
аргументов, ожидаемых printf в строке шаблонов. Информация сохраняется в
массиве argtypes;  каждый элемент этого массива описывает один аргумент.
Эта  информация  предоставляется  в  виде  различных  'PA_' макрокоманд,
которые перечисляются ниже.
<P>
<P>Аргумент n определяет число  элементов  в  массиве  argtypes.  Это
наибольшее   число   элементов,   которые   parse_printf_format  пробует
написать.
<P>Parse_printf_format возвращает  общее число аргументов,  требуемых
шаблоном. Если это число больше n, то возвращаемая информация, описывает
только   первые   n  аргументов.  Если  Вы  хотите  получить  информацию
относительно большего,  чем n,  числа аргументов, зарезервируйте больший
массив и вызовете parse_printf_format снова.
<P>
<P>Типы аргумента закодированы как комбинация базисного типа и  битов
флага модификатора.
<P>
<DT><B>- Макрос:  int  PA_FLAG_MASK </B><DD><P>Эта макрокоманда  - маска для битов флага модификатора типа.  Вы
можете написать выражение (argtypes [i]  &amp;  PA_FLAG_MASK)  чтобы
извлечь  только  биты  флага для аргумента,  или (argtypes [i] &amp;
~PA_FLAG_MASK) чтобы извлечь только базисный код типа.
<P>Имеются символические  константы,  которые  представляют  базисные типы;
они устанавливаются для значений integer.
<BLOCKQUOTE><CODE>
<PRE>
       PA_INT     Определяет, что исходный тип - int.
       PA_CHAR    Определяет, что исходный тип - int, приведеннное к char.
       PA_STRING  Определяет, что исходный тип - char *, строка с нулевым
                  символом в конце.
       PA_POINTER Определяет, что исходный тип - void *, произвольный
                  указатель.
       PA_FLOAT   Определяет,  что  исходный  тип  с  плавающей точкой.
       PA_DOUBLE  Определяет,  что исходный тип - double.
       PA_LAST    Вы можете определять дополнительные исходные типы для ваших
                  собственных программ как смещения из PA_LAST.
</PRE>
</CODE></BLOCKQUOTE>
 Например, если  у  Вас  определены  типы  данных  'foo'  и  'bar'  с  их
собственными специализированными форматами  для  printf,  то  Вы  можете
определять эти типы как:
<BLOCKQUOTE><CODE>
<PRE>
       #define PA_FOO  PA_LAST
       #define PA_BAR  (PA_LAST + 1)
</PRE>
</CODE></BLOCKQUOTE>
       Имеются биты флага,  которые изменяют базисный тип. Они объединены
с кодом для базисного типа, используя операцию или.
<DL>
<DT><B>PA_FLAG_PTR </B><DD><P>Если этот бит устанавливается, это указывает, что закодированный
тип - указатель на исходный тип, а не непосредственное значение.
<P>Например, 'PA_INT | PA_FLAG_PTR' представляет тип `int *'.
<DT><B>PA_FLAG_SHORT </B><DD><P>Если этот бит устанавливается,  это указывает,  что исходный тип
изменяется как short. (Соответствует модификатору типа 'h'.)
<DT><B>PA_FLAG_LONG </B><DD><P>Если этот бит устанавливается,  это указывает,  что исходный тип
изменяется как long. (Соответствует модификатору типа 'l'.)
<DT><B>PA_FLAG_LONG_LONG </B><DD><P>Если этот бит устанавливается,  это указывает,  что исходный тип
изменяется как long long.
<DT><B>PA_FLAG_LONG_DOUBLE </B><DD><P>Это - синоним  для  PA_FLAG_LONG_LONG,  используемого  обычно  с
исходным типом PA_DOUBLE для обозначения типа long double.
</DL>
</DL>
<H3>Пример Синтаксического анализа Строки Шаблона</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      /* Проверка, является ли NARGS, определяющий объекты вектора
         ARGS формату строки FORMAT:
         если да, возвращает 1.
         в противном случае возвращает 0 после вывода сообщения об ошибке */

      int
      validate_args (char *format, int nargs, OBJECT *args)
      {
        int *argtypes;
        int nwanted;

        /* Получить информацию об аргументах.
           Каждый спецификатор формата должен быть длиной по крайней мере
           в два символа, поэтому не может быть спецификаторов длиной
           длиной больше половины длины строки.
        */

        argtypes = (int *) alloca (strlen (format) / 2 * sizeof (int));
        nwanted = parse_printf_format (string, nelts, argtypes);

        /* Проверим количество аргументов  */
        if (nwanted &gt; nargs)
          {
            error ('too few arguments (at least %d required)', nwanted);
            return 0;
          }

        /* Проверим тип, требуемый для каждого аргумента,
           и соответствие ему данного аргумента.  */
        for (i = 0; i &lt; nwanted; i++)
          {
            int wanted;

            if (argtypes[i] &amp; PA_FLAG_PTR)
              wanted = STRUCTURE;
            else
              switch (argtypes[i] &amp; ~PA_FLAG_MASK)
                {
                case PA_INT:
                case PA_FLOAT:
                case PA_DOUBLE:
                  wanted = NUMBER;
                  break;
                case PA_CHAR:
                  wanted = CHAR;
                  break;
                case PA_STRING:
                  wanted = STRING;
                  break;
                case PA_POINTER:
                  wanted = STRUCTURE;
                  break;
                }
            if (TYPE (args[i]) != wanted)
              {
                error ('type mismatch for arg number %d', i);
                return 0;
              }
          }
        return 1;
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss7.10">7.10 Настройка  printf</A>
</H2>

<P>
<P>Библиотека GNU   C   позволяет  Вам  определять  ваши  собственные
спецификаторы преобразования для  строк  шаблона  printf,  т.е.  научить
printf  выводить  важные  структуры данных вашей программы так,  как Вам
этого хочется.
<P>
<P>Это можно сделать,  указав формат преобразования с помощью функции
register_printf_function;  см.  Раздел  7.10.1  [Указание Новых Форматов
Вывода].  Один из  аргументов,  которые  Вы  передаете  этой  функции  &shy;
указатель на функцию обработчика,  которая производит фактический вывод;
за более подробной информацией о написании этой  функции  обращайтесь  к
Разделу 7.10.3 [Определение Обработчика Вывода].
<P>
<P>Вы можете также установить функцию,  которая возвращает информацию
относительно  числа и типа аргументов,  ожидаемых спецификатором формата
преобразования.  См.  Раздел  7.9.10   [Синтаксический   анализ   Строки
Шаблона], для получения дополнительной  информации об этом.
<P>
<P>Средства этого раздела объявлены в  файле 'printf.h'.
<P>
<P>Примечание о Переносимости: возможность изменения синтаксиса
printf строк шаблона - расширение GNU.  Стандарт ANSI C не имеет  ничего
подобного.
<P>
<H3>Указание Новых Форматов Вывода</H3>

<P>
<P>Функция для    регистрирования    новых    преобразований    вывода
register_printf_function,  объявлена  в  `printf.h'.
<DL>
<DT><B>- Функция:  int register_printf_function(int SPEC,printf_function HANDLER_FUNCTION, printf_arginfo_function ARGINFO_FUNCTION) </B><DD><P>
<P>
<P>Эта функция  определяет  символ спецификатора преобразования SPEC.
<P>Так, если SPEC равен 'q', то определяется модификатор '%q'.
<P>HANDLER_FUNCTION -   функция,   вызываемая   printf,   когда   это
модификатор   появляется  в  строке  шаблона.  См.  Раздел  7.10.3
[Определение  Обработчика  Вывода],   для   уточнения   информации
относительно   того,  как  определить  функцию  в  качестве  этого
аргумента.  Если Вы задаете пустой указатель, существующая функция
обработчика для спецификаций удаляется.
<P>Arginfo_function - функция,  вызываемая parse_printf_format, когда
это преобразование появляется в строке шаблона.  См. Раздел 7.9.10
[Синтаксический  анализ Строки Шаблона].  Обычно Вы устанавливаете
обе функции обработки вывода одновременно,  но если Вы никогда  не
обращаетесь к parse_printf_format, Вы не должны определять функцию
arginfo_function.
<P>
<P>Возвращаемое значение - 0 в случае успеха,  и -1 при сбое (который
происходит, если спецификации находятся вне диапазона).
<P>
<P>Вы можете  переопределять  форматы  стандартного вывода,  но это &shy;
возможно не лучшая идея из-за потенциального путаницы. Если Вы это
сделаете,  могут пострадать библиотечные подпрограммы,  написанные
другими людьми.
</DL>
<H3>Ключи Спецификатора Преобразования</H3>

<P>
<P>Если Вы   определяете   какое-либо   значение   для  '%q',то  что
произойдет,  если шаблон содержит '%+23q' или '%-#q'?  Чтобы реализовать
обработку   этого,  обработчик  должен  быть  способен  получить  ключи,
определенные в шаблоне.
<P>
<P>Оба аргумента  функции register_printf_function - HANDLER_FUNCTION
и  ARGINFO_FUNCTION  получает   в   качестве   аргумента   типа   struct
printf_info,    который   содержит   информацию   относительно   ключей,
появляющихся в образце спецификатора формата  вывода.  Этот  тип  данных
объявлен в заглавном файле 'printf.h'.
<DL>
<DT><B>- Тип:  struct  printf_info </B><DD><P>Эта структура  используется  для  передачи  информации   о   ключах,
появляющихся  в  образце  спецификатора  формата  вывода в printf строке
шаблона в  обработчик  и  функции  arginfo  для  их  спецификатора.  Она
содержит следующие элементы:
<DL>
<DT><B>'int prec' </B><DD><P>Эта переменная содержит задаваемую точность. Значение -1, если
никакая точность  не  была  определена.  Если,  точность  была
задана  как '*',  структура printf_info,  переданная в функцию
обработчика,  содержит фактическое значение,  взятое из списка
параметров.   Но   структура,  переданная  в  функция  arginfo
содержит значение INT_MIN,  так как  фактическое  значение  не
известно.
<DT><B>'int width' </B><DD><P>Эта переменная  содержит  задаваемую  минимальную  ширину поля
вывода.  Значение 0,  если ширина не  была  определена.  Если,
ширина  поля  была  задана  как  '*',  структура  printf_info,
переданная  в  функцию   обработчика,   содержит   фактическое
значение,   взятое   из   списка   параметров.  Но  структура,
переданная в функция arginfo содержит  значение  INT_MIN,  так
как фактическое значение не известно.
<DT><B>'сhar spec' </B><DD><P>Эта переменная  содержит заданный символ спецификатора формата
вывода.  Он содержится в структуре для того,  чтобы  Вы  могли
указать  одну  и  ту  же  функцию  обработчика  для  различных
символов,  но при этом  иметь  возможность  их  различать  при
вызове функции обработчика.
<DT><B>'unsigned int is_long_double' </B><DD><P>Это - логическая переменная, которая содержит значение истина,
если модификатор типа 'L' был определен.
<DT><B>'unsigned int is_short' </B><DD><P>Это - логическая переменная, которая содержит значение истина,
если модификатор типа 'h' был определен.
<DT><B>'unsigned int is_long' </B><DD><P>Это - логическая переменная, которая содержит значение истина,
если модификатор типа 'l' был определен.
<DT><B>'unsigned int alt' </B><DD><P>Это - логическая переменная, которая содержит значение истина,
если был определен флаг '#'.
<DT><B>'unsigned int space' </B><DD><P>Это - логическая переменная, которая содержит значение истина,
если был определен флаг ' '.
<DT><B>'unsigned int left' </B><DD><P>Это - логическая переменная, которая содержит значение истина,
если был определен флаг '-'.
<DT><B>'unsigned int showsign' </B><DD><P>Это - логическая переменная, которая содержит значение истина,
если был определен флаг '+'.
<DT><B>'char pad' </B><DD><P>Это -  символ,  использующийся   для   дополнения   вывода   в
минимальную  ширину  поля.  Значение  - '0' если был определен
определен флаг '0' , иначе ' '.
</DL>
</DL>
<H3>Определение Обработчика  Вывода</H3>

<P>
<P>Теперь рассмотрим,  как определить функцию обработчика и  функции
arginfo,  которые передаются как аргументы для register_printf_functi&shy;
on.
<P>Вы должны определить ваши функции обработчика с прототипом следу&shy;
ющим образом:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 int function (FILE *stream,  const  struct  printf_info  *info,  va_list *ap_pointer)
</PRE>
</CODE></BLOCKQUOTE>
<P>Аргумент stream,  переданный  функции  обработчика - это поток,  в
который она должна записать вывод.
<P>
<P>Аргумент info   -   указатель   на   структуру,  которая  содержит
информацию относительно различных ключей, которые были включены в строку
шаблона.  Вы  не  должны  изменять  эту  структуру  внутри вашей функции
обработчика. См. Раздел 7.10.2 [Опции Спецификатора Преобразования], для
описания этой структуры данных.
<P>
<P>Аргумент ap_pointer  используется  для  передачи   хвоста   списка
параметров,   содержащего   значения   котторые  Ваш  обработчик  должен
напечатать.  В отличие от большинства других функций, которым может быть
передан явный список параметров,  здесь передается указатель на va_list,
а не сам va_list.  Таким образом,  Вы должны  обрабатывать  аргументы  с
помощью va_arg(TYPE, * ap_pointer).
<P>( Введение указателя  здесь  позволяет  указать  функцию,  которая
вызывает  вашу  функцию  обработчика,  чтобы  модифицировать собственную
переменную va_list,  для обновления информации о параметрах, которые ваш
обработчик обрабатывает. См. Раздел A. 2 [Variadic (функция)] 2.)
<P>
<P>Ваша функция обработчика должна возвратить значение точно  так  же
как это делает printf: она должна возвратить число символов, которое она
написала, или отрицательное значение, чтобы указать ошибку.
<DL>
<DT><B>-Тип данных:  printf_function </B><DD><P>
<P>Это тип данных,  который должна иметь функция обработчика. Если Вы
собираетесь  использовать  parse_printf_format в вашем приложении,
то Вы  должны  также  определить  функцию,  являющуюся  параметром
arginfo_function   для   каждого   нового   формата,   который  Вы
устанавливаете с помощью register_printf_function.
<P>Вот прототип подобной функции:
<BLOCKQUOTE><CODE>
<PRE>
 int function  (const struct printf_info *info,size_t n,int *argtypes);
</PRE>
</CODE></BLOCKQUOTE>
<P>Функция должна  возвращать число параметров,  которые обрабатывает
формат вывода.  Кроме того,  функция не должна заполнять больше,  чем  n
элементов  argtypes  массива с информацией относительно типов каждого из
этих  параметров.  Эта   информация   закодирована   с   помощью   'PA_'
макрокоманд.  (Обратите внимание, что это - то же самое что и соглашение
о вызовах parse_printf_format.)
<P>
<DT><B>-Тип данных: printf_arginfo_function </B><DD><P>Этот тип  используется,  для  описания функций,  которые возвращают
информацию  о  числе  и  типе  параметров,  используемых  спецификатором
формата вывода.
<DT><B>t </B><DD><P>
</DL>
<H3>Пример Расширения Printf</H3>

<P>
<P>Вот пример, показывающий, как определять printf функцию обработчика.
Эта программа определяет структуру данных называемую Widget и определяет
формат '%M',  для печати информации о параметре Widget* включая значение
указателя  и  имя,  содержащееся в структуре данных.  Формат вывода '%W'
поддерживает минимальную ширину поля и  опции  левого  выравнивания,  но
игнорирует все остальные.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;stdio.h&gt;
      #include &lt;printf.h&gt;
      #include &lt;stdarg.h&gt;
      typedef struct
        {
          char *name;
        } Widget;



      int
      print_widget (FILE *stream, const struct printf_info *info, va_list *app)
      {
        Widget *w;
        char *buffer;
        int len;

        /* Преобразуем выходную информацию в строку. */
        w = va_arg (*app, Widget *);
        len = asprintf (&amp;buffer, '&lt;Widget %p: %s&gt;', w, w-&gt;name);
        if (len == -1)
          return -1;
        /* Заполняем поле минимальной длины и выводим в поток.*/
        len = fprintf (stream, '%*s',
                       (info-&gt;left ? - info-&gt;width : info-&gt;width),
                       buffer);

        /* Сброс и возврат. */
        free (buffer);
        return len;
      }


      int
      main (void)
      {

         / * Создаем widget, который необходимо напечатать. * /
         Widget mywidget;
         mywidget.name = 'mywidget';

         / * Теперь печатаем widget. * /
         printf ('|%W|\n',  &amp;mywidget);
         printf ('|%35W|\n',  &amp;mywidget);
         printf ('|%-35W|\n', &amp;mywidget);
         return 0;
 }
</PRE>
</CODE></BLOCKQUOTE>

Программа выводит:
<BLOCKQUOTE><CODE>
<PRE>
      |&lt;Widget 0xffeffb7c: mywidget&gt;|
      |      &lt;Widget 0xffeffb7c: mywidget&gt;|
      |&lt;Widget 0xffeffb7c: mywidget&gt;      |
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss7.11">7.11 Форматируемый Ввод</A>
</H2>

<P>Функции, описанные  в  этом  разделе  (scanf и ей подобные) обеспечивают
средства для форматируемого ввода,  аналогичного форматируемым средствам
вывода.  Эти  функции  обеспечивают  механизм  для  чтения  произвольных
значений при контроле над строкой формата или строкой шаблона.
<P>
<H3>Основы  Форматируемого  Ввода</H3>

<P>Вызов scanf  на  первый  взгляд  подобен  обращениям к printf,  в
котором  произвольные  параметры  считываются  под  управлением   строки
шаблона. В то время, как синтаксис спецификаций преобразования в шаблоне
очень схож,  синтаксис для printf,  интерпретация шаблона  ориентируется
больше на ввод свободного формата и простое сопоставление с образцом,  а
не форматирование устанавливаемого  поля.  Например,  большинство scanf
пропускают    любое    преобразование   над   каким-нибудь   количеством
'пробельных символов'  (включая  пробел,  метки  табуляции,  и   символы
перевода  строки) во входном файле,  и нет никакого понятия точности для
числовых входных  преобразований  которое  имеется  для  соответствующих
преобразований вывода.  Обычно,  непробельные  символы  в  шаблоне,  как
ожидается, будут точно соответствовать символам во  входном  потоке,  но
соответствующая ошибка отличается от входной ошибки в потоке.
<P>
<P>Другая отличие между scanf и printf - то,  что Вы должны не забыть
обеспечивать указатели а не непосредственные значения как необязательные
параметры scanf;  значения, которые читаются, сохраняются в объектах, на
которые  указывают указатели.  Даже опытные программисты имеют тенденцию
забывать это иногда,  так если ваша программа получает странные  ошибки,
которые, кажется, связаны со scanf, Вам следует дважды проверить это.
<P>
<P>Когда происходит  ошибка   несоответствия   ,   scanf   немедленно
прерывается, оставляя первый символ несоответствия как следующий символ,
который нужно читать из  потока.  Нормальное  возвращаемое  значение  из
scanf  -  число  значений,  которые  были  назначены,  так что Вы можете
использовать это,  чтобы определить,  случалась ли  ошибка  соответствия
прежде, чем все прочитались ожидаемые значения.
<P>
<P>Функция scanf обычно используется для  программ  вроде  считывания
содержания таблиц. Ниже приводится функция, которая использует scanf для
того,  чтобы инициализировать массив элементов  double:
<BLOCKQUOTE><CODE>
<PRE>
 void  readarray (double *array, int n) {
         int i; for (i=0; i&lt;n; i++)
                 if (scanf (' %lf', &amp;(array[i])) !=
                         1) invalid_input_error ();
 }
</PRE>
</CODE></BLOCKQUOTE>
       Функции форматируемого ввода  используются не  так  часто   как
функции форматируемого  вывода.
<P>
<P>Если Вы   пытаетесь   считывать  входную  информацию,  которая  не
соответствует ни простому,  фиксированному шаблону,  то может  быть  Вам
лучше  использовать  средства типа Flex,  чтобы сгенерировать лексический
сканер,  или Bison,  чтобы сгенерировать синтаксический анализатор,  а не
использовать scanf. Для получения более подробной информации, см. раздел
'Flex' в Flex: Лексический Генератор Ввода и раздел 'Bison' в Справочном
описании Bison.
<P>
<H3>Синтаксис Входных Форматов</H3>

<P>Строка шаблона  для  scanf  это   строка,   которая   содержит   обычные
многобайтовые   символы   со   спецификациями   преобразования,  которые
начинаются с '%'.
<P>
<P>Любой пробельный  символ  (как  определено  функцией isspace;  см.
Раздел 4.1 [Классификация Символов]) в шаблоне  заставляет  любое  число
символов промежутка во входном потоке читаться и отбрасываться.  Символы
промежутка,  которые согласованы могут быть не точно те же самые символы
промежутка которые появляются в строке шаблона. Например, добавьте ',' к
шаблону,  чтобы распознать запятую с любым  количеством  пробелов  до  и
после нее.
<P>
<P>Другие символы  в  строке  шаблона,  которые  не  являются  частью
спецификаций  преобразования,  должны  точно соответствовать символам во
входном  потоке;  если  дело  обстоит  не   так,   возвращается   ошибка
несоответствия.
<P>
<P>Спецификации преобразования  в  строке scanf шаблона имеют общую
форму:
<BLOCKQUOTE><CODE>
<PRE>
       % FLAGS WIDTH TYPE CONVERSION
</PRE>
</CODE></BLOCKQUOTE>
      Более подробно,  входная спецификация  преобразования  состоит  из
начального символа '%', сопровождаемого последовательностью:
<UL>
<LI>        Необязательный флаг '*',  который  говорит  игнорировать  чтение
текста  для этой спецификации.  Когда scanf находит спецификацию
формата вывода,  который использует этот флаг,  она читает  ввод
так,  как это задается остальной частью спецификации формата, но
она отбрасывает этот ввод,  не использует аргумент указателя,  и
не увеличивает число успешных назначений.</LI>
<LI>        Необязательный флаг 'а'  (допустимый  со  строковыми  форматами)
задает резервирование достаточно большого буфера чтобы хранения
строки.  (Это - расширение GNU.) См. Раздел 7.11.6 [Динамический
Строковый Ввод].</LI>
<LI>        Необязательный  десятичное  целое  число,   которое   определяет
максимальную  ширину  поля.  Чтение  символов из входного потока
останавливается либо когда достигнут этот максимум,  либо  когда
найден   символ   несоответствия.   Большинство   преобразований
отбрасывает начальные символы промежутка (если не явно указаны),
и  эти  отброшенные  символы не увеличивают счетчик максимальной
ширины поля.  Строковые входные преобразования сохраняют  пустой
символ,   отмечая  конец  ввода;  максимальная  ширина  поля  не
включает этот признак конца.</LI>
<LI>        Необязательный символ модификатора типа. Например, Вы можете
задавать модификатор типа 'l' с преобразованиями integer типа
'%d' чтобы указать, что аргумент - указатель на long int а не
указатель на int.</LI>
<LI>        Символ,  который  определяет применяемый формат.  Точные опции и
как они интерпретируются,  все это изменяется  между  различными
спецификаторами    преобразования.   См.   описания   конкретных
спецификаторов  для  уточнения  информации  относительно   опций,
которые они допускают.</LI>
</UL>
<H3>Таблица   Входных  Преобразований</H3>

<P>Ниже приводится  таблица,  которая   содержит   различные   спецификации
форматов:
<DL>
<DT><B>'%d' </B><DD><P>Соответствует  необязательно целому числу со знаком,  которое
записано  в  десятичном  виде.  См.  Раздел  7.11.4  [Входные
Форматы Чисел].
<DT><B>'%i' </B><DD><P>Соответствует необязательно целому числу со знаком в любом из
форматов, которые Язык C определяет для определения константы
integer. См. Раздел 7.11.4 [Числовые Входные Преобразования].
<DT><B>'%o' </B><DD><P>Соответствует   integer   unsigned,   который    записан    в
восьмеричной системе счисления.  См.  Раздел 7.11.4 [Числовые
Входные Форматы].
<DT><B>'%u' </B><DD><P>Соответствует  беззнаковому целому,  записанному в десятичной
системе  счисления.  См.  Раздел  7.11.4  [Числовые   Входные
Преобразования].
<DT><B>'%x', '%X' </B><DD><P>Соответствуют  беззнаковому  целому,   записанному   в
шестнадцатеричной   системе   счисления.  См.  Раздел  7.11.4
[Числовые Входные Преобразования].
<DT><B>'%e', '%f', '%g', '%E', '%G' </B><DD><P>Соответствуют необязательному  знаковому  числу  с  плавающей
запятой. См. Раздел 7.11.4 [Числовые Входные Преобразования].
<DT><B>'%s' </B><DD><P>Соответствует строке, содержащей только символы непромежутка.
См.   Раздел  7.11.5  [Входные  Преобразования  Строки].
<DT><B>'%[' </B><DD><P>Соответствует строке символов,  которые принадлежат заданному
множеству. См. Раздел 7.11.5 [Входные Преобразования Строки].
<DT><B>'%c' </B><DD><P>Соответствует  строке  из  одного  или  большего   количества
символов;  чтение  числа  символов  управляется  максимальной
шириной поля, заданной для формата.
<DT><B>'%p' </B><DD><P>Соответствует  значению указателя в том же самом определенном
реализацией  формате,  используемом  форматом  вывода  printf
'%p'. См. Раздел 7.11.7 [Другие Входные Форматы].
<DT><B>'%n'  </B><DD><P>Это преобразование не читает никакие символы;  оно записывает
число прочитанных символов. См. Раздел 7.11.7 [Другие Входные
Преобразования].
<DT><B>'%%' </B><DD><P>Это соответствует символу `%' во входном потоке.  См.  Раздел
7.11.7 [Другие  Входные   Преобразования].   Если   синтаксис
спецификации преобразования является недопустимым,  поведение
неопределено.  Если не достаточно аргументов  функции,  чтобы
обнспечить  адреса  для  всех  спецификаций формата в строках
шаблона,  которые выполняют назначения,  или  если  аргументы
имеют  неправильные  типы,  поведение  также неопределено.  С
другой стороны, дополнительные аргументы просто игнорируются.
</DL>
<H3>Числовые  Входные  Преобразования</H3>

<P>Этот раздел   описывает  преобразования  scanf  для  чтения  числовых
значений.
<P>
<P>Формат ввода  '%d'  соответствует  необязательно  целому  числу со
знаком в десятичной системе счисления.  Синтаксис - такой же как  и  для
функции strtol (см.  Раздел 14.7.1 [Синтаксический анализ Целых чисел] )
со значением 10 для основного аргумента.
<P>
<P>Формат ввода  '%i'  соответствует  необязательному целому числу со
знаком в  любом  из  форматов,  которые  Язык  C  определяет  для  целой
константы.  Синтаксис  -  такой  же  как для функции strtol (см.  Раздел
14.7.1  [Синтаксический  анализ  Целых  чисел]  )  со  значением  0  для
основного аргумента. (Вы можете печатать integer в этом синтаксисе через
printf, используя  флаг '*' с форматами '%x', '%o', или '%d'. См. Раздел
7.9.4 [Целочисленные Преобразования].)
<P>
<P>Например, любая из строк '10',  '0xa', или '012' может cчитываться
как  целая  константа  при  преобразовании  '%i'.  Каждая из этих строк
определяет число с десятичным значением 10.
<P>
<P>Форматы ввода '%o', '%u', и '%x' соответствуют беззнаковому целому
в восьмеричном, десятичном, и шестнадцатеричном форматах соответственно.
Синтаксис  -  такой  же  как  для  функции  strtoul  (см.  Раздел 14.7.1
[Синтаксический анализ Целых чисел] ) с  соответствующим  значением  (8,
10, или 16) для основного аргумента.
<P>
<P>Формат '%X' идентичен формату '%x'. Оба они разрешают использовать
как цифры или символы верхнего регистра или символы нижнего регистра.
<P>
<P>Заданный по умолчанию тип соответствующего аргумента форматов '%d'
и '%i'  является  'int  *',  и 'unsigned int *' для других целочисленных
форматов.  Вы можете использовать  следующие  модификаторы  типа,  чтобы
задать другие размеры integer:
<UL>
<LI>       'h' Определяет,  что аргумент - short int * или short unsigned int*.</LI>
<LI>       'l' Определяет, что аргумент - long int * или long unsigned int*.</LI>
<LI>       'L' Определяет, что аргумент - long long int * или long long
unsigned int *. (Тип long long - расширение, обеспечиваемое компилятором
GNU C.  Для систем, которые не обеспечивают сверхдлинных целых, это &shy;
то же что long int.)</LI>
</UL>
       Все входные   форматы   '%e',   '%f',   '%g',   '%E',    и    '%G'
взаимозаменяемы. Они все соответствуют необязательному знаковому числу с
плавающей запятой, в том же самом синтаксисе как для функции strtod (см.
Раздел 14.7.2 [Синтаксический анализ Чисел с Плавающей Запятой] ).
<P>
<P>Для преобразований с плавающей запятой,  заданный по умолчанию тип
аргумента - float *.  (Это  отличается от  соответствующих  преобразований
вывода,  где  заданный  по  умолчанию  тип  - double;  не забудьте,  что
аргументы  float  в  printf  преобразовываются  в  double  заданными  по
умолчанию поддержками аргумента, но float * аргументы не преобразуются в
double *.) Вы можете задавать другие размеры float,  используя следующие
модификаторы типа:
<UL>
<LI>       ' l ' Определяет, что аргумент имеет тип double *.</LI>
<LI>       ' L ' Определяет, что аргумент имеет тип long double *.</LI>
</UL>
<H3>Строковые  Входные  Преобразования</H3>

<P>Этот раздел описывает преобразования ввода scanf для чтения
строковых и символьных значений:  '%s', '%[', и '%c'.
<P>Имеется два способа  получить ввод от этих преобразований:
<UL>
<LI>      Определить  буфер  для хранения входной информации.  Этот способ
задан  по  умолчанию.  Вы  должны  указать аргумент  типа  char*.

Предупреждение:

для того,    чтобы   сделать   надежную   программу,   Вы   должны
удостовериться,  что  входная  информации  (плюс   пустой   символ
завершения)   не   может   превышать   размер  буфера,  котрый  Вы
определили.  Вообще,  единственный способ  сделать  это  -  задать
максимальную ширину поля на один меньше чем размер буфера. Если Вы
определяете буфер,  всегда задавайте максимальную ширину поля  для
предотвращения    переполнения.</LI>
<LI>      Указать функции scanf зарезервировать  достаточно  большой  буфер,
задавая флаг 'f'.  Это является расширением GNU. Вы должны указать
аргумент типа char ** для сохранения  адреса  буфера.  См.  Раздел
7.11.6 [Динамический Строковый Ввод].</LI>
</UL>
      Формат '%c' (самое простое): оно соответствует фиксированному числу
символов.  Если  Вы  не  задаете максимум длины поля ввода,  значение по
умолчанию 1.  Это преобразование не  добавляет  пустой  символ  в  конец
текста, которую оно читает. Оно также не пропускает начальные пробельные
символы.  Оно читает ровно n символов,  и выдает ошибку,  если оно  не
может  их получить.  Так как при '%c' всегда имеется максимальная ширина
поля (заданная,  или 1 по умолчанию),  Вы  всегда  можете  предотвратить
переполнение, делая буфер достаточно большим.
<P>
<P>Формат '%s'  соответствует  строке  непробельных   символов.   Оно
пропускает    и    отбрасывает    начальные   пробельные   символы,   но
останавливается,  когда сталкивается с  пробельным  символом  когда  уже
что-то считано.  Он  сохраняет  пустой  символ  в конце текста,  который
считывает. Например, при считывании:
<BLOCKQUOTE><CODE>
<PRE>
       hello, world
</PRE>
</CODE></BLOCKQUOTE>
 формат '%10c' производит 'hello,  wo',  а считывании того  же  самого  с
форматом '%10s' производит 'hello,'.
<P>
<P>Предупреждение: если Вы не задаете ширину поля  для  '%s',  то
число символов, ограничено только тем, где появится следующий пробельный
символ. Это конечно означает что недопустимый ввод может вызвать ошибку.
<P>
<P>Чтобы считывать символы,  которые принадлежат произвольному набору
по вашему выбору,  используйте формат '%['.  Вы определяете набор  между
символом `[' и следующим символом `]', используя синтаксис, используемый
в регулярных выражениях. Частные случаи:
<UL>
<LI>        Литеральный символ `]' может быть определен как первый символ
набора.</LI>
<LI>        Внутренний  символ  `-'  (то есть тот,  который не первый или не
последний  символ  набора)  используется,  чтобы   определить   диапазон
символов.</LI>
<LI>        Если,  за символом '^' немедленно следует начальный '[', а затем
набор  символы,  то  позволяемые  входные  символы  - все за исключением
перечисленных символов.</LI>
</UL>
       '%[' преобразование не перескакивает начальные пробельные символы.
Ниже приводятся некоторые примеры форматов '%[' преобразования и что они
означают:
<BLOCKQUOTE><CODE>
<PRE>
       `%25[1234567890]'
</PRE>
</CODE></BLOCKQUOTE>
       Соответствует строке до 25 цифр.
<BLOCKQUOTE><CODE>
<PRE>
       `%25[][]'
</PRE>
</CODE></BLOCKQUOTE>
       Соответствует строке до 25 квадратных скобок.
<BLOCKQUOTE><CODE>
<PRE>
       `%25[^ \f\n\r\t\v]'
</PRE>
</CODE></BLOCKQUOTE>
       Соответствует строке до 25 символов,  которая не содержит любых из
стандартных пробельных символов.  Это немного отличается от '%s', т. к.,
если   ввод  начинается  с  символа  пропуска,  '%['  возвращает  ошибку
несоответствия,  в  то  время  как  '%s'  просто  отбрасывает  начальный
пропуск.
<BLOCKQUOTE><CODE>
<PRE>
       `%25[a-z]'
</PRE>
</CODE></BLOCKQUOTE>
       Соответствует до  25   символам   нижнего   регистра.   Еще   одно
напоминание:  форматы  '%s'  и  '%['  опасны,  если  Вы  не  определяете
максимальную ширину или используете флаг 'a', т. к. слишком длинный ввод
переполнит   любой   буфер.   Хорошо  написанная  программа  сообщает  о
недопустимом вводе сообщением об ошибках,  а  не  завершается  аварийным
отказом.
<P>
<H3>Динамическое Распределение Форматов Строки</H3>

<P>
<P>Расширение GNU для форматируемого ввода  позволяет  Вам  безопасно
считывать  строку  безо  всякого  указания  максимального  размера.  При
использовании этой возможности,  Вы не указываете буфер; а вместо этого,
scanf распределяет буфер,  достаточно большой,  чтобы содержать данные и
возвращает Вам его адрес.  Чтобы использовать эту возможность,  укажите
'а' в качестве флага, например '%as' или '%a[0-9a-z]'.
<P>
<P>Аргумент указателя,  который  Вы  обеспечиваете   для   размещения
входной информации,  должен иметь тип char **. Функция scanf резервирует
буфер  и  сохраняет  адрес  там,  куда  указывает  аргумент.  Вы  должны
освободить буфер функцией free, когда Вы больше не нуждаетесь в нем.
<P>
<P>Вот пример использования флага 'а' со спецификацией преобразования
'%[...]'  для  чтения  'переменного  назначения'  в  форме 'переменная =
значение'.
<BLOCKQUOTE><CODE>
<PRE>
      {
        char *variable, *value;

        if (2 &gt; scanf ('%a[a-zA-Z0-9] = %a[^\n]\n',
                       &amp;variable, &amp;value))
          {
            invalid_input_error ();
            return 0;
          }

        ...
      }
</PRE>
</CODE></BLOCKQUOTE>
<H3>Другие   Входные  Форматы</H3>

<P>Этот  раздел описывает разнообразные входные форматы.
<P>Формат '%p'  используется,  для   того   чтобы   считывать   значение
указателя.  Оно  распознает тот же самый синтаксис,  как и формат вывода
'%p' для printf  (см.  Раздел  7.9.6  [Другие  Преобразования  Вывода]).
Соответствующий параметр должен иметь тип void **;  то есть адрес места,
где разместить  указатель.
<P>Формат '%n' возвращает число  прочитанных  символов.  Соответствующий
параметр  должен  иметь тип int *.  Это преобразование работает таким же
образом как и формат '%n'  для  printf;  см.  примеры  в  Разделе  7.9.6
[Другие Форматы Вывода].
<P>Формат '%n'  -   единственный   механизм   для   определения   успеха
буквального соответствия или преобразования с подавляемыми назначениями.
Если '%n' следует за ошибкой несоответствия,  scanf возвратится,  не  успев
обработать  '%n'.  Если Вы поместите -1 в этот  параметр перед вызовом scanf,
присутствие -1 после вызова scanf указывает,  что  ошибка произошла перед
обработкой '%n'.
<P>
<P>В заключение,  формат '%%' соответствует символу  `%'  во  входном
потоке,  без  использования  параметра.  Это преобразование не позволяет
определение никаких флагов, ширины поля, или модификаторов типа.
<P>
<H3>Форматируемые Входные Функции</H3>

<P>Ниже приводятся  описания  функций для выполнения форматируемого ввода.
Прототипы для этих функций находятся в  файле  'stdio.h'.
<DL>
<DT><B>-Функция: int scanf (const char *template, ...) </B><DD><P>Функция scanf  читает форматируемый ввод из потока stdin под управлением
строки шаблона.  Необязательные параметры - указатели на места,  которые
получают возникающие в результате значения.
<P>
<P>Возвращаемое значение  -  обычно  число успешных соответствий.  Если
условие  конца  файла  обнаружено  перед  любым  соответствием  (включая
соответствие пробельным символам  и  литеральных  символов в шаблоне),  то
возвращается EOF.
<DT><B>-Функция:  int fscanf (FILE *stream, const char *template, ...) </B><DD><P>
<P>Эта функция   -  аналог  scanf,  за  исключением  того,  что  ввод
осуществляется из вместо stdin указанного потока.
<DT><B>-Функция:  int sscanf (const char *s, const char *template, ...) </B><DD><P>Подобна scanf,  за  исключением  того,  что символы берутся из
строки s с нулевым символом в конце,  а не из потока.  Достижение  конца
строки обрабатывается как условие конца файла.
<P>
<P>Поведение этой функции неопределено,  если копирование  происходит
между объектами, которые пересекаются, например, если s  задан еще и как
аргумент  для  получения  считанной  строки  под управлением формата '%s'.
</DL>
<P>
<P>
<H3>Функции  Ввода С Переменными Аргументами</H3>

<P>
<P>Функции vscanf и ей подобные работают так, чтобы Вы могли определять
ваши собственные scanf-подобные функции,  которые используют ту же самую
внутреннюю организацию как встроенные форматируемые функции вывода.  См.
Раздел 7.9.9 [Вывод Аргументов Переменной].
<P>Примечание о   Переносимости:  функции,  перечисленные  в  этом  разделе
являются расширением GNU.
<DL>
<DT><B>-Функция: int vscanf (const char *template, va_list ap) </B><DD><P>Эта функция похожа на scanf за исключением того,  что вместо  того,
чтобы  принимать переменное число аргументов непосредственно,  она берет
указатель на список  параметров  -  ар  типа  va_list  (см.  Раздел  A.2
Variadic Функции] ).
<P>
<DT><B>-Функция: int vfscanf (FILE  *stream,const char *template,va_list ap) </B><DD><P>Эта функция -  эквивалент  fscanf  с  переменным  списком  параметров,
заданным непосредственно как для vscanf.
</DL>
<H2><A NAME="ss7.12">7.12 Блочный  Ввод-Вывод</A>
</H2>

<P>Этот раздел описывает операции ввода  и  вывода  на  блоках  данных.  Вы
можете  использовать  эти  функции  для чтения и записи двоичных данных,
также как читать и писать текст блоками устанавливаемого размера - а не
символами или строками.
<P>
<P>Сохранение данных   в   двоичной  форме  часто  значительно  более
эффективно чем  использование  форматируемых  функций  ввода  -  вывода.
Также,  для чисел с плавающей запятой, двоичная форма избегает возможной
потери точности в процессе преобразования.  С другой  стороны,  двоичные
файлы  не  могут быть легко исследованы или изменяться,  используя много
стандартных файловых  утилит  (вроде   текстовых   редакторов),   и   не
переносимы  между  различными реализациями языка,  или различными видами
компьютеров.
<P>Эти функции объявлены в ' stdio.h '.
<DL>
<DT><B>-Функция:size_t  fread  (void  *data, size_t size, size_t count, FILE *stream) </B><DD><P>
<P>Эта функция  читает  до count объектов размера size в массив.  Она
возвращает число прочитанных объектов,  которое может  быть  меньше  чем
count,  если  происходит ошибка чтения,  или достигнут конец файла.  Эта
функция возвращает значение нуль (и ничего не читает) если или size  или
count равен  нулю.
<P>
<P>Если fread достигает  конца файла  в  середине  объекта,  она
возвращает номер   прочитанных   полностью   объектов,   и   отбрасывает
несчитанные до конца.
<P>
<DT><B>-Функция: size_t fwrite (const void *data, size_t size, size_t count, FILE *stream) </B><DD><P>
<P>Эта функция записывает до  count  объектов  из  массива  данных  в
указанный поток.  Возвращаемое значение - обычно count,  если считывание
успешно.  Любой другое значение указывает  какую-либо  ошибку,  например
нехватку памяти.
</DL>
<H3>КОНЕЦ ФАЙЛА и Ошибки</H3>

<P>Многие из  функций,  описанных  в   этой   главе   возвращают   значение
макрокоманды  EOF,  указывающей  неудачное  завершение  операции.  Когда
используется EOF,  для сообщения о конце файла или о  случайной  ошибке,
часто лучше использовать функцию feof,  чтобы явно проверить конец файла
и ferror, чтобы проверить наличие ошибки. Это контрольные индикаторные
функции,  которые  являются частью внутреннего состояния объекта потока,
индикаторы устанавливаются если соответствующее условие было  обнаружено
предыдущей операцией ввода - вывода на этом потоке.
<P>
<P>Эти символы  объявлены  в  заглавном  файле  ' stdio.h '.
<DL>
<DT><B>- Макрос: int EOF </B><DD><P>Этот макрос  имеет  целое  значение,  которое  возвращается рядом
функций,  чтобы указать условие  конца  файла,  или  какую-нибудь
другую ошибку.  В библиотеке GNU, EOF имеет значение -1. В других
библиотеках,  значением может быть некоторое другое отрицательное
число.
<P>
<DT><B>-Функция: void clearerr   (FILE   *stream) </B><DD><P>Эта функция  очищает  индикаторы  конца  файла   и   ошибки   для
указанного потока.  Позиционирующие файл функции (см. Раздел 7.15
[Позиционирование Файла]) также,  очищают индикатор  конца  файла
для потока.
<P>
<DT><B>-Функция: int feof (FILE *stream) </B><DD><P>Функция feof  возвращает  отличное  от  нуля  число,  только если
установлен индикатор конца файла для потока.
<DT><B>-Функция: int ferror (FILE  *stream) </B><DD><P>Функция ferror возвращает отличное от  нуля  число,  только  если
индикатор  ошибки  для  потока  установлен,  указывая  что ошибка
произошла на предыдущей операции на потоке.
</DL>

В дополнение к установке индикатора  ошибки,  связанного  с  потоком,
функции,  которые работают с потоками,  устанавливают errno
таким же образом как соответствующие  функции  низкого  уровня,  которые
работают   с дескрипторами  файла.  Например,  все  функции,  которые
выполняют  вывод в поток, такие  как  fputc,  printf,   и   fflush,
осуществлены   в   терминах   записи,   и  все    условия  ошибки errno,
определенные для  записи,  имеют  значение  и  для  этих  функций.   Для
получения   более   подробной   информации о  функциях  ввода  -  вывода
на  уровне дескрипторов, см. Главу 8 [ввод - вывод низкого уровня] 3.
<P>
<H2><A NAME="ss7.13">7.13 Текстовые   и   Двоичные   Потоки</A>
</H2>

<P>Система GNU    и   другие   posix-совместимые   операционные   системы
организовывает все файлы  как  однородные  последовательности  символов.
Однако,   некоторые   другие  системы  делают  различие  между  файлами,
содержащими текст и файлами,  содержащими двоичные  данные,  и  средства
ввода и вывода ANSI C предусматривают это различие. Этот раздел сообщает
Вам, как написать программы, переносимые на такие системы.
<P>
<P>Когда Вы открываете поток,  Вы  можете  определять  или  текстовый
поток или двоичный поток.  Вы указываете,  что Вы хотите двоичный поток,
определяя модификатор 'b'  в параметре opentype для fopen;  см.  Раздел
7.3  [Открытие  Потоков].  Без  этой  опции,  fopen  открывает  файл как
текстовый поток.
<P>
<P>Текстовые и двоичные потоки имеют различия:
<UL>
<LI>        Данные   из  текстового  потока  разделены  на  строки,  которые
завершены символом перевода строки (' \n ') символы,  в то время
как двоичный поток - просто ряд символов.  Текстовый поток может
на некоторых системах быть не в  состоянии  обрабатывать  строки
больше чем 254 символа (включая символ перевода строки).

</LI>
<LI>        На некоторых системах,  текстовые файлы могут  содержать  только
символы  печати,  горизонтальные  cимволы  табуляции,  и символы
перевода  строки,  и  так  что   текстовые   потоки   не   могут
поддерживать  другие  символы.  Однако,  двоичные  потоки  могут
обрабатывать любое символьное значение.</LI>
<LI>        Символы пробела, которые написаны перед символом перевода строки
в текстовом потоке, могут исчезать.</LI>
<LI>        В более общем смысле,  не обязательно имеется взаимнооднозначное
отображение   между   символами,   которые    считываются    или
записываются в текстовый поток, и символами в фактическом файле.</LI>
</UL>
       Так как двоичный поток  более  общий  и  более  предсказуемый  чем
текстовый  поток,  Вы  могли бы задаться вопросом,  в чем цель текстовых
потоков.  Почему не всегда используют двоичные потоки?  Ответ в том, что
на разных операционных системах,  текстовые и двоичные потоки используют
различные форматы файла,  и  единственный  способ  читать  или  записать
'обычный текстовый файл' который может работать с другими ориентируемыми
текстом программами - через текстовый поток.
<P>
<P>В библиотеке  GNU,  и на всех POSIX системах,  не имеется никакого
различия между  текстовыми  потоками  и  двоичными  потоками.  Когда  Вы
открываете  поток,  Вы  получаете тот же самый вид потока,  даже если Вы
заказывали двоичный.  Этот поток  может  обрабатывать  любое  содержание
файла,  и не имеет ни каких ограничений,  которые в отличие от текстовые
потоков.
<P>
<H2><A NAME="ss7.14">7.14 Позиционирование Файла</A>
</H2>

<P>
<P>Позиция файла  потока  описывает,  где  в  файле поток в настоящее
время читает или производит  запись.  Ввод-вывод  на  потоке  продвигает
позицию   файла   через   весь   файл.  В  системе  GNU,  позиция  файла
представляется как целое число,  которое содержит число байтов от начала
файла. См. Раздел 6.1.2 [Позиция Файла].
<P>
<P>В течение ввода-вывода в обычный дисковый файл,  Вы можете  менять
позицию  в  файле  всякий раз,  когда Вы желаете читать или записывать в
любую часть файла.  Некоторые другие виды файлов также позволяют  делать
это.   Файлы,   которые  поддерживают  изменение  позиции  файла  иногда
упоминается как файлы прямого доступа.
<P>
<P>Вы можете  использовать функции в этом разделе,  чтобы исследовать
или изменить индикатор позиции  файла,  связанный  с  потоком.  Символы,
перечисленные ниже объявлены в заглавном файле 'stdio.h'.
<DL>
<DT><B>-Функция: long int ftell (FILE *stream) </B><DD><P>
<P>Эта функция возвращает текущую позицию  файла  указанного  потока.
<P>Эта  функция  может  выдать  ошибку,  если  поток  не поддерживает
позиционирование  файла,  или  если   позиция   файла   не   может
представляться как long int,  или возможно по другим причинам.
<P>Если происходит ошибка,  возвращаемое значение -1.
<DT><B>-Функция: int fseek (FILE *stream,  long  int  offset,  int  whence) </B><DD><P>
<P>Функция fseek используется для изменения позиции файла  указанного
потока.  Значение  whence  должно быть одной из констант SEEK_SET,
SEEK_CUR,  или SEEK_END,  т.  е.  указывать является  ли  смещение
относительно начала файла, текущей позиции файла, или конца файла,
соответственно.  Эта функция возвратит нуль,  если  операция  была
успешна,  и  значение,  отличное  от  нуля  чтобы  указать  отказ.
<P>Успешное обращение также очищает индикатор конца  файла  потока  и
отбрасывает   любые   символы,  которые  были  'помещены  обратно'
использованием ungetc.  Fseek  дописывает  любой  буферизированный
вывод перед позиционированием файла,  или еще запоминает его,  так
что  он  будет  записан  позже  в  соответствующем  месте   файла.
</DL>

Примечание о Переносимости:  В не-posix системах,  ftell и  fseek  могут
работать   надежно  только  на  двоичных  потоках.  См.  Раздел  7.14
[Двоичные Потоки].
<P>Следующие символические  константы  определены  для  использования  в
качестве аргумента whenceа для fseek.  Они также  используются  функцией
lseek  (см.  Раздел  8.2  [Примитивы  ввода  -  вывода] ) и для указания
смещения для блокировок файла (см. Раздел 8.7 [Операции Управления] ).
<DL>
<DT><B>-Макрос: int SEEK_SET </B><DD><P>Это целая  константа которая,  когда используется как аргумент whence
функции fseek и определяет, что смещение указывается относительно начала
файла.
<P>
<DT><B>-Макрос: int SEEK_CUR </B><DD><P>Это целая константа которая используется как аргумент whence  функции
fseek  и  определяет,  что  смещение  указывается  относительно  текущей
позиции файла.
<P>
<DT><B>-Макрос: int SEEK_END </B><DD><P>Это целая  константа которая используется как аргумент whence функции
fseek и определяет, что смещение указывается относительно конца файла.
<P>
<DT><B>-Функция: void rewind  (FILE *stream) </B><DD><P>Функция rewind  позиционирует  указанный  поток  в начало файла.  Это
эквивалентно  вызову  fseek  на  потоке  с  аргументом  смещения  0L   и
аргументом  whence  SEEK_SET,  за  исключением  того,  что  возвращаемое
значение отбрасывается, и индикатор ошибки для потока сброшен.
<P>
<P>Эти три побочных результата исследования для  констант  'SEEK_...'
существуют  ради  совместимости  с  более  старыми  BSD  системами.  Они
определены в двух различных  файлах: 'fcntl.h' и 'sys/file.h'.
<P>L_SET синоним  SEEK_SET.
<P>L_INCR синоним  SEEK_CUR.
<P>L_XTND синоним SEEK_END.
</DL>
<H2><A NAME="ss7.15">7.15 Переносимые  Функции позиционирования  файла</A>
</H2>

<P>В системе GNU,  позиция файла - просто символьный счетчик.  Вы можете
задавать любое значение count как аргумента в fseek и получать  надежные
результаты  для  любого файла произвольного доступа.  Однако,  некоторые
ANSI C системы не представляет позиции файла таким образом,.
<P>
<P>На некоторых системах, где текстовые потоки отличаются от двоичных
потоков  невозможно  представить  позицию  файла  текстового  потока как
счетчик символов от начала файла.  Например,  позиция файла на некоторых
системах должна кодировать,  и смещение записи внутри файла,  и смещение
символа внутри записи.
<P>
<P>Как следствие, если Вы хотите чтобы ваши программы были переносимы
на эти системы, Вы должны соблюдать некоторые правила:
<UL>
<LI>        Значение, возвращенное ftell на текстовом потоке не имеет
никакой предсказуемостной связи с числом символов,  которое Вы читали из
пока.  Единственная вещь,  на которую Вы можете полагаться - то,  что Вы
сможете использовать его впоследствии,  поскольку  аргумент  смещения  в
fseek двигается обратно в ту же самую позицию файла.</LI>
<LI>        При обращении к fseek на текстовом потоке, смещение должно
быть либо нуль;  либо SEEK_SET, и смещение должно быть результатом более
раннего обращения к ftell на том же самом потоке.</LI>
<LI>        Значение   индикатора   позиции    файла    текстового    потока
неопределено,  если  имеются  символы,  которые  были  помещены  обратно
функцией ungetc,  которые не читались или не отбрасывались.  См.  Раздел
7.8 [Обратное чтение].</LI>
</UL>
<P>Но даже если Вы соблюдаете эти правила,  Вы можете все  еще  иметь
проблемы длинными файлами,  т.  к. ftell и fseek используют значение int
long,  для представления позицию файла.  Этот тип может не иметь участка
памяти, для кодирования всех позиций файла в большом файле.
<P>
<P>Так, если   Вы   хотите  поддерживать  системы  со  специфическими
кодированием для позиций файла,  то лучше использовать функции fgetpos и
fsetpos.  Эти  функции представляют позицию файла,  используя тип данных
fpos_t, чье внутреннее представление меняется от системы к системе.
<P>Эти символы  объявлены в заглавном файле ' stdio.h '.
<DL>
<DT><B>-Тип данных: fpos_t </B><DD><P>
<P>Это - тип объекта,  который может кодировать информацию относительно
файловой позиции потока, для использования функциями fgetpos и fsetpos.
<P>
<P>В системе  GNU,  fpos_t эквивалентен off_t или long int.  В других
системах, он может иметь различное внутреннее представление.
<P>
<DT><B>-Функция: int fgetpos (FILE *stream, fpos_t *position) </B><DD><P>Эта функция  сохраняет  значение  индикатора  файловой  позиции  для
указанного  потока  в  указанном объекте fpos_t.  Обращение успешно если
fgetpos возвращает нуль;  иначе она возвращает значение отличное от нуля
и сохраняет определенное реализацией положительное значение в errno.
<P>
<DT><B>-Функция: int fsetpos (FILE *stream,  const fpos_t position) </B><DD><P>Эта функция устанавливает индикатор файловой позиции для  указанного
потока  в  позицию  position,  которая  должна  определяться  предыдущим
обращением к fgetpos на том же самом  потоке.  Если  обращение  успешно,
fsetpos  очищает  индикатор  конца  файла  на потоке,  отбрасывает любые
символы,  которые  были  'помещены  обратно'  использованием  ungetc,  и
возвращает значение нуля. Иначе, fsetpos возвращает значение отличное от
нуля и  сохраняет  определенное  реализацией  положительное  значение  в
errno.
</DL>
<P>
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss7.16">7.16 Буферизация  Потока</A>
</H2>

<P>
<P>
<P>Символы, которые  записаны  в  поток,   обычно   накапливаются   и
передаются в файл блоками асинхронно, вместо того, чтобы появляться, как
только они выводятся прикладной  программой.  Аналогично,  потоки  часто
восстанавливают  ввод  из  главной  среды  в  блоках  а  не  по принципу
символ-за-символ. Это называется буферизацией.
<P>Если Вы напишете программы,  которые делают интерактивный  ввод  и
вывод  используя  потоки,  Вы  должны знать,  как работает буферизация,
когда Вы разрабатываете интерфейс пользователя в вашей программе. Иначе,
вывод (типа подсказки) может не появиться, как ожидалось, и т. д.
<P>Этот раздел  имеет  дело  только  с управлением передачей символов
между потоком и файлом или устройством.
<P>Вы можете обходить средства буферизации  потока  в  целом(вполне),
используя   ввод  и  вывод  низкого  уровня,  которые  функционируют  на
описателях файла. См. Главу 8 [ввод - вывод низкого уровня].
<P>
<H3>Понятие Буферизации</H3>

<P>Имеются три различных вида  cтратегий буферизации:
<UL>
<LI>     Символы,  записываемые  или  читаемые  из небуферизованного потока,
передаются индивидуально в файл или из файла как можно скорее.</LI>
<LI>     Символы,  записываемые  или  читаемые  из строчно буферизированного
потока передаются в или из файла в блоках,  когда прочитан с символ
перевода строки.</LI>
<LI>     Символы,  записываемые или читаемые из полностью  буферизированного
потока, передаются в или из файла в блоках произвольного размера.</LI>
</UL>
      Вновь открываемые потоки обычно полностью буферизируются,  с  одним
исключением:   поток,   соединенный  с  интерактивным  устройством  типа
терминала -  изначально  буферизирован  строчно.  См.  Раздел  7.17.3
[Управление Буферизацией], для уточнения информации о том, как в выбирают
различные виды буферизации.
<P>
<P>Использование строчной  буферизации  для  интерактивных  устройств
подразумевает окончание вывода сообщения  с  символом  перевода  строки.
Вывод,  который не заканчивается на символе перевода строки,  может и не
быть обнаружен немедленно, так если Вы хотите вывести его немедленно, Вы
должны очистить  буферизированный  вывод функцией fflush,  как описано в
Разделе 7.17.2 [Очистка буфера].
<P>
<P>Буферизация строки  -  хорошее  значение  по  умолчанию  для ввода
терминала,  т.  к.  большинство интерактивных программ  читают  команды,
которые  являются  обычно  одиночными  строками.  Программа  должна быть
способна выполнять каждую строку сразу же.  Буферизированный ввод  также
согласуется  с  обычными  редактирующими  вводом  средствами большинства
операционных систем, которые работают внутри строки ввода.
<P>
<P>Они включают  программы,  которые  читают  одиночно  -  символьные
команды (подобно Emacs) и  программам,  которые  делают  их  собственное
редактирование  ввода  (типа тех что используют readline).  Чтобы просто
читать символ, не достаточно выключить буферизацию во входном потоке; Вы
должны также выключить редактирование ввода, в операционной системе. Это
требует изменения режима терминала (см.  Раздел 12.4 [Режимы  Терминала]
).
<P>
<H3>Промывание  Буфера</H3>

<P>Сброс вывода   на  буферизированном  потоке,  передает  все  накопленные
символы в файл. Имеются много обстоятельств когда буферизированный вывод
на потоке, сбрасывается автоматически:
<UL>
<LI>        Когда Вы пробуете выводить, и буфер вывода полон.</LI>
<LI>        Когда поток закрыт. См. Раздел 7.4 [Закрывание Потоков].</LI>
<LI>        Когда программа завершается,  вызывая exit. См. Раздел 22.3.1
[Нормальное Окончание].</LI>
<LI>        Когда введен символ перевода строки,  если  поток  буферизирован
строчно.</LI>
<LI>        Всякий раз,  когда операция ввода  на  любом  потоке  фактически
читает данные из файла.</LI>
</UL>
<P>Если Вы  хотите  сбросить  буферизированный вывод в другой момент,
вызывайте fflush, которая объявлен в заглавном файле ' stdio.h '.
<DL>
<DT><B>-Функция: int  fflush (FILE  *stream) </B><DD><P>
<P>Эта функция  заставляет  любой  буферизированный  вывод  на потоке
дописываться в файл. Если поток - нулевой указатель, то буферизированный
вывод на всех открытых выходных потоках будет сброшен.
<P>Эти функции возвращают EOF, если происходит ошибка записи, и нуль
в другом случае.
</DL>
<P>Примечание о Совместимости:    Некоторые   поврежденные в уме
операционные  системы,  как известно,  были настолько помешаны на строчно
ориентированном вводе,  что  для  сброса  строчно  буферизированного
потока  должен  быть  введен  символ  перевода  строки!  К счастью, эта
'удобство', кажется, становится менее распространенным.
В системе GNU беспокоиться  об этом Вам нет нужды.
<P>
<H3>Управление  Видом  Буферизации</H3>

<P>После открытия потока (но прежде любой другой операции на нем),  Вы
можете явно определить какую буферизацию Вы  хотите,  используя  функцию
setvbuf.
<P>Средства, перечисленные  в  этом   разделе   объявлены   в   файле
'stdio.h'.
<DL>
<DT><B>-Функция: int setvbuf (FILE *stream, char *buf, int mode, size_t size) </B><DD><P>
<P>Эта функция  используется,  чтобы определить,  что указанный поток
должен иметь заданный режим буферизации, который может быть: _IOFBF (для
полной  буферизации),  _IOLBF (для буферизации строки),  или _IONBF (для
небуферизованного ввода -вывода).
<P>
<P>Если Вы   определяете  нулевой  указатель  как  параметр  buf,  то
setvbuf,  распределяет буфер,  непосредственно  используя  malloc.  Этот
буфер будет освобожден, когда Вы закроете поток.
<P>
<P>Иначе, buf  должен  быть  символьным   массивом,   который   может
содержать   по   крайней  мере  size  символов.  Вы  не  должны  трогать
пространство для этого массива,  пока поток  остается  открытым  и  этот
массив  остается  буфером.  Использование  автоматического  массива - не
очень хорошая идея,  если Вы не закрываете файл перед выходом из  блока,
который объявляет массив.
<P>
<P>В то время как массив остается буфером потоков,  функции  ввода  &shy;
вывода  потока  используют  буфер для их внутренних целей.  Вы не должны
пробовать обращаться к значениям в массиве непосредственно,  в то  время
как поток использует его для буферизации.
<P>
<P>Функция setvbuf возвращает ноль  в  случае  успеха,  или  значение
отличное  от нуля,  если значение режима не допустимо или если запрос не
мог быть удовлетворен.
<P>
<P>
<P>
<P>
<DT><B>-Макрос:  int _IOFBF </B><DD><P>Значение этой   макрокоманды   -  константа  integer,  которая  может
использоваться  как  параметр  режима   для   функции   setvbuf,   чтобы
определить, что поток должен быть полностью буферизирован.
<P>
<DT><B>-Макрос: int _IOLBF </B><DD><P>Значение  этой  макрокоманды  -  константа integer, которая может
использоваться как   параметр   режима   для   функции   setvbuf,  чтобы
определить, что поток должен быть буферизирован строчно.
<P>
<DT><B>-Макрос: int _IONBF </B><DD><P>Значение  этой  макрокоманды  -  константа integer, которая может
использоваться как   параметр   режима   для   функции   setvbuf,  чтобы
определить, что поток должен быть небуферизован.
<P>
<DT><B>-Макрос: int BUFSIZ </B><DD><P>Значение  этой  макрокоманды  -  константа integer, которую удобно
использовать как   параметр   size   для   setvbuf.  Это  значение,  как
гарантируют, будет по крайней мере 256.
<P>Значение BUFSIZ выбрано в каждой системе таким,  чтобы делать ввод
- вывод потока наиболее эффективным.
<P>Фактически, Вы  можете  лучшее  значение,  чтобы  использовать для
размера буфера посредством fstat системного вызова:  его можно  найти  в
st_blksize поле атрибутов файла. См. Раздел 9.8.1 [Значения Атрибута].
<P>Иногда также используют BUFSIZ как размер  распределения  буферов,
используемых для соответствующих целей,  типа строк, используемых,
чтобы получить строку ввода через  fgets  (см.  Раздел  7.6  [Символьный
Ввод]). Не имеется никакой специфической причины использовать BUFSIZ для
этого вместо любого другого integer,  за исключением того, что это могло
бы привести к выполнению ввода - вывода в кусках эффективного размера.
<P>
<DT><B>-Функция: void setbuf (FILE *stream,  char  *buf  ) </B><DD><P>Если  buf  - нулевой указатель, эффект этой функции эквивалентен
вызову setvbuf с  параметром  режима  _IONBF.  Иначе,  это  эквивалентно
вызову setvbuf с buf, и режимом _IOFBF и параметром size - BUFSIZ.
Функция setbuf предусмотрена для совместимости  со  старым  кодом;
используйте setvbuf во всех новых программах.
<P>
<DT><B>-Функция: void setbuffer (FILE *stream,  char *buf,  size_t size) </B><DD><P>
<P>Если buf - нулевой указатель, эта функция делает поток
небуферизованным. Иначе,  это делает поток полностью буферизированным  с
использованием buf в качестве  буфера. Параметр size определяет длину buf.
<P>Эта функция предусмотрена для совместимости со старым  BSD  кодом.
Используйте вместо нее setvbuf.
<P>
<DT><B>-Функция: void setlinebuf (FILE *stream) </B><DD><P>Эта функция делает поток  буферизированным  строчно,  и  распределяет
буфер  для  Вас.  Эта  функция предусмотрена совместимость со старым BSD
кодом. Используйте setvbuf вместо нее.
</DL>
<H2><A NAME="ss7.17">7.17 Другие Виды Потоков</A>
</H2>

<P>Библиотека GNU  обеспечивает  способы определить дополнительные виды
потоков, которые не обязательно соответствуют открытому файлу.
<P>Один такой тип потока берет ввод из или пишет вывод в строку.  Эти
виды  потоков используются внутренне,  чтобы выполнить функции sprintf и
sscanf.  Вы можете также создавать такой поток явно,  при  использовании
функций, описанных в Разделе 7.18.1 [Строковые Потоки].
<P>В более общем смысле,  Вы можете определять потоки, которые делают
ввод -вывод для произвольных объектов,  используя функции,  обеспеченные
вашей программой.  Этот протокол обсужден  в  Разделе  7.18.3  [Заказные
Потоки] .
<P>Примечание о  Переносимости:  средства,  описанные  в этом разделе
специфические для GNU.  Другие системы  или  реализации  C  могли  и  не
обеспечивать эквивалентные функциональные возможности.
<P>
<H3>Строковые  Потоки</H3>

<P>Функции  fmemopen   и   open_memstream  делали
ввод -  вывод  в  буфер  памяти  или  строку.  Эти  средства объявлены в
'stdio.h '.
<DL>
<DT><B>-Функция: FILE * fmemopen (void *buf,  size_t size,  const char *opentype) </B><DD><P>Эта функция открывает поток, который допускает доступ,
определенный параметром opentype, и который считывается или записывается
в буфер, определенный параметром buf. Этот массив должен быть по крайней
мере size байтов длиной.
<P>
<P>Если Вы  определяете нулевой указатель как параметр buf,  fmemopen
динамически   распределяет   (как   с    malloc;    см.    Раздел    3.3
[Беспрепятственное    Распределение])    size   байтовый   массив.   Это
действительно полезно только,  если Вы собираетесь записывать  что-то  в
буфер и затем читать это обратно,  т.  к.  Вы не имеете никакого способа
фактически  получить  указатель  на   буфер   (для   этого,   попробуете
open_memstream, ниже). Буфер освобождается, когда открывается поток.
Параметр opentype - такой же как в fopen (См. Раздел 7.3 [Открытие
Потоков]). Если opentype определяет режим конкатенирования, то начальная
файловая позиция устанавливается на  первый  символ  пробела  в  буфере.
Иначе начальная файловая позиция - в начале буфера.
<P>
<P>Для потока, открытого для чтения, пустые символы (нулевые байты) в
буфере не считаются концом файла. Операции чтения возвращают
конец  файла  только  когда файловая позиция продвигается за size байт.
Так, если Вы хотите читать символы из строки с нулевым символом в конце,
Вы должны обеспечить длину строки как аргумент size.
<P>
<P>Вот пример использования fmemopen для создания потока  для  чтения
из строки:
<BLOCKQUOTE><CODE>
<PRE>
 #include &lt;stdio.h&gt;

      static char buffer[] = 'foobar';

      int
      main (void)
      {
        int ch;
        FILE *stream;

        stream = fmemopen (buffer, strlen (buffer), 'r');
        while ((ch = fgetc (stream)) != EOF)
          printf ('Got %c\n', ch);
        fclose (stream);

        return 0;
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Эта программа производит следующий вывод:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      Got f
      Got o
      Got o
      Got b
      Got a
      Got r
</PRE>
</CODE></BLOCKQUOTE>
<DT><B>-Функция: FILE * open_memstream (char **ptr,  size_t *sizeloc) </B><DD><P>Эта функция открывает поток для записи в буфер. Буфер размещен
динамически (как   с   malloc;   см.   Раздел   3.3   [Беспрепятственное
Резервирование]) и растет по мере необходимости.
<P>
<P>Когда поток   закрывается   с помощью fclose   или    сбрасывается  с
помощью  fflush, указатели ptr и sizeloc модифицируются,  и содержат
указатель на  буфер и size. Значения, таким образом сохраненные остаются
допустимыми только, пока не происходит никакой дальнейший вывод на потоке.
Если, Вы выводите еще, Вы должны промыть поток, чтобы сохранить новые
значения прежде, чем Вы используете его снова.
<P>
<P>Пустой символ записывается в конце буфера.  Этот пустой символ  не
включен в значение size, сохраненное в sizeloc.
<P>
<P>Вы можете перемещать файловую позицию потока функцией  fseek  (см.
Раздел  7.15  [Позиционирование  Файла]).  Перемещение  файловой позиции
после конца уже записанных данных,  заполняет  захваченное  пространство
нулями.
<P>Вот пример использования open_memstream:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;stdio.h&gt;

      int
      main (void)
      {
        char *bp;
        size_t size;
        FILE *stream;

        stream = open_memstream (&amp;bp, &amp;size);
        fprintf (stream, 'hello');
        fflush (stream);
        printf ('buf = `%s', size = %d\n', bp, size);
        fprintf (stream, ', world');
        fclose (stream);
        printf ('buf = `%s', size = %d\n', bp, size);

        return 0;
      }
     Эта программа производит следующий вывод:
      buf = `hello', size = 5
      buf = `hello, world', size = 12
</PRE>
</CODE></BLOCKQUOTE>
</DL>
<H3>Obstack   Потоки</H3>

<P>Вы  можете  открывать  выходной  поток, который помещает данные в
obstack. См.  Раздел  3.4 [Obstack].
<DL>
<DT><B>-Функция: FILE * open_obstack_stream (struct obstack *obstack) </B><DD><P>
<P>Эта функция открывает поток для записи  данных в obstack. Она
начинает объект в obstack и увеличивает его, при записывании данных
(см. Раздел 3.4.6 [Возрастастающие Объекты]).
<P>
<P>Вызов fflush на этом потоке модифицирует текущий размер объекта, в
соответствии   с   количеством  данных,  которое  было  записано.  После
обращения к fflush, Вы можете исследовать объект.
<P>
<P>Вы можете  перемещать  файловую  позицию  obstack  потока функцией
fseek (см. Раздел 7.15 [Позиционирование Файла]).
<P>
<P>Чтобы сделать объект постоянным, модифицируйте obstack с fflush, и
тогда используйте obstack_finish  для  завершения  объекта  и  получения
адреса. Следующая запись в поток, начинает новый объект в obstack.
<P>
<P>Но как Вы узнаете,  какой длины объект? Вы можете получать длину
в  байтах,  вызывая  obstack_object_size  (см.  Раздел  3.4.8 [Состояние
Obstack]), или Вы можете пустым символом завершить объект, примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
   obstack_1grow (obstack, 0);
</PRE>
</CODE></BLOCKQUOTE>
<P>Вот типичная функция, которая использует open_obstack_stream:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 char *     make_message_string (const char *a, int b)
      {
        FILE *stream = open_obstack_stream (&amp;message_obstack);
        output_task (stream);
        fprintf (stream, ': ');
        fprintf (stream, a, b);
        fprintf (stream, '\n');
        fclose (stream);
        obstack_1grow (&amp;message_obstack, 0);
        return obstack_finish (&amp;message_obstack);
      }
</PRE>
</CODE></BLOCKQUOTE>
</DL>
<H3>Программирование  Ваших Собственных Потоков</H3>

<P>Этот  раздел описывает, как Вы можете создавать потоки, которые
берут ввод   из   произвольного  источника  данных  или  пишут  вывод  в
произвольный сток данных,  программируемый Вами. Назовем эти потоки
пользовательскими.
<P>
<H3>Пользовательские   Потоки  и  Cookies</H3>

<P>
<P>Внутри  каждого пользовательского   потока есть специальный объект
называемый cookie.  Это - объект,  определяемый  Вами, который указывает,
где берутся  или сохраняются данные.
<P>
<P>Чтобы реализовать пользовательский  поток,  Вы должны указать, как
выбирать или сохранять данные в заданном месте.  Это делается  определением
функции ловушки  для чтения,  записи,  изменения 'файловой позиции',  и
закрытия потока. Вся четыре из этих функций будут переданы cookie потока,
так чтоони могут сообщать, где брать или сохранять данные. Библиотечные
функции  не знают  что находится  внутри cookie, но ваши функции будут
знать.
<P>
<P>Когда Вы   создаете   пользовательский поток,  Вы  должны  задать
указатель на cookie,  а также четыре функции ловушки, содержащиеся  в
структуре типа struct cookie_io_functions.
<P>
<P>Эти средства объявлены в ' stdio.h '.
<DL>
<DT><B>-Тип даннаых: struct  cookie_io_functions </B><DD><P>Это  -  тип  структуры,  который  содержит функции, которые
определяют протокол  связи  между  потоком и cookie.  Он имеет следующие
элементы:
<DL>
<DT><B>cookie_read_function *read </B><DD><P>Это функция, которая читает данные из cookie. Если значение
является пустым указателем вместо функции,  то операции чтения на потоке
всегда возвращает EOF.
<P>
<DT><B>cookie_write_function *write </B><DD><P>Это - функция, которая пишет данные в cookie. Если значение
является пустым указателем вместо функции, то данные, записанные в поток
отбрасываются.
<DT><B>cookie_seek_function *seek </B><DD><P>Это  функция,  которая  выполняет   эквивалент позиционирования
файла на   cookie.  Если  значение  является  пустым  указателем  вместо
функции,  обращения к fseek на этом потоке,  может  искать  расположения
только  внутри  буфера;  любая попытка искать снаружи буфера,  возвратит
ESPIPE ошибку.
<DT><B>cookie_close_function *close </B><DD><P>Эта    функция   выполняет   любую   соответствующую сброс cookie
при закрытии  потока.  Если  значение  является пустым указателем вместо
функции, то при закрытии потока ничего не делается для закрытия cookie.
</DL>
<DT><B>-Функция:  FILE *  fopencookie  (void *cookie,  const char *opentype, struct </B><DD><P>
<P>Эта функция  фактически  создает  поток  для  сообщения  с  cookie
используя  функции   в   io_functions   аргументе.   Opentype   аргумент
интерпретируется как для fopen;  см.  Раздел 7.3 [Открытие Потоков]. (Но
отметьте что опция 'усечения при открытии'  игнорируется.)  Новый  поток
полностью буферизирован.
<P>
<P>Функция fopencookie возвращает недавно созданный поток, или пустой
указатель в случае ошибки.
</DL>
<P>
<H3>Пользовательские    Функции-Ловушки   Потока</H3>

<P>Имеется   большое количество деталей  определения четырех  функций
ловушки, которые  необходимы для пользовательского потока.
<P>Вы должны определить функцию для чтения данных из cookie как:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       ssize_t reader (void *cookie, void *buffer, size_t size)
</PRE>
</CODE></BLOCKQUOTE>

Это очень похоже на функцию read; см. Раздел 8.2 [Примитивы
ввода - вывода].  Ваша функция должна передать до size байтов в буфер, и
возвращать число прочитанных байтов,  или нуль указывая конец файла.  Вы
можете возвращать значение -1 для указания ошибки.
<P>
<P>
<P>
<P>
<P>Вы должны определить функцию, для записи данных в cookie как:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       ssize_t writer (void *cookie, const void *buffer, size_t size)
</PRE>
</CODE></BLOCKQUOTE>
 Это очень похоже на функцию write; см. Раздел 8.2 [Примитивы
ввода - вывода].  Ваша функция должна передать до size байтов из буфера,
и возвращать число записанных байтов.
<P>
<P>Вы должны   определить   функцию,    для    выполнения    операции
позиционирования на cookie как:
<BLOCKQUOTE><CODE>
<PRE>
       int seeker (void *cookie,  fpos_t *position,  int whence)
</PRE>
</CODE></BLOCKQUOTE>
<P>Для этой функции, position и whence аргументы интерпретируются
как для fgetpos;  см.  Раздел  7.16  [Переносимое  Позиционирование].  В
библиотеке  GNU,  fpos_t  эквивалентен  off_t  или  long  int,  и просто
представляет число байтов от начала файла.
<P>После выполнения операции установки, ваша функция должна сохранить
возникающую в результате файловую позицию относительно  начала  файла  в
position.  Ваша функция должна возвратить значение 0 в случае успеха,  и
-1 в случае ошибки.
<P>Вы должны определить функцию,  для операции очистки на cookie, при
закрытии потока как:
<BLOCKQUOTE><CODE>
<PRE>
       int cleaner  (void  *cookie)
</PRE>
</CODE></BLOCKQUOTE>
     Ваша  функция  должна возвратить -1, указывая ошибку,  или 0 иначе.
<DL>
<DT><B>-Тип данных: cookie_read_function </B><DD><P>
<P>Это - тип данных, который должна иметь функция чтения для
пользовательского потока. Если Вы объявляете функцию как показано выше, это
тип, который она будет иметь.
<P>
<DT><B>-Тип данных:  cookie_write_function </B><DD><P>Тип данных пишущей функции  для
пользовательского   потока.
<P>
<DT><B>-Тип данных: cookie_seek_function </B><DD><P>Тип данных функции инициализации  для пользовательского  потока.
<DT><B>-Тип данных: cookie_close_function </B><DD><P>Тип данных функции close для заказного потока.
</DL>
<HR>
<A HREF="glibc-8.html">Вперед</A>
<A HREF="glibc-6.html">Назад</A>
<A HREF="glibc.html#toc7">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
