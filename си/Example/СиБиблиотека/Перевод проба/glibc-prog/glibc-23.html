<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Дочерние Процессы</TITLE>
 <LINK HREF="glibc-24.html" REL=next>
 <LINK HREF="glibc-22.html" REL=previous>
 <LINK HREF="glibc.html#toc23" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-24.html">Вперед</A>
<A HREF="glibc-22.html">Назад</A>
<A HREF="glibc.html#toc23">Содержание</A>
<HR>
<H2><A NAME="s23">23. Дочерние Процессы</A></H2>

<P>
<P>
<P>Процессы - примитивные модули для резервирования ресурсов 
системы. Каждый процесс имеет собственное адресное пространство. 
Процесс выполняет программу; Вы можете иметь многократные процессы, 
выполняющие ту же самую программу, но каждый процесс имеет 
собственную копию программы внутри собственного адресного 
пространства и выполняет это независимо от других копий.
<P>Процессы организованы иерархически. Каждый процесс имеет 
родительский процесс. Процессы, созданные данным родителем 
называются дочерними процессами. Дочерний наследует многие из 
атрибутов родительского процесса.
<P>Эта глава описывает, как программа может создавать, завершать, и 
управлять дочерними процессами. Фактически, имеются три различных 
операции: создание нового дочернего процесса, назначение новому 
процессу выполнить программу, и координирование завершения 
дочернего процесса.
<P>Функция системы обеспечивает простой механизм для выполнения 
другой программы; он делает все три шага автоматически. Если Вы 
нуждаетесь в большом количестве контроля, Вы можете использовать 
примитивные функции, чтобы делать каждый шаг индивидуально.
<P>
<H2><A NAME="ss23.1">23.1 Выполнение Команды</A>
</H2>

<P>
<P>
<P>Простой способ выполнять другую программу состоит в том, чтобы 
использовать функцию system. Эта функция делает всю работу 
выполнения подпрограммы, но она не дает Вам контроля над 
подробностями: Вы должны ждать, пока подпрограмма не завершится 
прежде, чем Вы сможете делать что-нибудь еще.
<BLOCKQUOTE><CODE>
<PRE>
       int system (const char *command)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция выполняет command как команду оболочки. В библиотеке 
GNU C, она всегда использует заданную по умолчанию оболочку sh, 
чтобы выполнить команду. В частности она ищет каталоги в PATH, 
чтобы найти программу для выполнения. Возвращаемое значение -1, 
если не возможно создать процесс оболочки, иначе - состояние 
процесса оболочки. См. Раздел 23.6 [Завершение Процесса], для 
подробностей относительно того, как этот код состояния может 
интерпретироваться.
<P>Функция system объявлена в заглавном файле " stdlib.h ".
<P>Примечание Переносимости: Некоторые реализации C могут не иметь 
понятие командного процессора, который может выполнять другие 
программы. Вы можете определить, существует ли командный процессор,  
выполняя system (NULL); если возвращаемое значение отлично от нуля, 
командный процессор доступен.
<P>Popen и pclose функции (см. Раздел 10.2 [Трубопровод на 
Подпроцесса]) близко связаны функцией system. Они позволяют 
родительскому процессу связываться со стандартным вводом и  выводом 
выполняемой команды.
<P>
<H2><A NAME="ss23.2">23.2 Понятия Создания Процесса</A>
</H2>

<P>
<P>
<P>Этот раздел дает краткий обзор действий и шагов по созданию 
процесса и выполнения им другой программы.
<P>Каждый процесс именован ID процесса. Уникальный ID процесса дан 
каждому процессу при создании.
<P>Процессы создаются системным вызовом fork (так что операция 
создания нового процесса иногда вызывает раздваивание процесса). 
Дочерний процесс, созданный fork - точный аналог первоначального 
родительского процесса, за исключением того, что он имеет 
собственный ID.
<P>Если Вы хотите, чтобы ваша программа ждала завершения дочернего 
процесса, Вы должен делать это явно после операции fork, вызовом 
wait или waitpid (см. Раздел 23.6 [Завершение Процесса]). Эти 
функции дают Вам ограниченную информацию относительно того, почему 
завершился дочерний прцесс - например, код состояния exit.
<P>Раздвоенный дочерний процесс продолжает выполнять ту же самую 
программу как родительский процесс, в точке возвращения fork. Вы 
можете использовать возвращаемое значение от fork, чтобы отличить, 
выполняется ли программа в родительском процессе или в дочернем.
<P>Наличие нескольких процессов выполняющх ту же самую программу не 
очень полезно. Но дочерний может выполнять другую программу, 
используя одну из запускающих функций; см. Раздел 23.5 [Выполнение 
Файла]. Программа, которую процесс выполняет,  называется образом 
процесса. Начало выполнения новой программы заставляет процесс 
забыть все относительно предыдущего образа процесса; когда 
программа выходит, процесс тоже выходит, вместо того, чтобы 
возвратиться к предыдущему образу процесса.
<P>
<H2><A NAME="ss23.3">23.3 Идентификация Процесса</A>
</H2>

<P>
<P>Pid_t тип данных для ID процесса. Вы можете получить ID
процесса,  вызывая getpid. Функция getppid возвращает ID родителя 
текущего процесса (это также известно как ID родительского 
процесса). Ваша программа должна включить заглавные файлы " 
unistd.h " и " sys/types.h " чтобы использовать эти функции.
<BLOCKQUOTE><CODE>
<PRE>
       pid_t      (тип данных)
</PRE>
</CODE></BLOCKQUOTE>
       Pid_t тип данных - целое число со знаком, который способен 
представить ID процесса. В библиотеке GNU, это - int.
<BLOCKQUOTE><CODE>
<PRE>
       pid_t getpid (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Getpid функция возвращает ID текущего процесса.
<BLOCKQUOTE><CODE>
<PRE>
       pid_t getppid (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Getppid функция возвращает ID родителя текущего процесса.
<P>
<H2><A NAME="ss23.4">23.4 Создание Процесса</A>
</H2>

<P>
<P>
<P>Функция fork - примитив для создания процесса. Она объявлена в
заглавном файле " unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       pid_t fork (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция fork создает новый процесс.
<P>Если операция является успешной, то и родительский и дочерний 
процессы видят что fork возвращается, но с различными значениями: 
она возвращает значение 0 в дочернем процессе и ID порожденного 
процесса (ребенка) в родительском процессе.
<P>Если создание процесса потерпело неудачу, fork возвращает 
значение -1 в родительском процессе. Следующие errno условия ошибки 
определены для fork:
<DL>
<DT><B>EAGAIN </B><DD><P>не имеется достаточных ресурсов системы чтобы создать 
другой процесс, или пользователь уже имеет слишком много  
процессов.
<DT><B>ENOMEM </B><DD><P>процесс требует большего количества места чем система 
могла обеспечить.
</DL>

Специфические атрибуты дочернего процесса, которые отличаются от 
родительского процесса:
<UL>
<LI>        Дочерний процесс имеет собственный уникальный ID.</LI>
<LI>        ID родителя дочернего процесса - ID родительского процесса.</LI>
<LI>        Дочерний процесс получает собственные копии описателей 
открытых файлов родительского процесса. Впоследствии изменение 
атрибутов описателей файла в родительском процессе не будет 
воздействовать на описатели файла в дочернем, и наоборот. См. 
Раздел 8.7 [Операции Управления].</LI>
<LI>        Прошедшее процессорное время для дочернего процесса 
установлено на нуль; см. Раздел 17.1 [Процессорное время].</LI>
<LI>        Дочерний не наследует набор блокировок файла родительского 
процессоа. См. Раздел 8.7 [Операции Управления].</LI>
<LI>        Дочерний не наследует набор таймеров родительского процесса. 
См. Раздел 17.3 [Установка Сигнализации].</LI>
<LI>        Набор отложенных сигналов (см. Раздел 21.1.3 [Получение 
Сигналов] ) для дочернего процесса, очищен. (Дочерний процесс 
наследует маску блокированных сигналов и действий сигналов из 
родительского процесса.)</LI>
</UL>

<BLOCKQUOTE><CODE>
<PRE>
       pid_t vfork (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Vfork функция подобна fork, но более эффективна; однако, имеются 
ограничения, которым Вы должны следовать, чтобы использовать ее 
безопасно.
<P>В то время как fork делает полную копию адресного пространства 
вызывающего процесса и позволяет, и родителю и дочернему 
выполняться независимо, vfork не делает эту копию.
<P>Взамен, дочерний процесс, созданный с vfork совместно использует 
адресное пространство родителя, пока он не вызывает одну из функций 
exec. Тем временем, родительский процесс приостанавливает свое 
выполнение.
<P>Вы должны быть очень осторожны, чтобы не позволить дочернему 
процессу, созданному с vfork изменять любые глобальные данные или 
даже локальные переменные, общедоступнные с родителем. Кроме того, 
дочерний процесс не может возвращаться из (или делать длинный 
переход) функции, которая вызвала vfork! Это спутало бы информацию 
управления родительского процесса. Если Вы сомневаетесь, 
используйте fork.
<P>Некоторые операционные системы не выполняют vfork. Библиотека 
GNU C разрешает Вам использовать vfork на всех системах, но 
фактически выполняет fork, если vfork не доступна. Если Вы 
соблюдаете соответствующие предосторожности при использовании 
vfork, ваша программа будет работать, даже если система использует 
fork взамен.
<P>
<H2><A NAME="ss23.5">23.5 Выполнение Файла</A>
</H2>

<P>
<P>
<P>Этот раздел описывает совокупность exec функций, для выполнения 
файла как образа процесса. Вы можете использовать эти функции, 
чтобы заставить дочерний процесс выполнить новую программу после 
того, как он был раздвоен.
<P>Эти функции отличаются тем, как Вы определяете аргументы, но
они все делают ту же самую вещь. Они объявлены в заглавном файле " 
unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int execv (const char *filename, char *const argv[])  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Execv функция выполняет файл, именованный filename как новый 
образ процесса.
<P>Аргумент argv - массив строк с нулевым символом в конце, который 
используется, чтобы обеспечить значение для аргумента argv функции 
main программы, которая будет выполнена. Последний элемент этого 
массива должен быть пустой указатель. Обычно, первый элемент этого 
массива - имя файла программы. См. Раздел 22.1 [Аргументы 
Программы] , для подробностей относительно того, как программы 
могут обращаться к этим аргументам.
<P>Среда для нового образа процесса берется из переменной environ 
текущего образа процесса; см. Раздел 22.2 [Переменные среды], для 
уточнения инфрмации относительно сред.
<BLOCKQUOTE><CODE>
<PRE>
       int execl (const char *filename, const char *arg0, . . .)   (функция)
</PRE>
</CODE></BLOCKQUOTE>

Подобна execv, но строки argv определены индивидуально, а не как 
массив. Пустой указатель должен быть передан как последний такой 
аргумент.
<BLOCKQUOTE><CODE>
<PRE>
       int execve (const char *filename, char *const argv[], char  *const env[])
</PRE>
</CODE></BLOCKQUOTE>

Подобна execv, но разрешает Вам определять среду для новой 
программы явно как env аргумент. Это должен быть массив строк в том 
же самом формате как переменная environ; см. Раздел 22.2.1 [Доступ 
Среды].
<BLOCKQUOTE><CODE>
<PRE>
       int execle (const char *filename, const char *arg0, char *const env[], . . .)
</PRE>
</CODE></BLOCKQUOTE>

Подобна execl, но разрешает Вам определять среду для новой 
программы явно. Аргумент среды передан после пустого указателя, 
который отмечает последний аргумент argv, и должен быть массивом 
строк в том же самом формате как переменная environ.
<BLOCKQUOTE><CODE>
<PRE>
       int execvp (const char *filename, char *const argv[])  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Execvp функция подобна execv, за исключением того, что она ищет 
каталоги, перечисленные в переменной среды PATH (см. Раздел 22.2.2 
[Стандартная Среда]) чтобы найти полное имя файла filename, если 
filename не содержит наклонную черту вправо.
<P>Эта функция полезна для выполняющихся утилит системы, потому что 
она ищет их в местах, которые пользователь выбрал. Оболочки 
используют ее, чтобы выполнить команды написанные пользователем.
<BLOCKQUOTE><CODE>
<PRE>
       int execlp (const char *filename, const char *arg0, . . .)   (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - подобна execl, за исключением того, что она 
выполняет тот же поиск имени файла как в execvp.
<P>Размер списка параметров и списка среды, вместе не должен быть 
больше чем ARG_MAX байт. См. Раздел 27.1 [Общие Ограничения]. В 
системе GNU, размер (который сравнивается c ARG_MAX) включает, для 
каждой строки, число символов в строке, плюс размер char*, плюс 
один, округленный вверх после умножения на размер char*. Другие 
системы могут иметь несколько отличные правила для подсчета.
<P>Эти функции обычно не возвращаются, так как выполнение новой 
программы заставляет завершиться программу выполнения в настоящее 
время. Значение -1 возвращено в случае отказа. В дополнение к 
обычным синтаксическим ошибкам имени файла (см. Раздел 6.2.3 
[Ошибки Имени файла]), следующие errno условия ошибки определены 
для этих функций:
E2BIG объединенный размер списка параметров новой программы и 
списка среды больше чем ARG_MAX байт. Система GNU не имеет никакого 
специфического ограничения размера списка параметров, так что этот 
код ошибки не может получиться, но Вы можете получать ENOMEM 
взамен, если аргументы слишком большие для доступной памяти.
<DL>
<DT><B>ENOEXEC </B><DD><P>заданный файл не может быть выполнен, потому что он не 
находится в правильном формате.
<P>
<DT><B>ENOMEM </B><DD><P>Выполнение заданного файла требует большего количества 
памяти чем было доступно.
</DL>

Если выполнение нового файла преуспевает, это модифицирует поле 
времени доступа файла, как будто файл был прочитан. См. Раздел 
9.8.9 [Времена Файла].
<P>
<P>Выполнение нового образа процесса полностью не изменяет
содержимое памяти, копируются только аргументы и строки среды.
Но много других атрибутов процесса неизменяемы:
<UL>
<LI>         ID процесса и ID родительского процесса. См. Раздел 23.2 
[Понятия Создания Процесса].</LI>
<LI>         Групповая принадлежность сеанса и процесса. См. Раздел 24.1
[Понятия Управления заданиями].</LI>
<LI>         Реальный пользовательский ID, ID группы, и дополнительный ID 
группы. См. Раздел 25.2 [Владелец Процесса].</LI>
<LI>         Отложенные таймеры. См. Раздел 17.3 [Установка Сигнализации].</LI>
<LI>         Текущий рабочий каталог и корневой каталог. См. Раздел 9.1 
[Рабочий каталог].</LI>
<LI>         Маска режима создаваемого файла. См. Раздел 9.8.7 [Установка 
Прав].</LI>
<LI>         Маска сигналов Процесса; см. Раздел 21.7.3 [Маска сигналов 
Процесса].</LI>
<LI>         Отложенные сигналы; см. Раздел 21.7 [Блокированные Сигналы].</LI>
<LI>         Прошедшее процессорное время, связанное с процессом; см. 
Раздел 17.1 [Процессорное время]. Если set-user-ID и set-group-ID 
биты режима файла образа процесса установлены, это воздействует на 
эффективный ID пользователя и эффективный ID группы 
(соответственно) процесса. Эти понятия обсуждены подробно в Разделе 
25.2 [Владелец Процесса].</LI>
</UL>

Сигналы которые игнорируются в существующем образе процесса,  
также будут установлены, чтобы игнорироваться в новом образе 
процесса. Все другие сигналы будт установлены по умолчанию в новом 
образе процесса. См. Главу 21 [Обработка Сигнала].
<P>Описатели Файла, открытые в существующем образе процесса 
остаются открытыми в новом образе процесса, если они не имеют 
FD_CLOEXEC флага. Файлы, которые остаются открытыми, наследуют все 
атрибуты описания открытого файла из существующего образа процесса, 
включая блокировки файла. Описатели Файла обсуждены в Главе 8 [Ввод 
- вывод низкого уровня].
<P>Новый образ процесса не имеет никаких потоков за исключением 
тех, что он создает заново. 
<P>Каждый из потоков в предыдущем образе процесса имеет описатель 
внутри него, и эти описатели остаются после exec (если они не имеют 
FD_CLOEXEC). Новый образ процесса может повторно соединять их с 
новыми потоками, используя fdopen (см. Раздел 8.4 [Описатели и 
Потоки]). 
<P>
<H2><A NAME="ss23.6">23.6 Завершение Процесса</A>
</H2>

<P>
<P>
<P>Функции, описанные в этом разделе используются, чтобы ждать 
завершения или останова дочернего процесса и определять его 
состояние. Эти функции объявлены в заглавном файле " sys/wait.h ".
<BLOCKQUOTE><CODE>
<PRE>
       pid_t waitpid (pid_t pid, int *status_ptr, int options)   (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Waitpid функция используется, чтобы запросить информацию 
состояния дочернего процесса, чей ID является pid. Обычно, 
вызывающий процесс приостановлен, пока дочерний процесс не делает 
информацию состояния доступной, завершаясь.
<P>Другие значения для pid аргумента имеют специальные 
интерпретации. Значение -1 или WAIT_ANY информация состояния для 
любого дочернего процесса; значение 0 или WAIT_MYPGRP запрашивает 
информацию для любого дочернего процесса в той же самой группе 
процесса как вызывающий процесс; и любое другое отрицательное 
значение - pgid запрашивает информацию для любого дочернего 
процесса, чей ID группы - pgid.
<P>Если информация состояния дочернего процесса доступна 
немедленно, эта функция возвращается немедленно без ожидания. Если 
доступна информация состояния больше чем одного готового 
продолжиться дочернего процесса, один из них будет выбран 
беспорядочно, и его состояние возвращено немедленно. 
<P>Чтобы получить состояние других готовых продолжиться дочерних 
процессов, Вы должны вызвать waitpid снова.
<P>Аргумент options - битовая маска. Значение должно быть 
поразрядным ИЛИ (то есть `|') нуля или большого количества WNOHANG 
и WUNTRACED флагов. Вы можете использовать WNOHANG флаг, чтобы 
указать, что родительский процесс не должен ждать; и WUNTRACED 
флаг, чтобы запросить информацию состояния остановленных процессов 
также как процессов, которые завершились.
<P>Информация состояния дочернего процесса сохранена в объекте, на 
который указывает status_ptr, если status_ptr не пустой указатель.
<P>Возвращаемое значение - обычно ID дочернего процесса, о чьем 
состояние сообщено. Если WNOHANG опция была определена и никакой 
дочерний процесс, не ждет, чтобы быть отмеченным, то значение - 
нуль. Значение -1 возвращено в случае ошибки. Следующие errno 
ошибки определены для этой функции:
<DL>
<DT><B>EINTR     </B><DD><P>
<P>Функция была прервана получением сигнала. См. Раздел 21.5 
[Прерванные Примитивы].
<DT><B>ECHILD </B><DD><P>
<P>
<P>Не имеется никаких дочерних процессов, или заданный pid не 
дочерний для вызывающего процесса.
<DT><B>EINVAL </B><DD><P>
<P>
<P>Недопустимое значение аргумента options.
</DL>

Эти символические константы определены как значения для pid 
аргумента waitpid функции.
<BLOCKQUOTE><CODE>
<PRE>
       WAIT_ANY
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда (чье значение -1) определяет, что waitpid должен 
возвратить информацию состояния относительно любого дочернего 
процесса.
<BLOCKQUOTE><CODE>
<PRE>
       WAIT_MYPGRP
</PRE>
</CODE></BLOCKQUOTE>

Эта константа (со значением 0) определяет, что waitpid должен 
возвратить информацию состояния относительно любого дочернего 
процесса в той же самой группе процесса что и вызывающий процесс.
<P>Эти символические константы определены как флаги для аргумента 
options функции waitpid.
<P>Вы можете сделать OR флагов вместе, чтобы получить значение, и 
использовать его как аргумент.
<BLOCKQUOTE><CODE>
<PRE>
       WNOHANG
</PRE>
</CODE></BLOCKQUOTE>

Этот флаг определяет, что waitpid должна возвратиться немедленно 
вместо ожидания, если не имеется никакого дочернего процесса, 
готового быть отмеченным.
<BLOCKQUOTE><CODE>
<PRE>
       WUNTRACED
</PRE>
</CODE></BLOCKQUOTE>

Этот флаг определяет, что waitpid должна сообщить состояние 
любых дочерних процессов, которые были остановлены также как тех, 
которые завершились.
<BLOCKQUOTE><CODE>
<PRE>
       pid_t wait (int *status_ptr)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Это - упрощенная версия waitpid; используется, чтобы ждать пока 
не завершится любой дочерний процесс. Обращение:
<BLOCKQUOTE><CODE>
<PRE>
                        wait (&amp;status)
</PRE>
</CODE></BLOCKQUOTE>
       эквивалентно:
<BLOCKQUOTE><CODE>
<PRE>
                        waitpid (-1, &amp;status, 0)
</PRE>
</CODE></BLOCKQUOTE>

Имеется пример того, как использовать waitpid, чтобы получить 
состояние всех дочерних процессов, которые завершились, без какого&shy;
либо ожидания. Эта функция разработана, чтобы быть обработчиком для 
сигнала SIGCHLD, который указывает, что по крайней мере один 
дочерний процесс завершился.
<BLOCKQUOTE><CODE>
<PRE>
                void
                sigchld_handler (int signum)
                {
                        int pid;
                        int status;
                        while (1)
                        {
                                pid = waitpid (WAIT_ANY, &amp;status,           
                                                WNOHANG);
                                if (pid &lt; 0)
                                {
                                        perror ("waitpid");
                                        break;
                                }
                                if (pid == 0)
                                break;
                                notice_termination (pid, status);
                        }
                }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss23.7">23.7 Состояние Завершения Процесса</A>
</H2>

<P>
<P>
<P>Если значение состояния выхода (см. Раздел 22.3 [Завершение 
Программы]) дочернего процесса - нуль, то значение состояния, 
сообщенное waitpid или wait - также нуль. Вы можете проверять 
другие виды информации, закодированные в возвращенном значении
состояния, используя следующие макрокоманды. Эти макрокоманды 
определены в заглавном файле " sys/wait.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int WIFEXITED (int status)
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда возвращает значение отличное от нуля если 
дочерний процесс завершон exit или _exit.
<BLOCKQUOTE><CODE>
<PRE>
       int WEXITSTATUS (int status)
</PRE>
</CODE></BLOCKQUOTE>

Если WIFEXITED - истина, эта макрокоманда возвращает 8 битов 
младшего разряда значения состояния выхода из дочернего процесса. 
См. Раздел 22.3.2 [Состояние Выхода].
<BLOCKQUOTE><CODE>
<PRE>
       int WIFSIGNALED (int status)
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда возвращает значение отличное от нуля, если 
дочерний процесс завершен потому что он получил сигнал который не 
был обработан. См. Главу 21 [Обработка Сигнала].
<BLOCKQUOTE><CODE>
<PRE>
       int WTERMSIG (int status)
</PRE>
</CODE></BLOCKQUOTE>

Если WIFSIGNALED - истина, эта макрокоманда возвращает номер 
сигнала, который завершил дочерний процесс.
<BLOCKQUOTE><CODE>
<PRE>
       int WCOREDUMP (int status)
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда возвращает значение отличное от нуля, если 
дочерний процесс завершен и произведен core-файл.
<BLOCKQUOTE><CODE>
<PRE>
       int WIFSTOPPED (int status)
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда возвращает значение отличное от нуля, если 
дочерний процесс остановлен.
<BLOCKQUOTE><CODE>
<PRE>
       int WSTOPSIG (int status)
</PRE>
</CODE></BLOCKQUOTE>

Если WIFSTOPPED - истина, эта макрокоманда возвращает номер 
сигнала, который заставил дочерний процесс остановиться.
<P>
<H2><A NAME="ss23.8">23.8 BSD Функции Ожидания Процесса</A>
</H2>

<P>
<P>
<P>Библиотека GNU также обеспечивает эти средства для совместимости 
с UNIX BSD. BSD использует тип данных union, чтобы представить
значения состояния, а не int. Два представления фактически 
взаимозаменяемы; они описывают те же самые битовые шаблоны. 
Библиотека GNU C определяет макрокоманды типа WEXITSTATUS так, чтобы 
они работали на любом виде объекта, и функция wait определена, 
чтобы принять любой тип указателя как аргумент status_ptr.
<P>Эти функции объявлены в " sys/wait.h ".
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       union wait         (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных представляет значения состояния окончания 
программы. Он имеет следующие элементы:
<BLOCKQUOTE><CODE>
<PRE>
                        int w_termsig
</PRE>
</CODE></BLOCKQUOTE>

Значение этого элемента - то же что результат WTERMSIG 
макрокоманды.
<BLOCKQUOTE><CODE>
<PRE>
                        int w_coredump
</PRE>
</CODE></BLOCKQUOTE>

Значение этого элемента - результат WCOREDUMP макрокоманды.
<BLOCKQUOTE><CODE>
<PRE>
                        int w_retcode
</PRE>
</CODE></BLOCKQUOTE>

Значение этого элемента - результат WEXITSTATUS          макрокоманды.
<BLOCKQUOTE><CODE>
<PRE>
                        int w_stopsig
</PRE>
</CODE></BLOCKQUOTE>

Значение этого элемента - результат WSTOPSIG макрокоманды.
<P>Вместо того, чтобы обращаться к этим элементам непосредственно, 
Вы должны использовать эквивалентные макрокоманды.
<BLOCKQUOTE><CODE>
<PRE>
       pid_t wait3 (union wait *status_ptr, int options, struct rusage *usage)
</PRE>
</CODE></BLOCKQUOTE>

Если usage - пустой указатель, wait3 эквивалентна waitpid (-1, 
status_ptr, options).
<P>Если usage - не пустой символ, wait3 сохраняет тип использования 
для дочернего процесса в *rusage (но только, если дочерний 
завершился, а не остановился). См. Раздел 17.5 [Использование 
Ресурсов].
<BLOCKQUOTE><CODE>
<PRE>
       pid_t wait4 (pid_t pid, union wait *status_ptr, int options, struct rusage *usage)
</PRE>
</CODE></BLOCKQUOTE>

Если usage - пустой указатель, wait4 эквивалентна waitpid (pid, 
status_ptr, options).
<P>Если usage - не пустой символ, wait4 сохраняет тип использования 
для дочернего процесса в *rusage (но только, если дочерний 
завершился, а не остановился). См. Раздел 17.5 [Использование 
Ресурсов].
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss23.9">23.9 Пример Создания Процесса</A>
</H2>

<P>
<P>
<P>Вот пример программы, показывающий, как Вы могли бы написать 
функцию, подобную встроенной системе. Она выполняет аргумент 
command, используя " sh -c command ".
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stddef.h&gt;
                #include &lt;stdlib.h&gt;
                #include &lt;unistd.h&gt;
                #include &lt;sys/types.h&gt;
                #include &lt;sys/wait.h&gt;
                #define SHELL "/bin/sh"
                int
                my_system (const char *command)
                {
                        int status;
                        pid_t pid;
                        pid = fork ();
                        if (pid == 0)
                        {
                                execl (SHELL, SHELL, "-c", command,     
                                                        NULL);
                                _exit (EXIT_FAILURE);
                        }
                        else if (pid &lt; 0)
                                status = -1;
                        else
                        if (waitpid (pid, &amp;status, 0) != pid)
                                status = -1;
                        return status;
                }
</PRE>
</CODE></BLOCKQUOTE>

Имеется две вещей, на которые Вы должны обратить внимание в
этом примере.
<P>Не забудьте, что первый аргумент argv, представляет имя 
выполняемой программы. Именно поэтому, в обращении к execl, SHELL 
обеспечена один раз, чтобы назвать выполняемую программу, и второй 
раз, чтобы обеспечить значение для argv [0].
<P>Вызов execl в дочернем процессе не возвращается, если он 
успешен. Если он терпит неудачу, Вы должен делать кое-что, чтобы 
заставить дочерний процесс завершиться. Правильное поведение для 
дочернего процесса - сообщить отказ родительскому процессу.
<P>Вызовите _exit, чтобы выполнить это. Причина для использования 
_exit вместо exit состоит в том, чтобы избежать flush полностью 
буферизированных потоков типа stdout. Буфера этих потоков возможно 
содержат данные, которые были скопированы из родительского процесса 
функцией fork, эти данные будут выводиться в конечном счете 
родительским процессом. Вызов exit в дочернем вывел бы данные 
дважды. См. Раздел 22.3.5 [Внутренняя организация Окончания].
<P>
<P>
<HR>
<A HREF="glibc-24.html">Вперед</A>
<A HREF="glibc-22.html">Назад</A>
<A HREF="glibc.html#toc23">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
