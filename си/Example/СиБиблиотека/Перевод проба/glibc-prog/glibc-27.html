<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Параметры Конфигурации Системы</TITLE>
 <LINK HREF="glibc-28.html" REL=next>
 <LINK HREF="glibc-26.html" REL=previous>
 <LINK HREF="glibc.html#toc27" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-28.html">Вперед</A>
<A HREF="glibc-26.html">Назад</A>
<A HREF="glibc.html#toc27">Содержание</A>
<HR>
<H2><A NAME="s27">27. Параметры Конфигурации Системы</A></H2>

<P>
<P>
<P>Функции и макрокоманды, перечисленные в этой главе дают 
информацию относительно параметров конфигурации операционной 
системы, например, ограничений пропускной способности, присутствие 
необязательных POSIX возможностей, и заданный по умолчанию путь для 
исполняемых файлов (см. Раздел 27.12 [Строковые Параметры]).
<P>
<H2><A NAME="ss27.1">27.1 Общие Ограничения Пропускной способности</A>
</H2>

<P>
<P>POSIX.1 и POSIX.2 стандарты определяют ряд параметров, которые 
описывают ограничения пропускной способности системы. Эти 
ограничения могут быть фиксированные константы для данной 
операционной системы, или они могут изменяться от машины к машине.
<P>Каждый из следующих параметров ограничения имеет макрокоманду, 
которая определена в " limits.h " только, если система имеет 
фиксированное, однородное ограничение для рассматриваемого 
параметра. Если система позволяет различным файловым системам или 
файлам иметь различные ограничения, то макрокоманда неопределена; 
используйте sysconf, чтобы выяснить ограничение, которое 
применяется в специфическое время на специфической машине. См. 
Раздел 27.4 [Sysconf].
<P>Каждый из этих параметров также имеет другую макрокоманду, с 
именем, начинающимся с " _POSIX ", которая дает самое низкое 
значение, которое ограничению позволяется иметь на любой системе 
POSIX. См. Раздел 27.5 [Минимумы].
<BLOCKQUOTE><CODE>
<PRE>
       int ARG_MAX
</PRE>
</CODE></BLOCKQUOTE>

Если этот макрос определен, то это неизменяющийся максимум 
объединенной длины argv и  environ аргументов которые могут быть 
переданы функции exec.
<BLOCKQUOTE><CODE>
<PRE>
       int CHILD_MAX
</PRE>
</CODE></BLOCKQUOTE>

Если этот макрос определен, то это неизменяющееся число 
максимума процессов, которые могут существовать с тем же самым 
реальным пользовательским ID одновременно.
<BLOCKQUOTE><CODE>
<PRE>
       int OPEN_MAX
</PRE>
</CODE></BLOCKQUOTE>

Если этот макрос определен, то это неизменяющееся число 
максимума файлов, которые одиночный процесс может иметь открытым 
одновременно.
<BLOCKQUOTE><CODE>
<PRE>
       int STREAM_MAX
</PRE>
</CODE></BLOCKQUOTE>

Если этот макрос определен, то это неизменяющееся число 
максимума потоков, которые одиночный процесс может иметь открытым 
одновременно. См. Раздел 7.3 [Открытие Потоков].
<BLOCKQUOTE><CODE>
<PRE>
       int TZNAME_MAX
</PRE>
</CODE></BLOCKQUOTE>

Если этот макрос определен, то это неизменяющаяся максимальная 
длина имени часового пояса. См. Раздел 17.2.6 [Функции Часового 
пояса].
<P>Эти макрокоманды ограничений всегда определяются в " limits.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int NGROUPS_MAX
</PRE>
</CODE></BLOCKQUOTE>

Максимальное число ID дополнительных групп, которые один процесс 
может иметь.
<BLOCKQUOTE><CODE>
<PRE>
       int SSIZE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Самое большое значение, которое может содержаться в объекте типа 
ssize_t. Действительно, это - ограничение числа байтов, которые 
могут читаться или записываться в одиночной операции.
<P>Эта макрокоманда определена во всех системах POSIX, т. к. это 
ограничение никогда не переконфигурируется.
<BLOCKQUOTE><CODE>
<PRE>
       int RE_DUP_MAX  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самое большое число повторений, которое Вам позволяется в 
конструкции " \{min,max\} " в регулярном выражении.
<P>Эта макрокоманда определена во всех POSIX.2 системах, т. к. 
POSIX.2 говорит, что она должна всегда определяться, даже если не 
имеется никакого специфического наложенного ограничения.
<P>
<H2><A NAME="ss27.2">27.2 Полные Опции Системы</A>
</H2>

<P>
<P>POSIX определяет некоторые системно-специфические опции, которые 
не все системы POSIX поддерживают. Так как эти опции обеспечиваются 
в ядре, а не в библиотеке, просто использование библиотек GNU C не 
гарантирует любой из этих возможностей; это зависит от системы, 
которую Вы используете.
<P>Вы можете проверять доступность данной опции, используя 
макрокоманды в этом разделе, вместе с функцией sysconf. макрокоманды 
определены только, если Вы включаете " unistd.h ".
<P>Для следующих макрокоманд, если макрокоманда определена в " 
unistd.h ", то опция обеспечивается.
<P>Иначе, опция может или не может обеспечена; используйте sysconf 
для выяснения. См. Раздел 27.4 [Sysconf].
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX_JOB_CONTROL  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот символ определен, это указывает что система 
поддерживает управление заданиями. Иначе, реализация ведет себя, 
как будто все процессы внутри сеанса принадлежат одиночной группе 
процессов. См. Главу 24 [Управление заданиями]. 
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX_SAVED_IDS  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот символ определен, это указывает, что система 
запоминает эффективный ID пользователя и группы процесса прежде, 
чем она выполняет исполняемый файл с установкой set-user-ID или 
set-group-ID битов, и что явное изменение эффективного пользователя 
или группы обратно к этим значениям разрешается. Если эта опция не 
определена, то, если непривилегированный процесс изменяет 
эффективного пользователя или группу на реального пользователя или 
группу процесса, то он не может изменять их обратно снова. См. 
раздел 25.8 [ВКЛЮЧЕНИЕ/ОТКЛЮЧЕНИЕ Setuid].
<P>Для следующих макрокоманд, если макрокоманда определена в " 
unistd.h ", то значение указывает, обеспечивается ли опция. 
Значение -1 означает нет, а любое другое значение означает да. Если 
макрокоманда не определена, то опция может или не может 
обеспечиваться; используйте sysconf для выяснения. См. Раздел 27.4 
[Sysconf].
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX2_C_DEV  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот символ определен, это указывает, что система имеет 
POSIX.2 команду компилятора C, c89. Библиотека GNU C всегда 
определяет его как 1.
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX2_FORT_DEV  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот символ определен, это указывает, что система имеет 
POSIX.2 команду компилятора ФОРТРАНа, fort77. Библиотека GNU C 
никогда не определяет его, т. к. мы не знаем то, что система имеет.
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX2_FORT_RUN
</PRE>
</CODE></BLOCKQUOTE>

Если этот символ определен, это указывает, что система имеет 
POSIX.2 команду asa для интерпретирования управление каретки 
ФОРТРАНа. Библиотека GNU C никогда не определяет его, т. к. мы не 
знаем что имеет система.
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX2_LOCALEDEF  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот символ определен, это указывает, что система имеет 
POSIX.2 команду localedef. Библиотека GNU C никогда не определяет 
его.
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX2_SW_DEV  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот символ определен, это указывает, что система имеет 
POSIX.2 команды ar, make, и strip. Библиотека GNU C всегда 
определяет его как 1.
<P>
<H2><A NAME="ss27.3">27.3 Которая Версия POSIX Обеспечивается</A>
</H2>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       long int _POSIX_VERSION  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта константа представляет версию POSIX.1 стандарта который 
соответствует реализация. Для реализации, соответсвующей  1990 
POSIX.1 стандарту, значение - целое число 199009L.
_POSIX_VERSION всегда определяется (в " unistd.h ") в любой 
системе POSIX.
<P>Примечание Использования: Не пробуйте тестировать поддерживает 
ли система POSIX,  включая " unistd.h " и тогда проверяя, определен 
ли _POSIX_VERSION. На не - posix системах, это возможно выдаст 
ошибку, т. к. там нет никакого " unistd.h ". Мы не знаем  любого 
способа, которым Вы можете надежно проверять при трансляции, 
поддерживает ли ваша целевая система POSIX или существует ли " 
unistd.h ".
<P>Компилятор GNU C предопределяет символ __ POSIX __, если целевая 
система - система POSIX. Если Вы не используете любой, другие 
компиляторы на системах POSIX, проверяя определенный (__ POSIX __) 
надежно обнаружят такие системы.
<BLOCKQUOTE><CODE>
<PRE>
       long int _POSIX2_C_VERSION  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта константа представляет версию POSIX.2 стандарта, который 
поддерживает библиотека и ядро системы. Мы не знаем какое значение 
это будет для первой версии POSIX.2 стандарта, т. к. значение 
включает год и месяц, в котором стандарт официально принят.
<P>Значение этого символа не говорит ничто относительно утилит, 
установленных на системе.
<P>Примечание Использования: Вы можете использовать эту 
макрокоманду, чтобы проверить что POSIX.1 библиотека систем 
поддерживает POSIX.2 также. Любая POSIX.1 система содержит " 
unistd.h ", так что включайте этот файл и тогда проверяйте  defined 
(_POSIX2_C_VERSION).
<P>
<H2><A NAME="ss27.4">27.4 Использование sysconf</A>
</H2>

<P>
<P>
<P>Когда ваша система имеет ограничения системы с перестраиваемой 
конфигурацией, Вы можете использовать функцию sysconf для выяснения 
значений, которые применяются для любой специфической машины. 
Функция и связанные константы параметров объявлены в заглавном 
файле " unistd.h ".
<P>
<H3>Определение sysconf</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       long int sysconf (int parameter)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция используется, для запроса относительно параметров 
системы. Аргумент parameter должен быть один из " _SC_ " символов, 
перечисленных ниже.
<P>Нормальное возвращаемое значение из sysconf - значение, которое 
Вы запросили. Значение -1 возвращается, если реализация не налагает 
ограничения, и в случае ошибки.
<P>Следующие errno условия ошибки определены для этой функции:
<DL>
<DT><B>EINVAL </B><DD><P>значение параметра недопустимо.
</DL>
<H3>Константы для Sysconf Параметров</H3>

<P>
<P>
<P>Имеются символические константы которые используют как аргументы
в sysconf. Значения - все целочисленные константы (более 
специально, значения перечислимого типа).
<P>
<BLOCKQUOTE><CODE>
<PRE>
       _SC_ARG_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего ARG_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_CHILD_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего CHILD_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_OPEN_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего OPEN_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_STREAM_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего STREAM_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_TZNAME_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего TZNAME_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_NGROUPS_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего NGROUPS_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_JOB_CONTROL
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего 
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_JOB_CONTROL.
       _SC_SAVED_IDS
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего 
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_SAVED_IDS.
       _SC_VERSION
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего _POSIX_VERSION.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_CLK_TCK
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно параметра, соответствующего CLOCKS_PER_SEC; 
см. Раздел 17.1.1 [Основное Время CPU].
<BLOCKQUOTE><CODE>
<PRE>
       _SC_2_C_DEV
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно того, имеет ли система POSIX.2 команду 
компилятора C, c89.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_2_FORT_DEV
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно того, имеет ли система POSIX.2 команду 
компилятора ФОРТРАНа, fort77.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_2_FORT_RUN
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно того, ли система имеет POSIX.2 команду asa 
для интерпретирования управления каретки ФОРТРАНа.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_2_LOCALEDEF
</PRE>
</CODE></BLOCKQUOTE>

Запросите относительно того, имеет ли система POSIX.2 команду 
localedef.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_2_SW_DEV
</PRE>
</CODE></BLOCKQUOTE>

Запросите относительно того, имеет ли система POSIX.2 команды 
ar, make, и strip.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_BC_BASE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального значения obase в утилите bc.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_BC_DIM_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального размера массива в утилите bc.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_BC_SCALE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального значения масштаба в утилите 
bc.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_BC_STRING_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального размера строковой константы в 
утилите bc.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_COLL_WEIGHTS_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального числа весов, которые могут 
обязательно использоваться в определении последовательности 
объединений для стандарта.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_EXPR_NEST_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального числа выражений, вложенных 
внутри круглых скобок при использовании утилиты expr.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_LINE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального размера текстовой строки 
который POSIX.2 текстовые утилиты могут обрабатывать.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_EQUIV_CLASS_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно максимального числа весов, которые могут 
быть назначены на вход LC_COLLATE класса (" порядок " ключевое 
слово в определении стандарта). Библиотека GNU C не поддерживает 
определения стандарта.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_VERSION
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно номера версии POSIX.1 поддерживаемой ядром.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_2_VERSION
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно номера версии POSIX.2, поддерживаемой 
утилитами системы.
<BLOCKQUOTE><CODE>
<PRE>
       _SC_PAGESIZE
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно виртуального размера страницы памяти машины. 
Getpagesize возвращает то же самое значение. См. &lt;неопределенный&gt; 
[XXX getpagesize].
<P>
<P>
<P>
<P>
<H3>Примеры sysconf</H3>

<P>
<P>
<P>Мы рекомендуем, чтобы Вы сначала проверили макроопределение для 
параметра в котором Вы заинтересованы, и вызывали sysconf только, 
если макрокоманда не определена. Например, вот как проверяют 
обеспечивается ли управление заданиями:
<BLOCKQUOTE><CODE>
<PRE>
                int
                have_job_control (void)
                {
                #ifdef _POSIX_JOB_CONTROL
                        return 1;
                #else
                        int value = sysconf (_SC_JOB_CONTROL);
                        if (value &lt; 0)
                                fatal (strerror (errno));
                        return value;
                #endif
                }
       Here is how to get the value of a numeric limit:
                int
                get_child_max ()
                {
                #ifdef CHILD_MAX
                        return CHILD_MAX;
                #else
                        int value = sysconf (_SC_CHILD_MAX);
                        if (value &lt; 0)
                                fatal (strerror (errno));
                        return value;
                #endif
                }
</PRE>
</CODE></BLOCKQUOTE>
      
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss27.5">27.5 Минимальные Значения для Общих Ограничений Емкости</A>
</H2>

<P>
<P>
<P>Имеются названия для POSIX минимальных верхних пределов для 
параметров ограничений системы.
<P>Смысл этих значений состоит в том, что Вы можете безопасно помещать в 
эти ограничения без проверки, может ли специфическая система, которую Вы 
используете принять их.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_ARG_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - наименьшее ограничение, разрешенное POSIX 
для максимума объединенной длины argv и других аргументов, которые могут 
быть переданы запускаемой функции. Значение - 4096.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_CHILD_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды наименьшее ограничение разрешенное POSIX 
для максимального числа одновременных процессов на реального 
пользователя. Значение - 6.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_NGROUPS_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - наименьшее значение ограничения, 
разрешенное POSIX для максимального числа дополнительных групп процесса. 
Значение - 0.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_OPEN_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - наименьшее значение ограничения, 
разрешенное POSIX для максимального числа файлов, которые одиночный 
процесс может иметь открытым одновременно. Значение - 16.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_SSIZE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - наименьшее значение ограничения, 
разрешенное POSIX для максимального значения, которое может быть 
сохранено в объекте типа ssize_t. Значение - 32767.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_STREAM_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - наименьшее значение ограничения, 
разрешенное POSIX для максимального числа потоков, которые одиночный 
процесс может иметь открытым одновременно. Значение - 8.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_TZNAME_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - наименьшее значение ограничения, 
разрешенное POSIX для максимальной длины имени часового пояса. Значение - 3.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_RE_DUP_MAX
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - наименьшее значение ограничения, 
разрешенное POSIX для чисел, используемых в " \ {min, max\} " конструкциях в 
регулярном выражении. Значение - 255.
<P>
<H2><A NAME="ss27.6">27.6 Ограничения Емкости Файловой системы</A>
</H2>

<P>
<P>POSIX.1 стандарт определяет ряд параметров, которые описывают 
ограничения файловой системы. Система может иметь фиксированное, 
однородное ограничение для параметра, но это не обычный случай. На 
большинстве систем, для различных файловых систем (и, для некоторых 
параметров, даже для различных файлов) имеются различные максимальные 
ограничения. Например, если Вы используете NFS для устанавливки некоторых 
файловых систем из других машин.
<P>Каждая из следующих макрокоманд определена в " limits.h " только, если 
система имеет фиксированное, однородное ограничение для рассматриваемого 
параметра. Если система позволяет различным файловым системам или файлам 
иметь различные ограничения, то макрокоманда неопределена; используйте 
pathconf или fpathconf, чтобы выяснить ограничение, которое применяется к 
специфическому файлу. См. Раздел 27.9 [Pathconf].
<P>Каждый параметр также имеет другую макрокоманду, с именем, 
начинающимся с " _POSIX ", которая дает самое низкое значение, которое 
ограничению позволяется иметь на любой POSIX системе. См. Раздел 27.8 
[Минимумы Файла].
<BLOCKQUOTE><CODE>
<PRE>
       int LINK_MAX     (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Однородное ограничение системы для числа имен для данного файла. См. 
Раздел 9.3 [Жесткие связи].
<BLOCKQUOTE><CODE>
<PRE>
       int MAX_CANON    (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Однородное ограничение системы для количества текста в строке ввода, 
когда допускается входное редактирование. См. Раздел 12.3 [Каноническиий 
или Нет].
<BLOCKQUOTE><CODE>
<PRE>
       int MAX_INPUT    (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Однородное ограничение системы для общего числа символов, печатаемых 
вперед как ввод. См. Раздел 12.2 [Очереди ввода - вывода].
<BLOCKQUOTE><CODE>
<PRE>
       int NAME_MAX     (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Однородное ограничение системы для длины компонента имени файла.
<BLOCKQUOTE><CODE>
<PRE>
       int PATH_MAX     (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Однородное ограничение системы для длины всего имени файла (то есть 
аргумент, данный системным вызовам типа open).
<BLOCKQUOTE><CODE>
<PRE>
       int PIPE_BUF     (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Однородное ограничение системы для числа байтов, которые можно 
написать в трубопровод быстро. См. Главу 10 [Трубопроводы и FIFOs].
<P>Это - альтернативные имена макрокоманд.
<BLOCKQUOTE><CODE>
<PRE>
       int MAXNAMLEN    (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это - имя BSD для NAME_MAX. Она определена в " dirent.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int FILENAME_MAX (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - целочисленное постоянное выражение, 
которое представляет максимальную длину строки имени файла. Она 
определена в " stdio.h ".
<P>В отличие от PATH_MAX, эта макрокоманда определена, даже если не 
имеется никакого фактического наложенного ограничения. В таком случае, 
значение - обычно очень большое количество. Так всегда в системе GNU.
<P>Примечание Использования: Не используйте FILENAME_MAX как размер 
массива,  чтобы сохранить имя файла! Вы не можете возможно делать массив 
таким большим! Используйте динамическое резервирование (см. Главу 3 
[Распределение памяти]).
<P>
<H2><A NAME="ss27.7">27.7 Необязательные Возможности в Поддержке Файлов</A>
</H2>

<P>
<P>POSIX определяет некоторые системно-специфические опции в системных 
вызовах для файлов. Некоторые системы поддерживают эти опции, а другие - 
нет. Так как эти опции обеспечиваются в ядре, а не в библиотеке, просто 
использование библиотеки GNU С не гарантирует, что любая из этих 
возможностей обеспечивается; это зависит от системы, которую Вы 
используете. Они могут также изменяться между файловыми системами на
одиночной машине.
<P>Этот раздел описывает макрокоманды, которые Вы можете проверять, 
чтобы определить, обеспечивается ли специфическая опция на вашей машине. 
Если данная макрокоманда определена в " unistd.h ", то значение, говорит
обеспечивается ли соответствующая возможность. (Значение -1 указывает нет; 
любое другое значение указывает да.) если макрокоманда неопределена, это 
означает специфические файлы  могут и не поддерживать эту возможность.
<P>Так как все машины, которые поддерживают библиотеку GNU C также 
поддерживают NFS, можно делать общее утверждение относительно того,
все ли файловые системы поддерживают возможности _POSIX_NO_TRUNC и
_POSIX_CHOWN_RESTRICTED. Так что эти имена никогда не определены как 
макрокоманды в библиотеке GNU C.
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX_CHOWN_RESTRICTED  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если эта опция есть, chown функция ограничена так, что единственые 
изменения, разрешенные непривилегированным процессам:  изменить 
владельца группы файла либо на эффективный ID группы процесса, либо на один 
из ID дополнительных групп. См. Раздел 9.8.4 [Владелец Файла].
<BLOCKQUOTE><CODE>
<PRE>
       int _POSIX_NO_TRUNC  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если эта опция обеспечивается, когда компоненты имени файла длиннее
чем NAME_MAX, генерируется ENAMETOOLONG ошибка. Иначе, компоненты имени
файла, которые являются слишком длинными будут тихо усечены.
<BLOCKQUOTE><CODE>
<PRE>
       unsigned char _POSIX_VDISABLE  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта опция значима только для файлов, которые являются устройствами 
терминала. Если она допускается, то обработчик для специальных управляющих 
символов, может быть заблокирован индивидуально. См. Раздел 12.4.9 
[Специальные Символы].
<P>Если одна из этих макрокоманд является неопределенной, это означает что 
эта опция может быть определена в действительности для некоторых файлов 
и не определена для других. Чтобы запрашивать относительно специфического 
файла, вызовите pathconf или fpathconf. См. Раздел 27.9 [Pathconf].
<P>
<H2><A NAME="ss27.8">27.8 Минимальные Значения для Ограничений Файловой системы</A>
</H2>

<P>
<P>
<P>Имеются имена для POSIX минимальных верхних пределов для некоторых из 
вышеупомянутых параметров.
<P>Смысл этих значений состоит в том, что Вы можете безопасно помещать в 
эти ограничения без проверки, может ли специфическая система, которую Вы 
используете принять их.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_LINK_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX для максимального 
значения числа связей файла. Значение этой константы - 8; таким образом, Вы 
можете всегда создавать до восьми имен для файла без  столкновений с 
ограничением системы.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_MAX_CANON
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX для максимального 
числа байтов в каноническиой входной строке из устройства терминала. 
Значение этой константы - 255.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_MAX_INPUT
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX для максимального 
числа байтов во входной очереди устройства терминала (или буфере 
клавиатуры). См. Раздел 12.4.4 [Режимы Ввода]. Значение этой константы - 255.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_NAME_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX для максимального 
числа байтов в компоненте имени файла. Значение этой константы - 14.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_PATH_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX для максимального 
числа байтов в имени файла. Значение этой константы - 255.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_PIPE_BUF
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX для максимального 
числа байтов, которые можно написать в трубопровод быстро. Значение этой 
константы - 512.
<P>
<H2><A NAME="ss27.9">27.9 Использование pathconf</A>
</H2>

<P>
<P>
<P>Когда ваша машина позволяет различным файлам иметь различные 
значения для параметра файловой системы, Вы можете использовать функции в 
этом разделе, чтобы выяснить значение, которое применяется к любому 
специфическому файлу.
<P>Эти функции и связанные константы для аргумента parameter объявлены в 
заглавном файле " unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       long int pathconf (const char *filename, int parameter)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция используется, чтобы запросить относительно ограничений, 
которые применяются к файлу, именованному filename.
<P>Аргумент parameter должен быть одной из " _PC_ " констант,
перечисленных ниже.
<P>Нормальное возвращаемое значение из pathconf - значение, которое Вы 
запросили. Значение -1 будет возвращено, если реализация не налагает 
ограничений, и в случае ошибки.
<P>В вышеупомянутом случае, errno не установлена, в то время как в последнем 
случае, errno установлена, чтобы указать причину проблемы. Так что 
единственый способ использовать эту функцию robustly состоит в том, чтобы 
сохранить 0 в errno перед ее вызовом.
<P>Кроме обычных синтаксических ошибок имени файла (см. Раздел 6.2.3 
[Ошибки Имени файла]), следующие условия ошибки определены для этой 
функции:
<DL>
<DT><B>EINVAL </B><DD><P>значение параметра недопустимо, или реализация не 
поддерживает параметр для специфического файла.
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       long int fpathconf (int filedes, int parameter)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Точно такая же как pathconf за исключением того, что вместо имени файла 
используется описатель открытого файла, чтобы определить файл, для 
которого запрошена информация.
<P>Следующие errno условия ошибки определены для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>filedes аргумент - не допустимый описатель файла.
<DT><B>EINVAL </B><DD><P>значение параметра недопустимо, или реализация не 
поддерживает параметр для специфического файла.
</DL>

Имеются символические константы, которые Вы можете использовать как 
аргумент parameter в  pathconf и fpathconf. Значения - целочисленные константы.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_LINK_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения LINK_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_MAX_CANON
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения MAX_CANON.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_MAX_INPUT
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения MAX_INPUT.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_NAME_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения NAME_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_PATH_MAX
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения PATH _MAX.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_PIPE_BUF
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения PIPE_BUF.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_CHOWN_RESTRICTED
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения _POSIX_CHOWN_RESTRICTED.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_NO_TRUNC
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения _POSIX_NO_TRUNC.
<BLOCKQUOTE><CODE>
<PRE>
       _PC_VDISABLE
</PRE>
</CODE></BLOCKQUOTE>

Запрос относительно значения _POSIX_VDISABLE.
<P>
<H2><A NAME="ss27.10">27.10 Ограничения для Утилит</A>
</H2>

<P>
<P>POSIX.2 стандарт определяет некоторые ограничения системы, к которым 
Вы можете обращаться через sysconf, которые относятся  к поведению
некоторых утилит а не к поведению библиотеки или операционной системы.
<P>Библиотека GNU C определяет макрокоманды для этих ограничений, и 
sysconf возвращает значения для них, если Вы спрашиваете; но эти значения не 
передают никакую значимую информацию. Они - просто самые маленькие 
значения которые POSIX. 2 разрешает.
<BLOCKQUOTE><CODE>
<PRE>
       int BC_BASE_MAX  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самое большое значение obase, который утилита bc, как гарантируют, 
будет поддерживать.
<BLOCKQUOTE><CODE>
<PRE>
       int BC_SCALE_MAX (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самое большое значение масштаба, который утилита bc, как гарантируют, 
будет поддерживать.
<BLOCKQUOTE><CODE>
<PRE>
       int BC_DIM_MAX   (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самое большое число элементов в одном массиве, который утилита bc, как 
гарантируют,  будет поддерживать.
<BLOCKQUOTE><CODE>
<PRE>
       int BC_STRING_MAX        (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самое большое число символов в одной строковой константе, которую 
утилита bc, как гарантируют,  будет поддерживать.
<BLOCKQUOTE><CODE>
<PRE>
       int BC_DIM_MAX   (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самое большое число элементов в одном массиве, который утилита bc, как 
гарантируют,  будет поддерживать.
<BLOCKQUOTE><CODE>
<PRE>
       int COLL_WEIGHTS_MAX     (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самое большое число весов, которые могут обязательно использоваться в 
определении последовательности объединений для стандарта.
<BLOCKQUOTE><CODE>
<PRE>
       int EXPR_NEST_MAX        (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Максимальное число выражений, которые могут быть вложены круглыми 
скобками для утилиты expr.
<BLOCKQUOTE><CODE>
<PRE>
       int LINE_MAX     (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Самая большая текстовая строка, которую POSIX.2 текстовые утилиты 
могут поддерживать. (Если, Вы используете GNU версии этих утилит, то нет 
никакого фактического ограничения за исключением тех, что наложены 
доступной виртуальной памятью, но  не никакого способа, которым библиотека 
может сообщать Вам это.)
<P>
<H2><A NAME="ss27.11">27.11 Минимальные Значения для Пределов Утилит</A>
</H2>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_BC_BASE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX.2 для максимального 
значения obase в утилите bc. Значение - 99.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_BC_DIM_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX.2 для максимального 
размера массива в утилите bc. Значение - 2048.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_BC_SCALE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX.2 для максимального 
значения масштаба в утилите bc. Значение - 99.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_BC_STRING_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX. 2 для максимального 
размера строковой константы в утилите bc. Значение - 1000.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_COLL_WEIGHTS_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX. 2 для максимального 
числа весов, которые могут использоваться в определении 
последовательности объединений для стандарта. Значение - 2.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_EXPR_NEST_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX. 2 для максимального 
числа выражений, вложенных внутри круглых скобок при использовании утилиты 
expr. Значение - 32.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX2_LINE_MAX
</PRE>
</CODE></BLOCKQUOTE>

Наименьшее значение предела, разрешенное POSIX. 2 для максимального 
размера текстовой строки, которую текстовые утилиты могут обрабатывать. 
Значение - 2048.
<P>27.12 Строковые Параметры
<P>POSIX. 2 определяет способ получить строковые параметры из 
операционной системы - функцией confstr:
<BLOCKQUOTE><CODE>
<PRE>
       size_t confstr (int parameter, char *buf, size_t len)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция читает значение строкового параметра системы, сохраняя 
строку в len байты пространства памяти, начинающегося в buf. Аргумент 
parameter должен быть один из " _CS_ " символов, перечисленных ниже.
<P>Нормальное возвращаемое значение из confstr - длина строкового значения, 
о котором Вы просили. Если Вы обеспечиваете пустой указатель для buf, то 
confstr, не пробует сохранять строку; она только возвращает длину. Значение 0 
указывает ошибку.
<P>Если строка, о которой Вы просили, слишком длинная для буфера (то есть 
длиньше чем len - 1), то confstr сохраняет только то что помещается (оставляя 
участок памяти для пустого символа завершения). Вы можете понять, что это 
случилось, потому что confstr возвращает значение больше чем или равный len.
<P>Следующие errno условия ошибки определены для этой функции:
<DL>
<DT><B>EINVAL </B><DD><P>значение параметра недопустимо.
</DL>

В настоящее время имеется только один параметр, который Вы можете 
читать с confstr:
<P>_CS_PATH значение этого параметра - рекомендуемый заданный по 
умолчанию путь для поиска исполняемых файлов. Это - путь, который 
пользователь имеет по умолчанию только после регистрации.
<P>Способ использовать confstr без любого произвольного ограничения 
строкового размера состоит в том, чтобы вызвать ее дважды: сначала 
вызвать ее, чтобы получить длину, зарезервировать буфер соответственно, и 
тогда вызывать confstr снова, чтобы заполнить буфер, примерно так:
<BLOCKQUOTE><CODE>
<PRE>
        char *
        get_default_path (void)
        {
                size_t len = confstr (_CS_PATH, NULL, 0);
                char *buffer = (char *) xmalloc (len);
                if (confstr (_CS_PATH, buf, len + 1) == 0) {
                        free (buffer);
                        return NULL;
                }
                return buffer;
         }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<P>
<P>
<HR>
<A HREF="glibc-28.html">Вперед</A>
<A HREF="glibc-26.html">Назад</A>
<A HREF="glibc.html#toc27">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
