<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Интерфейс Терминала низкого уровня</TITLE>
 <LINK HREF="glibc-13.html" REL=next>
 <LINK HREF="glibc-11.html" REL=previous>
 <LINK HREF="glibc.html#toc12" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-13.html">Вперед</A>
<A HREF="glibc-11.html">Назад</A>
<A HREF="glibc.html#toc12">Содержание</A>
<HR>
<H2><A NAME="s12">12. Интерфейс Терминала низкого уровня</A></H2>

<P>
<P>Эта глава описывает функции, которые являются специфическими для
терминальных устройств. Вы можете использовать эти функции для действий
аналогичным выключению входного отображения на экране,
установки характеристик строки типа быстродействия строки и
управления потоком данных, и изменения символов используемых для обозначения
конца файла, редактирования командной строки, посылки сигналов, и подобных функций управления.
<P>Большинство функций в этой главе использует на описатели
файлов. См. Главу 8 [ввод-вывод низкого уровня] для получения
более подробной информации, чем описатель файла является и как
открыть описатель файла для устройства терминала.
<P>
<H2><A NAME="ss12.1">12.1 Идентификация Терминалов</A>
</H2>

<P>
<P>Функции, описанные в этой главе работают с файлами, которые
соответствуют терминальному устройству. Используя функцию isatty, Вы можете
выяснять, связан ли описатель файла с терминалом.
<P>Прототипы и для isatty и ttyname объявлены в файле "unistd.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int isatty (int filedes)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает 1, если filedes - описатель файла,
связанный с открытым терминальным устройством, и 0 в противном случае.
<P>Если описатель файла связан с терминалом, Вы может получать
связанное имя файла, используя функцию ttyname. См. также ctermid
функцию, описанную в Разделе 24.7.1 [Идентификация Терминала].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char * ttyname (int filedes)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Если описатель файла filedes связан с терминальным устройством, то
функция ttyname возвращает указатель на статически размещенную
строку с нулевым символом в конце, содержащую имя файла терминала.
Значение - пустой указатель, если описатель файла не связан с
терминалом, или имя файла не может быть определено.
<P>
<H2><A NAME="ss12.2">12.2 Очереди Ввода-вывода</A>
</H2>

<P>
<P>Многие из функций в этом разделе обращаются к очередям ввода и
вывода терминального устройства. Эти очереди определяют форму
буферизации внутри ядра, которое независит от буферизации, выполненной
потоками ввода-вывода (см. Главу 7 [ввод-вывод на Потоках]).
<P>Входная очередь терминала также иногда упоминается как буфер
клавиатуры. Она содержит символы, которые были получены от
терминала, но еще не прочитанны ни каким процессом.
<P>Размер входной очереди терминала описан параметрами _POSIX
_MAX_INPUT и MAX_INPUT; см. Раздел 27.6 [Ограничения для Файлов].
Если управление потоком данных ввода допускается  установкой бита
режима ввода IXOFF (см. Раздел 12.4.4 [Входные Режимы]), драйвер
терминала передает символы STOP и START на терминал, когда
необходимо предохранить очередь от переполнения. Иначе, ввод
можно потерять при сликшом быстром поступлении данных с терминала. (Это
маловероятно, если Вы печатаете ввод вручную!)
<P>Очередь вывода терминала подобна входной очереди, но для вывода
она содержит символы, которые написаны процессами, но еще не
передавались на терминал. Если управление потоком данных вывода
допускается установкой бита режима ввода IXON (см. Раздел 12.4.4
[Входные Режимы]), то драйвер терминала удовлетворяет условиям
символов STOP и STOP, посланных терминалом, чтобы остановиться и
перезапустить передачу вывода.
<P>Очистка входной очереди терминала означает отбрасывание любых
символов, которые были получены, но еще не прочитаны. Аналогично,
очистка очереди вывода терминала означает отбрасывание любых
символов, которые написаны, но еще не передавались.
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss12.3">12.3 Два Стиля Ввода: каноническиий и неканонический.</A>
</H2>

<P>
<P>Системы POSIX поддерживают два базисных режима ввода:
каноническиий и неканоническиий.
<P>В каноническом входном режиме ввод с терминала обрабатывается построчно,
строка оканчивается символом перевода строки ("\n"), символами
EOF, или EOL. Ввод не может закончиться, пока вся строка не напечатана
пользователем.
<P>В каноническиом входном режиме, операционная система
обеспечивает входное редактирование: символы ERASE и KILL
интерпретируются особо для выполнения операций редактирования
внутри текущей строки текста. См. Раздел 12.4.9.1 [Редактирование
Символов].
<P>Константы _POSIX_MAX_CANON и MAX_CANON указывают максимальное
число байтов, которые могут появляться в одиночной строке
каноническиого ввода. См. Раздел 27.6 [Ограничения для Файлов].
<P>В неканоническиом входном режиме обработки символы не
сгруппированы в строки, и ERASE, и KILL не выполняются. Степень
детализации, с которой байты читаются в неканоническиом входном
режиме,  управляется MIN и TIME. См. Раздел 12.4.10
[Неканоническиий Ввод].
<P>Большинство программ использует каноническиий входной режим,
потому что это дает пользователю способ редактировать входную
строку. Обычной причиной для использования неканонического режима является
необходимость программой принимать одиночно-символьные команды или
предоставлять собственные средства редактирования.
<P>Выбор каноническиого или неканоническиого ввода управляется флагом
ICANON в элементе _lflag в  struct termios. См. Раздел 12.4.7
[Автономные режимов].
<P>
<P>
<P>
<H2><A NAME="ss12.4">12.4 Режимы Терминала</A>
</H2>

<P>
<P>Этот раздел описывает различные атрибуты терминала, которые
управляют вводом и выводом. Функции, структуры данных, и
символические константы объявлены в файле " termios.h".
<P>
<H3>Типы Данных Режима Терминала</H3>

<P>
<P>Вся коллекция атрибутов терминала сохранена в структуре типа
struct termios. Эта структура используется функциями tcgetattr и
tcsetattr, чтобы читать и установливать атрибуты.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct termios  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это структура, которая записывает все атрибуты ввода-вывода
терминала. Структура включает по крайней мере следующие элементы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    tcflag_t c_iflag
</PRE>
</CODE></BLOCKQUOTE>

Битовая маска, определяющая флаги для режимов ввода; см. Раздел
12.4.4 [Режимы Ввода].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    tcflag_t c_oflag
</PRE>
</CODE></BLOCKQUOTE>

Битовая маска, определяющая флаги для режимов вывода; см. Раздел
12.4.5 [Режимы вывода].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    tcflag_t c_cflag
</PRE>
</CODE></BLOCKQUOTE>

Битовая маска, определяющая флаги для режимов управления; см.
Раздел 12.4.6 [Режимы Управления].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    tcflag_t c_lflag
</PRE>
</CODE></BLOCKQUOTE>

Битовая маска, определяющая флаги для автономных режимов; см.
Раздел 12.4.7 [Автономные режимы].
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    cc_t c_cc[NCCS]
</PRE>
</CODE></BLOCKQUOTE>

Массив, определяющий, символы связаные  с различными
функциями управления; см. Раздел 12.4.9 [Специальные Символы].
<P>Структура struct termios также содержит элементы, которые
кодируют скорости передачи ввода и вывода, но представление не
преднано. См. Раздел 12.4.8 [Быстродействие Строки], для того,
как исследовать и сохранять значения быстродействия.
<P>Следующие разделы описывают подробности элементов структуры
struct termios.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    tcflag_t      (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это тип integer unsigned, используемый, чтобы представить
различные битовые маски для флагов терминала.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    cc_t                          (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это тип integer unsigned, используемый, чтобы представить
символы, связанные с различными функциями управления терминала.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int NCCS      (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Значение этой макрокоманды - число элементов в массиве c_cc.
<P>
<H3>Функции Режимов Терминала</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int tcgetattr (int filedes, struct termios *termios_p) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция используется, чтобы исследовать атрибуты терминального
устройства с описателем файла filedes. Атрибуты возвращены в
структуре на которую указывает termios_p.
<P>В случае успеха tcgetattr возвращает 0. Возвращаемое значение -1
указывает ошибку. Следующие условия ошибки errno  определены для
этой функции:
<DL>
<DT><B>EBADF </B><DD><P>filedes аргумент - не допустимый описатель файла.
<P>
<DT><B>ENOTTY </B><DD><P>filedes не связан с терминалом.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       int tcsetattr (int filedes, int when, const struct termios *termios_p) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция устанавливает атрибуты устройства терминала с
описателем файла filedes. Новые атрибуты принимаются из заданной
структуры.
<P>Аргумент when определяет, как поступать с вводом и выводом, уже
поставленным в очередь. Это может быть одно из следующих значений:
<DL>
<DT><B>TCSANOW </B><DD><P>Делать изменения немедленно.
<P>TCSADRAIN
Делать изменения после ожидания, пока весь поставленный в
очередь вывод не написан.
<P>Вы должны обычно использовать эту опцию при изменении
параметров, которые воздействуют на вывод.
<P>
<DT><B>TCSAFLUSH </B><DD><P>подобен TCSADRAIN, но отбрасывает любой поставленный в
очередь ввод.
<P>
<DT><B>TCSASOFT </B><DD><P>Это бит флага, который Вы можете добавлять к любому
из вышеупомянутых вариантов. Значение должно запретить чередование
состояния аппаратных средств терминала. Это BSD расширение; он не
имеет никакого эффекта в не-BSD системах.
</DL>

Если эта функция вызывается из фонового процесса на терминале
управления, то все процессы в группе этого процесса посылается сигнал
SIGTTOU, как будто процесс пробовал запись на терминал. Исключение &shy;
если процесс вызова непосредственно игнорирует или блокирует сигналы
SIGTTOU См. Главу 24 [Управление заданиями].
<P>При успехе tcsetattr возвращает 0. Возвращаемое значение -1
указывает ошибку. Следующие условия ошибки errno определены для
этой функции:
<DL>
<DT><B>EBADF </B><DD><P>filedes аргумент - не допустимый описатель файла.
<DT><B>ENOTTY </B><DD><P>filedes не связан с терминалом.
<DT><B>EINVAL </B><DD><P>или значение аргумента when не допустимо, или ошибка с данными
в аргументе termios_p .
</DL>

Хотя tcgetattr и tcsetattr определяют устройство терминала
описателем файла, атрибуты - сами устройства терминала
непосредственно, а не описателя файла. Это означает, что эффект
изменения атрибутов терминала постоянен; если другой процесс
открывает файл терминала позже, он будет видеть измененные
атрибуты.
<P>Аналогично, если одиночный процесс имеет многократные или
дублированные описатели файла для того же самого устройства
терминала, замена атрибутов терминала воздействует на ввод и вывод
для всех этих описателей файлов.
<P>
<H3>Установка Режимов Терминала Правильно</H3>

<P>
<P>Когда Вы устанавливаете режимы терминала, Вы должны сначала
вызвать tcgetattr, чтобы получить текущие режимы специфического
устройства терминала, и изменять только те режимы, в которых Вы
действительно заинтересованы. Для сохранения результата испольуйте tcsetattr.
<P>Плохая практика просто инициализировать структуру struct termios
для выбранного набора атрибутов и передавать ее непосредственно в
tcsetattr. Ваша программа может быть выполнена через годы  на системах,
которые поддерживают элементы, не зарегистрированные в этом руководстве.
<P>Более того различные терминальные устройства  могут требовать
различных установок режима. Так что Вы должны избегать слепого
копирования атрибутов из одного терминального устройства в другое.
<P>
<P>Вот пример того, как устанавливать один флаг (ISTRIP) в структуре
struct termios при правильном сохранении всех других данных в
структуре:
<BLOCKQUOTE><CODE>
<PRE>
                int
                set_istrip (int desc, int value)
                {
                        struct termios settings;
                        int result;
                        result = tcgetattr (desc, &amp;settings);
                        if (result &lt; 0)
                        {
                                perror ("error in tcgetattr");
                                return 0;
                        }
                        settings.c_iflag &amp;= ~ISTRIP;
                        if (value)
                                settings.c_iflag |= ISTRIP;
                        result = tcgetattr (desc, &amp;settings);
                        if (result &lt; 0)
                        {
                                perror ("error in tcgetattr");
                                return;
                        }
                        return 1;
                }
</PRE>
</CODE></BLOCKQUOTE>
       
<H3>Режимы Ввода</H3>

<P>
<P>Этот раздел описывает флаги атрибутов терминала, которые
управляют аспектами низкого уровня входной обработки: обработка
ошибок контроля четности, сигналы останова, управление потоком
данных, символы и RET и LFD.
<P>Все эти флаги - биты в c_iflag элементе структуры struct
termios. Элемент - integer, и Вы изменяете флаги, использующие
операторами &amp;, | и ^. Не пробуйте определять все значение для
c_iflag_instead, изменяйте только специфические флаги и оставляйте
остаток нетронутым (см. Раздел 12.4.3 [Режимы Установки]).
<P>INPCK если этот бит установлен, допускается входная проверка
контроля четности. Если он не установлен, никакой проверки  ошибок
четности нет; символы просто передаются к приложению.
<P>Если этот бит установлен, то при ошибки контроля четности
ситуация  зависит от того, установлены ли биты IGNPAR или  PARMRK. Если
никакой из этих битов не установлен, байт с ошибкой контроля четности,
передается  приложению как символ '\0'.
<P>IGNPAR если этот бит установлен, любой байт с ошибкой четности
игнорируется. Это полезно только, если также установлен INPCK.
<P>PARMRK если этот бит установлен, входные байты с ошибкой
четности или ошибкой синхронизации отмечены при передачи
программе. Этот бит значим только, когда INPCK установлен, и IGNPAR
не установлен.
<P>Ошибочные байты отмечены двумя предшествующими байтами, 377 и 0.
Таким образом, программа фактически читает три байта для одного
ошибочного байта, полученного от терминала.
<P>Если допустимый байт имеет значение 0377, и ISTRIP (см. ниже) не
установлен, программа может путать его с префиксом, который
отмечает ошибку контроля по четности. Так что допустимый байт 0377
передается программе как два байта, 0377 0377.
<P>ISTRIP если этот бит установлен, допустимые входные байты
урезаны до семи битов; иначе, все восемь битов доступны для
программ.
<P>IGNBRK если этот бит установлен, условия прерывания
игнорируются.
<P>Условие прерывания определено в контексте асинхронной
последовательной передачи данных как ряд нулевых битов длиннее
байта.
<P>BRKINT если этот бит установлен, и IGNBRK не установлен, условие
прерывания очищает ввод терминала и очереди вывода и поднимает
сигнал SIGINT для группы приоритетного процесса, связанной с
терминалом.
<P>Если ни BRKINT ни IGNBRK не установлены, условие прерывания
передается приложению как одиночный символ '\0', если PARMRK не
установлен, или иначе как последовательность из трех символов "\377",
"\0","\0".
<P>IGNCR Если этот бит установлен, символы возврата каретки ("\r")
отброшены на вводе. Отбрасывание возврата каретки может быть
полезно на терминалах, которые посылают, и возврат каретки и
перевод строки при нажатии клавишу RET.
<P>ICRNL Если этот бит установлен, и IGNCR не установлен, символ
возврата каретки (" \r ") передается к приложению как символ
перевода строки (" \n ").
<P>INLCR Если этот бит установлен, символ перевода строки ("\n")
передан к приложению как символ возврата каретки ("\r").
<P>IXOFF Если этот бит установлен, допускается start/stop контроль
над вводом. Другими словами, компьютер посылает символы STOP и
START по мере необходимости, чтобы предотвратить ввод от прибытия
быстрее чем программы его читают. Идея состоит в том, что
фактические аппаратные средства терминала, которые генерируют
входные данные, отвечают на символ STOP,  приостанавливая передачу,
а на символ START, продолжая передачу. См. Раздел 12.4.9.4
[Start/Stop Символы].
<P>IXON Если этот бит установлен, допускается start/stop контроль
над выводом. Другими словами, если компьютер получает символ STOP,
он приостанавливает вывод, пока символ START не получен.
<P>В этом случае, символы STOP и START никогда не переданы
прикладной программе. Если этот бит не установлен, то START и STOP,
могут читаться как обычные символы. См. Раздел 12.4.9.4 [Start/Stop
Символы].
<P>IXANY если этот бит установлен, любой входной символ
перезапускает вывод, когда вывод был приостановлен символом STOP.
Иначе, только символ START перезапускает вывод.
<P>IMAXBEL если этот бит установлен, то при заполнении буфера ввода
терминала посылается символ BEL (код 007) на терминал (звенит
звонок).
<P>
<H3>Режимы вывода</H3>

<P>
<P>Этот раздел описывает флаги терминала и поля, которые управляют,
как выводимые символы транслируются и дополняются для дисплея. Все
они содержатся в c_oflag элементе struct termiosstructure.
<P>C_oflag элемент непосредственно - integer, и Вы изменяете флаги
и поля, используюя операторы &amp;, |, и ^. Не пробуйте определять все
значения для c_oflag , изменяйте только специфические флаги и
оставляйте остаток нетронутым (см. Раздел 12.4.3 [Режимы
Установки]).
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int OPOST  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот бит установлен, выходные данные обрабатываются
некоторым неопределенным способом так, чтобы они отобразились
соответственно на устройстве терминала. Это обычно включает
отображение символа перевода строки ("\n") на пару перевод строки
и возврат каретки.
<P>Если этот бит не установлен, символы передаются как есть.
<P>Следующие три бита возможности BSD, и они не имеют никакого
эффекта на не-BSD системах. На всех системах, они эффективны
только, если OPOST установлен.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int ONLCR  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот бит установлен, преобразовывает символ перевода строки
на выводе в пару символов: возврат каретки, сопровождаемый
переводом строки.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int OXTABS  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот бит установлен, преобразовывает cимволы табуляции на
выводе в соответствующее число пробелов, чтобы эмулировать
табулятор через каждые восемь столбцов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int ONOEOT  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Если этот бит установлен, отбрасываются символы C-d (код 004) на
выводе. Эти символы заставляют терминалы разъединиться.
<P>
<H3>Режимы Управления</H3>

<P>
<P>Этот раздел описывает флаги терминала и поля, которые управляют
параметрами, обычно связываемыми с асинхронной последовательной
передачей данных. Эти флаги могут не иметь смысла для других видов
портов терминала (типа псевдо-терминального сетевого соединения).
Все они содержатся в  элементе c_cflag  структуры struct termios.
<P>Элемент с_сflag непосредственно integer, и Вы изменяете флаги
и поля, используюя операторы &amp;, |, и ^. Не пробуйте определять все
значения для c_cflag взамен, изменяйте только специфические флаги и
оставляйте остаток нетронутым (см. Раздел 12.4.3 [Режимы
Установки]).
<P>CLOCAL если этот бит установлен, это указывает, что терминал
соединен "локально", и что строки состояния модема должны
игнорироваться.
<P>Если этот бит не установлен и Вы вызываете open без O_NONBLOCK
набора флагов, оpen блокируются, пока соединение модема не
установлено.
<P>Если этот бит не установлен, а модем обнаружен, то посылается
сигнал SIGHUP группе процесса управления терминала. Обычно, это
вызывает завершение процессов; см. Главу 21 [Обработка Сигнала].
Чтение из терминала после разъединения дает условие конца файла, а
запиись вызывает ошибку EIO. Для очищения бита устройство терминала должно
быть закрыто и вновь открыто.
<P>HUPCL Если этот бит установлен, то использующие это терминальное устройство
процессы по окончании или закрытии файла  вызовут разъединение с модемом.
<P>CREAD Если этот бит установлен, ввод может читаться из
терминала. Иначе, поступающий ввод отбрасывается.
<P>CSTOPB если этот бит установлен, используются два стоповых бита.
Иначе, используется только один стоповый бит .
<P>PARENB если этот бит установлен, допускается порождение и
обнаружение бита контроля четности. См. Раздел 12.4.4 [Входные
Режимы], для уточнения информации о том, как обрабатываются входные ошибки
контроля четности .
<P>Если этот бит не установлен, никакой бит контроля четности не
добавлен при выводе символов, и входные символы не проверены  по
четности.
<P>PARODD Этот бит полезен только, если PARENB установлен. Если
PARODD установлен, используется проверка на нечетность, иначе
используется проверка на четность.
<P>Флаги режима управления также включают поле для числа битов на
символ. Вы можете использовать CSIZE макрокоманду как маску, чтобы
извлечь значение, примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    settings.c_cflag &amp; CSIZE.
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>CSIZE Это маска для числа битов на символ.
<P>CS5 Это определяет пять битов на байт.
<P>CS6 Это определяет шесть битов на байт.
<P>CS7 Это определяет семь битов на байт.
<P>CS8 Это определяет восемь битов на байт.
<P>CCTS_OFLOW Если этот бит установлен, он дает возможность управления
потоком выводимых данных, основанного на CTS (RS232 протокол).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    CRTS_IFLOW
</PRE>
</CODE></BLOCKQUOTE>

Если этот бит установлен, он дает возможность управления потоком
вводимых данных, основанного на RTS (RS232 протокол).
<P>MDMBUF если этот бит установлен, он предоставляет возможность
курьерскому управлению потоком выводимых данных.
<P>
<P>
<H3>Автономные режимы</H3>

<P>
<P>Этот раздел описывает флаги для элемента c_lflag  структуры
struct termios. Эти флаги управляют аспектами с более высоким
уровнем ввода, чем флаги режимов, описанные в Разделе 12.4.4
[Входные Режимы], типа отображения на экране, сигналов, и выбора
каноническиого или неканоническиого ввода.
<P>Элемент с_lflag  непосредственно - integer, и Вы изменяете флаги
и поля, используюя операторы &amp;, |, и ^. Не пробуйте определять все
значения для c_lflag, а изменяйте только специфические флаги и
оставляйте остаток нетронутым (см. Раздел 12.4.3 [Режимы
Установки]).
<P>ICANON Этот бит, устанавливает канонический режим обработки
ввода. Иначе, ввод обработан в неканоническом режиме. См. Раздел
12.3 [Каноническиий или Нет].
<P>ECHO
если этот бит установлен, допускается отображение  входных
символов обратно на терминал.
<P>ECHOE
если этот бит установлен, происходит отображение стирания
ввода символом ERASE, уничтожается последний символ в текущей
строке. Иначе, уничтоженный символ переотображен, чтобы показать
что случилось.
<P>Этот бит управляет только поведением дисплея; ICANON бит
управляет фактическим распознаванием символа ERASE и стиранием
ввода.
<P>ECHOK
Этот бит дает возможность специальному отображению символа
KILL. Имеются два способа, которыми это может быть выполнено.
Лучший способ стирать всю строку. Худший способ перемещение в
новую строку после отображения на экране символа KILL.
<P>Если этот бит не установлен, символ KILL отображается, точно
как это было бы, если не было символа KILL. Ввод предшестующий символу KILL
не отображается.
<P>ECHONL
если этот бит установлен, и бит ICANON также установлен,
то символ перевода строки ("\n") отображается на экране, даже если
бит ECHO не установлен.
<P>ISIG Этот бит управляет распознаванием символов INTR, QUIT, и
SUSP. Функции, связанные с этими символами выполняются только, если этот бит
установлен.
<P>В каноническиом или неканоническиом входном режиме терминал может не
реагировать на интерпретацию этих символов.
<P>IEXTEN Этот бит подобен ISIG, но контролирует определенные
реализацией специальные символы. Если он установлен, он мог бы
отменять заданное по умолчанию поведение для ICANON и ISIG флагов
автономного режима, и IXON и флагов режима ввода IXOFF.
<P>NOFLSH Обычно, символы INTR, QUIT, и SUSP очищают очереди ввода
и вывода для терминала. Если этот бит установлен, очереди, не
очищаются.
<P>TOSTOP если этот бит установлен, и система поддерживает
управление заданиями, то фоновыми процессами генерируются SIGTTOU
сигналы, при попытке записи на терминал. См. Раздел 24.4 [Доступ к
Терминалу].
<P>Следующие биты представляют собой расширения BSD; библиотека GNU определяет
эти символы в любой системе, но использоваться они будут только в системах
BSD.
<P>ECHOKE
на системах BSD этот бит выбирает между двумя
альтернативными способами отображения символа KILL, когда ECHOK
установлен. Если ECHOKE установлен, то символ KILL стирает целую
экранную строку; иначе, символ KILL перемещается в следующую
экранную строку. Установка ECHOKE не производит никакого эффекта, если
бит ECHOK не установлен.
<P>ECHOPRT
этот бит дает возможность отображать символ ERASE
заданным способом.
<P>ECHOCTL
если этот бит установлен, управляющие символы
отображаются с "^" сопровождаемый соответствующим текстовым
символом. Таким образом, control-A отображается на экране как "^A".
<P>ALTWERASE  Этот бит определяет сколько символов WERASE должен стереть.
Символ WERASE стирает обратно к началу слова.
<P>Если этот бит является неустановлен, то началом слова считается первый
символ после символов пробел. Если бит установлен, то начало
слова - алфавитно-цифровой символ или подчеркивание после символа,
который не является одним из этих.
<P>FLUSHO - бит, который переключается, когда пользователь печатает
символ DISCARD. Если этот бит установлен то вывод не производится.
<P>NOKERNINFO  Установка этого бита отключает обработку символа STATUS.
<P>PENDIN если бит установлен, то это означает, что имеется
строка ввода, которая должна быть перпечатана.
<P>Печать символа REPRINT устанавливает этот бит; бит остается
установленным, пока перепечатывание не закончено. См. Раздел
12.4.9.2 [Редактирование в BSD].
<P>
<P>
<H3>Быстродействие Строки</H3>

<P>
<P>Быстродействие строки терминала сообщает компьютеру как быстро
читать и писать данные относительно терминала.
<P>Если терминал соединен с реальной последовательной строкой,
быстродействие терминала, которое Вы определяете фактически
управляет строкой, если она не соответствует собственной концепции
терминала относительно быстродействия, связь не работает.
<P>Реальные последовательные порты воспринимают только некоторые
стандартные скорости. Специфические аппаратные средства не могут
поддерживать все стандартные скорости. При определении нулевой
скорости "зависает " соединение телефонного вызова по номеру и
выключаются сигналы управления модема.
<P>Если терминал не реальная последовательная строка (например,
если это сетевое соединение), то скорость не будет воздействовать
на быстродействие передачи данных, но некоторые программы
используют ее, чтобы определить количество необходимого дополнения.
Самое лучшее определить значение быстродействия строки, которое
соответствует фактическому быстродействию фактического терминала,
но Вы можете безопасно экспериментировать с различными значениями,
чтобы изменить количество дополнения.
<P>Имеются фактически две скорости строки для каждого терминала,
один для ввода и один для вывода. Вы можете устанавливать их
независимо, но наиболее часто терминалы используют то же самое
быстродействие для обоих направлений.
<P>Значения быстродействия сохранены в структуре struct termios, но
не пробуйте обращаться к ним в структуре struct termios
непосредственно. Взамен, Вы должны использовать следующие функции,
чтобы читать и сохранять их:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    speed_t cfgetospeed (const struct termios *termios_p)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает быстродействие строки вывода, сохраненное
в структуре * termios_p.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    speed_t cfgetispeed (const struct termios *termios_p)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает входное быстродействие строки,
сохраненное в структуре * termios_p.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int cfsetospeed (struct termios *termios_p, speed_t speed) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция сохраняет быстродействие в * termios_p как
быстродействие вывода. Нормальное возвращаемое значение 0;
значение -1 указывает ошибку. Если speed - не быстродействие,
cfsetospeed возвращает -1.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int cfsetispeed (struct termios *termios_p, speed_t speed) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция сохраняет быстродействие в * termios_p как входное
быстродействие. Нормальное возвращаемое значение - 0; значение -1
указывает ошибку. Если speed - не быстродействие, cfsetospeed
возвращает -1.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int cfsetspeed (struct termios *termios_p, speed_t speed) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция сохраняет быстродействие в * termios_p, и как
скорости вывода и как скорость ввода. Нормальное возвращаемое
значение 0; значение -1 указывает ошибку. Если speed не
быстродействие, cfsetspeed возвращает -1. Эта функция расширение
4.4 BSD.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    speed_t  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Speed_t тип данных integer unsigned, используемый, чтобы
представить скорости строки.
<P>Функции cfsetospeed и cfsetispeed выдают ошибки только для
значений быстродействия, которые система просто не может
обрабатывать. Если Вы определяете значение быстродействия, которое
является в основном допустимым, то эти функции выполняются успешно. Но они
не проверяют, что специфическое аппаратное устройство может
фактически поддерживать заданное быстродействие, они не знают, для
которого устройства Вы планируете устанавливать быстродействие.
Если Вы используете tcsetattr, чтобы установить быстродействие
специфического устройства в значение, которое оно не может
обрабатывать, tcsetattr, возвращает -1.
<P>Примечание Переносимости: В библиотеке GNU, функции выше
принимают скорости, измеряемые в битах в секунду как ввод, и
возвращает значения быстродействия, измеряемые в битах в секунду.
Другие библиотеки требуют, чтобы скорости были обозначены
специальными кодами. Для POSIX. 1 переносимости, Вы должны
использовать один из следующих символов, чтобы представить
быстродействие; их точные числовые значения зависят от системы,
но каждое имя, имеет фиксированное значение: B110 замещает 110
бит\сек, B300 для 300 бит\сек, и так далее. Нет никакого
переносимого способа представить любое быстродействие, но это
единственые скорости, которые последовательные строки
могут поддерживать.
<P>
<BLOCKQUOTE><CODE>
<PRE>
                B0  B50  B75  B110  B134  B150  B200
                B300  B600  B1200  B1800  B2400  B4800
                B9600  B19200  B38400
</PRE>
</CODE></BLOCKQUOTE>

BSD определяет два дополнительных символа быстродействия как
побочные результаты исследования: EXTA - побочный результат
исследования для B19200, и EXTB - побочный результат исследования
для B38400. Эти побочные результаты исследования устаревшие.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int cfmakeraw (struct termios *termios_p)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция обеспечивает простой способ установить * termios_p
для того, что традиционно вызвалось "необрабатываемый режим" в BSD.
Она делает следующее:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       termios_p-&gt;c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                        |INLCR|IGNCR|ICRNL|IXON);
       termios_p-&gt;c_oflag &amp;= ~OPOST;
       termios_p-&gt;c_lflag &amp;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
       termios_p-&gt;c_cflag &amp;= ~(CSIZE|PARENB);
       termios_p-&gt;c_cflag |= CS8;
</PRE>
</CODE></BLOCKQUOTE>
<H3>Специальные Символы</H3>

<P>
<P>В каноническиом вводе, драйвер терминала распознает ряд
специальных символов, которые выполняют различные функции
управления. Они включают символ ERASE (обычно DEL) для
редактирования ввода, и другие символы редактирования. Символ INTR
(обычно C-c) для посылки сигнала SIGINT, и другие  сигнальные
символы, могут быть доступны либо в каноническиом либо в
неканоническиом входном режиме. Все эти символы описаны в этом
разделе.
<P>Специфические используемые символы определены в c_cc элементе
struct termios структуры. Этот элемент массив; каждый элемент
определяет символ для специфической роли. Каждый элемент имеет
символическую константу, которая замещает индекс этого элемента
например, INTR - индекс элемента, который определяет символ INTR,
так что сохранение "=" в termios.c_cc [INTR] определяет "=" как
символ INTR.
<P>На некоторых системах Вы можете отключать специфическую
специальную символьную функцию,  определяя значение _POSIX_VDISABLE. Это
значение неравно любому возможному символьному коду. См. Раздел 27.7 [Опции
Файлов] для получения более подробной информации, о том как сообщить
операционной системе, которую Вы используете, поддержку _POSIX_VDISABLE.
<P>
<H3>Символы для Входного Редактирования</H3>

<P>
<P>Эти специальные символы активны только в каноническиом входном
режиме. См. Раздел 12.3 [Каноническиий или Нет].
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int VEOF           (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа EOF в специальном массиве управляющих
символов. Termios.c_cc [VEOF] содержит символ непосредственно.
<P>Символ EOF распознаваем только в каноническиом входном режиме.
Он действует как конец строки таким же образом как символ
перевода строки, но если символ EOF печатается в начале строки, это
заставляет read возвращать нулевой счетчик байтов, указывая конец
файла. Символ EOF непосредственно отбрасывается.
<P>Обычно, символ EOF - C-d.
<BLOCKQUOTE><CODE>
<PRE>
       int VEOL           (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа EOL в специальном массиве управляющих
символов. Termios.c_cc [VEOL] содержит символ непосредственно.
<P>Символ EOL распознаваем только в каноническиом входном режиме.
Он действует как признак конца строки, точно так же как символ
перевода строки. Символ EOL не отбрасывается; он читается как
последний символ во входной строке.
<P>Вы не должны использовать символ EOL, чтобы заставить RET
закончить строку. Просто установите ICRNL флаг. Фактически, это
заданное по умолчанию состояние.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VERASE
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа ERASE в специальном массиве управляющих
символов. Termios.c_cc [VERASE] содержит символ непосредственно.
<P>Символ ERASE распознаваем только в каноническиом входном режиме.
Когда пользователь печатает символ удаления, предыдущий печатаемый
символ отбрасывается. (Если терминал генерирует многобайтовые
символьные последовательности, может быть отброшен больше чем один
байт ввода.) Символ ERASE непосредственно отбрасывается.
<P>Обычно, символ ERASE - DEL.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VKILL  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа KILL в специальном массиве управляющих
символов. Termios.c_cc [VKILL] содержит символ непосредственно.
<P>Символ KILL распознаваем только в каноническиом входном режиме.
Когда пользователь печатает этот символ, все содержимое текущей
строки ввода отбрасывается. Сам символ непосредственно также
отбрасывается.
<P>Символ KILL - обычно C-u.
<P>
<BLOCKQUOTE><CODE>
<PRE>
         12.4.9.2 BSD Расширения Редактирующих Символов
</PRE>
</CODE></BLOCKQUOTE>

Эти специальные символы активны только в каноническиом входном
режиме. См. Раздел 12.3 [Каноническиий или Нет]. Они являются расширениями
BSD; библиотека GNU определяет символы на любой системе, но работают они
только в системе BSD.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VEOL2  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа EOL2 в специальном массиве управляющих
символов. Termios.c_cc [VEOL2] содержит символ непосредственно.
<P>Символ EOL2 работает точно так же как символ EOL (см. выше), но
это может быть другой символ. Таким образом, Вы можете определять
два символа, чтобы завершить входную строку, устанавливая EOL как
один из них и EOL2 как другой.
<P>
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VWERASE  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа WERASE в специальном массиве
управляющих символов. Termios.c_cc [VWERASE] содержит символ
непосредственно.
<P>Символ WERASE распознаваем только в каноническиом входном
режиме. Он стирает слово предшествующего ввода.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VREPRINT  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа REPRINT в специальном массиве
управляющих символов. Termios.c_cc [VREPRINT] содержит символ
непосредственно.
<P>Символ REPRINT распознаваем только в каноническом входном
режиме. Он перепечатывает текущую входную строку.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VLNEXT  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа LNEXT в специальном массиве управляющих
символов. Termios.c_cc [VLNEXT] содержит символ непосредственно.
<P>Символ LNEXT распознаваем только, когда IEXTEN установлен. Он
отключает редактирующее значение следующего печатающегося символа.
Это  аналог команды C-q в Emacs.
<P>Символ LNEXT - обычно C-v.
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Символы вызывающие Сигналы</H3>

<P>
<P>Эти специальные символы могут быть активны или в каноническом
или в неканоническом входном режиме, но только, когда флаг ISIG
установлен (см. Раздел  12.4.7 [Автономные режимы]).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VINTR  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа INTR в специальном массиве управляющих
символов. Termios.c_cc [VINTR] содержит символ непосредственно.
<P>INTR символ (прерывания) вызывает сигнал SIGINT для всех
процессов в приоритетной работе, связанной с терминалом. Символ
INTR непосредственно отбрасывается. См. Главу 21 [Обработка
Сигнала] , для получения более подробной информации.
<P>Обычно, символ INTR - C-c.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VQUIT  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа QUIT в специальном массиве управляющих
символов. Termios.c_cc [VQUIT] содержит символ непосредственно.
<P>Символ QUIT вызывает сигнал SIGQUIT для всех процессов в
приоритетной работе, связанной с терминалом. Символ QUIT
непосредственно отбрасывается. См. Главу 21 [Обработка Сигнала], дл
получения более подробной информации.
<P>Обычно, символ QUIT - C-\.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VSUSP  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это - нижний индекс для символа SUSP в специальном массиве
управляющих символов.
<P>Termios.c_cc [VSUSP] содержит символ непосредственно.
<P>
<P>SUSP (приостанавливающий) символ,  распознается только, если
реализация поддерживает управление заданиями (см. Главу 24
[Управление заданиями]). Он посылает сигнал SIGTSTP всем процессам
в приоритетной работе, связанной с терминалом. Символ SUSP
непосредственно отбрасывается. См. Главу 21 [Обработка Сигнала],
для получения более подробной информации.
<P>Обычно, символ SUSP - C-z.
<P>Некоторые приложения отключают нормальную интерпретацию символа
SUSP. Если ваша программа делает это, она должна обеспечить
какой-нибудь другой механизм для пользователя, чтобы остановить
работу. Когда пользователь вызывает этот механизм, программа должна
послать сигнал SIGTSTP группе процесса, а не только процессу
непосредственно. См. Раздел 21.6.2 [Передача сигналов для Другого
Процесса].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VDSUSP  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа DSUSP в специальном массиве управляющих
символов. Termios.c_cc [VDSUSP] содержит символ непосредственно.
<P>DSUSP (приостанавливающий) символ распознается только, если
реализация поддерживает управление заданиями (см. Главу 24
[Управление заданиями]). Он посылает сигнал SIGTSTP, подобно
символу SUSP, но не сразу, а когда программа пробует читать его как
ввод.
<P>Не все системы с управлением заданиями поддерживают DSUSP;
только системы BSD. См. Главу 21 [Обработка Сигнала], для получения
более подробной информации.
<P>Обычно, символ DSUSP - C-y.
<P>
<P>
<P>
<P>
<P>
<H3>Специальные Символы для Управления потоком данных</H3>

<P>
<P>Эти специальные символы могут быть активны или в каноническиом
или в неканоническиом входном режиме, но их использование
управляется флагами IXON и IXOFF (см. Раздел 12.4.4 [Входные
Режимы]).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VSTART
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа START в специальном массиве управляющих
символов. Termios.c_cc [VSTART] содержит символ непосредственно.
<P>Символ START используется, чтобы поддерживать режимы ввода IXON и IXOFF.
Если IXON установлен, то получение символа START продолжает приостановленный
вывод; символ START непосредственно отбрасывается. Если IXOFF установлен, то
система может также передавать символы START на терминал.
<P>Обычное значение для символа START - C-q. Вы не можете изменить
это значение, т. к. аппаратные средства могут настаивать на
использовании C-q независимо от того, что Вы определяете.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VSTOP  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа STOP в специальном массиве управляющих
символов. Termios.c_cc [VSTOP] содержит символ непосредственно.
<P>Символ STOP используется, чтобы поддерживать IXON и IXOFF режимы
ввода. Если IXON установлен, то получение символа STOP заставляет
риостановить вывод; символ STOP непосредственно отбрасывается. Если IXOFF
установлен, система может также передавать символы STOP на терминал,
предохранняя входную очередь от переполнения.
<P>Обычное значение для символа STOP - C-s.
<P>
<P>
<P>
<P>
<P>
<H3>Другие Специальные Символы</H3>

<P>
<P>Имеются два дополнительных специальных символа, которые являются
значимыми на системах BSD.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VDISCARD  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа DISCARD в специальном массиве
управляющих символов. Termios.c_cc [VDISCARD] содержит символ
непосредственно.
<P>Символ DISCARD распознаваем только, когда установлен IEXTEN . Он
должен переключить флаг отбрасывания вывода. Когда этот флаг
установлен, весь вывод программы отбрасывается. Установка флага также
отбрасывает весь вывод находящийся в настоящее время в буфере
вывода.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VSTATUS  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для символа STATUS в специальном массиве
управляющих символов. Termios.c_cc [VSTATUS] содержит символ
непосредственно.
<P>Символ STATUS должен распечатать сообщение состояния
относительно того, как текущий процесс выполняется.
<P>Символ STATUS распознаваем только в каноническом режиме. Это
специфическое решение задачи, так как значение символа STATUS
ничего не делает со вводом.
<P>
<H3>Неканоническиий Ввод</H3>

<P>
<P>В неканоническом входном режиме, специальные символы
редактирования типа ERASE и KILL игнорируются.
<P>Средства системы для редактирования ввода в неканоническиом
режиме заблокированы, так, чтобы все входные символы (если они не
специальные сигналы и не управляющие потоком данных) были переданы
прикладной программе точно как печатались.
<P>Неканоническиий режим предлагает специальные параметры
называемые MIN и TIME для управления тем как долго ждать доступного
ввода. Вы можете даже использовать их, чтобы избежать ожидания,
чтобы возвратиться немедленно с любым вводом, или без ввода.
<P>MIN и TIME сохранены в элементах c_cc массива, который является
элементом struct termiosstructure. Каждый элемент этого массива
имеет специфическую роль, и каждый элемент имеет символическую
константу, которая замещает индекс этого элемента. VMIN и VMAX &shy;
имена для индексов TIME и MIN.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VMIN
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для MIN в c_cc массиве. Таким образом, в termios.c_cc
[VMIN] значение MIN хранится непосредственно.
<P>MIN значим только в неканоническиом входном режиме; он
определяет минимальное число байтов, которые должны быть доступны
во входной очереди для возвращения read.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int VTIME  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это индекс для TIME в массиве c_cc. Таким образом,
в termios.c_cc [VTIME] значение TIME представлено непосредственно.
<P>TIME значим только в неканоническиом входном режиме; он
определяет, как долго ждать ввод перед возвращением, в единицах по
0.1 секунды.
<P>Значения MIN и TIME взаимодействуют, чтобы определить критерий
для возвращения read; их точные значения зависят, от того какой
из них является отличным от нуля. Имеются четыре возможных случая:
<P>O И MIN и TIME - нули.
<P>
<P>В этом случае, read всегда возвращается немедленно со столькими
символами, сколько доступно в очереди, до запрошенного числа. Если
никакой ввод не является немедленно доступным, read возвращает
нуль.
<P>O MIN - нуль, но TIME имеет значение отличное от нуля.
<P>В этом случае, read ждет в течение времени TIME доступного
ввода; доступность одиночного байта должна быть достаточна, чтобы
удовлетворить запрос read. По возвращению функция принимает значение
обозначающее количество доступных символов вплоть до запрошенного числа. Если
никакой ввод не является доступным в заданное время, read возвращает нуль.
<P>O TIME - нуль, но MIN имеет значение отличное от нуля.
<P>В этом случае, read ждет, пока по крайней мере MIN байтов станут
доступны в очереди. И возвращает количество доступных символов.
Read может возвращать больше, чем MIN символов.
<P>O И TIME и MIN отличны от нуля.
<P>В этом случае, TIME определяет, как долго ждать следующего ввода
после каждого входного символа. Read ждет, пока или MIN байтов
прочитаны, или TIME истекает без дальнейшего ввода.
<P>Read может не возвращать никакого ввода, если TIME истекает
прежде, чем появится первый входной символ. Read может возвращать
больше, чем MIN символов, если в очереди их больше чем MIN.
<P>Что случается, если MIN - 50, и Вы запрашиваете прочитать только
10 байтов? Обычно, read ждет до 50 байтов в буфере (т. е. пока
условие ожидания не удовлетварено), и тогда читает 10 из них,
оставляя другие 40 буферизированными в операционной системе для
последующего обращения read.
<P>Примечание Переносимости: На некоторых системах, места MIN и
TIME в массиве фактически такие же как у EOF и EOL. Это не вызывает
никакой серьезной проблемы, потому что MIN и TIME используется
только в неканоническиом вводе, а EOF и EOL  используются только в
каноническиом вводе, но это не совсем хорошо. Библиотека GNU
резервирует отдельные места для них.
<P>
<P>
<H2><A NAME="ss12.5">12.5 Функции управления Строкой</A>
</H2>

<P>
<P>Эти функции выполняют разнообразные управляющие действия на
терминальных устройствах. Что касается доступа к терминалу, они
обрабатываются подобно выполнению вывода: если любая из этих
функций используется фоновым процессом на управляемом терминале, то
обычно всем процессам в группе процесса посланы сигналы SIGTTOU.
Исключение, если вызывающий процесс непосредственно игнорирует или
блокирует сигналы SIGTTOU, тогда операция выполняется, и никакой
сигнал не посылается. См. Главу 24 [Управление заданиями].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int tcsendbreak (int filedes, int duration)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция генерирует условие прерывания,  передавая поток нулевых
битов на терминал, связанный с описателем файла filedes.
Продолжительность прерывания управляется аргументом duration. Если
нуль, то продолжительность - между 0.25 и 0.5 секундами. Значение
значения отличного от нуля зависит от операционной системы.
<P>Эта функция ничего не делает, если терминал не асинхронный
последовательный порт данных.
<P>Возвращаемое значение обычно нуль. В случае ошибки,
возвращается значение -1. Следующие условия ошибки errno определены
для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>filedes - не допустимый описатель файла.
<DT><B>ENOTTY </B><DD><P>filedes не связан с устройством терминала.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
    int tcdrain (int filedes)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Tcdrain функция ждет, пока весь поставленный в очередь вывод на
терминал filedes не будет передан.
<P>Возвращаемое значение обычно нуль. В случае ошибки,
возвращается значение -1. Следующие условия ошибки errno определены
для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>filedes - не допустимый описатель файла.
<DT><B>ENOTTY </B><DD><P>filedes не связан с устройством терминала.
<DT><B>EINTR </B><DD><P>операция была прервана сигналом. См. Раздел 21.5
[Прерванные Примитивы].
</DL>

<BLOCKQUOTE><CODE>
<PRE>
    int tcflush (int filedes, int queue)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция используется, чтобы очистить очереди ввода и/или
вывода, связанные с файлом терминала filedes. Аргумент queue
определяет, какую очередь очищать, и может принимать одно из следующих
значений:
<P>TCIFLUSH очистить любые полученные, но еще не прочитанные, входные
данные.
<P>TCOFLUSH очистите любые выходные данные, которые написаны, но еще не
переданный.
<P>TCIOFLUSH Очистить, поставленный в очередь и ввод и вывод.
<P>Возвращаемое значение обычно нуль. В случае ошибки,
возвращаеися значение -1. Следующие  условия ошибки errno определены
для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>filedes - не допустимый описатель файла.
<DT><B>ENOTTY </B><DD><P>filedes не связан с устройством терминала.
<DT><B>EINVAL </B><DD><P>плохое значение было обеспечено как аргумент queue.
</DL>

tcflush не совсем удачное название для это функции, так как термин
"поток" обычно используется для совершенно другой операции. К
сожалению, имя tcflush исходит из POSIX, и мы не можем изменять
его.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int tcflow (int filedes, int action)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция используется, чтобы выполнить операции в
отношении XON/XOFF управления потоком данных на файле терминала,
заданном filedes.
<P>Аргумент action определяет то, какую операцию выполнять, и может
быть одним из следующих значений:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    TCOOFF Приостанавливают передачу вывода.
    TCOON Рестарт передачи вывода.
    TCIOFF Передача символа STOP.
    TCION Передача символа START.
</PRE>
</CODE></BLOCKQUOTE>

Для получения более подробной информации о символах STOP и
START, см. Раздел 12.4.9 [Специальные Символы].
<P>Возвращаемое значение обычно нуль. В случае ошибки,
возвращается значение -1. Следующие  условия ошибки errno определены
для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>filedes - не допустимый описатель файла.
<DT><B>ENOTTY </B><DD><P>filedes не связан с устройством терминала.
<DT><B>EINVAL </B><DD><P>плохое значение был обеспечен как аргумент action.
</DL>
<H2><A NAME="ss12.6">12.6 Пример Неканонического Режима</A>
</H2>

<P>
<P>Вот пример программ, который показывает как Вы можете
устанавливать устройство терминала для чтения одиночных символов в
неканоническиом входном режиме, без ECHO.
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;unistd.h&gt;
                #include &lt;stdio.h&gt;
                #include &lt;stdlib.h&gt;
                #include &lt;termios.h&gt;
                struct termios saved_attributes;
                void
                reset_input_mode (void)
                {
                        tcsetattr (STDIN_FILENO, TCSANOW,
                &amp;saved_attributes);
                }
                void
                set_input_mode (void)
                {
                        struct termios tattr;
                        char *name;
                        if (!isatty (STDIN_FILENO))
                                {
                                        fprintf (stderr,
                "Not a terminal.\n");
                                        exit (EXIT_FAILURE);
                                }
                        tcgetattr (STDIN_FILENO, &amp;saved_attributes);
                        atexit (reset_input_mode);
                        tcgetattr (STDIN_FILENO, &amp;tattr);
                        tattr.c_lflag &amp;= ~(ICANON|ECHO);
                        tattr.c_cc[VMIN] = 1;
                        tattr.c_cc[VTIME] = 0;
                        tcsetattr (STDIN_FILENO, TCSAFLUSH, &amp;tattr);
                }
                int
                main (void)
                {
                        char c;
                        set_input_mode ();
                        while (1)
                                {
                                        read (STDIN_FILENO, &amp;c, 1);
                                        if (c == '\004')        /* C-d */
                                                break;
                                        else
                                                putchar (c);
                                }
                        return EXIT_SUCCESS;
                }
</PRE>
</CODE></BLOCKQUOTE>

Эта программа осторожна, она восстанавливает первоначальные
режимы терминала перед выходом или завершением с сигналом. Она
использует функцию atexit  (см. Раздел 22.3.3 [Очистка на Выходе])
чтобы удостовериться в установке режимов.
<P>Оболочка, как предполагается,  заботится о сбросе режимов
терминала, когда процесс остановлен или продолжается; см. Главу 24
[Управление заданиями]. Но некоторые существующие оболочки
фактически не делают это, так что Вы можете  установить обработчики
для сигналов управления заданиями, которые сбрасывают режимы
терминала. Вышеупомянутый пример делает так.
<P>
<P>
<HR>
<A HREF="glibc-13.html">Вперед</A>
<A HREF="glibc-11.html">Назад</A>
<A HREF="glibc.html#toc12">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
