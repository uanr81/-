<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Расширение Символов</TITLE>
 <LINK HREF="glibc-19.html" REL=next>
 <LINK HREF="glibc-17.html" REL=previous>
 <LINK HREF="glibc.html#toc18" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-19.html">Вперед</A>
<A HREF="glibc-17.html">Назад</A>
<A HREF="glibc.html#toc18">Содержание</A>
<HR>
<H2><A NAME="s18">18. Расширение Символов</A></H2>

<P>
<P>
<P>Ряд языков использует наборы символов, которые больше чем набор
значений типа char.
<P>Японский и Китайский - возможно наиболее близкие примеры.
<P>Библиотека GNU C включает поддержку двух механизмов для работы с
расширенными наборами символов: многобайтовые символы и широкие
символы. Эта глава описывает, как использовать эти механизмы, и
функции для преобразования между ними.
<P>На поведение функций в этой главе воздействует текущий стандарт
для символьной классификации LC_CTYPE класса; см. Раздел 19.3
[Категории Стандарта]. Этот стандарт указывает, который
многобайтовый код используется, и также управляет значениями и
характеристиками расширенных символьных кодов.
<P>
<H2><A NAME="ss18.1">18.1 Введение в Расширение Символов</A>
</H2>

<P>
<P>Вы можете представлять расширенные символы одним из двух
способов:
<UL>
<LI>        Как многобайтовые символы, которые могут быть внедрены в
обычной строке, т. е. в массиве объектов char. Их преимущество &shy;
то, что много программ и операционных систем могут обрабатывать
случайные многобайтовые символы, рассеянные среди обычных символов
ASCII, без любого изменения.</LI>
<LI>        Как расширенные символы, которые подобны обычным символам за
исключением того, что они занимают большое количество битов.
Широкий символьный тип данных wchar_t, имеет достаточно места,
чтобы содержать расширенные символьные коды также как традиционные
коды ASCII.</LI>
</UL>

Преимущество расширенных символов - то, что каждый символ
является одиночным объектом данных, точно так же как обычные
символы ASCII. Имеются несколько недостатков:
<UL>
<LI>          Каждая существующая программа должна быть измененна и
перетранслирована, чтобы использовать расширенные символы.</LI>
<LI>          Файлы расширенных символов не могут быть прочитаны
программами, которые ожидают обычные символы.</LI>
</UL>

Обычно, Вы используете многобайтовое символьное представление
как часть внешнего интерфейса программы, типа чтения или запииси в
файлы. Однако, обычно проще выполнить внутренние манипулирования на
строках, содержащих расширенные символы, в массивах объектов
wchar_t, так как однородное представление делает операции
редактирования намного проще. Если Вы используете многобайтовые
символы для файлов и расширенные символы для внутренних операций,
Вы должен преобразовать их при записи и чтении данных.
<P>Если ваша система поддерживает расширение символов, то она
поддерживает их, и как многобайтовые символы и как расширенные
символы. Библиотека включает функции, которые Вы можете
использовать, чтобы преобразовать между двумя представлениями. Эти
функции описаны в этой главе.
<P>
<H2><A NAME="ss18.2">18.2 Стандарты и Расширенные Символы</A>
</H2>

<P>
<P>Компьютерная система может поддерживать больше чем один
многобайтовый символьный код, и больше чем один расширенный
символьный код. Пользователь управляет выбором кодов через текущий
стандарт для символьной классификации (см. Главу 19 [Стандарты] ).
Каждый стандарт определяет специфический многобайтовый символьный
код и специфический расширенный символьный код. Выбор стандарта
влияет на поведение функций преобразования в библиотеке.
<P>Некоторые стандарты не поддерживают ни расширенные символы, ни
нетривиальные многобайтовые символы. В этих стандартах,
библиотечные функции преобразования все еще работают, даже если,
что они в основном тривиальны.
<P>Если Вы выбираете нновый стандарт для символьной классификации,
внутренний параметр сдвига, поддерживаемый этими функциями может
стать спутанным, так что - не стоит изменять стандарт в то время
как, Вы находитесь в середине обработки строки.
<P>
<P>
<H2><A NAME="ss18.3">18.3 Многобайтовые Символы</A>
</H2>

<P>
<P>В обычном коде ASCII, последовательность символов &shy;
последовательность байтов, и каждый символ - один байт. Это очень
просто, но учитывает только 256 различных символов.
<P>В многобайтовом символьном коде, последовательность символов &shy;
последовательность байтов, но каждый символ может занимать одни или
более последовательных байт последовательности.
<P>Имеются много различных способов проектирования многобайтового
символьного кода; различные системы используют различные коды.
Специфический способ кодирования определяется обозначением базисных
последовательностей байтов, которые представляют одиночный символ и
какие символы они замещают. Код, который компьютер может фактически
использовать, должен иметь конечное число этих базисных
последовательностей, и обычно ни одна из них не длиннее чем
несколько символов.
<P>Эти последовательности не имеют одинаковую длину. Фактически,
многие из их - только один байт. Потому что базисные символы ASCII
в промежутке от 0 до 0177 настолько важны, что они замещают себя во
всех многобайтовых символьных кодах. То есть байт, чье значение от
0 до 0177 - всегда символ сам по себе. Символы, которые больше чем
один байт, должны всегда начинаться с байта в промежутке от 0200 до
0377.
<P>Значение 0 байта может использоваться, чтобы завершить строку,
точно как это часто используется в строке символов ASCII.
<P>Определение базисных последовательностей байтов, которые
представляют одиночные символы автоматически дают значения более
длинным последовательностям байтов, больше чем один символ.
Например, если последовательность два байта 0205 049 замещает
символ греческой альфы, то 0205 049 065 должна заместить альфу,
сопровождаемую " " (код ASCII 065), а 0205 049 0205 049 должна
заместить две альфы в строке.
<P>Если любая последовательность байтов может иметь больше чем одно
значение как последовательность символов, то многобайтовый код
неоднозначен и опасен. Коды, которые системы фактически используют
все однозначны.
<P>В большинстве кодов, имеются некоторые последовательности
байтов, которые не имеют никакого значения как символ или символы.
Они называются недопустимыми.
<P>Самый простой возможный многобайтовый код - тривиальный:
<P>Базисные последовательности состоят из одиночных байтов.
<P>Данный специфический код не использует многобайтовые символы
вообще. Он не имеет никаких недопустимых последовательностей. Но он
может обрабатывать только 256 различных символов.
<P>Вот другой возможный код, который может обрабатывать 9376
различных символов:
<P>Базисные последовательности состоят из
<UL>
<LI>        одиночных байтов со значениями в промежутке от 0 до 0237.</LI>
<LI>        двух-байтовых последовательностей, в которых оба байта имеют
значения в промежутке от 0240 до 0377.</LI>
</UL>
<P>Этот код или подобный используется на некоторых системах, чтобы
представить Японские символы. Недопустимые последовательности - те,
которые состоят из нечетного числа последовательных байтов в
промежутке от 0240 до 0377.
<P>Вот другой многобайтовый код, который может обрабатывать больше
различных расширенных символов, фактически, почти тридцать
миллионов:
<P>Базисные последовательности состоят из
<UL>
<LI>        одиночных байтов со значениями в промежутке 0 до 0177.</LI>
<LI>        последовательностей до четырех байтов, в которых первый байт
находится в промежутке от 0200 до 0237, а оставшиеся байты
находятся в промежутке от 0240 до 0377.</LI>
</UL>

В этом коде, любая последовательность, которая начинается с
байта в промежутке от 0240 до 0377, недопустима.
<P>Вот другой вариант, который имеет преимущество: при удалении
последнего байта или байтов допустимого символа, никогда не может
появиться другой допустимый символ.
<P>Базисные последовательности состоят из
<UL>
<LI>        одиночных байтов со значениями в промежутке от 0 до 0177.</LI>
<LI>        двух-байтовых последовательностей, в которых первый байт
находится в промежутке от 0200 до 0207, а второй байт находятся в
промежутке от 0240 до 0377.</LI>
<LI>        трех-байтовых последовательностей, в которых первый байт
находится в промежутке от 0210 до 0217, а другие байты находятся в
промежутке от 0240 до 0377.</LI>
<LI>       четырех-байтовых последовательностей, в которых первый байт
находится в промежутке от 0220 до 0227, а другие байтаы находятся в
промежутке от 0240 до 0377.</LI>
</UL>
<P>Список недопустимых последовательностей для этого кода &shy;
довольно длинный и не стоит полного просмотра; примеры недопустимых
последовательностей включают 0240 и 0220 0300 065.
<P>Число возможных многобайтовых кодов очень велико. Но данная
компьютерная система будет поддерживать не больше нескольких
различных кодов. (Один из этих кодов может учитывать тысячи
различных символов.) Другая компьютерная система может поддерживать
полностью отличный код. Библиотечные средства, описанные в этой
главе полезны, потому что они описывают подробности многобайтового
кода специфической компьютерной системы, хотя ваши программы не
должны знать.
<P>Вы можете использовать специальные стандартные макрокоманды,
чтобы выяснить максимальное возможное число байтов символа в
текущем многобайтовом коде ипользуйте MB_CUR_MAX, а максимум для
любого многобайтового кода, обеспечиваемого на вашем компьютере
содержится в MB_LEN_MAX.
<BLOCKQUOTE><CODE>
<PRE>
       int MB_LEN_MAX  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это - максимальная длина многобайтового символа для любого
обеспечиваемого стандарта. Она определена в " limits.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int MB_CUR_MAX  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда отображает (возможно не-константу) положительное
целочисленное выражение, которое является максимальным числом
байтов в многобайтовом символе в текущем стандарте. Значение
никогда не большее чем MB_LEN_MAX.
<P>MB_CUR_MAX определен в " stdlib.h ".
<P>Что случается, если Вы пробуете передавать строку, содержащую
многобайтовые символы функции, которая не знает о них? Обычно,
такая функция обрабатывает строку как последовательность байтов, и
интерпретирует некоторые значения особенно; все другие значения
байтов "обычны". Если многобайтовый символ не содержит специальное
значение байта, функция должна обработать его, как будто это были
отдельные обычные символы.
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss18.4">18.4 Введение в Расширенные Символы</A>
</H2>

<P>
<P>Расширенные символы намного проще чем многобайтовые символы. Они
- просто символы с больше, чем восемью битами, так, чтобы они имели
место для больше, чем 256 различных кодов. Расширенный символьный
тип данных wchar_t, имеет достаточно большой диапазон, чтобы
содержать расширенные символьные коды также как традиционные коды
ASCII.
<P>Преимущество расширенных символов - в том, что каждый символ
является одиночным объектом данных, точно так же как обычные
символы ASCII. Эти символы также имеют некоторые недостатки:
<UL>
<LI>          Каждая существующая программа должна быть изменена и
перетранслирована, чтобы использовать расширенные символы.</LI>
<LI>          Файлы расширенных символов не могут быть прочитаны
программами, которые ожидают обычные символы.</LI>
</UL>

Расширенные символьные значения от 0 до 0177 всегда идентичны 
кодам символов ASCII. Расширенный нуль часто используется,
чтобы завершить строку расширенных символов, точно как, одиночный
нулевой байт часто завершает строку обычных символов.
<BLOCKQUOTE><CODE>
<PRE>
       wchar_t  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это - тип " расширенных символов " , целочисленный тип, чей
диапазон достаточно велик, чтобы представить все различные
значения в любом расширенном наборе символов в обеспечиваемых
стандартах. См. Главу 19 [Стандарты], для получения более подробной
информации. Этот тип определен в заглавном файле " stddef.h ".
<P>Если ваша система поддерживает расширенные символы, то каждый
расширенный символ имеет и расширенный символьный код и
соответствующую многобайтовую базисную последовательность.
<P>В этой главе, термин код используется, чтобы обратиться к
одиночному расширенному символьному объекту, чтобы подчеркнуть
различие от типа данных char.
<P>
<H2><A NAME="ss18.5">18.5 Преобразование Расширенных Строк</A>
</H2>

<P>
<P>Функция mbstowcs преобразовывает строку многобайтовых символов в
массив расширенных символов. Функция wcstombs делает обратный
процесс. Эти функции объявлены в заглавном файле " stdlib.h ".
<P>В большинстве программ, эти функции - единственная Ваша
потребность в преобразовании между расширенными строками и
многобайтовыми символьными строками. Но они имеют ограничения. Если
ваши данные не с нулевым символом в конце или - не все в ядре
сразу, Вы возможно должны использовать функции преобразования
низкого уровня, чтобы преобразовать один символ за раз. См. Раздел
18.7 [Преобразование Одного Символа].
<BLOCKQUOTE><CODE>
<PRE>
       size_t mbstowcs (wchar_t *wstring, const char *string, size_t size)
</PRE>
</CODE></BLOCKQUOTE>

mbstowcs (" многобайтовая строка в строку расширенных символов
") функция преобразовывает строку с нулевым символом в конце
многобайтовых символов в массив расширенных символов, сохраняя не
больше чем size расширенных символов в массиве, начинающемся в
wstring. Пустой символ завершения рассчитывается в size, так что,
если размер меньше, чем фактическое число расширенных символов,
следующих из строки, никакой пустой символ завершения не будет
сохранен.
<P>Преобразование символов из строки начинается с начальным
параметром регистра.
<P>Если недопустимая многобайтовая символьная последовательность
найдена, функция возвращает значение -1. Иначе, она возвращает
число расширенных символов, сохраненных в массиве wstring. Это
число не включает пустой символ завершения, который присутствует,
если число меньше, чем size.
<P>Вот пример, показывающий, как преобразовывать строку
многобайтовых символов, резервируя достаточное пространство для
результата.
<BLOCKQUOTE><CODE>
<PRE>
         wchar_t *
         mbstowcs_alloc (const char *string)
         {
                 size_t size = strlen (string) + 1;
                 wchar_t *buf = xmalloc (size * sizeof (wchar_t));
                 size = mbstowcs (buf, string, size);
                 if (size == (size_t) -1)
                         return NULL;
                 buf = xrealloc (buf, (size + 1) * sizeof (wchar_t));
                 return buf;
         }
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
       size_t wcstombs (char *string,const wchar_t wstring,size_t size)
</PRE>
</CODE></BLOCKQUOTE>
       wcstombs преобразует массив расширенных символов с нулевым
символом в конце в строку, содержащую многобайтовые символы,
сохраняя не больше чем size байт, начиная с string.
<P>Если найден код, который не соответствует допустимому
многобайтовому символу, то эта функция возвращает значение -1.
Иначе, возвращаемое значение - число байтов, сохраненных в массиве.
Это число не включает пустой символ завершения, который
присутствует, если число - меньше чем size.
<P>
<H2><A NAME="ss18.6">18.6 Длина Многобайтового Символа</A>
</H2>

<P>
<P>Этот раздел описывает, как просмотреть строку, содержащую
многобайтовые символы, по одному символу. Трудность в том, что нужно
знать, сколько байтов каждый символ содержат. Ваша программа может
использовать mblen, чтобы узнать это.
<BLOCKQUOTE><CODE>
<PRE>
       int mblen (const char *string, size_t size) 
</PRE>
</CODE></BLOCKQUOTE>

Функция mblen с непустым аргументом string возвращает число
байтов, которые составляют многобайтовый символ, начинающийся с
string, никогда не исследуя больше size байт. (Идея состоит в том,
чтобы обеспечить для size число байтов данных, которые Вы имеете.)
<P>Возвращаемое значение mblen отличает три возможности: первые
size байт строки начинаются с допустимого многобайтового символа,
они начинаются с недопустимой последовательности байтов или
включают только часть символа, или string указывает на пустую
строку (пустой символ).
<P>Для допустимого многобайтового символа, mblen возвращает число
байтов в этом символе (всегда по крайней мере 1, и никогда не
больше чем size). Для недопустимой последовательности байтов, mblen
возвращает -1. Для пустой строки, она возвращает 0.
<P>Если многобайтовый символьный код использует символы смены
регистра, то mblen, поддерживает и модифицирует параметр регистра.
Если Вы вызываете mblen с пустым указателем для строки, она
инициализирует параметр регистра к стандартному начальному
значению. См. Раздел 18.9 [Параметра Регистра] .
<P>Функция mblen объявлена в " stdlib.h ".
<P>
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss18.7">18.7 Преобразование Расширенных Символов по Одному</A>
</H2>

<P>
<P>Вы можете преобразовывать многобайтовые символы в расширенные
символы по одному mbtowc функцией.
Wctomb функция делает обратное. Эти функции объявлены в "
stdlib.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int mbtowc (wchar_t *result, const char *string, size_t size)
</PRE>
</CODE></BLOCKQUOTE>
      Mbtowc преобразовывает первый многобайтовый символ в string в
соответствующий расширенный символьный код. Она сохраняет результат
в *result.
Mbtowc никогда не исследует больше чем size байт. (Идея состоит
в том, чтобы обеспечить для size число байтов данных, которое Вы
имеете.)
Mbtowc с непустой строкой Возвращаемое значение mblen отличает
три возможности: первые size байт строки начинаются с допустимого
многобайтового символа, они начинаются с недопустимой
последовательности байтов или включают только часть символа, или
string указывает на пустую строку (пустой символ).
<P>Для допустимого многобайтового символа, mbtowc преобразовывает
его в расширенный символ, сохраняет его в *result, и возвращает
число байтов в том символе (всегда по крайней мере 1, и никогда не
болольше чем size).
<P>Для недопустимой последовательности байтов, mbtowc возвращает &shy;
1. Для пустой строки, она возвращает 0, также сохраняя 0 в *result.
<BLOCKQUOTE><CODE>
<PRE>
       int wctomb (char *string, wchar_t wchar)  
</PRE>
</CODE></BLOCKQUOTE>

Функция wctomb преобразует расширенный символьный код wchar в
соответствующую многобайтовую символьную последовательность, и
сохраняет результат в байтах, начиная с string.
Wctomb с непустой строкой отличает три возможности для wchar:
допустимый расширенный символьный код (тот, который может
транслироваться в многобайтовый символ), недопустимый код, и 0.
<P>Если wchar - недопустимый расширенный символьный код, wctomb
возвращает -1. Если wchar - 0, она возвращает 0, также сохраняя 0 в
*string.
<P>Вызов этой функции с нулевым wchar аргументом, когда строка - не
пустой символ, имеет побочный эффект переинициализации сохраненного
параметра регистра также как сохранения многобайтового символа 0 и
возвращения 0.
<P>
<H2><A NAME="ss18.8">18.8 Пример Посимвольного Преобразования</A>
</H2>

<P>
<P>Вот пример, который читает многобайтовоый-символьный текст из
дескриптора input и записывает соответствующие расширенные символы
в описатель output. Мы должны преобразовать символы один за другим
в этом примере, потому что mbstowcs неспособна продолжиться после
пустого символа, и не может справляться с очевидно недопустимым
частичным символом, читая большое количество ввода.
<BLOCKQUOTE><CODE>
<PRE>
                 int
                 file_mbstowcs (int input, int output)
                 {
                         char buffer[BUFSIZ + MB_LEN_MAX];
                         int filled = 0;
                         int eof = 0;
                         while (!eof)
                         {
                                 int nread;
                                 int nwrite;
                                 char *inp = buffer;
                                 wchar_t outbuf[BUFSIZ];
                                 wchar_t *outp = outbuf;
                                 nread = read (input, buffer +
                         filled, BUFSIZ);
                                 if (nread &lt; 0)
                                 {
                                         perror ("read");
                                         return 0;
                                 }
                                 if (nread == 0)
                                         eof = 1;
                                 filled += nread;
                                 while (1)
                                 {
                                         int thislen = mbtowc (outp,
                                         inp, filled);
                                         if (thislen == -1)
                                                 break;
                                         if (thislen == 0) {
                                                 thislen = 1;
                                                 mbtowc (NULL, NULL, 0);
                                         }
                                         inp += thislen;
                                         filled -= thislen;
                                         outp++;
                                 }
                                 nwrite = write (output, outbuf,
                                         (outp-outbuf)*sizeof(wchar_t));
                                 if (nwrite &lt; 0)
                                 {
                                         perror ("write");
                                         return 0;
                                 }
                                 if ((eof &amp;&amp; filled &gt; 0) ||
                 filled &gt;= MB_CUR_MAX)
                                 {
                                         error ("invalid
                 multibyte character");
                                         return 0;
                                 }
                                 if (filled &gt; 0)
                                         memcpy (inp, buffer, filled);
                         }
                         return 1;
                 }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss18.9">18.9 Многобайтовые Коды, использующие Последовательности Регистров</A>
</H2>

<P>
<P>В некоторых многобайтовых символьных кодах, значение любой
специфической последовательности байтов не фиксировано; оно зависит
от других последовательностей рассмотренных ранее в той же самой
строке. Обычно имеются только несколько последовательностей,
которые могут изменять значение других последовательностей; эти
немногие называются последовательностями регистров, и мы говорим,
что они устанавливают параметр регистра для других
последовательностей, которые последуют.
<P>Чтобы проиллюстрировать состояние регистра и последовательности
регистров, предположите, что мы устанавливаем, что
последовательность 0200 (только один байт) вводит Японский режим, в
котором пары байтов в промежутке от 0240 до 0377 являются
одиночными символами, в то время как 0201 вводит Латинский-1 режим,
в котором одиночные байты в промежутке от 0240 до 0377 являются
символами, и интерпретируются согласно набору символов Latin-1
Международной организации по стандартизации. Это - многобайтовый
код, который имеет два альтернативных состояния регистра 
("Японский режим " и " Латинский-1 режим "), и две последовательности
регистров, которые определяют специфические состояния регистра.
<P>Когда используемый многобайтовый символьный код имеет состояния
регистра, то mblen, mbtowc и wctomb должны поддерживать и
модифицировать текущее состояние регистра, поскольку они
просматривают строку. Чтобы делать эту работу правильно, Вы должны
следовать этим правилам:
* Перед стартом просмотра строки, вызовите функцию с пустым
указателем для многобайтового символьного адреса например, mblen
(NULL, 0). Это инициализирует состояние регистра к стандартному
начальному значению.
* Просматривайте строку по одному символу. Не "возвращайтесь" и
не перепросмотривайте уже просмотренные символы, и не смешивайте
обработку различных строк.
<P>Вот пример использования mblen с соблюдением этих правил:
<BLOCKQUOTE><CODE>
<PRE>
                         void
                         scan_string (char *s)
                         {
                                 int length = strlen (s);
                                 mblen (NULL, 0);
                                 while (1)
                                 {
                                         int thischar = mblen (s, length);
                                         if (thischar == 0)
                                                 break;
                                         if (thischar == -1)
                                         {
                                                 error ("invalid multibyte
                                                         character");
                                                                         break;
                                         }
                                         s += thischar;
                                         length -= thischar;
                                 }
                         }
</PRE>
</CODE></BLOCKQUOTE>

Функции mblen, mbtowc и wctomb не используются при
использовании многобайтового кода, который использует состояние
регистра. Однако, никакие другие библиотечные функции не вызывают
эти функции, так что Вы не должны волноваться относительно этого.
<P>
<P>
<HR>
<A HREF="glibc-19.html">Вперед</A>
<A HREF="glibc-17.html">Назад</A>
<A HREF="glibc.html#toc18">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
