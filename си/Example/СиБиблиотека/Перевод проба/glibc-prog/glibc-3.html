<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Распределение памяти</TITLE>
 <LINK HREF="glibc-4.html" REL=next>
 <LINK HREF="glibc-2.html" REL=previous>
 <LINK HREF="glibc.html#toc3" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-4.html">Вперед</A>
<A HREF="glibc-2.html">Назад</A>
<A HREF="glibc.html#toc3">Содержание</A>
<HR>
<H2><A NAME="s3">3. Распределение памяти</A></H2>

<P>
<P>Система GNU обеспечивает несколько методов для распределения
пространства памяти при явном управлении программы. Они различны по
общности и по эффективности.
<UL>
<LI>       malloc производит общее динамическое распределение. См. раздел
3.3 [Беспрепятственное распределение].
</LI>
<LI>       оbstacks - другое средство, менее общее чем malloc, но более
эффективное и удобное для стеко-подобного распределения. См. раздел 3.4
[Obstacks].
</LI>
<LI>       Функция alloca позволяет Вам динамически распределять память,
которая будет освобождена автоматически. См. раздел 3.5 [Размер
автоматической переменной].</LI>
</UL>
<H2><A NAME="ss3.1">3.1 Концепции динамического распределения памяти</A>
</H2>

<P>
<P>Динамическое распределение памяти - методика, в которой программы
определяют, где сохранить некоторую информацию. Вы нуждаетесь в
динамическом распределении, когда число блоков памяти, в которых Вы
нуждаетесь, или то, как долго Вы продолжаете нуждаться в них, зависит от
данных, с которыми Вы продолжаете работать.
<P>Например, Вы можете нуждаться в блоке, чтобы сохранить строку
прочитанную из входного файла; так как не имеется никаких ограничений,
как долго нужно будет хранить строку, Вы должны динамически распределить
память и динамически ее увеличивать, поскольку Вы читаете большее
количество строк.
<P>Или, Вам может понадобиться блок для каждой записи или каждого
определения во входных сведениях; так как Вы не можете знать заранее,
сколько их будет, Вы должны определять новый блок для каждой записи или
определения, поскольку Вы их читаете.
<P>Когда Вы используете динамическое распределение, распределение
блока памяти представляет собой действие, которое программа запрашивает
явно. Когда Вы хотите зарезервировать место, Вы вызываете функцию или
макрокоманду и определяете размер аргументом. Если Вы хотите освободить
место, Вы вызываете другую функцию или макрокоманду. Вы можете делать это
всякий раз, когда Вы хотите, и так часто, как Вы хотите.
<P>
<H2><A NAME="ss3.2">3.2 Динамическое Распределение в C</A>
</H2>

<P>
<P>Язык С поддерживает два вида распределения памяти через переменные
в программах C:
<UL>
<LI>       Статическое распределение - то, что случается, когда Вы
объявляете статическую переменную. Каждая статическая переменная
определяет один блок места, фиксированного размера. Место размещено один
раз, когда ваша программа начата, и никогда не освобождается.
</LI>
<LI>       Автоматическое распределение происходит, когда Вы объявляете
динамическую локальную переменную, например аргумент функции или местную
переменную. Пространство для динамической локальной переменной
резервируется, когда начинается выполнение составного утверждения,
содержащего объявление, и освобождается, когда это составное
утверждение, покидается.</LI>
</UL>

В GNU C, длина автоматической памяти может быть выражением, которое
изменяется. В других C реализациях, это должна быть константа.
<P>Динамическое распределение не обеспечивается C переменными; не
имеется никакого класса памяти "dynamic", и не может быть переменной C,
чье значение сохранено в динамически размещенном месте. Единственный
способ обратиться к динамически размещенному месту - через указатель.
Т.к. это менее удобно, и фактический процесс динамического распределения
требует большего количества компьютерного времени, программисты
использует динамическое распределение только когда ни статическое ни
автоматическое распределение применить невозможно.
<P>Например, если Вы хотите зарезервировать динамически некоторое
место, чтобы разместить struct foobar, Вы не можете объявлять переменную
типа struct foobar, чье содержание - динамически размещенное место. Но
Вы можете объявить переменную struct foobar * типа указатель и назначить
ей адрес. Тогда Вы можете использовать операторы "*" и "-&gt;" для этой
переменной- указателя, чтобы обратиться по адресу:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      {
       struct foobar *ptr= (struct foobar *) malloc (sizeof (struct foobar));
       ptr-&gt;name = x;
       ptr-&gt;next = current_foobar;
       current_foobar = ptr;
       }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss3.3">3.3 Беспрепятственное распределение</A>
</H2>

<P>
<P>Наиболее общее динамическое средство распределения - malloc. Оно
разрешает Вам зарезервировать блоки памяти любого размера в любое время,
увеличивать или уменьшать их, и освободждать блоки индивидуально в любое
время (или не освобождать) .
<P>
<H3>Базисное распределение памяти</H3>

<P>
<P>Чтобы зарезервировать блок памяти, вызовите malloc. Прототип для
этой функции находится в "stdlib.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * malloc (size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает указатель к только что размещенныому блоку
size байтов длиной, или нулевому указателю если блок не мог бы быть
размещен.
<P>Содержание блока неопределено; Вы должны инициализировать его
непосредственно (или использовать calloc; см. раздел 3.3.5
[Распределение очищенного места] ). Обычно Вы приводите значение
указателя к виду объекта, который Вы хотите сохранять в блоке. Здесь мы
показываем такой пример, и инициализации место нулями, используя
библиотечную функцию memset (см. раздел 5.4 [Копирование и
конкатенация]):
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct foo *ptr;
      . . .
      ptr = (struct foo *) malloc (sizeof (struct foo));
      if (ptr == 0) abort ();
      memset (ptr, 0, sizeof (struct foo));
</PRE>
</CODE></BLOCKQUOTE>

Вы можете сохранять результат malloc в любую переменную-указатель
без приведения, потому что ANSI C автоматически преобразовывает void* в
другой тип указателя когда необходимо. Но приведение необходимо в
контекстах отличных от операторов назначения или если Вы хотите, чтобы
ваш код выполнился в традиционном C.
<P>Не забудьте, что при распределении пространства для строки,
аргумент malloc должен быть один плюс длина строки. Это - потому что
строка завершена символом \0, который не учтен в "длине" строки, но
нуждается в месте. Например:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char *ptr;
      . . .
      ptr = (char *) malloc (length + 1);
</PRE>
</CODE></BLOCKQUOTE>
<H3>Примеры malloc</H3>

<P>
<P>Если место не доступно, malloc возвращает нулевой указатель. Вы
должны проверить значение каждого обращения к malloc. Полезно написать
подпрограмму, которая вызывает malloc и сообщает ошибку, если значение &shy;
нулевой указатель, и возвращает результат только если значение отлично
от нуля. Эта функция традиционно называется xmalloc:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * xmalloc (size_t size)
      {
       register void *value = malloc (size);
       if (value == 0) fatal ("virtual memory exhausted");
       return value;
      }
</PRE>
</CODE></BLOCKQUOTE>

Это реальный пример использования malloc (через xmalloc). Функция
savestring будет копировать последовательность символов в завершенную
пустым указателем строку:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * savestring (const char *ptr, size_t len)
      {
       register char *value = (char *) xmalloc (len + 1);
       memcpy (value, ptr, len);
       value[len] = '\0';
       return value;
      }
</PRE>
</CODE></BLOCKQUOTE>

Блок, который malloc дает Вам, уже выровнен и может содержать любой
тип данных. В системе GNU, адрес всегда делится на восемь; если размер
блока - 16 или больше, то адрес всегда делится на 16. Более высокая
граница (типа границы страницы) необходима гораздо реже; для этих
случаев, используйте memalign или valloc (см. раздел 3.3.7
[Выравниваемые блоки памяти]).
<P>Обратите внимание, что память, размещенная после конца блока,
вероятно будет в использовании для чего - нибудь еще; возможно для
блока, уже размещенный другим обращением к malloc. Если Вы пытаетесь
обрабатывать блок как дольше чем Вы установили, Вы можете разрушить
данные, что malloc использует, чтобы следить за блоками, или Вы можете
разрушить содержимое другого блока. Если Вы уже зарезервировали блок и
обнаруживаете, что Вам нужен больший, используйте перераспределение (см.
раздел 3.3.4 [Изменение размеров блока]).
<P>
<H3>Освобождение памяти, размещенной malloc</H3>

<P>
<P>Когда Вы больше не нуждаетесь в блоке, который Вы создали malloc,
используйте функцию free чтобы сделать блок доступным, для следующего
резервировния. Прототип для этой функции находится в "stdlib.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void free (void * ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция освобождает блок памяти, указанной в ptr.
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void cfree (void * ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция делает то же самое что и предыдущая. Она
предусматривает совместимость снизу вверх с SunOS.
<P>Освобождение блока изменяет содержание блока. Не ищите какие-либо
данные (типа указателя на следующий блок в цепочке блоков) в блоке после
его освобождения. Копируйте все необхоимое во вне блока перед его
освобождением! Вот пример соответствующего способа освободить все блоки
в цепочке, и строки на которые они указывают:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct chain {struct chain *next; char *name;}
      void free_chain (struct chain *chain)
      {
       while (chain != 0)
        {
         struct chain *next = chain-&gt;next;
         free (chain-&gt;name);
         free (chain);
         chain = next;
        }
      }
</PRE>
</CODE></BLOCKQUOTE>

Иногда, free может фактически возвращать память в операционную
систему и делать процесс меньшим. Обычно, все это позволяет, вызывая
позже malloc, многократно использовать место. Тем временем, место
остается в вашей программе в списе свободных, и используется внутри
malloc.
<P>В конце программы, не имеется никаких указателей на освобожденые
блоки, потому что все место программы было отдано обратно системе, когда
процесс завершвлся.
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Изменение размера блока</H3>

<P>
<P>Часто Вы не уверены, насколько большой блок Вам будетнужен в
конечном счете. Например, блок может быть буфером, что Вы используете,
чтобы содержать строку читаемую из файла; неважно какой длины Вы делаете
буфер первоначально, Вы можете сталкнуться со строкой, которая будет
длиннее.
<P>Вы можете делать блок длиннее, вызывая realloc. Эта функция
объявлена в "stdlib.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * realloc (void * ptr, size _t newsize) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция realloc изменяет размер блока с адресом ptr, на newsize.
<P>Если место после конеца блока используется, realloc скопизует блок
по новому адресу, где доступно большее количество свободного
пространства. Значение realloc - новый адрес блока. Если блок должен
передвигаться, realloc, копирует старое содержимое.
<P>Если Вы передаете пустой указатель для ptr, realloc, ведет себя
точно так же как "malloc (newsize)". Это может быть удобно, но
остерегайтесь более старых реализаций (до ANSI C) которые не имеют права
поддерживать это поведение, и будут вероятно что-то разрушать , когда
realloc получит пустой указатель.
<P>Подобно malloc, realloc может возвращать пустой указатель, если
никакое пространство памяти не доступно, чтобы увеличить блок. Когда это
случается, первоначальный блок остается нетронутым; он не изменяется и
не перемещается.
<P>В большинстве случаев это не имеет значения, что случается с
первоначальным блоком, когда realloc терпит неудачу, потому что
прикладная программа не может продолжаться, когда не хватает памяти, и
единственное что, нужно сделать - это выдать сообщение о фатальной
ошибке. Часто бывает удобно написать и использовать подпрограмму,
традиционно называемую xrealloc, которая заботится о сообщениях об
ошибках, как xmalloc делает для malloc:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * xrealloc (void *ptr, size_t size)
      {
       register void *value = realloc (ptr, size);
       if (value == 0) fatal ("Virtual memory exhausted");
        return value;
      }
</PRE>
</CODE></BLOCKQUOTE>

Вы можете также использовать realloc, чтобы уменьшить блок. Чтобы
не связывать много пространства памяти, когда необходимо немного.
Создание меньшего блока иногда требует копировать его, так что это может
неудаться, если никакое другое место не доступно.
<P>Если новый размер, который Вы определяете - такой же как старый,
realloc, не изменит ничего и возвратит тот же самый адрес, который Вы
дали.
<P>
<H3>Распределение очищенного места</H3>

<P>
<P>Функция calloc резервирует память и обнуляет ее. Она объявлена в
"stdlib.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * calloc (size_t count, size _t eltsize) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция резервирует блок достаточно длинный, чтобы содержать
вектор из count элементов, каждый размера eltsize. Содержимое очищается
обнулением прежде чем calloc сделает возврат.
<P>Вы можете определять calloc следующим образом:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * calloc (size_t count, size_t eltsize)
      {
       size_t size = count * eltsize;
       void *value = malloc (size);
       if (value != 0) memset (value, 0, size);
       return value;
      }
</PRE>
</CODE></BLOCKQUOTE>

Мы редко используем calloc сегодня, потому что она эквивалентна
простой комбинации других средств, которые больее часто используются.
Это историческое средство, которое устаревает.
<P>
<P>
<P>
<P>
<H3>Обсуждение эффективности malloc</H3>

<P>
<P>Чтобы лучше использовать malloc, нужно знать, что GNU версия malloc
всегда назначает наименьший объем памяти в блоках, чьи размеры являются
степенями двойки. Она хранит раздельные пулы для каждой степени двойки.
И каждый занимает столько места сколько страница. Следовательно, если у
Вас есть свободный выбор размера маленького блока, чтобы сделать malloc
более эффективным, делайте его степенью двойки.
<P>Если страница разбита для определенного размеа блока, она не может
многократно использоваться для другого размера, если все блоки этого
размера не освобождены. В многих программах маловероятно, что это
случается. Таким образом, Вы можете иногда делать программы использующие
память более эффективно, используя блоки того же самого размера для
многих различных целей.
<P>Когда Вы запрашиваете о блоках памяти рамера страницы или больших,
malloc использует различную стратегию; она округляет сверху размер до
нескольких размеров странцы, и может обьединять и разбивать блоки как
необходимо.
<P>Причина для двух cтратегий то, что важно зарезервировать и
освободить маленькие блоки так быстро как возможно, но для большого
блока быстродействие менее важно, так как программа обычно тратит больше
времени используя его. Больших блоков обычно меньше. Следовательно, для
больших блоков, имеет смысл использовать метод, который занимает большее
количество времени, чтобы минимизировать потраченное впустую место.
<P>
<P>
<P>
<P>
<H3>Распределение выравниваемых блоков памяти</H3>

<P>
<P>Адрес блока, возвращенного malloc или realloc в системе GNU &shy;
всегда делится на восемь. Если Вы нуждаетесь в блоке, чей адрес &shy;
делится на более высокой степень двойки чем этот, используйте memalign
или valloc. Эти функции объявлены в "stdlib.h".
<P>С библиотекой GNU, Вы можете использовать free, чтобы освободить
блоки которые возвращают memalign и valloc. Это не работает в BSD, т. к.
BSD не обеспечивает ни какого способа освободить такие блоки.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * memalign (size _t size, size _t boundary) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция memalign зарезервирует блок size байтов чей адрес - делится
на boundary. Граница boundary должна быть степенью двойки! Функция
memalign работает, вызывая malloc, чтобы зарезервировать несколько
больший блок, и возвращает адрес внутри блока, который находится на
заданной границе.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * valloc (size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Подобна memalign с размером страницы заданным как значение второго
аргумента:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * valloc (size_t size)
      {
       return memalign (size, getpagesize ());
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Проверка непротиворечивости кучи</H3>

<P>
<P>Вы можете указать, чтобы malloc проверила непротиворечивость
динамической памяти, используя функцию mcheck. Эта функция - расширение
GNU, объявленное в "malloc.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int mcheck (void (* abortfn) (void)) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Вызывая mcheck сообщает, чтобы malloc выполнил случайные проверки
непротиворечивости. Они будут захватывать вещи типа письменного
соглашения после конца блока, который был размещен malloc.
<P>аbortfn аргумент - это функция, которая вызвается, когда
несогласованность найдена. Если Вы обеспечиваете пустой указатель,
используется функция аварийного прекращения работы.
<P>Слишком поздно начинать проверку, если Вы уже зарезервировали что-&shy;
нибудь с помощью malloc. Так как mcheck в этом случае ничего не делает.
Функция возвращает -1, если Вы вызываете ее слишком поздно, и 0 иначе (в
случае успеха).
<P>Самый простой способ вызывать mcheck вовремя состоит в том, чтобы
использовать опцию "-lmcheck" когда Вы компонуете вашу программу; то Вы
вообще не должны изменять вашу исходную программу.
<P>
<H3>Ловушки для резервирования памяти</H3>

<P>
<P>GNU C библиотека позволяет Вам изменять поведение malloc, realloc,
и free, определяя соответствующие функции ловушки. Вы можете
использовать эти ловушки, чтобы отладить программы, которые используют
динамическое резервирование памяти.
<P>Переменные-ловушки объявлены в "malloc.h".
<DL>
<DT><B>__realloc_hook (переменная) </B><DD><P>
<P>Значение этой переменной - указатель на функцию, которe realloc
использует всякий раз, когда вызывается. Вы должны определить эту
функцию, как:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * function (void * ptr, size _t size)
</PRE>
</CODE></BLOCKQUOTE>
<DT><B>__free_hook (переменная) </B><DD><P>
<P>Значение этой переменной - указатель на функцию, которую free
использует всякий раз, когда вызывается. Вы должны определить эту
функцию, как:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void function (void * ptr)
</PRE>
</CODE></BLOCKQUOTE>

Вы должны удостовериться, что функция, которую Вы устанавливаете
как ловушку для одной из этих функций, не вызывает заменяемую функцию
рекурсивно без того, чтобы сначала восстановить старое значение ловушки!
Иначе, ваша программа будет эастревать в бесконечной рекурсии.
</DL>

Это пример показывает как правильно использовать __malloc_hook. Мы
устанавливаем функцию, которая выводит информацию каждый раз когда
вызывается malloc.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      static void *(*old_malloc_hook) (size_t);
      static void * my_malloc_hook (size_t size)
      {
       void *result; __malloc_hook = old_malloc_hook;
       result = malloc (size);
       __malloc_hook = my_malloc_hook;
       printf ("malloc (%u) returns %p\n", (unsigned  int) size, result);
       return result;
      }
      main ()
      {
       ...
       old_malloc_hook = __malloc_hook;
       __malloc_hook = my_malloc_hook;
       ...
      }
</PRE>
</CODE></BLOCKQUOTE>

Функция mcheck (см. раздел 3.3.8 [Непротиворечивость кучи]) в ходе
своей работы устанавливает такие ловушки.
<P>
<H3>Статистика резервирования памяти при помощи malloc</H3>

<P>
<P>Вы можете получить информацию относительно динамического
резервирования памяти, вызывая функцию mstats. Эта функция и связанный
тип данных объявлены в "malloc.h"; они являются расширением GNU.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct mstats (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот структурный тип используется, чтобы возвратить информацию
относительно динамической программы распределения памяти. Она содержит
следующие поля:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t bytes_total
</PRE>
</CODE></BLOCKQUOTE>

Это - полный размер памяти, управляемой malloc, в байтах.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t chunks_used
</PRE>
</CODE></BLOCKQUOTE>

Это - число используемых кусков. (Программа распределения памяти
внутренне получает куски памяти из операционной системы, и преобразует
их в такие, которые удовлетворяют индивидуальным запросам malloc; см.
раздел 3.3.6 [Эффективность и malloc])
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t bytes_used
</PRE>
</CODE></BLOCKQUOTE>

Это число используемых байтов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t chunks_free
</PRE>
</CODE></BLOCKQUOTE>

Это - число кусков, которые являются свободными - то есть которые
были размещены операционной системой вашей программы, но теперь не
используются.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size_t bytes_free
</PRE>
</CODE></BLOCKQUOTE>

Это - число свободных байт.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct mstats mstats (void) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает информацию относительно текущего
динамического использования памяти в структуре типа struct mstats.
<P>
<H3>Обзор функций, имеющих отношение к функции malloc</H3>

<P>
<P>Это обзор функций, которые имеют отношение к malloc:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * malloc (size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует блок из size байт. См. раздел 3.3.1 [Базисное
резервирование].
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void free (void *addr)
</PRE>
</CODE></BLOCKQUOTE>

Освобождает блок, предварительно размещенный malloc. См. раздел
3.3.3 [Освобождение после malloc].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * realloc (void * addr, size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Делает блок, предварительно размещенный malloc больше или меньше,
возможно, копируя его по новому расположению. См. раздел 3.3.4
[Изменение размеров блока].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * calloc (size _t count, size _t eltsize)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует блок в count * eltsize байт, используя malloc, и
обнуляет содержимое. См. раздел 3.3.5 [Распределение очищенного места].
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * valloc (size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Зарезервирует блок в size байт, начинающийся на границе страницы.
См. раздел 3.3.7 [Выравниваемые блоки памяти].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * memalign (size _t size, size _t boundary)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует блок в size байт, начинающийся с адреса, который
является делится на выравнивание. См. раздел 3.3.7 [Выравниваемые блоки
памяти].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int mcheck (void (* abortfn) (void))
</PRE>
</CODE></BLOCKQUOTE>

Указывает, чтобы malloc выполнил случайную проверку
непротиворечивости динамически размещенной памяти, и вызыватл abortfn,
если найдена несогласованность. См. раздел 3.3.8 [Непротиворечивость
кучи].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * (* __ malloc_hook) (size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Указатель на функцию, которую malloc использует всякий раз, когда
вызывается.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * (* __ realloc _hook) (void * ptr, size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Указатель на функцию, которую realloc использует всякий раз, когда
вызывается.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void (* __ free _hook) (void * ptr)
</PRE>
</CODE></BLOCKQUOTE>

Указатель на функцию, которую free использует всякий раз, когда
вызывается.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct mstats mstats (void)
</PRE>
</CODE></BLOCKQUOTE>

Возвращают информацию относительно текущего динамического
исполнения памяти. См. раздел 3.3.10 [Статистика malloc].
<P>
<H2><A NAME="ss3.4">3.4 obstacks</A>
</H2>

<P>
<P>obstack - пул памяти, содержащей стек объектов. Вы можете создавать
любое число различных obstacks, и зарезервировать объекты в заданном
obstacks. Внутри каждого obstack, последний размещенный объект должен
всегда быть первым освобожденным, но различные obstacks независят от
друг друга.
<P>Кроме этого одного ограничения на порядок освобождения, obstacks
полностью свободен: obstack может содержать любое число объектов любого
размера. Они выполнены как макрокоманды, так что резервирование обычно
очень быстро, так как объекты обычно маленькие. И единственные
дополнительные непроизводительные затраты на объект необходимы, чтобы
начать каждый объект с подходящей границы.
<P>
<H3>Создание obstacks</H3>

<P>
<P>Утилиты для управления obstacks объявлены в заголовочном файле
"obstack.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct obstack (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

obstack представляется структурой данных типа struct obstack. Эта
структура имеет маленький фиксированный размер; она содержит состояния
obstack и информацию о том, как как найти место, в котором размещены
объекты. Она не содержит ни какой из объектов непосредственно. Вы не
должны пробовать непосредственно обращаться к содержимому структуры;
используйте только функции, описанные в этой главе.
<P>Вы можете объявлять переменные типа struct obstack и использовать
их как obstacks, или Вы можете зарезервировать obstacks динамически
подобно любому другому виду объекта. Динамическое резервирование
obstacks разрешает вашей программе иметь переменное число различных
стеков. (Вы можете даже зарезервировать структуру obstack в другом
obstack, но это редко требуется.)
<P>Все функции, которые работают с obstacks, требуют, чтобы Вы
определили, какой obstack использовать. Вы делаете это указателем типа
struct obstack *. Далее, мы часто будем говорить "obstack" когда, строго
говоря, имеем в виду такой указатель.
<P>Объекты в obstack упакованы в большие блоки называемые кусками.
Структура struct obstack указывает на цепочку используемых в настоящее
время кусков.
<P>Библиотека obstack получает новый кусок всякий раз, когда Вы
резервируете объект, которому не удовлетворяет предыдущий кусок. Так как
библиотека obstack управляет кусками автоматически, Вы не должны уделять
им много внимания, но Вы должны обеспечить функцию, которую библиотека
obstack должна использовать, чтобы получить кусок. Обычно Вы
обеспечиваете функцию, которая использует malloc непосредственно или
косвенно. Вы должны также обеспечить функцию освобождения куска. Эти
вопросы описаны в следующем разделе.
<P>
<H3>Подготовка к использованию obstacks</H3>

<P>
<P>В каждый исходный файл, в котором Вы планируете использовать
функции obstack, следует включить заголовочный файл "obstack.h":
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #include &lt;obstack.h&gt;
</PRE>
</CODE></BLOCKQUOTE>

Также, если исходный файл использует макрокоманду obstack_init, он
должен объявить или определить две функции или макрокоманды, которые
будут вызываться библиотекой obstack. Это, obstack_chunk_alloc, которая
используется, чтобы зарезервировать куски памяти, в которую объекты
упакованы. Другая, obstack_chunk_free, которая используется, чтобы
возвратить куски, когда объекты из них освобождены.
<P>Обычно они определены, чтобы использовать malloc через посредника
xmalloc (см. раздел 3.3 [Беспрепятственное Резервирование]). Это
выполнено следующей парой макроопределений:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #define obstack_chunk_alloc xmalloc*
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
      #define obstack_chunk_free free
</PRE>
</CODE></BLOCKQUOTE>

Хотя память, которую Вы получаете используя obstacks действительно,
исходит из malloc, использование obstacks - быстрее, потому что malloc
вызывается менее часто, для больших блоков памяти. См. раздел 3.4.10
[Куски obstack], для полной информации.
<P>Во время выполнения, прежде, чем программа может использовать
struct obstack object как obstack, она должна инициализировать obstack,
вызывая obstack_init.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_init (struct obstack * obstack_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Инициализирует obstack obstack_ptr для резервирования объектов.
<P>Имеются два примера того, как зарезервировать пространство для
obstack и инициализировать его. Первый, obstack, который является
статической переменной:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      static struct obstack myobstack;
      ...
      оbstack_init (&amp;myobstack);
</PRE>
</CODE></BLOCKQUOTE>

Во-вторых, obstack, который самостоятельно динамически размещен:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct obstack * myobstack_ptr= (struct obstack *) xmalloc (sizeof(struct obstack));

      obstack_init (myobstack_ptr);
</PRE>
</CODE></BLOCKQUOTE>
<H3>Резервирование в obstack</H3>

<P>
<P>Наиболее прямой способ зарезервировать объект в obstack - через
obstack_alloc, которая вызывается почти как malloc.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_alloc (struct obstack * obstack_ptr, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует неинициализированный блок size байт в obstack и
возвращает адрес. Здесь obstack_ptr определяет, в каком obstack
зарезервировать блок; это - адрес struct obstack object, который
представляет obstack. Каждая функция obstack или макрокоманда требует,
чтобы Вы определили obstack_ptr как первый аргумент.
<P>Например функция, которая резервирует копию строки str в
определенном obstack, который находится в переменной string_obstack:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      struct obstack string_obstack;
      char * copystring (char *string)
      {
       char *s = (char *) obstack_alloc (&amp;string_obstack, strlen (string) + 1);
       memcpy (s, string, strlen (string));
       return s;
      }
</PRE>
</CODE></BLOCKQUOTE>

Чтобы зарезервировать блок с заданным содержимым, используйте
функцию obstack_copy, объявляемую так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_copy (struct obstack * obstack_ptr, void *address, size_t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует блок и инициализирует его, копируя size байтов данных,
начинающихся по адресеу
<P>
<BLOCKQUOTE><CODE>
<PRE>
      vоid * obstack_copy0 (struct obstack * obstack_ptr, void *address, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Подобна obstack_copy, но конкатенирует дополнительный байт,
содержащий пустой символ. Этот дополнительный байт не учтен в размере
аргумента.
<P>Функция obstack_copy удобна для копирования последовательности
символов в obstack как законченной пустым символом строки. Пример
использования:
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * obstack_savestring (char * addr, size _t size)
      {
       return obstack_copy (myobstack, addr, size);
      }
</PRE>
</CODE></BLOCKQUOTE>

Сравните это с предыдущим примером сохранения строки, использующим
malloc (см. раздел 3.3.1 [Базисное резервирование]).
<P>
<H3>Освобождение объектов из obstack</H3>

<P>
<P>Для освобждения объекта, размещенный в obstack, используйте функцию
obstack_free. Так как obstack - стек объектов, освобождение одного
объекта автоматически освобождает все другие объекты, зарезервированные
позже в том же самом obstack.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_free (struct obstack * obstack_ptr, void * object) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Если object - пустой указатель, все размещенные в obstack
освобождаются. Если, object есть адрес объекта, размещенного в obstack,
то объект освобождается, наряду с всеми размещенноми в obstack начиная с
object.
<P>Обратите внимание, что, если object является пустым указателем, то
результат - неинициализированный obstack. Для освобождения всей памяти в
obstack, с возможным его использованием для дальнейшего резервирования,
вызовите obstack_free с адресом первого объекта, размещенного в obstack:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      obstack_free (obstack_ptr, first_object_allocated_ptr);
</PRE>
</CODE></BLOCKQUOTE>

Обратите внимание, что объекты в obstack сгруппированы в куски.
Когда все объекты в куске становятся свободными, библиотека obstack
автоматически освобождает кусок (см. раздел 3.4.2 [Подготовка obstack]
). Тогда другое obstack-, или не obstack-резервирование, может
многократно использовать куска, занимаемое куском.
<P>
<P>
<P>
<H3>Функции и макросы obstack</H3>

<P>
<P>Интерфейсы для использования obstacks могут быть определены или как
функции или как макрокоманды, в зависимости от транслятора. obstack
средство работает со всеми C трансляторами, включая, и ANSI C и
традиционный C, но имеются предосторожности, которые Вы должны
соблюдать, если Вы планируете использовать трансляторы отличные от GNU
C.
<P>Если Вы используете традиционный не ANSI C транслятор, все obstack
"функции" фактически определены только как макрокоманды. Вы можете
вызывать эти макрокоманды подобно функциям, но Вы не можете использовать
их любым другим способом (например, Вы не можете брать их адрес).
<P>Вызов макрокоманд требует некоторых предосторожностей: а именно,
первый операнд (указатель на obstack) не имеет права содержать никаких
побочных эффектов, потому что он может быть вычислен больше чем один
раз. Например, если Вы напишете: obstack_alloc (get_obstack (), 4), Вы
увидите, что get_obstack может называться несколько раз. Если Вы
используете * obstack_list_ptr ++ как аргумент-указатель obstack, Вы
получите очень странные результаты, так как приращение может происходить
несколько раз.
<P>В ANSI C, каждая функция имеет, и макроопределение и определение
функции. Определение функции используется, если Вы берете адрес функции
без того, чтобы вызвать ее. Обычное обращение использует
макроопределение по умолчанию, но Вы можете запрашивать определение
функции, написав имя функции в круглых скобках, как показано здесь:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      char * x; void * (* funcp) (); /* Используем макрокоманду. */
      x = (char *) obstack_alloc (obptr, size);  /* Вызываем функцию. */
      x = (char *) (obstack_alloc) (obptr, size);  /* Берем адрес функции. */
      funcp = obstack_alloc;
</PRE>
</CODE></BLOCKQUOTE>

Это - та же самая ситуация, что и в ANSI C для стандартных
библиотечных функций. См. раздел 1.3.2 [Определение макросов].
<P>
<P>Предупреждение: Когда Вы используете макрокоманды, Вы должны
соблюдать предосторожности избавившись от побочных эффектов в первом
операнде, даже в ANSI C.
<P>Если Вы используете транслятор GNU C, эта предосторожность,
необязательна, потому что различные расширения языка в GNU C разрешают
определять макрокоманды, чтобы вычислять каждый аргумент только один
раз.
<P>
<H3>Возрастающие объекты</H3>

<P>
<P>Т.к. память в кусках obstack используется последовательно, возможно
создать объект шаг за шагом, добавляя один или больше байт сразу к концу
объекта. При таком способе, Вы не должны знать, сколько данных у Вас
будет включено в объект до этого. Мы называем это методикой
возрастастающих объектов. В этом разделе описаны специальные функции для
добавления данных к возрастастающему объекту.
<P>Вы не должны делать что-нибудь особенное, когда Вы начинаете
наращивать объект. Использование одной из функций, чтобы добавить данные
к объекту автоматически начинает его. Однако, необходимо явно указать,
когда объект закончен. Это выполняется функцией obstack_finish.
<P>Действительный адрес объекта, созданного таким образом не известен,
пока объект не закончен. До тех пор, всегда остается возможность, что Вы
добавите так много данных, что объект придется скопировать в новый
кусок.
<P>Поскольку obstack используется для возрастастающего объекта, Вы не
можете использовать obstack для обычного резервирования другого объекта.
Если, Вы попробуете это сделать, то место, уже добавленное к
возрастастающему объекту, станет частью другого объекта.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_blank (struct obstack * obstack_ptr, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Базисной функцией для добавления к возрастастающему объекту
является obstack_blank, которая добавляет место без его
инициализированя.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_grow (struct obstack * obstack_ptr, void *data , size_t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Добавляет блок инициализированного места, используя obstack_grow,
которая является аналогом obstack_copy для возрастающих объектов. Она
добавляет size байт данных к возрастастающему объекту, копируя
содержимое из данных.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_grow0 (struct obstack * obstack_ptr, void *data, size_t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Это - аналог obstack_copy для возрастающих объектов. Она добавляет
size байт копируемых из данных, добавляя дополнительный пустой символо.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_1grow (struct obstack * obstack_ptr, char c) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Чтобы добавить только один символ, используется функция
obstack_1grow. Она добавляет одиночный байт с к возрастастающему
объекту.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_finish (struct obstack * obstack_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Когда Вы закончили увеличивать объект, используйте функцию
obstack_finish, чтобы закрыть его и получить конечный адрес.
<P>Если Вы закончили объект, obstack доступен для обычного
резервирования или для увеличения другого объекта.
<P>Когда Вы формируете объект, Вы будете вероятно должны знать, позже
сколько места занял. Вы не должны следить за этим, потому что Вы можете
выяснять длину из obstack перед самым окончанием объекта функцией
obstack_object_size, объявленный следующим образом:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t obstack_object_size (struct obstack * obstack_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает текущий размер возрастастающего объекта, в
байтах. Не забудьте вызывать эту функцию перед окончанием объекта. После
того, как он закончен, obstack_object_size будет возвращать нуль.
<P>Если Вы начали увеличивать объект и желаете отменить это, Вы должны
закончить его и тогда освободить его, примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      obstack_free (obstack_ptr, obstack_finish (obstack_ptr));
</PRE>
</CODE></BLOCKQUOTE>

Это не имеет никакого эффекта, если никакой объект не возрастастал.
<P>Вы можете использовать obstack_blank с отрицательным аргументом
size, чтобы делать текущий объект меньше. Только не пробуйте сокращать
его до меньше нуля, не имеется никаких сведенний, что случиться, если Вы
сделаете это.
<P>
<H3>Сверхбыстро возрастастающие объекты</H3>

<P>
<P>Обычные функции для возрастастающих объектов делают
непроизводительные затраты для проверки, имеется ли участок памяти для
нового роста в текущем куске. Если Вы часто создаете объекты в с
маленькими шагами роста, эти непроизводительные затраты, могут быть
значительны.
<P>Вы можете уменьшать непроизводительные затраты, используя
специальный "быстрый рост", т. е. функции, которые выращивают объект без
проверки. Чтобы иметь здоровую программу, Вы должны делать проверку
самостоятельно. Если Вы делаете это самым простым способом каждый раз.
когда Вы собираетесь, добавлять данные к объекту, Вы ничего не
приобретете, потому что это и делают обычные функции возрастания. Но
если Вы можете проверить менее часто, или проверять более эффективно, то
Вы сделаете программу быстрее.
<P>Функция obstack_room возвращает количество памяти, доступной в
текущем куске. Она объявлена следующим образом:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t obstack_room (struct obstack * obstack_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Возвращает число байтов которые могут быть добавлены к текущему
возрастастающему объекту (или к объекту, собирающемуся начаться) в
obstack при использовании быстрых функций роста.
<P>Если Вы знаете, что имеется участок памяти, Вы можете использовать
эти быстрые функции роста для добавления данных к возрастастающему
объекту:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_1grow_fast (struct obstack * obstack_ptr, char c) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция obstack_1grow_fast добавляет один байт, содержащий символ с
к возрастастающему объекту в obstack obstack_ptr.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_blank_fast (struct obstack * obstack_ptr, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция obstack_blank_fast добавляет size байтов к возрастастающему
объекту в obstack obstack_ptr без их инициализации.
<P>Если Вы проверяете место, используя obstack_room и нет достаточного
участка памяти, для того, что Вы хотите добавлять, то быстрые функции
роста не безопасны. В этом случае, просто используйте соответствующую
обычную функцию роста. Если она будет копировать объект в новый кусок;
то будет иметься больше доступной памяти.
<P>Так, каждый раз когда Вы используете обычную функцию роста,
проверяйте есть ли достаточного места, используя obstack_room. Как
только объект скопирован в новый кусок, будет снова иметься много места,
так что программа будет начинать использовать быстрые функции роста.
<P>Вот пример:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void add_string (struct obstack * obstack, char * ptr, size _t len)
      {
       while  (len &gt; 0)
       {
        if (obstack_room (obstack) &gt; len)
         {          /* Мы имеем достаточный участок памяти: добавляйте все
                        быстро. */
           while (len - &gt; 0) obstack_1grow_fast (obstack, * ptr ++);
         }
        else
         {
      /* Нет достаточного участка памяти. Добавьте один символ, он может
 быть скопирован в новый кусок для создания места. */
          obstack_1grow (obstack, * ptr ++); len -;
         }
       }
      }
</PRE>
</CODE></BLOCKQUOTE>
<H3>Состояние obstack</H3>

<P>
<P>Имеются функции, которые обеспечивают информацию относительно
текущего состояния резервирования в obstack. Вы можете использовать их,
чтобы узнать относительно объекта при все еще возрастании это.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_base (struct obstack * obstack_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает временный адрес начала в настоящее время
возрастастающего объекта в obstack_ptr. Если Вы заканчите объект
немедленно, он будет иметь этот адрес. Если Вы сначала его увеличиваете,
он может перерасти этот кусок и адрес будет изменяться!
<P>Если никакой объект в данный момент не возрастастает, это значение
показывает, где будет начинаться следующий объект, который Вы
зарезервируете.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_next_free (struct obstack * obstack_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает адрес первого свободного байта в текущем
куске obstack obstack_ptr, т. е. - конца в настоящее время
возрастастающего объекта. Если никакой объект не возрастастает,
obstack_next_free, возвращает то же самое значение что и obstack_base.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t obstack_object_size (struct obstack * obstack_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает размер в байтах возрастастающего в настоящее
время объекта. Она эквивалентна toobstack_next_free (obstack_ptr) &shy;
obstack_base (obstack_ptr)
<P>
<H3>Выравнивание данных в obstacks</H3>

<P>
<P>Каждый obstack имеет границу выравнивания; каждый объект,
размещенный в obstack автоматически начинается на адресе, который
делится на заданную границу (выравнивание). По умолчанию, эта граница &shy;
4 байта.
<P>Чтобы обращаться к границе выравнивания obstack, используйте
макрокоманду obstack_alignment_mask, чей функциональлный прототип
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int obstack_alignment_mask (struct obstack * obstack_ptr) (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Его значение - битовая маска; установленная еденица, указывает, что
соответствующий бит в адресе объекта должен быть 0. Значение маски
должно быть на еденицу меньше чем степень 2; и все адреса объекта &shy;
делится на эту степень 2. По умолчанию значение маски - 3, чтобы адреса
- делились на 4. Значение маски 0 означает, что объект может начинаться
с любого целого адреса (то-есть никакое выравнивание не требуется).
<P>Расширение макрокоманды obstack_alignment_mask - именующее
выражение, так что Вы можете изменять маску назначением. Например, это
утверждение:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      obstack_alignment_mask (obstack_ptr) = 0;
</PRE>
</CODE></BLOCKQUOTE>

Выключает обработку выравнивания в заданном obstack.
<P>Обратите внимание, что изменение в маске выравнивания не действует
до окончания или размещения следующего объекта в obstack. Если Вы не
увеличиваете объект, Вы может заставить новую маску выравнивания
воздействовать немедленно, вызывая obstack_finish. Она заканчит объект
нулевой длины и то сделает соответствующее выравнивание для следующего
объекта.
<P>
<H3>Куски obstack</H3>

<P>
<P>obstacks работает, резервируя пространство для себя в больших
кусках, и разбивает место снаружи на куски, чтобы удовлетворить ваши
запросы. Куски - обычно длиной 4096 байтов, если Вы не определите другой
размер куска. Размер куска включает 8 байтов непроизводительных затрат,
которые фактически не используются для сохранения объектов. Независимо
от заданного размера, длинные объекты будут размещены в более длинные
куски, когда необходимо.
<P>obstack библиотека зервирует куски, вызывая функцию
obstack_chunk_alloc, которую Вы должны определить. Когда кусок больше не
нужен, если Вы освободили в нем все объекты, obstack библиотека
освобождает кусок, вызывая obstack_chunk_free, которыую Вы должны также
определить.
<P>Эти две функции должны быть определены (как макрокоманды) или
объявляться (как функции) в каждом исходном файле, который использует
obstack_init (см. раздел 3.4.1 [Создание obstacks]). Наиболее часто они
определены как макрокоманды подобно:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      #define obstack_chunk_alloc xmalloc
      #define obstack_chunk_free free
</PRE>
</CODE></BLOCKQUOTE>

Обратите внимание, что это простые макрокоманды (никаких
аргументов). Определения макросов с аргументами работать не будут!
Необходимо чтобы obstack_chunk_alloc или obstack_chunk_free, расширялась
в имя функции, если она не является именем функции.
<P>Функция, которая фактически осуществляет obstack_chunk_alloc, не
может возвратить "отказ" в любом режиме, потому что obstack библиотека
не подготовлена, чтобы обработать отказ. Следовательно, malloc
непосредственно не подходит. Если функция не может получить место, она
должна также завершить процесс (см. раздел 22.3 [Прерывание программ]
или делать нелокальный выход, используя longjmp (см. Главу 20
[Нелокальные выходы] ).
<P>Если Вы зарезервируете куски с malloc, размер куска, должен быть
степенью 2. Заданный по умолчанию размер куска - 4096, был выбран,
достаточно большим чобы удовлетворить много типичных запросов на obstack
однако достаточно коротким, чтобы не тратить впустую слишком много
памяти.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t obstack_chunk_size (struct obstack * obstack_ptr) (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Он возвращает размер куска данного obstack.
<P>Так как эта макрокоманда расширяется до именующего выражения, Вы
можете определить новый размер куска, назначая новое значение. Ее
выполнение не подействует на куски, уже размещенные, но изменит размер
кусков, размещенных в том конкретном obstack в будущем., вряд ли, будет
полезно сделать размер куска меньше, но создание большего могло бы
увеличивать эффективность, если Вы зарезервируете много объектов, чьи
размеры являются сравнимыми с размером куска. Вот как это можно сделать:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      if (obstack_chunk_size (obstack_ptr) &lt; new_chunk_size)
       obstack_chunk_size (obstack_ptr) = new_chunk_size;
</PRE>
</CODE></BLOCKQUOTE>
<H3>Обзор функций, имеющих отношение к obstack</H3>

<P>
<P>Это обзор всех функций, связанных с obstack. Каждая берет в
качестве первого аргумента адрес obstack (struct obstack *).
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_init (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Инициализирует использование obstack. См. раздел 3.4.1 [Создание
obstacks].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_alloc (struct obstack * obstack'ptr, size_t size)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует объект как size неинициализированных байт. См. раздел
3.4.3 [Резервирование в obstack].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_copy (struct obstack * obstack'ptr, void *address, size_t size)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует объект из size байтов, с содержимым, скопированным из
адреса address. См. раздел 3.4.3 [Резервирование в obstack].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_copy0 (struct obstack * obstack'ptr, void *address, size_t size)
</PRE>
</CODE></BLOCKQUOTE>

Резервирует объект из size + 1 байт, size из которых скопированы из
адреса address, сопровождаемый пустым символом в конце. См. раздел 3.4.3
[Резервирование в obstack].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_free (struct obstack * obstack'ptr, void * object)
</PRE>
</CODE></BLOCKQUOTE>

Освобождает обьект (и все размещенное в заданном obstack позже чем
object). См. раздел 3.4.4 [Освобождение obstack объектов].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_blank (struct obstack * obstack'ptr, size_t size)
</PRE>
</CODE></BLOCKQUOTE>

Добавляет size неинициализированных байтов к возрастастающему
обьекту object. См. раздел 3.4.6 [Возрастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_grow (struct obstack * obstack'ptr, void * address,
 size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Добавляет size байт, скопированных из address, к возрастастающему
обьекту object. См. раздел 3.4.6 [Возрастастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_grow0 (struct obstack * obstack'ptr, void * address,
 size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Добавляет size байт, скопированных из address, к возрастастающему
обьекту object, и еще добавляет другой байт, содержащий пустой символ.
См. раздел 3.4.6 [Возрастастающие объекты].
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_1grow (struct obstack * obstack'ptr, char data'char)
</PRE>
</CODE></BLOCKQUOTE>

Добавляет один байт данных к возрастастающему обьекту object. См.
раздел 3.4.6 [Возрастастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_finish (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Завершает объект, который возрастастает и возвращает постоянный
address. См. раздел 3.4.6 [Возрастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t obstack_object_size (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Получает текущий размер в настоящее время возрастастающего объекта.
См. раздел 3.4.6 [Возрастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void obstack_blank_fast (struct obstack * obstack'ptr, size _t size)
</PRE>
</CODE></BLOCKQUOTE>

Добавляет size неинициализированных байт к возрастастающему объекту
без проверки, что имеется достаточный участок памяти. См. раздел 3.4.7
[Сверхбыстро возрастастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      vid obstack_1grow_fast (struct obstack * obstack'tr, char
 data'char)
</PRE>
</CODE></BLOCKQUOTE>

Добавляет один байт к возрастастающему объекту без проверки, что
имеется достаточный участок памяти. См. раздел 3.4.7 [Сверхбыстро
возрастастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t obstack_room (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Получает участок памяти, теперь доступный для возрастания текущего
объекта. См. раздел 3.4.7 [Сверхбыстро возрастающие объекты].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      int obstack_alignment_mask (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Маска, используемая для выравнивания начала объекта. Это &shy;
именующее выражение (адрес переменной). См. раздел 3.4.9 [Выравнивание
данных obstacks].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      size _t obstack_chunk_size (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Размер распределяемых кусков. Это - именующее выражение. См. раздел
3.4.10 [ Куски obstack].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_base (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Пробный начальный адрес в настоящее время возрастастающего объекта.
См. раздел 3.4.8 [Состояние obstack].
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * obstack_next_free (struct obstack * obstack'ptr)
</PRE>
</CODE></BLOCKQUOTE>

Адрес следующий сразу за концом в настоящее время возрастастающего
объекта. См. раздел 3.4.8 [Состояние obstack].
<P>
<H2><A NAME="ss3.5">3.5 Автоматическая память с учетом размера переменной</A>
</H2>

<P>
<P>Функция alloca поддерживает вид полудинамического резервирования, в
котором блоки размещены динамически, но освобождаются автоматически.
<P>Распределение блока alloca - явное действие; Вы можете
зарезервировать так много блоков, как Вы желаете, и вычислять размеры во
время выполнения. Но все блоки освобождатся, когда Вы выходите из
функции из которой alloca вызывалась,как если бы они были динамические
локальные переменные, объявленные в этой функции. Не имеется никакого
способа освободить место явно.
<P>Прототип для alloca находится в "stdlib.h". Эта функция - BSD
расширение.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * alloca (size _t size); (функция)
</PRE>
</CODE></BLOCKQUOTE>

Возвращаемое значение alloca - адрес блока из size байтов памяти,
размещенного в области данных вызывающей функции.
<P>
<P>Не используйте alloca внутри аргументов обращения к функции, Вы
получите непредсказуемые результаты, потому что стек-пространство для
alloca появится на стеке в середине пространства для аргументов функции.
Пример того, что нужно избегать - foo (x, alloca (4), y).
<P>
<H3>Примеры alloca</H3>

<P>
<P>Пример использования alloca, это функция, которая открывает имя
файла, сделанное из связывания двух строк аргумента, и возвращает
описатель файла или минус один выражая отказ:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      intopen2 (char * str1, char * str2, int flags, int mode)
      {
       char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
       strcpy (name, str1);
       strcat (name, str2);
       return open (name, flags, mode);
      }
</PRE>
</CODE></BLOCKQUOTE>

А вот, как Вы получили бы те же самые результаты с malloc и free:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      intopen2 (char * str1, char * str2, int flags, int mode)
      {
       char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
       int desc;
       if (name == 0) fatal ("превышенна виртуальная память ");
       strcpy (name, str1);
       strcat (name, str2);
       desc = (name, flags, mode);
       free (name);
       desc;
      }
</PRE>
</CODE></BLOCKQUOTE>

Вы видите, что это более просто с alloca. Но alloca имеет другие,
более важные преимущества, и некоторые недостатки.
<P>
<P>
<P>
<H3>Преимущества alloca</H3>

<P>
<P>Имеются причины, почему alloca может быть предпочтительнее malloc:
<UL>
<LI>       Использование alloca занимает мало места и очень быстро. (Это
открыто кодируется компилятором GNU С.)
</LI>
<LI>       С тех пор alloca не имеет отдельных пулов для различных размеров
блока, место, используемое для блока любого размера может многократно
использоваться и для любого другого. alloca не вызывает фрагментацию
памяти.
</LI>
<LI>       Нелокальные выходы, выполненные через longjmp (см. Главу 20
[Нелокальные выходы]) автоматически освобождают место, размещенное
alloca, когда они выходят из функции, которая вызвала alloca. Это &shy;
наиболее важная причина использовать alloca.</LI>
</UL>

Чтобы иллюстрировать это, предположите, что Вы имеете функцию
open_or_report_error, которая возвращает описатель открытого, если она
успешно завершается, но не возвращается к вызывающему оператору, если
она терпит неудачу. Если файл не может быть открыт, она печатает
сообщение об ошибках и переходит с командного уровня вашей программы,
используя longjmp. Давайте изменим open2 (см. раздел 3.5.1 [Примеры
alloca]) чтобы использовать эту подпрограмму:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      intopen2 (char * str1, char * str2, int flags, int mode)
      {
       char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
       strcpy (name, str1); strcat (name, str2);
       return open_or_report_error (name, flags, mode);
      }
</PRE>
</CODE></BLOCKQUOTE>

Из-за способа работы alloca, память, которую она резервирует,
освобождается даже, когда происходит ошибка, без специального усилия.
<P>А предыдущее определение open2 (которое использует malloc и free)
допустило бы утечку памяти, если это было бы изменено таким образом,.
Даже если Вы хотите сделать большее количество изменений, чтобы
устранить это, не имеется никакого простого способа делать так.
<P>
<H3>Недостатки alloca</H3>

<P>
<P>Здесь недостатки alloca по сравнению с malloc:
<UL>
<LI>       Если, Вы пробуете зарезервировать большее количество памяти чем
машина, может обеспечивать, Вы не получаете чистое сообщение об ошибках.
Взамен Вы получаете фатальный сигнал подобно тому, который Вы получили
бы из бесконечной рекурсии; возможно нарушение сегментации (см. раздел
21.2.1 [Сигналы об ошибках в программе]).
</LI>
<LI>       Некоторые не-GNU системы будут не в состоянии поддерживать
alloca, так что она менее переносима. Однако, более медленная эмуляция
alloca, которую пишут на C доступна для использования в системах с этой
неточностью.</LI>
</UL>
<H3>GNU C массивы с переменным размером</H3>

<P>
<P>В GNU C, Вы можете заменять большинство использований alloca с
массивом переменного размера. Вот, как выглядела бы open2:
<BLOCKQUOTE><CODE>
<PRE>
      int open2(char * str1, char * str2, int flags, int mode)
      {
       char name [strlen (str1) + strlen(str2) + 1];
       strcpy (name, str1);
       strcat (name, str2);
       return open (name, flags,mode);
      }
</PRE>
</CODE></BLOCKQUOTE>

Но alloca не всегда эквивалентна динамическому массиву, по
следующим причинам:
<UL>
<LI>       Место динамического массива освобождается в конце области
действия имени массива. Место, размещенное alloca остается до конца этой
функции.
</LI>
<LI>       Возможно использовать alloca внутри цикла, резервируя
дополнительный блок на каждой итерации. Это невозможно с динамическими
массивами.</LI>
</UL>

Обратите внимание: если Вы смешиваете использование alloca и
динамических массивов внутри одной функции, выход из области, в который
динамический массив был объявлен, освобождает все блоки, размещенные
alloca во время выполнения этой области.
<P>
<H2><A NAME="ss3.6">3.6 Настройка программы распределения</A>
</H2>

<P>
<P>Любая система динамического распределения памяти имеет
непроизводительные затраты: количество места, которое она использует &shy;
больше чем количество, о котором программа просит. Программа настройки
распределения памяти достигает очень низких непроизводительных затрат,
перемещая блоки в памяти по мере необходимости, по собственной
инициативе.
<P>
<H3>Понятия настройки резервирования</H3>

<P>
<P>Когда Вы резервируете блок malloc, адрес блока никогда не
изменяется, если Вы не используете realloc, чтобы изменить размер. Таким
образом, Вы можете безопасно сохранять адрес в различных местах,
временно или постоянно, как захотите. Это не безопасно, когда Вы
используете программу настройки распределения памяти, потому что любые
переместимые блоки могут двигаться всякий раз, когда Вы зарезервируете
память в любом режиме. Даже вызов malloc или realloc может перемещать
переместимые блоки.
<P>Для каждого переместимого блока, Вы должны делать дескриптор
указываемого объекта в памяти, предназначенный для того, чтобы сохранять
адрес этого блока. Программа настройки распределения знает, где
находится дескриптор каждого блока, и модифицирует адрес, сохраненный
там всякий раз, когда она перемещает блок, так, чтобы дескриптор всегда
указывал на блок. Каждый раз Вы обращаетесь к содержимому блока, Вы
должны брать адрес из дескриптора.
<P>Вызов любой функции программы настройки распределения из
обработчика сигнала почти всегда неправилен, потому что сигнал мог
появиться в любое время. Единственый способ делать это безопасно состоит
в том, чтобы блокировать сигнал для любого доступа к содержимому любого
переместимого блока, не удобен для работы. См. раздел 21.4.6
[Неповторное вхождение].
<P>
<H3>Распределение и освобождение переместимых блоков</H3>

<P>
<P>В описаниях ниже, handleptr обозначает адрес дескриптора. Все
функции объявлены в "malloc.h"; все являются расширениями GNU.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * r_alloc (void ** handleptr, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция резервирует переместимый блок размера size. Она
сохраняет адрес блока в * handleptr и возвращает непустой указатель в
случае успеха.
<P>Если r_alloc не может получить необходимое место, она сохраняет
пустой указатель в *handleptr, и возвращает пустой указатель.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void r_alloc_free (void ** handleptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - способ освободить переместимый блок. Она освобождает
блок, на который указывает *handleptr, и сохраняет пустой указатель в
*handleptr, чтобы показать что он больше не указывает на размещенный
блок.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void * r_re_alloc (void ** handleptr, size _t size) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция r_re_alloc корректирует размер блока на который указывает
*handleptr, делая его size байт длиной. Она сохраняет адрес измененного
блока в *handleptr и возвращает непустой указатель в случае успеха.
<P>Если достаточная память не доступна, эта функция, возвращает пустой
указатель и не изменяет *handleptr.
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss3.7">3.7 Предупреждения относительно использования памяти</A>
</H2>

<P>
<P>Вы можете просить о предупреждениях для программ исчерпывающих
пространство памяти, вызывая memory_warnings. Она указывает, чтобы
malloc проверял использование памяти, каждый раз когда он просит о
большем количестве памяти из операционной системы. Это - расширение GNU,
объявленное в "malloc.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
      void memory_warnings (void *start, void (* warn_func) (const char*)) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Вызывайте эту функцию, чтобы запросить предупреждения для
приближающегося исчерпывания виртуальной памяти.
<P>Аргумент start говорит, где начинается место данных в памяти.
Программа распределения сравнивает его c последним используемым адресом
и с пределом места данных, определяя долю доступной памяти. Если Вы
указываете нуль как начало, то по умолчанию, используется наиболее
вероятное значение.
<P>malloc может вызывать функцию warn_func, чтобы предупредить Вас.
Она вызывается со строкой (предупреждающим сообщением) как аргументом.
Обычно она должнаот образить строку для пользователя.
<P>Предупреждения приходят, когда память становится полной на 75%, на
85%, и на 95%. Если занято более чем 95 % Вы получаете другое
предупреждение каждый раз увеличивая используемую память.
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR>
<A HREF="glibc-4.html">Вперед</A>
<A HREF="glibc-2.html">Назад</A>
<A HREF="glibc.html#toc3">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
