<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Сопоставления с образцом</TITLE>
 <LINK HREF="glibc-17.html" REL=next>
 <LINK HREF="glibc-15.html" REL=previous>
 <LINK HREF="glibc.html#toc16" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<A HREF="glibc-17.html">Вперед</A>
<A HREF="glibc-15.html">Назад</A>
<A HREF="glibc.html#toc16">Содержание</A>
<HR>
<H2><A NAME="s16">16. Сопоставления с образцом</A></H2>

<P>
<P>Библиотека GNU C обеспечивает средства сопоставления с образцом 
для двух видов шаблонов: регулярные выражения и универсальные 
символы имени файла. 
<P>
<H2><A NAME="ss16.1">16.1 Универсальное сопоставление</A>
</H2>

<P>
<P>Этот раздел описывает, как шаблон универсальных символов  
соответствует специфической строке. Результат - ответ да или 
никакого ответа: строка удовлетворяет шаблону или нет. Символы, 
описанные здесь объявлены в " fnmatch.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int fnmatch (const char *pattern, const char *string, int flags)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция проверяет, соответствует ли указанная строка 
шаблону. Она возвращает 0, если они соответствуют; иначе, она
возвращает значение FNM_NOMATCH отличное от нуля. 
<P>Flags - комбинация флаговых битов, которые изменяют подробности 
соответствия. См. ниже список определенных флагов.
<P>В Библиотеке GNU C, fnmatch не может испытывать "ошибку", она 
всегда возвращает ответ, преуспевает ли соответствие. Однако, 
другие реализации fnmatch могут иногда сообщать "ошибки", возвращая 
значения отличные от нуля, которые не равны FNM_NOMATCH.
<P>Вот доступные флаги для аргумента flags:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    FNM_FILE_NAME
</PRE>
</CODE></BLOCKQUOTE>

Если этот флаг установлен, универсальные конструкции символов в
шаблоне не могут соответствовать " / " в строке. Таким образом, 
единственый способ соответствовать " / " явно указать " / " в 
шаблоне.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    FNM_PATHNAME
</PRE>
</CODE></BLOCKQUOTE>

Это - побочный результат исследования для FNM_FILE_NAME; он 
исходит ИЗ POSIX.2. Мы не рекомендуем это имя, потому что мы не 
используем термин "имя пути" для имен файла.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    FNM_PERIOD
</PRE>
</CODE></BLOCKQUOTE>

Обрабатывает "." особенно, если она появляется в начале строки. 
Если этот флаг установлен, универсальные конструкции символов в 
шаблоне не могут соответствовать "." (первый символ строки).
<P>Если Вы устанавливаете, и FNM_PERIOD и FNM_FILE_NAME, то "." 
после "/" трактуется также как к "." в начале строки. (Оболочка 
использует FNM_PERIOD и FNM_FILE_NAME флаги вместе для соответствия 
имен файлов.)
<P>
<BLOCKQUOTE><CODE>
<PRE>
    FNM_NOESCAPE
</PRE>
</CODE></BLOCKQUOTE>

Не обрабатывает символ `\' в шаблонах. Обычно, " \ " означает 
(цитирует) следующий символ непосредственно. Когда цитирование
допускается, шаблон " \? " означает строку "? ", потому что 
вопросительный знак в шаблоне действует подобно обычному символу.
<P>Если Вы используете FNM_NOESCAPE, то " \ " является обычным 
символом.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    FNM_LEADING_DIR
</PRE>
</CODE></BLOCKQUOTE>

Игнорирует конечную последовательность символов, начинающихся с 
" / " в строке.
<P>Если этот флаг установлен, и " foo* " и " foobar " как шаблоны, 
соответствуют строке " foobar/frobozz ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
     FNM_CASEFOLD
</PRE>
</CODE></BLOCKQUOTE>

Игнорирует case при сравнении строки и шаблона.
<P>
<H2><A NAME="ss16.2">16.2 Globbing</A>
</H2>

<P>
<P>Типичное использование групповых символов - для соответствия  
файлов в каталоге, и создании списка всех соответствий. Это 
называется globbing.
<P>Вы могли бы делать это используя fnmatch, читая входы каталога 
один за другим и проверяя каждый с fnmatch. Но это было бы медлено 
(и сложно, так как Вы будете должны обработать подкаталоги 
вручную).
<P>Библиотека обеспечивает функцию glob, чтобы делать это с 
использованием удобных универсальных символов. Glob и другие 
символы в этом разделе объявлены в " glob.h ".
<P>
<H3>Вызов glob</H3>

<P>
<P>Результат globbing - вектор имен файлов. Чтобы возвращать этот 
вектор, glob использует специальный тип данных, glob _t, который 
является структурой. Вы передаете glob адрес структуры, и она 
вносит поля структуры, чтобы сообщить Вам результаты.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    glob_t                (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных содержит указатель на вектор слов. Более точно, 
он содержит, и адрес вектора слов и размер.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    Gl_pathc Число элементов в векторе.
    Gl_pathv Адрес вектора. Это поле имеет тип char **.
    Gl_offs Смещение первого реального элемента вектора, от 
            номинального адреса в gl_pathv поле. В отличие от других полей, 
            это -- всегда ввод glob, а не вывод из нее (т. е. вы должны 
            указать его).
</PRE>
</CODE></BLOCKQUOTE>

Если Вы используете смещение отличное от нуля, то много 
элементов в начале вектора будут оставлены пустыми. (Функция glob 
заполняет их пустыми указателями.)
<P>Gl_offs поле значимо только, если Вы используете GLOB_DOOFFS 
флаг.
<P>Иначе, смещение - всегда нуль независимо от того, что находится 
в этом поле, и первый реальный элемент расположен в начале вектора.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int glob (const char *pattern, int flags, int (*errfunc) (const char *filename, int error-code), glob_t *vector_ptr)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция делает globbing, используя указанный шаблон в 
текущем каталоге. Она помещает результат в недавно размещенном 
векторе, и сохраняет размер и адрес этого вектора в *vector_ptr. 
Flags аргумент - комбинация битовых флагов; см. Раздел 16.2.2 
[Флаги для Globbing].
<P>Результат globbing - последовательность имен файлов. Glob 
резервирует строку для каждого возникающего в результате слова, и 
вектор типа char **, чтобы сохранить адреса этих строк. Последний 
элемент вектора - пустой указатель. Этот вектор называется вектором 
слов.
<P>Чтобы возвратить этот вектор, glob сохраняет и адрес и длину 
(число элементов, не считая завершающий пустой символа) в 
*vector_ptr.
<P>Обычно, glob сортирует имена файлов в алфавитном порядке перед 
их возвращением. Вы можете указать флаг GLOB_NOSORT, если Вы хотите 
получать информацию, с наибольшей скоростью. 
<P>Если glob преуспевает, она возвращает 0. Иначе, она возвращает 
один из этих кодов ошибки:
<P>GLOB_ABORTED Имелась ошибка открытия каталога, и Вы использовали флаг 
GLOB_ERR, или ваша заданная errfunc возвратила значение отличное от 
нуля. См. ниже объяснение GLOB_ERR и errfunc.
<P>GLOB_NOMATCH Шаблон не соответствовал ни каким существующим файлам. Если Вы 
используете GLOB_NOCHECK флаг, то Вы, никогда не получаете этот код 
ошибки, потому что этот флаг сообщает, чтобы glob симулировал что 
шаблону соответствует по крайней мере один файл.
<P>GLOB_NOSPACE Было невозможно зарезервировать память, чтобы содержать 
результат.
<P>В случае ошибки, glob сохраняет информацию в *vector_ptr
относительно всей соответствий, которые она уже нашла.
<P>
<H3>Флаги для Glob</H3>

<P>
<P>Этот раздел описывает флаги, которе Вы можете определять в 
аргументе flags в glob. Выберите флаги которые Вы хотите, и 
объедите их оператором OR (| в Си).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    GLOB_APPEND
</PRE>
</CODE></BLOCKQUOTE>

Добавлять слова от этого поиска к вектору слов, произведенных 
предыдущими обращениями к glob.
<P>Для этого, Вы не должны изменить содержимое структуры вектора 
слов между обращениями к glob. И, если Вы устанавливаете
GLOB_DOOFFS в первом обращении к glob, Вы должны также установить 
его, когда Вы добавляете.
<P>Обратите внимание, что указатель, сохраненный в gl_pathv может 
больше не быть допустимым после того, как Вы вызываете glob второй
раз, потому что glob может переместить вектор. Так что всегда 
берите gl_pathv из структуры _t glob после каждого обращения к 
glob; никогда не сохраните указатель между обращений.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    GLOB_DOOFFS
</PRE>
</CODE></BLOCKQUOTE>

Оставьте пустые места в начале вектора слов. Gl_offs поле 
говорит сколько мест оставить. Пустые места содержат пустые 
указатели.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    GLOB_ERR 
</PRE>
</CODE></BLOCKQUOTE>

Сразу же сообщает ошибку, если имеется любая трудность. Такие 
трудности могут включать каталог, в котором Вы не имеете 
необходимого доступа. Обычно, glob пробует продолжить несмотря на
любые ошибки, и читает любые каталоги, какие может.
<P>Вы можете осуществлять управление,  определяя функцию 
обработчика ошибки errfunc, когда Вы вызываете glob. Если errfunc - 
не пустой указатель, то glob не отказывается сразу же, когда она не
может читать каталог; взамен, она вызывает errfunc с двумя 
аргументами, примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    (*errfunc) (filename, error-code)
</PRE>
</CODE></BLOCKQUOTE>

Filename - имя каталога, который glob не может открыть, или не 
может читать, а error-code - значение errno, которое было сообщено 
glob.
<P>Если функция обработчика ошибки возвращает не нуль, то glob 
завершается сразу же. Иначе, она продолжается.
<P>GLOB_MARK  Если шаблон соответствует имени каталога, конкатенирует " / " к 
имени каталога при его возвращении.
<P>GLOB_NOCHECK Если шаблон не соответствует ни каким именам файлов, возвращает 
шаблон непосредственно, как будто это было имя файла. (Обычно, 
когда шаблон не соответствует чему - нибудь, glob говорит что не 
имелось никакого соответствия.)
<P>GLOB_NOSOR(***)      Не сортирует имена файлов. (Практически, порядок будет зависеть 
от порядка входов в каталоге.) Единственая причина не сортировать 
состоит в том, чтобы сохранить время.
<P>GLOB_NOESCAPE Не обрабатывает символ ` \ ' в шаблонах. Обычно, " \ " 
цитирует следующий символ, выключая специальное значение так, чтобы он 
соответствовал только непосредственно символу. Когда цитирование 
допускается, шаблон " \? " соответствует только строке "? ", потому 
что вопросительный знак в шаблоне действует подобно обычному 
символу.
<P>Если Вы используете GLOB_NOESCAPE, то " \ " является обычным 
символом.
<P>Glob делает это, вызывая функцию fnmatch. Она обрабатывает флаг
GLOB_NOESCAPE, включая FNM_NOESCAPE флаг в обращениях к fnmatch.
<P>
<H2><A NAME="ss16.3">16.3 Соответствия Регулярных Выражений</A>
</H2>

<P>
<P>Библиотека GNU C поддерживает два интерфейса для соответствия
регулярных выражений. Один - стандартный POSIX.2 интерфейс, а 
другой - тот, который система GNU использовала много лет.
<P>Оба интерфейса объявлены в заглавном файле " regex.h ". Если Вы 
определяете _POSIX_C_SOURCE, то будут объявлены только POSIX.2 
функции, структуры, и константы.
<P>
<P>
<P>
<P>
<P>
<P>
<H3>POSIX Регулярные Выражения</H3>

<P>
<P>Прежде, чем Вы можете фактически использовать регулярное 
выражение, Вы должны откомпилировать его. Это - не истинная 
трансляция, это производит специальную структуру данных, а не 
машинные команды. Но это - подобно обычной трансляции, цель которой 
дать Вам возможность " выполнить" шаблон быстро. (См. Раздел 16.3.3 
[Соответствие POSIX Регулярным Выражениям], для того, как
использовать компилируемое регулярное выражение для соответствия.)
<P>Имеется специальный тип данных для компилируемых регулярных 
выражений:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    regex_t               (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип содержит компилируемое регулярное выражение. Это - 
фактически структура. Она имеет только одно поле, которое ваши 
программы должны рассмотреть: re_nsub . Это поле содержит некоторое 
число вводных подвыражений регулярного выражения.
<P>Имеются и другие поля, но мы не описываем их здесь, потому что 
только функции в библиотеке должны использовать их.
<P>После того, как Вы создаете объект regex_t, Вы можете 
компилировать регулярное выражение в ней, вызывая regcomp.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int regcomp (regex_t *compiled, const char *pattern, int cflags)
</PRE>
</CODE></BLOCKQUOTE>

Функция regcomp "компилирует" регулярное выражение в структуру 
данных, которую Вы можете использовать с regexec, чтобы искать 
соответствующие строки. Компилируемый формат регулярного выражения 
разработан для эффективного соответствия. Regcomp сохраняет его в 
*compiled.
<P>Вам нужно только зарезервировать объект типа regex_t и передать 
адрес regcomp.
<P>
<P>Аргумент cflags допускает Вам, определять различные опции, 
которые управляют синтаксисом и семантикой регулярных выражений. 
<P>Если Вы используете флаг REG_NOSUB, то regcomp, опускает из 
компилируемого регулярного выражения информацию, необходимую для 
записи соответствий подвыражений. В этом случае, Вы можете также 
указывать 0 для matchptr и nmatch аргументов, когда Вы вызываете 
regexec.
<P>Если Вы не используете REG_NOSUB, то компилируемое регулярное 
выражение имеет запись соответствия подвыражений. Также, regcomp
сообщает Вам, сколько подвыражений имеет шаблон, сохраняя число в 
compiled-&gt;re_nsub. Вы можете использовать это значение, чтобы 
решить, какую длину массива зарезервировать, чтобы содержать 
информацию относительно соответствий подвыражений.
<P>Regcomp возвращает 0, если она преуспевает в компилировании 
регулярного выражения; иначе, она возвращает код ошибки отличный от 
нуля (см. таблицу ниже). Вы можете использовать regerror, чтобы 
произвести строку сообщения об ошибках для значений отличных от 
нуля.
<P>Имеются возможные значения отличные от нуля, которые regcomp 
может возвращать:
<P>REG_BADBR Имеется недопустимая конструкция " \{. . .\} " в регулярном 
выражении. Допустимая " \{. . .\} " конструкция должна содержать 
или одиночное число, или два числа в увеличивающемся порядке, 
отделенные запятой.
<P>REG_BADPAT Имелась синтаксическая ошибка в регулярном выражении.
<P>REG_BADRPT Оператор повторения типа " ? " или " * " оказался, в плохой 
позиции (без предшествующего подвыражения).
<P>REG_ECOLLATE Регулярное выражение сносится на недопустимый элемент
объединения (не определенный в текущем стандарте для строкового 
объединения). См. Раздел 19.3 [Категории Стандарта].
<P>REG_ECTYPE Регулярное выражение ссылается на недопустимое символьное имя 
класса.
<P>REG_EESCAPE Регулярное выражение законченно " \ ".
<P>REG_ESUBREG Имелось недопустимое число в " \digit " конструкции.
<P>REG_EBRACK Имелись несбалансированные квадратные скобки в регулярном 
выражении.
<P>REG_EPAREN Расширенное регулярное выражение имело незакрытые скобки, или 
базисное регулярное выражение имело несбалансированные "\(" и "\)".
<P>REG_EBRACE Регулярное выражение имело несбалансированные "\{" и "\}".
<P>REG_ERANGE Одна из оконечных точек в выражении диапазона была недопустима.
<P>REG_ESPACE Regcomp не хватает памяти.
<P>
<H3>Флаги для POSIX Регулярных Выражений</H3>

<P>
<P>Это - битовые флаги, который Вы можете использовать в cflags 
операнде при компилировании регулярного выражения с regcomp.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    REG_EXTENDED
</PRE>
</CODE></BLOCKQUOTE>

Обрабатывает шаблон как расширенное регулярное выражение, а не 
как базисное регулярное выражение.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    REG_ICASE
</PRE>
</CODE></BLOCKQUOTE>

Игнорирует case при соответствии символов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    REG_NOSUB
</PRE>
</CODE></BLOCKQUOTE>

Не сохраняет содержимое matches_ptr массива.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    REG_NEWLINE
</PRE>
</CODE></BLOCKQUOTE>

Обрабатывает символ перевода строки в строке как деление строки 
на многократные строки, так, чтобы " $ " мог соответствовать перед 
символом перевода строки, а " ^ " мог соответствовать после. Также, 
не разрешает "." соответствовать символу перевода строки, и не 
разрешает " [^. . .] " соответствовать символу перевода строки.
<P>Иначе, символ перевода строки действует подобно любому другому 
обычному символу.
<P>
<P>
<H3>Соответствие Компилируемого POSIX Регулярного Выражения</H3>

<P>
<P>Если только Вы компилировали регулярное выражение, как описано в 
Разделе 16.3.1 [Трансляция POSIX Регулярных выражений], Вы можете 
применять его к строкам используя regexec. Соответствие где-нибудь 
внутри строки считается как успех, если регулярное выражение не 
содержит символы " ^ " или " $ ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция пробует подобрать соответствие компилируемому 
регулярному выражению *compiled.
<P>Regexec возвращает 0 если tcnm соответствие выражению; иначе, 
она возвращает значение отличное от нуля. См. таблицу ниже для 
того, что означают значения отличные от нуля. Вы можете 
использовать regerror, чтобы произвести строку сообщения об ошибках 
для значений отличных от нуля.
<P>Аргумент eflags - слово битовых флагов, которые дают возможность 
различным опциям.
<P>Если Вы хотите получать информацию относительно части строки 
которая фактически соответствовала регулярному выражению или 
подвыражению, используйте аргументы matchptr и nmatch. Иначе, 
укажите 0 для nmatch, и пустой указатель для matchptr.
<P>Функция regexec принимает следующие флаги в аргументе eflags:
<P>REG_NOTBOL Не расценивает начало заданной строки как начало строки; более 
вообще, не делает ни каких предположений относительно того, что 
текст мог бы предшествовать ей.
<P>REG_NOTEOL Не расценивает конец заданной строки как конец строки; более 
обще, не делает ни каких предположений относительно того, что текст 
мог бы следовать за ней.
<P>Имеются возможные значения отличные от нуля, которые regexec 
может возвращать:
<DL>
<DT><B>REG_NOMATCH </B><DD><P>Шаблон не соответствовал строке. Это в общем не ошибка.
<P>
<DT><B>REG_ESPACE Regexec не хватило памяти. </B><DD><P>
</DL>
       
<P>
<P>
<P>
<H3>Результаты Соответствия с Подвыражениями</H3>

<P>
<P>Когда regexec находит соответствия подвыражениям шаблона, она
записывает, которым частям строки они соответствуют. Она возвращает
эту информацию, сохраняя смещения в массиве, чьи элементы являются
структурами типа regmatch_t. Первый элемент массива (индекс 0)
записывает часть строки, которая соответствовала всему регулярному
выражению. Каждый другой элемент массива записывает начало и конец
части, которая соответствовала одиночному вводному подвыражению.
<BLOCKQUOTE><CODE>
<PRE>
      regmatch_t
</PRE>
</CODE></BLOCKQUOTE>

Это - тип данных matcharray массива, который Вы передаете к
regexec. Он содержит два поля-структуры, следующим образом:
Rm_so - Смещение начала подстроки в строке. Добавьте это значение
к строке, чтобы получить адрес этой части.
Rm_eo - Смещение конца подстроки в строке.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       regoff_t
</PRE>
</CODE></BLOCKQUOTE>
       Regoff_t - побочный результат исследования для другого целого
типа со знаком. Поля regmatch_t имеют тип regoff_t.
Regmatch_t элементы соответствуют подвыражениям позиционно;
первый элемент (индекс 1) хранит, где первое согласованное
подвыражение, второй элемент записывает второе подвыражение, и так
далее. Порядок подвыражений - порядок, в котором они начинаются.
<P>Когда Вы вызываете regexec, Вы определяете длину matchptr
массива, с nmatch аргументом.
<P>Это сообщает regexec сколько элементов сохранить. Если
фактическое регулярное выражение имеет больше чем nmatch
подвыражений, то, Вы не будет получать информацию о смещениях
относительно остальной их части.
<P>Еслио Вы не хотите, чтобы regexec возвращал любую информацию
относительно подвыражений, Вы можете обеспечить 0 для nmatch, или
использовать флаг REG_NOSUB, когда Вы компилируете шаблон с
regcomp.
<P>
<H3>Осложнения в Соответствиях Подвыражений</H3>

<P>
<P>Иногда подвыражение соответствует подстроке без символов. Это
случается, когда " f\(o*\) " соответствует строке " fum ". (Оно
действительно соответствует только " f ".) В этом случае, оба
смещения идентифицируют отметку в строке, где была найдена пустая
подстрока. В этом примере, оба смещения 1.
<P>Иногда все регулярное выражение может соответствовать без
использования некоторых из подвыражений вообще, например, когда "
ba\(na\)* " соответствует строке " ba ", вводное подвыражение не
используется. Когда это случается, regexec сохраняет -1 в обоих
полях элемента для этого подвыражения.
<P>Иногда при соответствии всего регулярного выражения некоторая
подстрока может соответствовать специфическому подвыражению больше
чем один раз например, когда " ba\(na\)* " соответствует строка "
bananana ", вводное подвыражение соответствует три раза. Когда это
случается, regexec обычно сохраняет смещения последней части
строки, которая соответствовала подвыражению. В случае " bananana
", эти смещения - 6 и 8.
<P>
<P>
<H3>Очистка POSIX Regexp Соответствий</H3>

<P>
<P>Когда Вы закончили использование компилируемого регулярного
выражения, Вы можете освободить память, которую оно использует,
вызывая regfree.
<BLOCKQUOTE><CODE>
<PRE>
       void regfree (regex_t *compiled)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Вызов regfree освобождает всю память, на которую *compiled
указывает. Включая различные внутренние поля структуры regex_t,
которые не описаны в этом руководстве.
Regfree не освобождает объект *compiled непосредственно.
<P>Вы должны всегда освобождать место в структуре regex_t с regfree
перед использованием структуры, чтобы компилировать другое
регулярное выражение.
<P>Когда regcomp или regexec сообщает об ошибке, Вы можете
использовать функцию regerror, преобразовать ее в строку сообщения
об ошибках.
<BLOCKQUOTE><CODE>
<PRE>
       size_t regerror (int errcode, regex_t *compiled, char *buffer, size_t length) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция производит строку сообщения об ошибках для кода
ошибки errcode, и сохраняет строку в length байтах памяти,
начинающейся с buffer. Для аргумента compiled, обеспечьте то же
самое регулярное выражение, с которой работал regcomp или regexec
когда получил ошибку. В качестве альтернативы, Вы можете
обеспечивать пустой указатель для compiled; Вы будете все еще
получать значимое сообщение об ошибках, но оно может не быть
детализировано.
<P>Если сообщение об ошибках не помещается в length байтах (включая
пустой символ завершения), то regerror усекает его. Эта строка
всегда с нулевым символом в конце даже если она была усечена.
<P>Возвращаемое значение regerror - минимальный length, для
сохранения всего сообщения об ошибках. Если он меньше чем length,
то сообщение об ошибках не было усечено, и Вы можете использовать
его. Иначе, Вы должны вызвать regerror снова с большим buffer.
<P>
<P>
<P>
<P>
<P>
<P>
<P>Вот функция, которая использует regerror, но всегда динамически,
резервируя буфер для сообщения об ошибках:
<BLOCKQUOTE><CODE>
<PRE>
 char *get_regerror (int errcode, regex_t *compiled)
 {
   size_t length = regerror(errcode,compiled,NULL,0);
   char *buffer = xmalloc (length);
   (void) regerror (errcode, compiled, buffer, length);
   return buffer;
 }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss16.4">16.4 Разложение Слов в стиле оболочки</A>
</H2>

<P>
<P>Разложение Слов означает процесс разбивания строки в слова и
замену переменных, команд, и универсальных символов, точно так как
делает оболочка.
<P>Например, когда Вы пишите " ls -l foo.c ", эта строка
разбивается в три отдельных слова " ls ", " -l " и " foo.c ". Это &shy;
базисная функция разложения слов.
<P>Когда Вы пишите " ls *.c ", это может стать многими словами,
потому что слово " *.c " может быть заменено на любое число имен
файлов. Это называется разложением универсального символа, и это &shy;
также часть разложения слова.
<P>Когда Вы используете " ECHO $PATH " чтобы печатать ваш путь, Вы
пользуетесь преимуществом замены переменной, которая является также
частью разложения слова.
<P>Обычные программы могут выполнять разложение слова точно так же
как оболочка, вызывая библиотечную функцию wordexp.
<P>
<H3>Стадии Разложения Слова</H3>

<P>
<P>Когда разложение слова применяется к последовательности слов,
выполняются следующие преобразования в порядке, показанном здесь:
<OL>
<LI>        Разложение Тильды: Замена " ~foo " на имя исходного (home)
каталога " foo ".</LI>
<LI>        Затем, применяются три различных преобразования в том же
самом шаге, слева направо:
<UL>
<LI>          Замена переменных: Переменные среды заменяются для ссылок
типа " $foo ".</LI>
<LI>          Замена Команд: Конструкции типа "" cat foo "" и эквивалент "
$(cat foo) " заменены на вывод внутренней команды.</LI>
<LI>          Арифметическое разложение: Конструкции типа " $(($x-1)) "
заменены на результат арифметического вычисления.</LI>
</UL>
</LI>
<LI>        Разбивание Поля: разбиение текста в слова.</LI>
<LI>        Разложение Универсальных символов: замена конструкции типа
" *.c " на список " .c " имен файлов. Разложение Универсального
символа применяется к всему слову одновременно, и заменяет это
слово на 0 или большое количество имен файлов, которые являются
самостоятельными словами.</LI>
<LI>        Удаление Кавычек: стирание кавычек, теперь, когда они сделали
их работу, запрещая вышеупомянутые преобразования когда нужно.</LI>
</OL>

Для подробностей этих преобразований, и как написать использующие
их конструкции, см. Руководство BUSH (должно появиться).
<P>
<H3>Вызов wordexp</H3>

<P>
<P>Все функции, константы и типы данных для разложения слова
объявлены в заглавном файле " wordexp.h ".
<P>Разложение Слова производит вектор слов (строк). Чтобы
возвращать этот вектор, wordexp использует специальный тип данных,
wordexp_t, который является структурой. Вы передаете wordexp адрес
структуры, и она вносит поля структуры, чтобы сообщить Вам
результаты.
<BLOCKQUOTE><CODE>
<PRE>
       wordexp_t
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных содержит указатель на вектор слов. Более точно,
в нем записаны, и адрес вектора слов и размер.
We_wordc - Число элементов в векторе.
We_wordv - Адрес вектора. Это поле имеет тип char **.
We_offs - Смещение первого реального элемента вектора от
номинального адреса в we_wordv поле. В отличие от других полей, это
всегда ввод к wordexp, а не вывод из нее.
<P>Если Вы используете смещение отличное от нуля, то многие
элементы в начале вектора будут оставлены пустыми. (Wordexp функция
заполняет их пустыми указателями.)
We_offs поле значимо только, если Вы используете WRDE_DOOFFS
флаг. Иначе, смещение - всегда нуль независимо от того, что
находится в этом поле, и первый реальный элемент находится в начале
вектора.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int wordexp (const char *words, wordexp_t *word-vector-ptr, int flags)
</PRE>
</CODE></BLOCKQUOTE>

Выполните разложение слова на строке слов, помещая результат в
недавно размещенном векторе, и сохраните размер и адрес этого
вектора в *word-vector-ptr. Аргумент flags - комбинация битовых
флагов; см. Раздел 16.4.3 [Флаги для Wordexp].
<P>Вы не должны использовать любой из символов " | &amp; ; &lt; &gt; " в
строке слов, если они не заключены в кавычки; аналогично для символа
перевода строки. Если Вы используете эти символы без кавычек, Вы
получите WRDE_BADCHAR код ошибки. Не используйте круглые скобки или
фигурные скобки, если они заключены в кавычки или часть конструкции
разложения слова. Если Вы используете кавычки  " ' `,
они должены войти попарно.
<P>Результаты разложения слов - последовательность слов. Функция
wordexp зарезервирует строку для каждого возникающего в результате
слова, и вектор типа char **, чтобы сохранить адреса этих строк.
Последний элемент вектора - пустой указатель. Этот вектор
называется вектором слов.
<P>Чтобы возвращать этот вектор, wordexp сохраняет, и адрес и длину
(число элементов, не считая завершающий пустой символ) в *word&shy;
vector-ptr.
<P>Если wordexp завершает работу успешно, она возвращает 0. Иначе, она
возвращает один из этих кодов ошибки:
<DL>
<DT><B>WRDE_BADCHAR </B><DD><P>
<P>Входные строковые слова содержат незащищенный кавычками
недопустимый символ типа " | ".
<DT><B>WRDE_BADVAL </B><DD><P>
<P>Входная строка обращается к неопределенной переменной оболочки,
и Вы использовали флаг WRDE_UNDEF, чтобы запретить такие ссылки.
<DT><B>WRDE_CMDSUB </B><DD><P>
<P>Входная строка использует замену команды, и Вы использовала флаг
WRDE_ NOCMD, чтобы запретить замену команд.
<DT><B>WRDE_NOSPACE </B><DD><P>
<P>Было невозможно зарезервировать память для
результат. В этом случае, wordexp может сохранять часть
результатов, столько, сколько она смогла зарезервировать памяти.
<DT><B>WRDE_SYNTAX </B><DD><P>
<P>Имелась синтаксическая ошибка во входной строке. Например,
несогласованные кавычки - синтаксическая ошибка.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
       void wordfree (wordexp_t *word-vector-ptr)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Освободит память, используемую для строки слов и вектора, на
который указывает * word-vector-ptr. Она не освобождает структуру
*word-vector-ptr непосредственно, а только другие данные, на
которые она указывает.
<P>
<H3>Флаги для Разложения Слова</H3>

<P>
<P>Этот раздел описывает флаги, которые Вы можете определять в
аргументе flags wordexp. Выберите флаги, которые Вы хотите, и
объединяете их оператором  |.
<DL>
<DT><B>WRDE_APPEND </B><DD><P>
<P>Добавляет слова этого разложения к вектору слов, произведенных
предыдущими обращениями к wordexp.
<P>Для этого Вы не должны изменять содержимое структуры вектора
слов между обращениями к wordexp. И, если Вы устанавливаете
WRDE_DOOFFS в первом обращении к wordexp, Вы должны также
установить его, когда Вы добавляете.
<DT><B>WRDE_DOOFFS </B><DD><P>
<P>Оставляет пустое место в начале вектора слов. We_offs поле
говорит, сколько места оставить. Пустое место содержит пустые
указатели.
<DT><B>WRDE_NOCMD </B><DD><P>
<P>Не делает замену команд; при попытке замены команды, сообщаает
об ошибке.
<DT><B>WRDE_REUSE </B><DD><P>
<P>Многократно использует вектор слов, сделанный предыдущим
обращением к wordexp. Вместо того, чтобы зарезервировать новый
вектор слов, это обращение к wordexp использует вектор, который уже
существует (увеличивая его в случае необходимости).
<P>Обратите внимание, что вектор может перемещаться в памяти, так что
небезопасно хранить старый указатель и использовать его снова после
вызова wordexp. Вы должны сохранять we_pathv после каждого
обращения.
<DT><B>WRDE_SHOWERR </B><DD><P>
<P>Покажет любые сообщения об ошибках.
<DT><B>WRDE_UNDEF </B><DD><P>
<P>Если ввод относится к переменной оболочки которая не определена,
выдает ошибку.
</DL>
<H3>Пример Wordexp</H3>

<P>
<P>Вот пример использования wordexp, чтобы рзложить отдельные
строки и использования результатов чтобы выполнить команду
оболочки. Он также показывает использование WRDE_APPEND, чтобы
добавлять разложения и wordfree, чтобы освободить место,
размещенное wordexp.
<BLOCKQUOTE><CODE>
<PRE>
 int
 expand_and_execute(const char*program,const char*options)
 {
  wordexp_t result;
  pid_t pid
  int status, i;
  switch (wordexp (program, &amp;result, 0))
  {
          case 0:
                  break;
          case WRDE_NOSPACE:
                  wordfree (&amp;result);
          default:
                  return -1;
  }
  for (i = 0; args[i]; i++)
  {
          if (wordexp (options, &amp;result, WRDE_APPEND))
          {
                  wordfree (&amp;result);
                  return -1;
          }
  }
  pid = fork ();
  if (pid == 0)
  {
          execv (result.we_wordv[0],
    result.we_wordv);
          exit (EXIT_FAILURE);
  }
  else if (pid &lt; 0)
          status = -1;
  else
           if (waitpid (pid, &amp;status, 0) != pid)
  status = -1;
  wordfree (&amp;result);
  return status;
</PRE>
</CODE></BLOCKQUOTE>
<P>Практически, т. к. wordexp работает, выполняя подоболочку, было
бы быстрее сделать это, связывая строки с пробелами между ними и
выполняя это как команду оболочки, используюя " sh -c ".
<P>
<P>
<HR>
<A HREF="glibc-17.html">Вперед</A>
<A HREF="glibc-15.html">Назад</A>
<A HREF="glibc.html#toc16">Содержание</A>
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>
