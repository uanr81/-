<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Расширенная фильтрация.</TITLE
><META http-equiv="Content-Type" content="text/html; charset=koi8-r"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Linux Advanced Routing &#38; Traffic Control HOWTO"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Netfilter и iproute -- маркировка пакетов."
HREF="c1430.html"><LINK
REL="NEXT"
TITLE="Классификатор route."
HREF="x1578.html"><style type="text/css"> p {text-align:justify;} </style></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Advanced Routing &#38; Traffic Control HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c1430.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1578.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="CHAPTER12"
></A
>Глава 12. Расширенная фильтрация.</H1
><P
>    Как уже говорилось в разделе <A
HREF="x1075.html"
>Классовые дисциплины обработки очередей</A
>, для того, чтобы определить
    в какую из подочередей направить пакет, используются фильтры-классификаторы.
  </P
><P
>    Ниже приводится неполный список доступных классификаторов:
    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><B
CLASS="COMMAND"
>fw</B
></DT
><DD
><P
>            Решение принимается на основе маркера пакета, установленного брандмауэром (например -- iptables).
            Наиболее простой классификатор, который можно рекомендовать в том случае, если вам не хочется 
            изучать синтаксис <B
CLASS="COMMAND"
>tc</B
>. За дополнительной информацией обращайтесь к 
            <A
HREF="c834.html"
>главе 9</A
>.
          </P
></DD
><DT
><B
CLASS="COMMAND"
>u32</B
></DT
><DD
><P
>            Решение принимается на основе значений полей в заголовке пакета (например, исходящий
            IP-адрес и т.п.).
          </P
></DD
><DT
><B
CLASS="COMMAND"
>route</B
></DT
><DD
><P
>            Решение принимается на основе маршрута, по которому движется пакет.
          </P
></DD
><DT
><B
CLASS="COMMAND"
>rsvp, rsvp6</B
></DT
><DD
><P
>            Маршрутизация пакетов производится на базе 
            <A
HREF="http://www.isi.edu/div7/rsvp/overview.html"
TARGET="_top"
>RSVP</A
>.
            Применимо только в том случае, если управление сетью полностью находится в ваших руках.
            В Интернет RSVP не поддерживается.
          </P
></DD
><DT
><B
CLASS="COMMAND"
>tcindex</B
></DT
><DD
><P
>            Используется в <B
CLASS="COMMAND"
>DSMARK</B
> qdisc, см. соответствующий раздел.
          </P
></DD
></DL
></DIV
>
  </P
><P
>    Вообще есть множество способов классификации пакетов, но практически все они находятся
    в прямой зависимости от предпочитаемой вами системы.
  </P
><P
>    Классификаторы, как правило, принимают некоторое количество аргументов. Перечислим их
    здесь, для удобства.
    
    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><B
CLASS="COMMAND"
>protocol</B
></DT
><DD
><P
>            Протокол, принимаемый классификатором. Как правило вы будете принимать только IP-трафик.
          </P
></DD
><DT
><B
CLASS="COMMAND"
>parent</B
></DT
><DD
><P
>            Существующий класс, к которому должен быть присоединен данный классификатор.
          </P
></DD
><DT
><B
CLASS="COMMAND"
>prio</B
></DT
><DD
><P
>            Приоритет классификатора. Чем меньше число -- тем выше приоритет.
          </P
></DD
><DT
><B
CLASS="COMMAND"
>handle</B
></DT
><DD
><P
>            Назначение и смысл аргумента зависит от контекста использования.
          </P
></DD
></DL
></DIV
>
      Во всех следующих разделах мы будем исходить из условия, что формируется трафик, идущий к хосту
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>HostA</I
></SPAN
>, что корневой класс сконфигурирован как 1:, а класс, которому 
      посылается выбранный трафик -- как 1:1.
  </P
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="THEU32CLASSIFIER"
></A
>12.1. Классификатор u32.</H1
><P
>      Фильтр <B
CLASS="COMMAND"
>U32</B
> наиболее гибкий из доступных в текущей конфигурации. Он целиком
      основан на хеш-таблицах, которые повышают устойчивость фильтра при значительном количестве
      правил фильтрации.
    </P
><P
>      В простейшем виде, фильтр <B
CLASS="COMMAND"
>U32</B
> -- это набор записей, каждая из которых состоит из двух 
      полей: селектора и действия. Селекторы, описанные ниже, проверяют обрабатываемый IP-пакет до тех пор, пока 
      не будет встречено первое совпадение, после чего выполняется соответствующее селектору действие. 
      Самый простой тип действия -- перенаправление пакета в определенный класс.
    </P
><P
>      Для конфигурирования фильтра используется команда <B
CLASS="COMMAND"
>tc filter</B
>, состоящая из
      трех частей: определение фильтра, селектор и действие. Определение фильтра может быть записано как:
      <PRE
CLASS="SCREEN"
>tc filter add dev IF [ protocol PROTO ]
                     [ (preference|priority) PRIO ]
                     [ parent CBQ ]        
      </PRE
>
      Поле <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
> описывает обслуживаемый протокол. Здесь мы будем обсуждать
      исключительно протокол IP. Поле <TT
CLASS="PARAMETER"
><I
>preference</I
></TT
> (в качестве синонима можно использовать
      <TT
CLASS="PARAMETER"
><I
>priority</I
></TT
>) описывает приоритет определяемого фильтра, что позволяет задавать
      несколько фильтров (списков правил) с различными приоритетами. Вообще, правила обслуживаются в порядке
      добавления в список, в случае с приоритетами -- первыми обслуживаются правила, имеющие наивысший
      приоритет (чем меньше число, тем выше приоритет). Поле <TT
CLASS="PARAMETER"
><I
>parent</I
></TT
> определяет
      вершину дерева CBQ (например 10:1), к которой должен быть присоединен данный фильтр.
    </P
><P
>      Описаные выше опции применимы ко всем фильтрам, а не только к <B
CLASS="COMMAND"
>U32</B
>.
    </P
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="U32SELECTOR"
></A
>12.1.1. Селектор U32.</H2
><P
>        Селектор <B
CLASS="COMMAND"
>U32</B
> содержит определение шаблона, который будет сопоставляться
        с обрабатываемым пакетом. Если быть более точным, он определяет -- какие биты в заголовке
        пакета будут проверяться и не более того, но, не смотря на свою простоту, это очень мощный
        и гибкий метод. Рассмотрим примеры, взятые из реально работающего и достаточно сложного
        фильтра:
        <PRE
CLASS="SCREEN"
># tc filter add dev eth0 protocol ip parent 1:0 pref 10 u32 \
  match u32 00100000 00ff0000 at 0 flowid 1:10        
        </PRE
>
        Оставим пока первую строку в покое, эти параметры описывают хеш-таблицы фильтра, и сконцентрируем
        свое внимание на строке селектора, которая содержит ключевое слово <TT
CLASS="PARAMETER"
><I
>match</I
></TT
>. 
        Этот селектор будет отбирать пакеты, в IP-заголовках которых второй байт будет содержать
        число 0x10 (0010). Как вы уже наверняка догадались, 00ff -- это маска, которая точно определяет 
        проверяемые биты. Ключевое слово <TT
CLASS="PARAMETER"
><I
>at</I
></TT
> означает, что поиск совпадения 
        должен начинаться с указанного смещения (в байтах), в данном случае -- с начала пакета. 
        Переведя все это, на человеческий язык, можно сказать, что пакет будет соответствовать 
        селектору, если в его поле TOS (Type of Service) будет установлен бит 
        <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Minimize-Delay</I
></SPAN
> (минимальная задержка). Проанализируем еще одно правило:
        <PRE
CLASS="SCREEN"
># tc filter add dev eth0 protocol ip parent 1:0 pref 10 u32 \
  match u32 00000016 0000ffff at nexthdr+0 flowid 1:10        
        </PRE
>
        Параметр <TT
CLASS="PARAMETER"
><I
>nexthdr</I
></TT
> означает переход к следующему заголовку в IP-пакете,
        т.е. к заголовку протокола более высокого уровня. Опять же, в данной ситуации поиск будет 
        вестись с начала заголовка. Анализу будет подвергнуто второе 32-х битное слово в заголовке.
        В протоколах TCP и UDP это поле содержит порт назначения. Число записывается в формате
        <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>big-endian</I
></SPAN
>, т.е. первым указывается старший байт. Таким образом мы получаем
        номер порта назначения -- 0x0016, или 22 (в десятичной форме). В случае протокола TCP, этот порт
        соответствует службе SSH. Надеюсь вы понимаете, что данное соответствие бессмысленно обсуждать
        вне контекста применения, поэтому отложим эту дискуссию на более позднее время.
      </P
><P
>        Уловив все, что говорилось выше, вы без труда поймете смысл следующего селектора: 
        <TT
CLASS="COMPUTEROUTPUT"
>match c0a80100 ffffff00 at 16</TT
>.
        Данный селектор будет пытаться найти 3-х байтовую последовательность в IP-заголовке,
        начиная с 17-го байта, отсчитываемого от начала заголовка, что соответствует
        любому адресу назначения в сети 192.168.1.0/24.
      </P
><P
>      </P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="GENERALSELECTORS"
></A
>12.1.2. Селекторы общего назначения.</H2
><P
>        Селекторы общего назначения задают шаблон, маску и смещение. Используя эти селекторы вы сможете
        выполнять проверку практически любого, отдельно взятого бита в заголовке IP (или протокола более
        высокого уровня). При написании и чтении они более сложны, чем селекторы специального назначения,
        которые будут обсуждаться в следующем разделе. Синтаксис селекторов общего назначения:
        <PRE
CLASS="SCREEN"
>match [ u32 | u16 | u8 ] PATTERN MASK [ at OFFSET | nexthdr+OFFSET]        
        </PRE
>
        Ключевое слово <B
CLASS="COMMAND"
>u32</B
>, или <B
CLASS="COMMAND"
>u16</B
>, или <B
CLASS="COMMAND"
>u8</B
>
        указывает длину шаблона в битах. PATTERN и MASK в обязательном порядке должны иметь длину,
        указанную в предыдущем ключевом слове. Параметр OFFSET задает смещение от начала заголовка в байтах.
        Если присутствует ключевое слово <TT
CLASS="PARAMETER"
><I
>nexthdr+</I
></TT
>, то смещение начинает отсчитываться
        от начала заголовка протокола более высокого уровня.
      </P
><P
>        Приведем несколько примеров:
      </P
><P
>        Этим селектором будут отобраны пакеты, у которых <SPAN
CLASS="QUOTE"
>"время жизни"</SPAN
> (поле TTL) равно
        64. Поле TTL находится в 9-м (в 8-м, если считать с нуля) байте IP-заголовка.
        <PRE
CLASS="SCREEN"
># tc filter add dev ppp14 parent 1:0 prio 10 u32 \
     match u8 64 0xff at 8 \
     flowid 1:4        
        </PRE
>
        Следующие селекторы отберут TCP-пакеты, в которых установлен бит ACK:
        <PRE
CLASS="SCREEN"
># tc filter add dev ppp14 parent 1:0 prio 10 u32 \
     match ip protocol 6 0xff \
     match u8 0x10 0xff at nexthdr+13 \
     flowid 1:3        
        </PRE
>
        Отбор ACK-пакетов, длина которых меньше 64 байт:
        <PRE
CLASS="SCREEN"
>## отбор ack-пакетов более сложным способом,
## IP protocol 6,
## Длина IP-заголовка 0x5 (32-х битных слов),
## Общая длина 0x34 (ACK + 12 байт опций TCP)
## TCP ACK (бит 5, смещение 33)
# tc filter add dev ppp14 parent 1:0 protocol ip prio 10 u32 \
            match ip protocol 6 0xff \
            match u8 0x05 0x0f at 0 \
            match u16 0x0000 0xffc0 at 2 \
            match u8 0x10 0xff at 33 \
            flowid 1:3        
        </PRE
>
        Это правило отберет пакеты TCP, с установленным битом ACK, и не несущие в себе данных.
        Это яркий пример использования двух селекторов. Конечный результат будет получен
        логическим умножением (операция <SPAN
CLASS="QUOTE"
>"И"</SPAN
>) результатов каждого из селекторов.
        Если вы посмотрите на диаграмму TCP-заголовка, то увидите, что флаг ACK -- это младший
        бит старшей тетрады (0x10) 14-го байта в TCP-заголовке (<TT
CLASS="PARAMETER"
><I
>at nexthdr+13</I
></TT
>).
        Что касается второго селектора, то если бы мы хотели усложнить себе жизнь, можно было бы записать 
        <TT
CLASS="COMPUTEROUTPUT"
>match u8 0x06 0xff at 9</TT
>, вместо специального селектора 
        <TT
CLASS="PARAMETER"
><I
>protocol tcp</I
></TT
> (здесь число 6 -- это номер протокола TCP), в 10-м байте 
        IP-заголовка. С другой стороны, в этом примере мы не использовали специальный селектор, для 
        отбора по биту ACK, просто потому, что такого селектора не существует.
      </P
><P
>        Фильтр, приведенный ниже, является модификацией предыдущего примера. На этот раз не производится
        проверка длины IP-заголовка. Вы спросите -- почему? Потому, что фильтр, приведенный выше,
        работает только на 32-х битных системах.
        <PRE
CLASS="SCREEN"
>tc filter add dev ppp14 parent 1:0 protocol ip prio 10 u32 \
     match ip protocol 6 0xff \
     match u8 0x10 0xff at nexthdr+13 \
     match u16 0x0000 0xffc0 at 2 \
     flowid 1:3        
        </PRE
>
      </P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="SPECIFICSELECTORS"
></A
>12.1.3. Селекторы специального назначения.</H2
><P
>        Следующая таблица содержит перечень селекторов специального назначения, которые автор данного
        раздела нашел в исходном коде утилиты <B
CLASS="COMMAND"
>tc</B
>. Они облегчат вам жизнь
        и повысят удобочитаемость ваших фильтров.
      </P
><P
>        FIXME: таблица находится в отдельном файле <TT
CLASS="FILENAME"
>selector.html</TT
>.
      </P
><P
>        FIXME: Она по-прежнему остается на польском языке :-(
      </P
><P
>        FIXME: надо перевести в формат sgml.
      </P
><P
>        Несколько примеров:
        <PRE
CLASS="SCREEN"
># tc filter add dev ppp0 parent 1:0 prio 10 u32 \
     match ip tos 0x10 0xff \
     flowid 1:4        
        </PRE
>
        FIXME: шаблон <TT
CLASS="PARAMETER"
><I
>tcp dport</I
></TT
>, в примере ниже, не работает.
      </P
><P
>        Правило выше отберет пакеты, в которых поле TOS имеет значение 0x10. Поле TOS -- это
        второй байт в IP-заголовке, причем это однобайтовое поле (8 бит). Таким образом, эквивалентный селектор
        можно было бы записать как: <TT
CLASS="PARAMETER"
><I
>match u8 0x10 0xff at 1</I
></TT
>. Это наталкивает на мысль,
        что селекторы специального назначения, внутри фильтров <B
CLASS="COMMAND"
>U32</B
>, преобразуются в
         селекторы общего назначения и в таком виде сохраняются в памяти ядра. Отсюда следует другое заключение 
         -- селекторы <TT
CLASS="PARAMETER"
><I
>tcp</I
></TT
> и <TT
CLASS="PARAMETER"
><I
>udp</I
></TT
> суть есть одно и то же. По этой
         причине вы не сможете использовать единичный селектор <TT
CLASS="PARAMETER"
><I
>match tcp dport 53 0xffff</I
></TT
>,
         для отбора TCP-пакетов, направляющихся на 53-й порт. Этим селектором будут отобраны как TCP-пакеты,
         так и UDP-пакеты. Вы обязательно должны добавлять селектор типа протокола:
        <PRE
CLASS="SCREEN"
># tc filter add dev ppp0 parent 1:0 prio 10 u32 \
        match tcp dport 53 0xffff \
        match ip protocol 0x6 0xff \
        flowid 1:2        
        </PRE
>
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c1430.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>В начало документа</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1578.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Netfilter и iproute -- маркировка пакетов.</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Классификатор route.</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>