<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Малоизвестные настройки.</TITLE
><META http-equiv="Content-Type" content="text/html; charset=koi8-r"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Linux Advanced Routing &#38; Traffic Control HOWTO"
HREF="index.html"><LINK
REL="UP"
TITLE="Параметры настройки сети в ядре."
HREF="c1699.html"><LINK
REL="PREVIOUS"
TITLE="Параметры настройки сети в ядре."
HREF="c1699.html"><LINK
REL="NEXT"
TITLE="Специализированные дисциплины управления очередями."
HREF="c2289.html"><style type="text/css"> p {text-align:justify;} </style></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Advanced Routing &#38; Traffic Control HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c1699.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Глава 13. Параметры настройки сети в ядре.</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c2289.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="OBSCURESETTINGS"
></A
>13.2. Малоизвестные настройки.</H1
><P
>      Итак, имеется целый ряд дополнительных настроек , которые вы можете изменить. Попробуем их перечислить.
      Кроме того, они частично описаны в файле <TT
CLASS="FILENAME"
>Documentation/ip-sysctl.txt</TT
>.
    </P
><P
>      Некоторым из этих параметров присвоены такие значения по-умолчанию, которые напрямую
      зависят от того как вы сконфигурировали свое ядро.
    </P
><P
>      Оскар Андриссон (Oskar Andreasson) написал руководство, в котором значительно лучше нас 
      описал все эти настройки, так что не поленитесь -- загляните на 
      <A
HREF="http://ipsysctl-tutorial.frozentux.net/"
TARGET="_top"
>http://ipsysctl-tutorial.frozentux.net/</A
>.
      (Русский перевод руководства <SPAN
CLASS="QUOTE"
>"ipsysctl tutorial"</SPAN
>, о котором идет речь,
      вы найдете по адресу: <A
HREF="http://gazette.linux.ru.net/rus/article/index-ipsysctl-tutorial.html"
TARGET="_top"
>      http://gazette.linux.ru.net/rus/article/index-ipsysctl-tutorial.html</A
>, тарболл с исходными текстами
      документа (на русском языке) -- <A
HREF="http://gazette.linux.ru.net/archive/ipsysctl-tutorial.1.0.4.tar.gz"
TARGET="_top"
>      http://gazette.linux.ru.net/archive/ipsysctl-tutorial.1.0.4.tar.gz</A
>.
    </P
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="GENERICIPV4"
></A
>13.2.1. Параметры настройки IPv4.</H2
><P
>        Небольшое примечание: в большинстве своем, приводимые здесь временные параметры не воздействуют на 
        локальный (loopback) интерфейс, так что вы не сможете проверить их, не имея реального 
        сетевого интерфейса. Кроме того, указываемые пределы измеряются в 'тиках', и предполагают 
        использование ранее упомянутого <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Token Bucket Filter</I
></SPAN
>.
      </P
><P
>        Ядро имеет встроенные 'часы', которые 'тикают' определенное число раз в секунду. Для платформы 
        Intel -- обычно 100 раз в секунду (в ядрах серии 2.6.x этот параметр можно изменить с помощью утилит конфигурирования. <B
CLASS="COMMAND"
>прим. перев.</B
>). Таким образом, число 50, в некоем параметре 
        <TT
CLASS="PARAMETER"
><I
>*_rate</I
></TT
>, будет означать '2 пакета в секунду'. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Token Bucket 
        Filter</I
></SPAN
> сконфигурирован так, чтобы иметь возможность превышения лимита не более
        чем на 6 пакетов.
      </P
><P
>        Некоторые пункты, из приводимого ниже списка, мы просто скопировали из 
        <TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/networking/ip-sysctl.txt</TT
>, написанного
        Алексеем Кузнецовым &lt;kuznet@ms2.inr.ac.ru&gt; и Энди Клином (Andi Kleen) &lt;ak@muc.de&gt;.
      </P
><P
>        <B
CLASS="COMMAND"
>От переводчика (А.К.):</B
> Я взял на себя смелость привести описание части параметров
        из <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
><SPAN
CLASS="QUOTE"
>"ipsysctl tutorial"</SPAN
></I
></SPAN
>, поскольку они более точные и полные.
      </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>/proc/sys/net/ipv4/icmp_destunreach_rate</DT
><DD
><P
>              Если ядро решит, что оно не в состоянии доставить пакет, то пакет будет сброшен, 
              а отправителю будет послано соответствующее ICMP-сообщение.
            </P
></DD
><DT
>/proc/sys/net/ipv4/icmp_echo_ignore_all</DT
><DD
><P
>Параметр может принимать два значения -- 0 (выключено) и 1 (включено). 
            Значение по-умолчанию -- 0 (выключено). Если записана 1, то ядро просто игнорирует все 
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Echo Request</I
></SPAN
> запросы и тогда никто не сможет 
            <B
CLASS="COMMAND"
>ping</B
>-ануть вашу машину, чтобы проверить ее наличие в сети, что само по 
            себе не есть хорошо. Однако, у каждого из нас может быть свое собственное мнение по поводу этой 
            опции. С одной стороны -- окружающие лишены возможности проверить ваше присутствие в сети, с 
            другой -- существует масса приложений, которые используют 
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Echo Request</I
></SPAN
> запросы далеко не в благовидных целях. 
            Вобщем все как всегда -- что-то плохо, а что-то хорошо.
            </P
></DD
><DT
>/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</DT
><DD
><P
>              Эта переменная очень близка по смыслу к <TT
CLASS="FILENAME"
>icmp_echo_ignore_all</TT
>, 
              только в данном случае будут игнорироваться ICMP-сообщения, отправленные на 
              широковещательный или групповой адрес. Вполне очевидно, почему полезно включить этот 
              параметр -- защита от smurf атак.
            </P
></DD
><DT
>/proc/sys/net/ipv4/icmp_echoreply_rate</DT
><DD
><P
>              Частота генерации эхо-ответов, посылаемых по любому адресу.
            </P
></DD
><DT
>/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</DT
><DD
><P
>              Отдельные маршрутизаторы, вопреки стандартам, описанным в RFC 1122, отправляют фиктивные ответы 
              в широковещательном диапазоне. Обычно эти ошибки заносятся в системный журнал. Если вы не 
              желаете регистрировать их, то включите этот параметр и тем самым сбережете некоторый объем 
              дискового пространства в своей системе.
              Параметр может принимать два значения -- 0 (выключено) и 1 (включено). 
              Значение по-умолчанию -- 0 (выключено)
            </P
></DD
><DT
>/proc/sys/net/ipv4/icmp_paramprob_rate</DT
><DD
><P
>              Относительно малоизвестное ICMP-сообщение, которое посылается в ответ на неправильные 
              пакеты с искаженными IP или TCP заголовками. Этот параметр регулирует частоту генерации
              подобных сообщений.
            </P
></DD
><DT
>/proc/sys/net/ipv4/icmp_timeexceed_rate</DT
><DD
><P
>              Ограничивает частоту генерации сообщений <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Time Exceeded</I
></SPAN
>. 
            </P
></DD
></DL
></DIV
><P
>        <B
CLASS="COMMAND"
>От переводчика (А.К.):</B
> По поводу двух предыдущих параметров (<TT
CLASS="FILENAME"
>icmp_paramprob_rate</TT
> и <TT
CLASS="FILENAME"
>icmp_timeexceed_rate</TT
>)
        у меня есть большие сомнения в том, что они присутствуют в файловой системе 
        <TT
CLASS="FILENAME"
>/proc</TT
>. Вероятно в более ранних версиях ядра (до 2.4) эти параметры присутствовали,
        но у себя я их не нашел, зато имеются два других параметра, которые обеспечивают данную
        функциональность.
      </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>icmp_ratelimit</DT
><DD
><P
>Максимальная частота генерации ICMP-пакетов с типом, указанным в 
            <TT
CLASS="FILENAME"
>icmp_ratemask</TT
> (см. ниже). Это значение задается в "тиках" и устанавливает
            временной интервал между ICMP-посылками. Таким образом, значение 0 означает отсутствие 
            ограничений. Обычно 1 "тик" равен 0.01 секунды, так значение 1 в этой переменной ограничивает 
            скорость передачи не более 100 посылок в секунду, а значение 100 -- не более 1 посылки в секунду.
            Значение по-умолчанию -- 100 (зависит от конфигурации ядра), 
            что означает не более 1 ICMP посылки за интервал в 100 "тиков".
            </P
></DD
><DT
>icmp_ratemask</DT
><DD
><P
>              Маска ICMP типов, на которые накладывается ограничение по частоте генерации переменной 
              icmp_ratelimit. Каждый из ICMP типов маскируется своим битом.
            </P
><P
>              <TT
CLASS="FILENAME"
>icmp_ratemask</TT
> -- это битовая маска, где каждый ICMP тип представлен 
              своим битом. Соответствие между символическим названием ICMP типа и его порядковым номером 
              вы найдете в заголовочном файле <TT
CLASS="FILENAME"
>netinet/ip_icmp.h</TT
> (обычно это 
              <TT
CLASS="FILENAME"
>/usr/include/netinet/ip_icmp.h</TT
>). За дополнительной информацией 
              обращайтесь к RFC 792 - Internet Control Message Protocol. Математически маска определяется так:
              
              <PRE
CLASS="SCREEN"
>              ratemask = SUM 2^n 
              </PRE
>
            </P
><P
>              где n принимает значения всех типов ICMP, которые должны быть ограничены.
            </P
><P
>              Например: Ограничим передачу сообщений <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Destination Unreachable</I
></SPAN
>. В 
              <TT
CLASS="FILENAME"
>/usr/include/netinet/ip_icmp.h</TT
> этому типу соответствует число 3. 
              Подсчитаем значение 2**3, это будет число 8. Теперь нужно прибавить это число к имеющейся 
              битовой маске. Допустим, что маска уже равна числу 6160 (в двоичном виде 0001100000010000), 
              тогда результирующая маска получится: 6160 + 8 = 6168 (в двоичном виде 0001100000011000).
            </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
src="images/warning.gif"
HSPACE="5"
ALT="Внимание!"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>              Перед добавлением маски подобным образом убедитесь сначала, что нужный вам бит сброшен, иначе вы 
              получите неверную маску! К примеру, если у вас маска является числом 256 и вы еще добавите число 
              256, то это приведет к размаскированию <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Echo Request</I
></SPAN
> и маскировке 
              9-го, отсутствующего типа ICMP.
              </P
></TD
></TR
></TABLE
></DIV
><P
>              Значение по-умолчанию -- 6168 (в двоичном виде 0001100000011000), что подразумевает наложение 
              ограничений на <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Destination Unreachable</I
></SPAN
>, 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Source Quench</I
></SPAN
>, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Time Exceeded</I
></SPAN
> и 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Parameter Problem</I
></SPAN
>, где <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Destination Unreachable</I
></SPAN
> 
              = 3, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Source Quench</I
></SPAN
> = 4, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Time Exceeded</I
></SPAN
> = 11 
              и <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Parameter Problem</I
></SPAN
> = 12. Таким образом, значение по-умолчанию 
              соответствует выражению:
              <PRE
CLASS="SCREEN"
>ratemask = 2^3 + 2^4 + 2^11 + 2^12             
              </PRE
>
            </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
src="images/note.gif"
HSPACE="5"
ALT="Примечание:"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>              Злоумышленник может "заставить" некоторый маршрутизатор или хост "затопить" жертву ICMP-посылками,
              передаваемыми в ответ на поддельный ICMP-пакет с обратным адресом жертвы. Поэтому очень важно
              ограничить частоту генерации отдельных видов ICMP-сообщений.
              </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
src="images/warning.gif"
HSPACE="5"
ALT="Внимание!"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>              На сайте <A
HREF="http://www.frozentux.net"
TARGET="_top"
>http://www.frozentux.net</A
> вы найдете
              небольшую программу -- <B
CLASS="COMMAND"
>ratemask</B
>, которая может оказаться полезной при создании 
              маски для переменной <TT
CLASS="FILENAME"
>icmp_ratemasks</TT
> или для дешифрации существующей маски.
              </P
></TD
></TR
></TABLE
></DIV
><P
> </P
></DD
><DT
>/proc/sys/net/ipv4/igmp_max_memberships</DT
><DD
><P
>              Максимальное число групп на каждый сокет. Значение по-умолчанию -- 20 и может быть изменено 
              по мере необходимости. FIXME: Это действительно так?
            </P
></DD
><DT
>/proc/sys/net/ipv4/inet_peer_gc_maxtime</DT
><DD
><P
>              Параметр <TT
CLASS="FILENAME"
>inet_peer_gc_maxtime</TT
> определяет частоту "сборки мусора" при 
              незначительном объеме данных. Эта переменная имеет то же предназначение, что и 
              <TT
CLASS="FILENAME"
>inet_peer_gc_mintime</TT
> (см. ниже), только выбор, каким параметром
              пользоваться, производится в зависимости от величины нагрузки на систему. Значение параметра
              измеряется в так называемых "тиках" (jiffies), понятие "тика" описывалось выше.
            </P
><P
>              Параметр принимает целое число, измеряемое в "тиках". Значение по-умолчанию -- 120 "тиков", 
              чего вполне достаточно для большинства серверов и рабочих станций.
            </P
></DD
><DT
>/proc/sys/net/ipv4/inet_peer_gc_mintime</DT
><DD
><P
>              Параметр <TT
CLASS="FILENAME"
>inet_peer_gc_mintime</TT
> устанавливает минимальное время между 
              проходами "сборщика мусора" при значительном объеме данных, хранящихся в "inet peer storage". 
              Когда система находится под тяжелыми нагрузками и появляется множество факторов, ограничивающих 
              размер пула памяти, то частота "сборки мусора" определяется этой переменной. Значение переменной 
              измеряется в "тиках".
            </P
><P
>              Параметр принимает целое число, измеряемое в "тиках". Значение по-умолчанию -- 10 "тиков", 
              чего вполне достаточно для большинства серверов и рабочих станций.
            </P
></DD
><DT
>/proc/sys/net/ipv4/inet_peer_maxttl</DT
><DD
><P
>              Это максимальное время хранения записей. При незначительных нагрузках на систему 
              неиспользуемые записи будут удаляться через данный промежуток времени.
            </P
></DD
><DT
>/proc/sys/net/ipv4/inet_peer_minttl</DT
><DD
><P
>              Параметр определяет минимальное время хранения данных в "inet peer storage". 
              Это время должно быть достаточно большим, чтобы перекрыть время сборки фрагментов на 
              противоположной стороне. Минимальное время хранения является гарантией того, что размер 
              пула будет меньше чем величина <TT
CLASS="FILENAME"
>inet_peer_threshold</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/inet_peer_threshold</DT
><DD
><P
>              Здесь хранится приблизительный размер памяти для "inet peer storage". Когда размер пула 
              достигает этой величины, то "сборщик мусора" переводится в более агрессивный режим работы -- 
              с периодом прохода <TT
CLASS="FILENAME"
>inet_peer_gc_mintime</TT
>. Кроме того, этот порог влияет 
              на срок хранения записей. Чем выше этот порог, тем больше срок хранения.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ip_autoconfig</DT
><DD
><P
>              Этот параметр содержит номер протокола, по которому получил сведения о конфигурации 
              (RARP, BOOTP, DHCP или нечто подобное). Иначе -- ноль.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ip_default_ttl</DT
><DD
><P
>              Устанавливает значение по-умолчанию для величины <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Time To Live</I
></SPAN
> 
              исходящих пакетов. Это число определяет продолжительность "жизни" пакета в Internet. 
              Каждый раз, когда пакет попадает на очередной роутер (брандмауэр и т.п.), величина TTL пакета 
              уменьшается на 1.
            </P
><P
>              Значение по-умолчанию -- 64. Это достаточно приемлемое значение. Очень трудно представить себе 
              ситуацию, когда это число оказалось бы недостаточным. Переменная принимает целое число без знака в 
              диапазоне от 0 до 255 включительно, однако, значение 255 слишком велико, а если поставить 0 -- то 
              вы вообще лишитесь выхода в сеть. Число 64 достаточно хорошее, если вы не пытаетесь установить 
              соединение с компьютером, отстоящим от вас на значительном растоянии, измеряемом в "переходах" 
              (hops). Тогда этой вличины TTL может и не хватить. Однако, на практике едва ли вам встретятся
              компьютеры, отстоящие от вас более чем на 30 "переходов" (hops).
            </P
><P
>              Увеличение TTL пакета до 255 может иметь свои негативные последствия. Если представить себе, что 
              где-то произошел сбой в 2-х маршрутизаторах и пакет "зациклился" между ними, тогда пакет начнет 
              "бегать" туда-сюда между маршрутизаторами, поглощая пропускную способность канала, до тех пор, пока 
              TTL пакета не истечет. Как правило, величину TTL не устанавливают больше 100.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ip_dynaddr</DT
><DD
><P
>              Параметр используется для разрешения некоторых проблем, связанных с динамической адресацией. 
              Позволяет демону <B
CLASS="COMMAND"
>diald</B
> одновременно устанавливать соединение и изменять 
              исходящий адрес в пакетах (и сокетах для локальных процессов). Эта возможность была реализованв 
              для поддержки TCP по коммутируемым соединениям и соединениям с маскарадингом (masqueradig). Эта 
              опция позволяет "маскарадить" исходящий адрес пакета при изменении динамического IP-адреса.
            </P
><P
>              В переменную можно записать одно из 3-х значений: 0, 1 или 2.
              <P
></P
><UL
><LI
><P
>                    0 -- опция выключена, это значение по-умолчанию.
                  </P
></LI
><LI
><P
>                    1 -- опция включена.
                  </P
></LI
><LI
><P
>                    Любое другое значение, отличающееся от 0 и 1 подразумевает включение этой опции в 
                    "многословном" (verbose) режиме, что приводит к записи в системный журнал отладочных 
                    сообщений.
                  </P
></LI
></UL
>
              Что происходит, если изменяется адрес исходящего интерфейса при включенной опции ip_dynaddr:
              <P
></P
><UL
><LI
><P
>                    Исходящий адрес пакета и сокета изменяется ПРИ ПОВТОРНОЙ ПЕРЕДАЧЕ, когда он находится в 
                    состоянии SYN_SENT. Это касается локальных процессов.
                  </P
></LI
><LI
><P
>                    Для транзитных пакетов -- исходящий адрес пакета изменяется на выходе, когда внутренний хост 
                    выполняет ПОВТОРНУЮ ПЕРЕДАЧУ, пока не будет принят внешний пакет.
                  </P
></LI
></UL
>
            </P
><P
>                Эта опция особенно полезна для случаев автодозвона, когда в момент установления связи исходящий
                адрес еще не известен. Любой запрос на соединение заставляет diald "поднять" исходящий 
                интерфейс, после чего пакеты отправляются через него. Это означает, что нет необходимости 
                сначала выдавать запрос который "поднимет" исходящий интерфейс, а затем выдавать "реальный" 
                запрос на соединение, вместо этого мы просто устанавливаем соединение.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ip_forward</DT
><DD
><P
>              Включает/отключает функцию форвардинга (передачу транзитных пакетов между сетевыми интерфейсами), 
              которая позволяет компьютеру выступать в роли брандмауэра или маршрутизатора. Эта переменная очень 
              важна для Network Address Translation (Трансляция Сетевых Адресов), брандмауэров, маршрутизаторов и 
              всего того, что должно передавать пакеты между сетями.
            </P
><P
>              Это булева переменная. Или, другими словами, она может принимать два значения -- 0 или 1. 
              Значение по-умолчанию -- 0, "запрещено". То есть 0 означает запрет форвардинга, а 1 -- 
              разрешает его.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ip_local_port_range</DT
><DD
><P
>              Содержит два целых числа, которые определяют диапазон локальных портов, которые используются в 
              клиентских соединениях, т.е. для исходящих соединений, которые связывают нашу систему с некоторым 
              узлом сети, где мы выступаем в качестве клиента. Первое число задает нижнюю границу диапазона, 
              второе -- верхнюю.
            </P
><P
>              Значения по-умолчанию зависят от имеющегося объема ОЗУ. Если установлено более чем 128 Мб, то 
              нижняя граница будет 32768, а верхняя -- 61000. При меньшем объеме ОЗУ нижняя граница будет 1024 а 
              верхняя -- 4999 или даже меньше.
            </P
><P
>              Этот диапазон определяет количество активных соединений, которые могут быть запущены одновременно, 
              с другой системой, которая не поддерживает TCP-расширение timestamp.
            </P
><P
>              Диапазона 1024-4999 вполне достаточно для установки до 2000 соединений в секунду с системами, не 
              поддерживающими <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>timestamp</I
></SPAN
>. Проще говоря, этого вполне достаточно для 
              большинства применений.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ip_no_pmtu_disc</DT
><DD
><P
>              Параметр <TT
CLASS="FILENAME"
>ip_no_pmtu_disc</TT
> запрещает поиск PMTU (от англ. Path Maximum Transfer 
              Unit -- Максимальный Размер Пакета для выбранного Пути). Для большинства случаев лучше установить в 
              эту переменную значение FALSE, или 0 (т.е. система будет пытаться определить максимальный размер 
              пакета, при котором не потребуется выполнять их фрагментацию, для передачи на заданный хост). Но 
              иногда, в отдельных случаях, такое поведение системы может приводить к "срывам" соединений. Если у 
              вас возникают такие проблемы, то вам следует попробовать отключить эту опцию (т.е. записать в 
              переменную число 1) и установить нужное значение MTU.
            </P
><P
>              Обратите внимание на то, что MTU и PMTU -- это не одно и то же! MTU -- (от англ. Maximum Transfer 
              Unit -- максимальный размер пакета) определяет максимальный размер пакета для наших сетевых 
              интерфейсов, но не для сетевых интерфейсов на другом конце. PMTU -- опция, которая заставляет 
              систему вычислять максимальный размер пакета, при котором не потребуется фрагментация пакетов, для 
              маршрута к заданному хосту, включая все промежуточные переходы.
            </P
><P
>              Значение по-умолчанию -- FALSE (0), т.е. функция определения разрешена. Если записать число 1 в 
              этот файл, то функция определения PMTU будет запрещена. Параметр 
              <TT
CLASS="FILENAME"
>ip_no_pmtu_disc</TT
> может принимать значение 0 или 1.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ipfrag_high_thresh</DT
><DD
><P
>              Параметр задает максимальный объем памяти, выделяемый под очередь фрагментированных пакетов. 
              Когда длина очереди достигает этого порога, то обработчик фрагментов будет отвергать все 
              фрагментированные пакеты до тех пор, пока длина очереди не уменьшится до значения переменной 
              <TT
CLASS="FILENAME"
>ipfrag_low_thresh</TT
>. Это означает, что все отвергнутые фрагментированные 
              пакеты должны быть повторно переданы узлом-отправителем.
            </P
><P
>              Пакеты фрагментируются в том случае, если их размер слишком велик, чтобы быть переданными по 
              данному каналу. Узел-отправитель, в этом случае, "режет" пакеты на более мелкие части и затем 
              передает их одну за другой. На узле-получателе эти фрагменты опять собираются в полноценный пакет. 
              Примечательно, что идея фрагментации пакетов, сама по себе, вещь замечательная, но, к сожалению, 
              может быть использована в весьма неблаговидных целях.
            </P
><P
>              Параметр содержит целое число в диапазоне 0 .. 2147483647 и означает верхний порог длины очереди 
              фрагментов в байтах. Значение по-умолчанию -- 262144 байт, или 256 Кб. Этого количества, как 
              правило, вполне достаточно даже для самых крайних случаев.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ip_nonlocal_bind</DT
><DD
><P
>              Установка этого параметра позволяет отдельным локальным процессам выступать от имени внешнего 
              (чужого) IP-адреса. Это может оказаться полезным в некоторых случаях, когда необходимо 
              "прослушивать" внешние (чужие) IP-адреса, например -- сниффинг чужого траффика. Однако, эта опция 
              может оказывать отрицательное влияние на работоспособность отдельных приложений.
            </P
><P
>              Может иметь два значения -- 0 или 1. Если установлено значение 0, то опция отключена, 1 -- 
              включена. Значение по-умолчанию -- 0.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ipfrag_low_thresh</DT
><DD
><P
>              Этот параметр очень тесно связан с переменной <TT
CLASS="FILENAME"
>ipfrag_high_thresh</TT
>. 
              Он устанавливает нижний порог, при достижении которого опять разрешается прием фрагментов в 
              очередь. Обработчик фрагментов имеет свою очередь, в которой находятся фрагментированные пакеты, 
              ожидающие сборки. Когда длина очереди достигает верхнего порога 
              (<TT
CLASS="FILENAME"
>ipfrag_high_thresh</TT
>), то прием фрагментов в очередь приостанавливается до 
              тех пор, пока длина очереди не уменьшится до величины <TT
CLASS="FILENAME"
>ipfrag_low_thresh</TT
>. 
              Это предохраняет систему от "затопления" фрагментированными пакетами и, тем самым, является, в 
              своем роде, защитой от некоторых видов DoS-атак.
            </P
><P
>              Целое число в диапазоне 0 .. 2147483647 и означает нижний порог длины очереди 
              фрагментов в байтах, по достижении которого, фрагментированные пакеты снова будут приниматься в 
              очередь. Значение по-умолчанию -- 196608 байт, или 192 Кб. Это число обязательно должно быть 
              меньше, чем <TT
CLASS="FILENAME"
>ipfrag_high_thresh</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/ipfrag_time</DT
><DD
><P
>               Определяет максимальное время "хранения" фрагментов в секундах. Это относится только к тем 
               фрагментам, которые пока невозможно собрать, поскольку собранные пакеты к этому сроку скорее 
               всего уже будут переданы дальше (на следующий уровень или в сеть).
            </P
><P
>               Принимает целое значение и определяет предельное время хранения фрагментов в секундах. Если 
               записать туда число 5, то это будет означать 5 секунд.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_abort_on_overflow</DT
><DD
><P
>               Заставляет ядро отвергать новые соединения, если их поступает такое количество, что система 
               не в состоянии справиться с таким потоком. Что это означает? Допустим, что на систему 
               обрушивается шквал запросов на соединение, тогда они могут быть просто отвергнуты, если 
               эта опция будет включена, поскольку система не в состоянии обработать их все. Если 
               не установлена, то система будет пытаться обслужить все запросы.
            </P
><P
>               Может иметь два значение -- 0(выключено) или 1(включено). Значение по-умолчанию -- 0. 
               Включение этой опции следует расценивать как крайнюю меру. Перед этим необходимо попытаться 
               поднять производительность сервисов.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_fin_timeout</DT
><DD
><P
>              Задает максимальное время пребывания сокета в состоянии FIN-WAIT-2. Используется в тех случаях, 
              когда другая сторона по тем или иным причинам не закрыла соединение со своей стороны. Каждый 
              сокет занимает в памяти порядка 1.5 Кб, что может привести к значительным утечкам памяти в 
              некоторых случаях.
            </P
><P
>              Принимает целое число. Значение по-умолчанию -- 60 секунд. В ядрах серии 2.2 это значение было 
              равно 180 секундам, но было уменьшено, поскольку иногда возникали проблемы, связанные с нехваткой 
              памяти, на web-серверах, которые, как правило, обслуживают огромное количество подключений.
            </P
><P
>              За дополнительной информацией -- обращайтесь к описанию параметров 
              <TT
CLASS="FILENAME"
>tcp_max_orphans</TT
> и <TT
CLASS="FILENAME"
>tcp_orphan_retries</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_keepalive_time</DT
><DD
><P
>              Определяет -- как часто следует проверять соединение, если оно давно не используется. Значение 
              параметра имеет смысл только для тех сокетов, которые были созданы с флагом SO_KEEPALIVE.
            </P
><P
>              Принимает целое число секунд. Значение по-умолчанию -- 7200, т.е. 2 часа. Не уменьшайте это 
              число без необходимости, поскольку это может привести к увеличению бесполезного трафика.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_keepalive_intvl</DT
><DD
><P
>              Определяет интервал проверки "жизнеспособности" сокета. Это значение учитывается при 
              подсчете времени, которое должно пройти перед тем как соединение будет разорвано.
            </P
><P
>              Принимает целое число. Значение по-умолчанию -- 75 секунд. Это достаточно высокое значение, 
              чтобы рассматривать его как нормальное. Значения параметров
              <TT
CLASS="FILENAME"
>tcp_keepalive_probes</TT
> и <TT
CLASS="FILENAME"
>tcp_keepalive_intvl</TT
> 
              могут использоваться для определения времени, через которое соединение будет разорвано.
            </P
><P
>              Со значениями по-умолчанию (9 попыток с интервалом 75 секунд) это займет примерно 11 минут. 
              Попытки определения "жизнеспособности", в свою очередь, начнутся через 2 часа после того, 
              как через данное соединение проследовал последний пакет.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_keepalive_probes</DT
><DD
><P
>              Определяет количество попыток проверки "жизнеспособности" прежде, чем будет принято решении о 
              разрыве соединения.
            </P
><P
>              Принимает целое число, которое не следует устанавливать больше 50-ти. 
              Значение по-умолчанию -- 9. Это означает, что будет выполнено 9 попыток проверки соединения, 
              чтобы убедиться в том, что соединение разорвано.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_max_orphans</DT
><DD
><P
>              Задает максимальное число "осиротевших" (не связанных ни с одним процессом) сокетов. Если это 
              число будет превышено, то такие соединения разрываются, а в системный журнал пишется 
              предупреждение.
            </P
><P
>              Это ограничение существует исключительно ради предотвращения простейших разновидностей DoS-атак. 
              Вообще вы не должны полагаться на эту переменную! Не рекомендуется уменьшать это число. Сетевая 
              среда может потребовать увеличение этого порога, однако, такое увеличение может привести к 
              необходимости увеличения объема ОЗУ в системе. Прежде чем поднимать этот предел -- попробуйте 
              перенастроить сетевые сервисы на более агрессивное поведение по отношению к "осиротевшим" сокетам.
            </P
><P
>              Принимает целое число. Значение по-умолчанию -- 8192, однако оно очень сильно зависит от объема 
              памяти в системе. Каждый "осиротевший" сокет "съедает" примерно 64 Кб памяти, которая не может быть 
              сброшена в своп (swap).
            </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
src="images/note.gif"
HSPACE="5"
ALT="Примечание:"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>                При возникновении проблем, связанных с этим ограничением -- в системный журнал будет записано 
                сообщение, подобное этому:
                
                <PRE
CLASS="SCREEN"
>TCP: too many of orphaned sockets
                </PRE
>
                Это может служить поводом к тому, чтобы пересмотреть значения переменных 
                <TT
CLASS="FILENAME"
>tcp_fin_timeout</TT
> или <TT
CLASS="FILENAME"
>tcp_orphans_retries</TT
>.
              </P
></TD
></TR
></TABLE
></DIV
><P
> </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_orphan_retries</DT
><DD
><P
>              Количество попыток закрыть соединение перед тем как оно будет разорвано принудительно. Если вы 
              администрируете http-сервер, который испытывает большие нагрузки, то стоит подумать об уменьшении 
              этого значения.
            </P
><P
>              Принимает целое число. Значение по-умолчанию -- 7, что соответствует, примерно, 
              от 50 секунд до 16 минут, в зависимости от внличины Retransmission Timeout (RTO -- Таймаут для 
              Повторной Передачи. прим. перев.). Детальное описание RTO вы найдете в разделе "3.7. Data 
              Communication" RFC 793 - Transmission Control Protocol.
            </P
><P
>              Кроме того, посмотрите описание переменной <TT
CLASS="FILENAME"
>tcp_max_orphans</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_max_syn_backlog</DT
><DD
><P
>               Определяет максимальное время хранения SYN-запросов в памяти до момента получения третьего, 
               завершающего установление соединения, пакета. Эта опция работает только тогда, когда включен
               параметр <TT
CLASS="FILENAME"
>tcp_syncookies</TT
>. Если сервер испытывает серьезные нагрузки, 
               то можно попробовать немного увеличить этот параметр.
            </P
><P
>              Значение по-умолчанию зависит от количества памяти, имеющейся в системе. 
              Если объем памяти менее 128 Мб, то значение по-умолчанию равно 128, если больше, то значение 
              по-умолчанию равно 1024.
            </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
src="images/note.gif"
HSPACE="5"
ALT="Примечание:"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>                Если вы увеличиваете эту переменную до величины более чем 1024, то было бы неплохо изменить 
                величину TCP_SYNQ_HSIZE и пересобрать ядро. TCP_SYNQ_HSIZE находится в файле linux/include/tcp.h. 
                Эта величина рассчитывается по формуле:
                <PRE
CLASS="SCREEN"
>TCP_SYNQ_HSIZE*16 &#60;= tcp_max_syn_backlog</PRE
>
              </P
></TD
></TR
></TABLE
></DIV
><P
> </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_max_tw_buckets</DT
><DD
><P
>              Максимальное число сокетов, находящихся в состоянии TIME-WAIT одновременно. При превышении этого 
              порога -- "лишний" сокет разрушается и пишется сообщение в системный журнал. Цель этой переменной 
              -- предотвращение простейших разновидностей DoS-атак.
            </P
><P
>              Целое число. Значение по-умолчанию -- 180000. На первый взгляд может показаться, что это очень 
              много, но на самом деле это не так. Если у вас начинают возникать ошибки, связанные с этим 
              параметром, то попробуйте увеличить его.
            </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
src="images/warning.gif"
HSPACE="5"
ALT="Внимание!"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>                Вам не следует уменьшать значение этой переменной. Вместо этого, если начали поступать 
                сообщения в системный журнал, ее следует увеличить, однако, это может потребовать 
                наращивания памяти в системе.
              </P
></TD
></TR
></TABLE
></DIV
><P
>              </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_retrans_collapse</DT
><DD
><P
>              Включает/выключает эмуляцию ошибки протокола TCP, делая возможным сетевое взаимодействие с 
              некоторыми устройствами, в которых реализация стека TCP имеет эту ошибку. Без ее эмуляции было 
              бы невозможным работать с отдельными моделями принтеров. Ошибка заключается в отправке 
              полноразмерных пакетов при повторной передаче.
            </P
><P
>              Может принимать два значения -- 0 (выключено) и 1 (включено). Значение по-умолчанию -- 1 
              (включено). Эмуляция ошибки никак не повредит взаимодействию с другими узлами сети, но при этом 
              позволит общаться с устройствами, имеющими ошибку в реализации стека TCP. Вообще эта опция 
              совершенно безопасна, однако, если в журнал пишутся непонятные сообщения -- можете попробовать 
              отключить ее.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_retries1</DT
><DD
><P
>              Максимальное количество попыток повторной передачи пакетов по установленному соединению прежде, 
              чем сообщение об ошибке будет передано сетевому уровню, в результате чего может быть выбран 
              другой маршрут для отправки последующих пакетов. Минимальное значение этого параметра 
              равно 3. Это число является значением по-умолчанию, что соответствует интервалу времени 
              от 3 секунд до 8 минут, в зависимости от величины Retransmission timeout (RTO). Детальное 
              описание RTO вы найдете в разделе "3.7. Data Communication" RFC 793 - Transmission Control Protocol.
            </P
><P
>              Целое число. Значение по-умолчанию -- 3. Стандарты определяют диапазон изменения этого параметра от 
              3 до 100.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_retries2</DT
><DD
><P
>              Максимальное количество попыток повторной передачи пакетов, до того как соединение будет считаться 
              разорванным. Это ограничение определено в <A
HREF="http://www.ietf.org/rfc/rfc1122.txt"
TARGET="_top"
>              RFC 1122</A
> и равно 100, но обычно его уменьшают.
            </P
><P
>              Значение по-умолчанию -- 15, что соответствует примерно 13-30 минутам в зависимости от 
              величины Retransmission timeout (RTO).
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_rfc1337</DT
><DD
><P
>               Является реализацией решения проблемы, описываемой в "RFC 1337 - TIME-WAIT Assassination Hazards 
               in TCP". Проблема связана с "устаревшими" дубликатами пакетов, которые могут вносить помехи во 
               вновь устанавливаемые соединения и порождать три различные проблемы. Первая -- "устаревший" 
               дубликат пакета с данными может быть ошибочно воспринят в новом соединении, что приведет к 
               передаче неверных данных. Вторая -- соединение может быть десинхронизировано и "уйти" в 
               ACK-цикл из-за "устаревших" дубликатов, которые порождают новые соединения (здесь автор имеет 
               ввиду "устаревшие" дубликаты SYN-пакетов, прим. перев.). И третья проблема -- "устаревшие" 
               дубликаты могут "проникнуть" в недавно созданное соединение и ошибочно уничтожить его.
            </P
><P
>              Согласно упомянутому RFC существуют три возможных решения, однако, одно из них решает эту проблему 
              лишь частично, другие требуют внесения значительных изменений в протокол TCP.
            </P
><P
>              Окончательное решение состоит в том, что RST-пакеты должны просто игнорироваться, пока сокет 
              находится в состоянии TIME_WAIT. Вместе с установкой параметра Maximum Segment Life (MSL -- 
              максимальное время жизни сегмента) равным 2 мин. такой подход решает все три проблемы, описанные в 
              RFC 1337.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_sack</DT
><DD
><P
>              Разрешает Selective Acknowledgements (SACK -- Выборочное Подтверждение), детальное описание вы 
              найдете в RFC 2883 - An Extension to Selective Acknowledgement (SACK) Option for TCP и RFC 2883 - 
              An Extension to Selective Acknowledgement (SACK) Option for TCP.
            </P
><P
>              Если этот параметр включен (1), то в TCP-заголовке будет устанавливаться SACK-флаг при передаче 
              SYN-пакета, сообщая тем самым удаленному хосту, что наша система в состоянии обрабатывать SACK, на 
              что удаленный хост может ответить ACK-пакетом с установленным флагом SACK. Этот режим выборочно 
              подтверждает каждый сегмент в TCP-окне. Это особенно полезно на неустойчивых соединениях, поскольку 
              позволяет производить повторную передачу лишь отдельных, не подтвержденных фрагментов, а не всего 
              TCP-окна, как это диктуется более старыми стандартами. Если какой либо сегмент TCP-окна был 
              "утерян", то приемная сторона не пришлет на него SACK-подтверждение о приеме. Отправитель, поняв 
              это, повторит передачу "потерявшихся" сегментов. Избыточные данные сохраняются в TCP-заголовке, 40 
              байт на сегмент. Подтверждение каждого сегмента -- это два 32-битных беззнаковых целых числа, таким 
              образом в заголовке может разместиться подтверждение 4-х сегментов. Однако, как правило, совместно 
              с опцией SACK используется опция timestamp, которая занимает 10 байт и поэтому в одном пакете может 
              быть подтверждено не более 3 сегментов.
            </P
><P
>              Рекомендуется включать эту опцию, если вы имеете неустойчивые соединения. Однако, если вы соединены 
              1.5-метровым кабелем с другой машиной, то в таком случае, для достижения наивысшей скорости обмена, 
              следует эту опцию отключить. Обычно эта опция не нужна, но лучше ее включить. Она обеспечивает 100% 
              обратную совместимость, т.е. вы не должны испытывать никаких проблем при соединении с хостами, 
              которые эту опцию не поддерживают.
            </P
><P
>              Значение по-умолчанию --1 (включено).
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_stdurg</DT
><DD
><P
>              Разрешает/запрещает соответствие стандарту RFC 1122. Поведение по-умолчанию соответствует 
              стандарту использования флага URG -- BSD 4.2, описанному в RFC 793. Если этот параметр включен, 
              то возможны сбои при работе с отдельными узлами Интернета, точнее -- с узлами, которые 
              придерживаются стандарта BSD 4.2. Значение по-умолчанию -- 0 (выключено).
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_syn_retries</DT
><DD
><P
>              Количество попыток передачи SYN-пакета при установлении нового соединения.
              Это число не должно устанавливаться больше чем 255, поскольку каждая повторная попытка 
              отнимает значительное время. На каждую попытку отводится примерно 30-40 секунд. Значение 
              по-умолчанию -- 5, что соответствует, примерно, 180 секундам.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_synack_retries</DT
><DD
><P
>              Количество попыток передачи SYN,ACK-пакета в ответ на SYN-запрос. Другими словами -- 
              максимальное число попыток установить пассивное TCP-соединение, инициированное другим хостом.
              Это число не должно устанавливаться больше чем 255. Значение по-умолчанию -- 5.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_timestamps</DT
><DD
><P
>              Разрешает/запрещает использование временных меток (timestamps), в соответствии с RFC 1323. Если 
              коротко, то это расширение TCP используется для расчета Round Trip Measurement (определение 
              времени возврата) лучшим способом, нежели метод Retransmission timeout (RTO). Эта опция должна
              сохранять обратную совместимость в большинстве случаев, так что лучше оставить ее включенной, 
              особенно если вы работаете в высокоскоростной сети (например LAN или 10mb Интернет). В случае 
              низкоскоростного оединения (скажем модемное) -- вы прекрасно обойдетесь и без этой опции, и будет 
              даже лучше, если вы ее отключите.
              Значение по-умолчанию -- 1 (включено).
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_tw_recycle</DT
><DD
><P
>              Разрешает/запрещает быструю утилизацию сокетов, находящихся в состоянии TIME-WAIT. Если вы не 
              уверены в своих действиях, то вам лучше не трогать эту переменную.
              Значение по-умолчанию -- 0.
            </P
></DD
><DT
>/proc/sys/net/ipv4/tcp_window_scaling</DT
><DD
><P
>              Разрешает/запрещает масштабирование TCP-окна, как определено в RFC 1323. В этом документе описано 
              как производится масштабирование TCP-окна при передаче по Large Fat Pipes (LFP -- "толстый" канал). 
              При передаче TCP-пакетов по "толстым" каналам возникают существенные потери пропускной способности 
              из-за того, что они не загружены полностью во время ожидания подтверждения о приеме предыдущего 
              TCP-окна. Основная проблема состоит в том, что окно не может иметь размер больше, чем 2**16 байт 
              (65 Кб). Разрешая масштабирование TCP-окна мы, тем самым, можем увеличить его размер и таким 
              образом уменьшить потери пропускной способности.
              Значение по-умолчанию -- 1 (включено).
            </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="PERDEVICESETTINGS"
></A
>13.2.2. Параметры настройки устройств.</H2
><P
>        Каталог <TT
CLASS="FILENAME"
>conf/DEV/</TT
>, где под DEV следует понимать название того или иного устройства, 
        содержит настройки для конкретного сетевого интерфейса. Настройки в каталоге
        <TT
CLASS="FILENAME"
>conf/all/</TT
> применяются ко ВСЕМ сетевым интерфейсам. Настройки в каталоге
        <TT
CLASS="FILENAME"
>conf/default/</TT
> -- настройки по-умолчанию, они не влияют на настройки 
        существующих интерфейсов, но используются для первоначальной настройки вновь устанавливаемых устройств.
      </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>/proc/sys/net/ipv4/conf/DEV/accept_redirects</DT
><DD
><P
>               Управляет приемом ICMP-сообщений о переадресации. Сообщения <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Redirect ...</I
></SPAN
> 
               используются для уведомления маршрутизаторов или хостов о существовании лучшего маршрута движения 
               пакетов к заданному хосту, который (маршрут) может быть быстрее или менее загружен.
            </P
><P
>              Может иметь два значения -- 0 (выключено -- сообщения о переадресации игнорируются) и 1 (включено 
              -- сообщения о переадресации принимаются). Значение по-умолчанию -- 1 (включено), однако я 
              посоветовал бы отключать эту опцию, поскольку она далеко небезопасна. В подавляющем большинстве 
              случаев необходимость в переадресации отсутствует, поэтому лучше держать эту переменную 
              выключенной, если конечно вы на 100% не уверены в обратном.
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/accept_source_route</DT
><DD
><P
>              Разрешает/запрещает "маршрутизацию от источника". Маршрутизация от источника весьма небезопасна.
               Значение по-умолчанию -- 1 (включено).
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/bootp_relay</DT
><DD
><P
>               Разрешает/запрещает форвардинг пакетов с исходящими адресами 0.b.c.d. Демон BOOTP relay должен 
               перенаправлять эти пакеты на корректный адрес. Значение по-умолчанию -- 0 (выключено),
               поскольку реализация обработки этого параметра еще отсутствует  (kernel v2.2.12).
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/forwarding</DT
><DD
><P
>              Включает/отключает функцию форвардинга (передачу транзитных пакетов) между сетевыми интерфейсами. 
              Могут использоваться для включения/выключения функции форвардинга для отдельных интерфейсов. 
              По-умолчанию все параметры conf/DEV/forwarding принимают значение, установленное
              в <TT
CLASS="FILENAME"
>ipv4/ip_forward</TT
> так, если этот параметр включить, то и все параметры 
              conf/DEV/forwarding будут включены, если выключить, то и conf/DEV/forwarding окажутся выключены.
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/log_martians</DT
><DD
><P
>              Включает/выключает функцию журналирования всех пакетов, которые содержат неправильные 
              (невозможные) адреса (так называемые martians -- "марсианские" пакеты). Под невозможными 
              адресами, в данном случае, следует понимать такие адреса, которые отсутствуют в таблице 
              маршрутизации. (см. раздел <A
HREF="c1699.html#REVERSEPATHFILTERING"
>Reverse Path Filtering</A
>).
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/mc_forwarding</DT
><DD
><P
>              Включает/выключает поддержку маршрутизации групповых рассылок для заданного интерфейса. Кроме того, 
              чтобы иметь поддержку маршрутизации групповых рассылок, необходимо собрать ядро с включенной опцией 
              CONFIG_MROUTE. Дополнительно в системе должен иметься демон, осуществляющий групповую 
              маршрутизацию. 
              Значение по-умолчанию -- 0 (выключено). Обратите внимание -- нет никакой необходимости включать эту 
              опцию, если вы желаете лишь получать групповые пакеты. Она необходима только если вы собираетесь 
              перенаправлять групповой трафик через вашу систему.
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/proxy_arp</DT
><DD
><P
>              Включает/выключает проксирование arp-запросов для заданного интерфейса. ARP-прокси позволяет 
              маршрутизатору отвечать на ARP запросы в одну сеть, в то время как запрашиваемый хост находится в 
              другой сети. С помощью этого средства происходит "обман" отправителя, который отправил ARP запрос, 
              после чего он "думает", что маршрутизатор является хостом назначения, тогда как в действительности 
              хост назначения находится по другую сторону маршрутизатора.

              Маршрутизатор выступает в роли уполномоченного агента хоста назначения, перекладывая пакеты от
              другого хоста.
              Значение по-умолчанию -- 0 (выключено). Дополнительную информацию вы найдете в Proxy-ARP mini HOWTO.
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/rp_filter</DT
><DD
><P
>              См. раздел <A
HREF="c1699.html#REVERSEPATHFILTERING"
>Reverse Path Filtering</A
>
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/secure_redirects</DT
><DD
><P
>              Включает/выключает режим безопасной переадресации. Если параметр выключен, то будут 
              приниматься любые сообщения ICMP Redirect ... от любого хоста из любого места. Если включен, 
              то сообщения о переадресации будут восприниматься только от тех шлюзов (gateways), которые 
              имеются в списке шлюзов по-умолчанию. С помощью этой опции можно избежать большинства ложных 
              переадресаций, которые могут быть использованы для перехвата трафика.
              Значение по-умолчанию -- 1 (включено). Обратите внимание -- действие этой параметра 
              отменяется параметром <TT
CLASS="FILENAME"
>shared_media</TT
>, так что, если вы включаете 
              <TT
CLASS="FILENAME"
>secure_redirects</TT
>, то необходимо включить и 
              <TT
CLASS="FILENAME"
>shared_media</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/send_redirects</DT
><DD
><P
>              Включает/выключает выдачу ICMP Redirect ... другим хостам. Эта опция обязательно должна быть
              включена, если хост выступает в роли маршрутизатора любого рода. Как правило ICMP-сообщения 
              о переадресации отправляются в том случае, когда необходимо сообщить хосту о том, что он 
              должен вступить в контакт с другим сервером. Значение по-умолчанию -- 1 (включено). 
              Если компьютер не выступает в роли маршрутизатора, то этот параметр можно отключить.
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/shared_media</DT
><DD
><P
>              Включает/выключает признак того, что физическая сеть является носителем нескольких логических 
              подсетей, например, когда на одном физическом кабеле организовано несколько подсетей с различными 
              сетевыми масками. Этот признак используется ядром при принятии решения о необходимости выдачи 
              ICMP-сообщений о переадресации. Значение по-умолчанию -- 0 (выключено). Этот параметр влияет
              на установку параметра <TT
CLASS="FILENAME"
>secure_redirects</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/conf/DEV/tag</DT
><DD
><P
>              FIXME: Заполните этот пробел.
            </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="NEIGHBORPOLICY"
></A
>13.2.3. Параметры сетевых политик.</H2
><P
>        Каталог <TT
CLASS="FILENAME"
>neigh/DEV/</TT
>, где под DEV следует понимать название того или иного 
        устройства, содержит настройки для конкретного сетевого интерфейса. Настройки в каталоге 
        <TT
CLASS="FILENAME"
>neigh/all/</TT
> применяются ко ВСЕМ сетевым интерфейсам. Настройки в каталоге 
        <TT
CLASS="FILENAME"
>neigh/default/</TT
> -- настройки по-умолчанию, они не влияют на настройки 
        существующих интерфейсов, но используются для первоначальной настройки вновь устанавливаемых устройств.
      </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>/proc/sys/net/ipv4/neigh/DEV/anycast_delay</DT
><DD
><P
>              Максимальное значение случайной задержки ответов в "тиках" (1/100 секунды). 
              Пока не реализовано (Linux пока еще не имеет поддержки anycast).
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/app_solicit</DT
><DD
><P
>              Определяет количество запросов, посылаемых демону  ARP пользовательского уровня. 
              0 -- отключено.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/base_reachable_time</DT
><DD
><P
>              Базовое значение, используемое для расчета случайного времени доступа, в соответствии с RFC2461.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/delay_first_probe_time</DT
><DD
><P
>              Задержка перед первой попыткой проверки доступности "соседей". (см. 
              <TT
CLASS="FILENAME"
>gc_stale_time</TT
>)
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/gc_stale_time</DT
><DD
><P
>              Определяет частоту проверки записей в таблице ARP на предмет "устаревания".
              Если запись "устарела", то она должна быть подтверждена при первой же возможности
              (бывает полезным в случае динамического  распределения IP-адресов). В случае, если
              параметр <TT
CLASS="FILENAME"
>ucast_solicit</TT
> имеет значение больше 0, то сначала выполняется
              попытка послать ARP-пакет напрямую известному хосту, а в случае неудачи, когда
              <TT
CLASS="FILENAME"
>mcast_solicit</TT
> больше 0, выполняется широковещательный
              ARP-запрос.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/locktime</DT
><DD
><P
>              Записи в таблице ARP обновляются только в том случае, если "возраст" записи превышает
              этот параметр. Предотвращает слишком частую "продувку" кэша ARP.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/mcast_solicit</DT
><DD
><P
>              Максимальное количество повторов передачи широковещательного запроса к маршрутизаторам.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/proxy_delay</DT
><DD
><P
>              Максимальное время (выбирается случайно из диапазона [0 .. proxytime]) задержки перед
              отправкой ответа на ARP-запрос, для которого имеется запись в proxy ARP. В некоторых случаях
              может использоваться для предотвращения сетевых атак.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/proxy_qlen</DT
><DD
><P
>              Максимальная длина очереди для задержанных ARP-откликов (см. <TT
CLASS="FILENAME"
>proxy_delay</TT
>).
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/retrans_time</DT
><DD
><P
>              Время, измеряемое в "тиках", между повторными передачами запросов к "соседям". 
              Используемых для определения адресов.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/ucast_solicit</DT
><DD
><P
>              Максимальное количество повторов передачи уникастного запроса.
            </P
></DD
><DT
>/proc/sys/net/ipv4/neigh/DEV/unres_qlen</DT
><DD
><P
>              Максимальная длина очереди для ожидающих arp-запросов - количество пакетов, которые 
              приняты от протоколов других уровней, ожидающие разрешения адреса.
            </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="ROUTINGSETTINGS"
></A
>13.2.4. Параметры маршрутизации.</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>/proc/sys/net/ipv4/route/error_burst и /proc/sys/net/ipv4/route/error_cost</DT
><DD
><P
>              <TT
CLASS="FILENAME"
>error_burst</TT
> используется в паре с <TT
CLASS="FILENAME"
>error_cost</TT
> для 
              ограничения количества генерируемых сообщений <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Destination Unreachable</I
></SPAN
>. 
              <TT
CLASS="FILENAME"
>error_burst</TT
> несет в себе смысл верхнего предела "стоимости" передачи
              сообщений, в то время как <TT
CLASS="FILENAME"
>error_cost</TT
> обозначает "цену" одного сообщения. 
              Когда <TT
CLASS="FILENAME"
>error_burst</TT
> "опустошается", то передача сообщений 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Destination Unreachable</I
></SPAN
> прекращается.
            </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
src="images/note.gif"
HSPACE="5"
ALT="Примечание:"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>                Сообщения <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Destination Unreachable</I
></SPAN
> обычно отсылаются тогда, когда 
                невозможно определить дальнейший маршрут движения пакета. Этому могут быть три причины:
                <P
></P
><OL
TYPE="1"
><LI
><P
>Невозможно выполнить передачу хосту.
                    </P
></LI
><LI
><P
>Не известен маршрут к заданному сегменту сети или хосту.
                    </P
></LI
><LI
><P
>Если данный маршрут запрещен набором правил маршрутизации.
                    </P
></LI
></OL
>
              В этих трех случаях сетевая подсистема генерирует сообщение 
              ICMP Destination Unreachable, свое для каждого случая:
                <P
></P
><OL
TYPE="1"
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Host Unreachabl</I
></SPAN
>e -- когда хост, находящийся в той же сети, 
                    что и наш роутер -- недоступен.
                    </P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Network Unreachable</I
></SPAN
> -- когда в таблице маршрутизации 
                    роутера нет ни одного маршрута, по которому пакет мог бы быть отправлен дальше.
                    </P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Communication Administratively Prohibited By Filtering</I
></SPAN
> -- 
                    когда пакет не может быть переправлен из-за наличия правил маршрутизации явно 
                    запрещающих передачу.
                    </P
></LI
></OL
>
              Значение по-умолчанию -- 500. Учитывая значение по-умолчанию переменной 
              <TT
CLASS="FILENAME"
>error_cost</TT
> (100) это соответствует 5-ти сообщениям 
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP Destination Unreachable</I
></SPAN
> в секунду.
              </P
></TD
></TR
></TABLE
></DIV
><P
> </P
></DD
><DT
>/proc/sys/net/ipv4/route/flush</DT
><DD
><P
>               Запись любой информации в эту переменную (само собой разумеется, запись может быть произведена 
               только, если вы обладаете правами root) приведет к очистке кэша маршрутов.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/gc_elasticity</DT
><DD
><P
>              Значения, управляющие частотой и поведением алгоритма сборки "мусора" в кэше маршрутизации. 
              Может оказаться полезным при восстановлении после сбоев. 
              Прежде чем Linux сможет перейти к другому маршруту, пройдет не менее
              <TT
CLASS="FILENAME"
>gc_timeout</TT
> секунд (по-умолчанию -- 300), если использовавшийся ранее 
              оказался недоступным. Это число можно немного уменьшить, чтобы ускорить восстановление после сбоев.
            </P
><P
>              См. также <A
HREF="http://mailman.ds9a.nl/pipermail/lartc/2002q1/002667.html"
TARGET="_top"
>              это сообщение</A
>, которое отправил Ard van Breemen.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/gc_interval</DT
><DD
><P
>              См. описание <TT
CLASS="FILENAME"
>/proc/sys/net/ipv4/route/gc_elasticity</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/gc_min_interval</DT
><DD
><P
>              См. описание <TT
CLASS="FILENAME"
>/proc/sys/net/ipv4/route/gc_elasticity</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/gc_thresh</DT
><DD
><P
>              См. описание <TT
CLASS="FILENAME"
>/proc/sys/net/ipv4/route/gc_elasticity</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/gc_timeout</DT
><DD
><P
>              См. описание <TT
CLASS="FILENAME"
>/proc/sys/net/ipv4/route/gc_elasticity</TT
>.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/max_delay</DT
><DD
><P
>              Максимальный размер задержки перед сбросом кэша маршрутов.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/max_size</DT
><DD
><P
>              Максимальный размер кэша маршрутов. Устаревшие записи будут удаляться из кэша
              только после достижения размера кэша этой величины
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/min_adv_mss</DT
><DD
><P
>              FIXME: Восполните этот пробел.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/min_delay</DT
><DD
><P
>              Минимальный  размер задержки перед сбросом кэша маршрутов.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/min_pmtu</DT
><DD
><P
>              FIXME: Восполните этот пробел.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/mtu_expires</DT
><DD
><P
>              FIXME: Восполните этот пробел.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/redirect_load</DT
><DD
><P
>              Факторы, влияющие на принятие решения о пересылке сообщений перенаправления на заданный хост.
              Перенаправление не производится в случае, если величина нагрузки или количество отправленных
              сообщений достигли своего предела.
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/redirect_number</DT
><DD
><P
>              См. описание <TT
CLASS="FILENAME"
>/proc/sys/net/ipv4/route/redirect_load</TT
>
            </P
></DD
><DT
>/proc/sys/net/ipv4/route/redirect_silence</DT
><DD
><P
>              Таймаут перенаправления. По истечении этого периода времени, сообщение о переадресации 
              посылается снова, независимо от того были ли достигнуты пределы 
              <TT
CLASS="FILENAME"
>redirect_load</TT
> или <TT
CLASS="FILENAME"
>redirect_number</TT
>.
            </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c1699.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>В начало документа</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c2289.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Параметры настройки сети в ядре.</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1699.html"
ACCESSKEY="U"
>К началу раздела</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Специализированные дисциплины управления очередями.</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>