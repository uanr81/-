<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Простые бесклассовые дисцплины обработки очереди.</TITLE
><META http-equiv="Content-Type" content="text/html; charset=koi8-r"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Linux Advanced Routing &#38; Traffic Control HOWTO"
HREF="index.html"><LINK
REL="UP"
TITLE="Дисциплины обработки очередей для управления пропускной способностью"
HREF="c834.html"><LINK
REL="PREVIOUS"
TITLE="Дисциплины обработки очередей для управления пропускной способностью"
HREF="c834.html"><LINK
REL="NEXT"
TITLE="Какие типы дисциплин нужно использовать."
HREF="x991.html"><style type="text/css"> p {text-align:justify;} </style></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Advanced Routing &#38; Traffic Control HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c834.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Глава 9. Дисциплины обработки очередей для управления пропускной способностью</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x991.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="SIMPLECLASSLESSQUEUEINGDISCIPLINES"
></A
>9.2. Простые бесклассовые дисцплины обработки очереди.</H1
><P
>      Как уже говорилось, дисциплины обработки очереди определяют способ передачи данных. Бесклассовые 
      дисциплины, в общем, получают данные, переупорядочивают, вносят задержку или уничтожают их. 
    </P
><P
>      Они могут использоватся для ограничения пропускной способности интерфейса целиком, без какого-либо
      разделения по классам. Крайне важно, чтобы вы поняли назначение этого типа очередей перед тем, как мы 
      перейдем к классовым дисциплинам!
    </P
><P
>      Наиболее распространенной дисциплиной является pfifo_fast -- она используется по-умолчанию.
    </P
><P
>      Каждая из дисциплин имеет свои достоинства и недостатки. Не все из них досконально протестированы.
    </P
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="PFIFO_FAST"
></A
>9.2.1. pfifo_fast</H2
><P
>        Эта дисциплина работает, как видно из названия, по принципу <SPAN
CLASS="QUOTE"
>"первым пришел, первым ушел"</SPAN
> 
        (First In, First Out). Это означает, что ни один пакет не получает специальной обработки. 
        Однако это не совсем так. Данная очередь имеет три, так называемых, <SPAN
CLASS="QUOTE"
>"полосы"</SPAN
>. В каждой 
        <SPAN
CLASS="QUOTE"
>"полосе"</SPAN
> пакеты обрабатываются по принципу FIFO. Но полоса 1 не будет обслуживаться
        до тех пор, пока есть пакеты в полосе 0. Аналогично, пока есть пакеты в полосе 1, 
        не обрабатывается полоса 2.
      </P
><P
>        Ядро учитывает значение поля пакета Type of Service, и направляет пакеты 
        с установленным флагом 'минимальная задержка' в полосу 0.
      </P
><P
>        Не путайте эту простую бесклассовую дисциплину с классовой дисциплиной PRIO! 
        Хотя они ведут себя похожим образом, pfifo_fast является бесклассовой и вы не можете добавлять к ней 
        другие дисциплины командой <B
CLASS="COMMAND"
>tc</B
>.
      </P
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN867"
></A
>9.2.1.1. Параметры и использование</H3
><P
>          Вы не можете конфигурировать pfifo_fast, поскольку ее параметры жестко "зашиты". Вот ее 
          конфигурация по умолчанию: 
          <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>priomap</DT
><DD
><P
>                  Определяет отображение пакетных приоритетов, присвоенных ядром, в полосы. Отображение 
                  основывается на значении поля TOS, которое выглядит следующим образом:
                  <PRE
CLASS="SCREEN"
>   0     1     2     3     4     5     6     7
+-----+-----+-----+-----+-----+-----+-----+-----+
|                 |                       |     |
|   PRECEDENCE    |          TOS          | MBZ |
|                 |                       |     |
+-----+-----+-----+-----+-----+-----+-----+-----+                  
                  </PRE
>
                  Четыре бита TOS (поле TOS) определяются так: 
                  <PRE
CLASS="SCREEN"
>Двоичн Десятичн  Значение
---------------------------------------------------------
1000   8         Минимизировать задержку (md)
0100   4         Максимальная пропускная способность (mt)
0010   2         Максимальная надежность (mr)
0001   1         Минимальная стоимость (mmc)
0000   0         Обычное обслуживание                  
                  </PRE
>
                  Поскольку справа еще есть 1 бит, реальное значение поля TOS вдвое больше значения битов TOS. 
                  Команда tcpdump -v -v выводит значение всего поля TOS, а не только четырех бит. Оно приведено в 
                  первой колонке таблицы:
                  <PRE
CLASS="SCREEN"
>TOS     Биты  Значение                 Приоритет Linux  Полоса
-------------------------------------------------------------
0x0     0     Normal Service           0 Best Effort     1
0x2     1     Minimize Monetary Cost   1 Filler          2
0x4     2     Maximize Reliability     0 Best Effort     1
0x6     3     mmc+mr                   0 Best Effort     1
0x8     4     Maximize Throughput      2 Bulk            2
0xa     5     mmc+mt                   2 Bulk            2
0xc     6     mr+mt                    2 Bulk            2
0xe     7     mmc+mr+mt                2 Bulk            2
0x10    8     Minimize Delay           6 Interactive     0
0x12    9     mmc+md                   6 Interactive     0
0x14    10    mr+md                    6 Interactive     0
0x16    11    mmc+mr+md                6 Interactive     0
0x18    12    mt+md                    4 Int. Bulk       1
0x1a    13    mmc+mt+md                4 Int. Bulk       1
0x1c    14    mr+mt+md                 4 Int. Bulk       1
0x1e    15    mmc+mr+mt+md             4 Int. Bulk       1                  
                  </PRE
>
                  Куча цифр. Вторая колонка содержит значение четырех значимых битов поля TOS, а в третьей 
                  расшифровывается значение. Например, 15 означает минимальную стоимость (Minimal Monetary Cost), 
                  максимальную надежность (Maximum Reliability), максимальную полосу пропускания(Maximum 
                  Throughput) И минимальную задержку (Minimum Delay).
                </P
><P
>                  В четвертой колонке приведены соответствующие уровни приоритетов, выставляемые ядром Linux. 
                </P
><P
>                  В последней колонке демонстрируется результат отображения в полосы по-умолчанию. 
                  В командной строке это выглядит так: 
                  <PRE
CLASS="SCREEN"
>1, 2, 2, 2, 1, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1                  
                  </PRE
>
                  Это означает, что, например, приоритет 4 отображается в первую полосу. 
                  <B
CLASS="COMMAND"
>priomap</B
> позволяет задавать и более высокие приоритеты (&#62; 7) , 
                  которые не соответствуют полю TOS, но они используются в других целях.
                </P
><P
>                  Ниже приводится таблица из документа RFC 1349 (за подробной информацией обратитесь к этому 
                  документу). Она показывает, каким образом приложения могут выставлять биты TOS: 
                  <PRE
CLASS="SCREEN"
>TELNET                   1000           (minimize delay)
FTP
        Control          1000           (minimize delay)
        Data             0100           (maximize throughput)

TFTP                     1000           (minimize delay)

SMTP 
        Command phase    1000           (minimize delay)
        DATA phase       0100           (maximize throughput)

Domain Name Service
        UDP Query        1000           (minimize delay)
        TCP Query        0000
        Zone Transfer    0100           (maximize throughput)

NNTP                     0001           (minimize monetary cost)

ICMP
        Errors           0000
        Requests         0000 (mostly)
        Responses        &lt;same as request&gt; (mostly)                  
                  </PRE
>
                </P
></DD
><DT
>txqueuelen</DT
><DD
><P
>                  Длина этой очереди определяется конфигурацией интерфейса, просмотреть которую можно 
                  командами <B
CLASS="COMMAND"
>ifconfig</B
> и <B
CLASS="COMMAND"
>ip</B
>. Для задания очереди длиной 10, 
                  выполните: <B
CLASS="COMMAND"
>ifconfig eth0 txqueuelen 10</B
>.
                </P
><P
>                  Вы не можете управлять этим параметром при помощи утилиты <B
CLASS="COMMAND"
>tc</B
>.
                </P
></DD
></DL
></DIV
>
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="TOKENBUCKETFILTER"
></A
>9.2.2. Token Bucket Filter</H2
><P
>        Token Bucket Filter (TBF) простая дисциплина очереди, которая передает поступающие пакеты со 
        скоростью не превышающей административно заданный порог, но с возможностью превышающих его 
        коротких всплесков.
      </P
><P
>        TBF очень точная дисциплина, при этом она не создает серьезных нагрузок на сеть и процессор. 
        Если вам нужно просто ограничить скорость на интерфейсе, то это первый кандидат на использование.
      </P
><P
>        Реализована TBF в виде буфера, постоянно заполняющегося токенами с заданой скоростью. 
        Наиболее важным параметром буфера является его размер, определяющий количество хранимых токенов.
      </P
><P
>        Каждый прибывающий токен сопоставляеться с одним пакетом данных из очереди после чего удаляется. 
        Связав этот алгоритм с двумя потоками -- токенов и данных, получим три возможных ситуации:
      <P
></P
><UL
><LI
><P
>            Данные прибывают со скоростью равной скорости входящих токенов. В этом случае каждый пакет 
            имеет соответствующий токен и проходит очередь без задержки. 
          </P
></LI
><LI
><P
>            Данные прибывают со скоростью меньшей скорости поступления токенов. В этом случае лишь часть 
            существующих токенов будет уничтожаться, потому они станут накапливаться до размера буфера. Далее, 
            накопленные токены могут использоваться при всплесках, для передачи данных со скоростью превышающей 
            скорость пребывающих токенов. 
          </P
></LI
><LI
><P
>            Данные прибывают быстрее, чем токены. Это означает, что в буфере скоро не останеться токенов, что 
            заставит дисциплину приостановить передачу данных. Эта ситуация называется 
            <SPAN
CLASS="QUOTE"
>"превышением"</SPAN
>. Если пакеты продолжают поступать, они начинают уничтожаться.
          </P
></LI
></UL
>
       Последняя ситуация очень важна, поскольку позволяет административно ограничивать доступную полосу 
       пропускания. 
      </P
><P
>        Накопленные токены позволяют пропускать короткие всплески, но при продолжительном превышении 
        пакеты будут задерживаться, а в крайнем случае -- уничтожаться.
      </P
><P
>        Учтите, что в реальной реализации дисциплины, токены соответствуют байтам, а не пакетам.
      </P
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN909"
></A
>9.2.2.1. Параметры и использование</H3
><P
>          Не смотря на то, что вам вероятно ничего не придется менять, дисциплина TBF имеет определенные 
          параметры. В первую очередь это: 
          <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>limit или latency</DT
><DD
><P
>                  <TT
CLASS="PARAMETER"
><I
>Limit</I
></TT
> -- это количество байт, которые могут быть помещены в очередь 
                  ожидания токенов. Эту же величину можно задать параметром <TT
CLASS="PARAMETER"
><I
>latency</I
></TT
>, 
                  который определяет максимальный <SPAN
CLASS="QUOTE"
>"возраст"</SPAN
> пакета в очереди TBF.
                  В последнем случае, во внимание принимается размер буфера, скорость и, 
                  если задана, пиковая скорость (<TT
CLASS="PARAMETER"
><I
>peakrate</I
></TT
>).
                </P
></DD
><DT
>burst/buffer/maxburst</DT
><DD
><P
>                  Размер буфера в байтах. Максимальное количество байт, для которых токены могут быть доступны 
                  мгновенно. В целом, чем больше граничная скорость, тем больше должен быть размер буфера. 
                  Например, для ограничения на скорости 10 мбит/с на платформе Intel, вам нужен буфер размером 
                  как минимум 10 Кбайт, чтоб достичь заявленной скорости!
                </P
><P
>                  Если буфер слишком мал, пакеты могут уничтожаться. Это связано с тем, что каждый тик таймера 
                  будет генерироваться больше токенов, чем может поместиться в вашем буфере.
                </P
></DD
><DT
>mpu</DT
><DD
><P
>                  Пакет нулевого размера все равно использует полосу пропускания. В сетях ethernet, любой пакет 
                  имеет размер не менее 64 байт. <TT
CLASS="PARAMETER"
><I
>MPU</I
></TT
> задает минимальное количество токенов 
                  для пакета.
                </P
></DD
><DT
>rate</DT
><DD
><P
>                  Ограничение скорости. 
                </P
></DD
></DL
></DIV
>
          Если буфер заполнен токенами, то поступающие пакеты будут проходить очередь без всяких задержек. 
          Если вас это не устраивает, используйте следующие параметры: 
          <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>peakrate</DT
><DD
><P
>                  Если на момент поступление пакета есть свободные токены, пакет пройдет очередь без каких-либо 
                  задержек. Так сказать, со скоростью света. Возможно, это не совсем то, чего вы хотите, 
                  особенно если вы используете большой буфер. 
                </P
><P
>                  Параметр <TT
CLASS="PARAMETER"
><I
>peakrate</I
></TT
> задает скорость, с которой элемент может проходить 
                  очередь. Согласно теории, это достигается организацией достаточной задержки между 
                  проходящими пакетами. 
                </P
><P
>                </P
></DD
><DT
>mtu/minburst</DT
><DD
><P
>                  Очевидно, что максимальное значение <TT
CLASS="PARAMETER"
><I
>peakrate</I
></TT
>, равное 1 Мбит/сек, 
                  накладывало бы сильное ограничение на область применения этой дисциплины. Однако, задание
                  больших значений <TT
CLASS="PARAMETER"
><I
>peakrate</I
></TT
> возможно. Достигается это за счет прохождения 
                  за один интервал времени более одного пакета данных.
                </P
><P
>                  По умолчанию, значение <TT
CLASS="PARAMETER"
><I
>mtu</I
></TT
> равно одному пакету, т.е. за раз 
                  проходит только один пакет.
                </P
><P
>                  Для расчета максимально возможного значения <TT
CLASS="PARAMETER"
><I
>peakrate</I
></TT
>, умножьте 
                  <TT
CLASS="PARAMETER"
><I
>mtu</I
></TT
> на 100 (или, точнее, на HZ, которое равно 100 для платформы Intel 
                  и 1024 для Alpha)
                </P
></DD
></DL
></DIV
>
        </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN954"
></A
>9.2.2.2. Пример конфигурации</H3
><P
>          Простая, но очень полезная конфигурация: 
          <PRE
CLASS="SCREEN"
># tc qdisc add dev ppp0 root tbf rate 220kbit latency 50ms burst 1540          
          </PRE
>
          Чем же она так замечательна? Если у вас есть сетевое устройство с большой очередью, 
          такое как DSL или кабельный модем, а вы обмениваетесь с ним данными через быстрое соединение, 
          например ethernet, вы обнаружите, что закачки полностью уничтожают возможность интерактивной работы. 
        </P
><P
>          Это связано с тем, что закачки заполняют очередь модема, которая часто очень большая. Большой размер 
          очереди позволяет достичь хороших результатов при передаче больших объемов данных, но ведь это не 
          совсем то, что вам нужно. Вы хотите, чтобы оставалась интерактивность и вы могли бы делать еще что-то 
          полезное во время закачки.
        </P
><P
>          Приведенная команда ограничивает скорость отправки данных так, чтобы очередь в модеме не 
          образовывалась. Таким образом, очередь будет находится в Linux, где мы можем контролировать ее размер.
        </P
><P
>          Замените 220 Кбит на реальную скорость, минус несколько процентов. Если у вас действительно быстрый 
          модем, можете немного увеличить параметр <TT
CLASS="PARAMETER"
><I
>burst</I
></TT
>. 
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="STOCHASTICFAIRNESSQUEUEING"
></A
>9.2.3. Stochastic Fairness Queueing.</H2
><P
>        Stochastic Fairness Queueing (SFQ) -- простая реализация семейства алгоритмов справедливой очередизации. 
        Она не так точна, как другие дисциплины, но требует меньше рассчетов, и при этом поровну распределяет 
        доступную полосу пропускания между сеансами.
      </P
><P
>        Ключевым понятием в SFQ является диалог (или поток), который приблизительно соответствует сеансу TCP или 
        потоку UDP. Трафик делится на достаточное количество очередей типа FIFO, по одной на каждый диалог. После 
        этого, все очереди обрабатываются в циклическом порядке, тем самым обеспечивая каждому сеансу равные 
        шансы на передачу данных.
      </P
><P
>        Благодаря этому достигается очень ровное поведение, которое не позволяет какому-либо диалогу подавлять 
        остальные. SFQ называется "стохастической", т.к. на самом деле для каждого сеанса очередь не формируется, 
        а трафик делится на ограниченое количество очередей на основе хеш-алгоритма.
      </P
><P
>        Из-за использования хеша, несколько сессий могут попасть в одну и ту же очередь, что уменьшает шансы на 
        передачу каждого сеанса. Для того, чтобы эта проблема не ощущалась, SFQ часто меняет алгоритм 
        хеширования, поэтому, если сессии и попадут в одну очередь, длиться это будет лишь несколько секунд.
      </P
><P
>        Стоит заметить, что SFQ эффективен только если исходящий интерфейс полностью загружен! В противном случае 
        очередь будет отсутствовать и, следовательно, никакого положительного эффекта наблюдаться не будет. Позже 
        мы рассмотрим варианты комбинирования SFQ с другими дисциплинами для достижения наилучшего результата.
      </P
><P
>        В частности, применение SFQ на ethernet интерфейсе к которому подключен кабельный модем или DSL 
        маршрутизатор совершенно бессмыслено без органичения полосы пропускания!
      </P
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN970"
></A
>9.2.3.1. Параметры и использование</H3
><P
>          SFQ в значительной степени самоконфигурирующаяся: 
          <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>perturb</DT
><DD
><P
>                  Интервал изменения алгоритма хеширования. Если не задан -- алгоритм меняться не будет, 
                  что не рекомендуется. Хорошим значением является 10 секунд.
                </P
></DD
><DT
>quantum</DT
><DD
><P
>                  Количество байт выводимых из очереди за один раз. По-умолчанию равно 1 пакету максимально 
                  возможного размера (MTU). Не устанавливайте этот параметр меньшим этого значения!
                </P
></DD
><DT
>limit</DT
><DD
><P
>                  Общее количество пакетов, которые могут быть помещены в очередь SFQ (последующие пакеты будут 
                  уничтожаться). 
                </P
></DD
></DL
></DIV
>
        </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN986"
></A
>9.2.3.2. Пример конфигурации</H3
><P
>          Если у вас есть устройство, скорость соединения которого равна доступной полосе пропускания, 
          например модем, следующий пример обеспечит разделение его возможностей между всеми пользователями: 
          <PRE
CLASS="SCREEN"
># tc qdisc add dev ppp0 root sfq perturb 10
# tc -s -d qdisc ls
qdisc sfq 800c: dev ppp0 quantum 1514b limit 128p flows 128/1024 perturb 10sec 
 Sent 4812 bytes 62 pkts (dropped 0, overlimits 0)           
          </PRE
>
          Число 800c: это автоматически присваеваемый дескриптор, параметр <TT
CLASS="PARAMETER"
><I
>limit</I
></TT
> говорит, 
          что в очереди может находиться до 128 пакетов. Доступно 1024 хеш-буфера, из которых 128 может быть 
          активно (максимальное число пакетов в очереди). Каждые 10 секунд хеши будут перенастраиваться.
        </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c834.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>В начало документа</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x991.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Дисциплины обработки очередей для управления пропускной способностью</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c834.html"
ACCESSKEY="U"
>К началу раздела</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Какие типы дисциплин нужно использовать.</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>