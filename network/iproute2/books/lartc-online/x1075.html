<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Классовые дисциплины обработки очередей.</TITLE
><META http-equiv="Content-Type" content="text/html; charset=koi8-r"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Linux Advanced Routing &#38; Traffic Control HOWTO"
HREF="index.html"><LINK
REL="UP"
TITLE="Дисциплины обработки очередей для управления пропускной способностью"
HREF="c834.html"><LINK
REL="PREVIOUS"
TITLE="Терминология"
HREF="x1013.html"><LINK
REL="NEXT"
TITLE="Классификация пакетов с помощью фильтров."
HREF="x1308.html"><style type="text/css"> p {text-align:justify;} </style></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Advanced Routing &#38; Traffic Control HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1013.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Глава 9. Дисциплины обработки очередей для управления пропускной способностью</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1308.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="CLASSFULQUEUEINGDISCIPLINES"
></A
>9.5. Классовые дисциплины обработки очередей.</H1
><P
>      Классовые дисциплины широко используются в случаях, когда тот или иной вид трафика необходимо
      обрабатывать по разному. Примером классовой дисциплины может служить 
      <B
CLASS="COMMAND"
>CBQ</B
> -- Class Based Queueing (дисциплина обработки очередей на основе классов).
      Она настолько широко известна, что многие идентифицируют понятие "Дисциплина Обработки Очередей"
      с названием <B
CLASS="COMMAND"
>CBQ</B
>, однако это далеко не так.
    </P
><P
>      <B
CLASS="COMMAND"
>CBQ</B
> -- один из старейших алгоритмов и кроме того -- один из самых сложных.
      К сожалению он может далеко не все. Это может оказаться неожиданностью для тех, кто свято верит в то,
      что если какая-либо достаточно сложная технология распространяется без документации, то
      это лучшая технология из имеющихся вариантов.
    </P
><P
>      Чуть ниже мы поближе рассмотрим CBQ и его альтернативы.
    </P
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="FLOWWITHINCLASSFULQDISCSCLASSES"
></A
>9.5.1. Порядок движения пакетов внутри полноклассовых дисциплин и классов.</H2
><P
>        Когда трафик передается на обработку классовой дисциплине, он должен быть отнесен к одному из 
        классов (классифицирован). Определение принадлежности пакета к тому или иному классу выполняется 
        фильтрами. Очень важно понимать, что именно фильтры вызываются из дисциплины, а не наоборот!
      </P
><P
>        Фильтры, присоединенные к дисциплине, возвращают результат классификации (грубо говоря -- класс пакета),
        после чего пакет передается в очередь, соответствующую заданному классу. Каждый из классов, в свою 
        очередь, может состоять из подклассов и иметь свой набор фильтров, для выполнения более точной 
        классификации свой доли трафика. В противном случае пакет обслуживается дисциплиной очереди класса.
      </P
><P
>        Кроме того, в большинстве случаев классовые дисциплины выполняют шейпинг (формирование) трафика, с 
        целью переупорядочивания пакетов (например, с помощью SFQ) и управления скоростью их передачи. Это 
        определенно необходимо в случае перенаправления трафика с высокоскоростного интерфейса (например, 
        ethernet) на медленный (например, модем).
      </P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="THEQDISCFAMILYROOTSHANDLESSIBLINGSANDPARENTS"
></A
>9.5.2. Элементы дисциплины: корень, дескриптор, родительские элементы и элементы одного уровня.</H2
><P
>        Каждый из интерфейсов имеет одну исходящую корневую дисциплину. По-умолчанию это, упоминавшаяся ранее
        дисциплина -- pfifo_fast. Каждой дисциплине и каждому классу назначается уникальный дескриптор, который
        который может использоваться последующими инструкциями для ссылки на эти дисциплины и классы. Помимо 
        исходящей дисциплины, интерфейс так же может иметь и входящую дисциплину, которая производит управление
        входящим трафиком.
      </P
><P
>        Дескрипторы дисциплин состоят из двух частей -- старшего и младшего номеров, в виде: &lt;старший&#62;:&lt;младший&#62;.
        Корневой дисциплине общепринято присваивать дескриптор  '1:', что эквивалентно записи '1:0'. Младший 
        номер в дескрипторе любой дисциплины всегда '0'.
      </P
><P
>        Старшие номера дескрипторов классов всегда дублируют старший номер дескриптора своего "родителя".
        Старший номер должен быть уникальным в пределах блоков настроек для входящего и исходящего трафиков.
        Младший номер должен быть уникальным в пределах дисциплины и ее классов.
      </P
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="HOWFILTERSAREUSEDTOCLASSIFYTRAFFIC"
></A
>9.5.2.1. Как выполняется классификация с помощью фильтров.</H3
><P
>          Типичная иерархия может выглядеть следующим образом:
          <PRE
CLASS="SCREEN"
>                      1:   корневая дисциплина
                      |
                     1:1    дочерний класс
                   /  |  \
                  /   |   \
                 /    |    \
                 /    |    \
              1:10  1:11  1:12   дочерние классы
               |      |     | 
               |     11:    |    краевой класс
               |            | 
               10:         12:   дисциплины
              /   \       /   \
           10:1  10:2   12:1  12:2   краевые классы
          </PRE
>
          Не дайте ввести себя в заблуждение! Вы не должны полагать, что ядро находится на вершине диаграммы, а 
          сеть под ней! Пакеты ставятся в очередь и извлекаются из очереди корневой дисциплиной, она единственная,
          с которой работает ядро.
        </P
><P
>          Порядок классификации некоторого пакета может быть представлен в виде цепочки, например:
        </P
><P
>          1: -&#62; 1:1 -&#62; 1:12 -&#62; 12: -&#62; 12:2
        </P
><P
>          Таким образом, пакет помещается в очередь, которая управляется дисциплиной, присоединенной к классу 
          12:2. В данном примере, к каждому узлу дерева присоединен фильтр, который принимает решение -- по какой 
          ветви продолжить классификацию пакета. Но возможен и другой вариант:
        </P
><P
>          1: -&#62; 12:2
        </P
><P
>          В этом случае, фильтр, присоединенный к корню, сразу же классифицировал пакет, как принадлежащий
          классу 12:2. 
        </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="HOWPACKETSAREDEQUEUEDTOTHEHARDWARE"
></A
>9.5.2.2. Как выполняется извлечение пакетов из очереди.</H3
><P
>          Когда ядро решает, что пора извлечь очередной пакет из очереди и передать его сетевому интерфейсу, оно
          посылает запрос на извлечение корневой дисциплине. Далее этот запрос передается по цепочке классу 1:1,
          а от него всем элементам одного уровня -- 10:, 11:, и 12:. В данном случае запрос полностью 
          обходит все дерево, поскольку только класс 12:2 имеет пакет.
        </P
><P
>          Проще говоря, вложенные классы "общаются" ТОЛЬКО со своими "родительскими" дисциплинами и никогда не 
          работают напрямую с интерфейсом. Только корневая дисциплина получает запрос на извлечение пакета из 
          очереди напрямую от ядра!
        </P
><P
>          В результате, классы никода не получат запрос на извлечение раньше, чем это будет сделано их 
          "родителями". А это как раз и есть то, что нам нужно: мы можем определить внутренний класс,
          который выполняет только планирование и дисциплину, которая отвечает за шейпинг.
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="THEPRIOQDISC"
></A
>9.5.3. Дисциплина PRIO.</H2
><P
>          Дисциплина PRIO фактически никак не ограничивает трафик, она лишь выполняет его классификацию на основе
          присоединенных к ней фильтров. Вы можете рассматривать дисциплину PRIO как более мощную версию
          pfifo_fast, в которой каждая из полос является отдельным классом, а не простой очередью FIFO.
        </P
><P
>          Постановка пакета в очередь выполняется дисциплиной PRIO на основе фильтров, заданных вами. По-умолчанию
          создаются три класса. Эти классы по-умолчанию содержат обычные дисциплины FIFO, но они могут быть
          заменены дисциплинами любого типа, какие вам только доступны.
        </P
><P
>          Когда необходимо извлечь пакет из очереди, то первым проверяется класс :1. Каждый последующий класс 
          проверяется только в том случае, если в предыдущем нет ни одного пакета.
        </P
><P
>          Эта дисциплина может с успехом применяться в тех случаях, когда необходимо "раскидать" трафик по 
          приоритетам, основываясь не только на флагах TOS. Вы можете так же добавить другие дисциплины
          к предопределенным классам, что повысит возможности управления трафиком, по сравнению с pfifo_fast.
        </P
><P
>          Поскольку данная дисциплина не имеет возможности шейпинга трафика, считаю своим долгом предупредить
          вас: используйте эту дисциплину только в том случае, если она полностью соответствует вашим требованиям,
          либо присоединяйте ее к классовым дисциплинам, которые могут выполнять шейпинг. Последнее замечание
          относится к владельцам кабельных модемов или DSL устройств.
        </P
><P
>          Формально, дисциплина PRIO относится к разряду планировщиков типа Work-Conserving.
        </P
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="PRIOPARAMETERSUSAGE"
></A
>9.5.3.1. Параметры и порядок использования дисциплины PRIO.</H3
><P
>          Применительно к данной дисциплине, утилита <B
CLASS="COMMAND"
>tc</B
> допускает следующие параметры:
  <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>bands</DT
><DD
><P
>          Число создаваемых полос. Каждая полоса фактически является классом. Если вы изменяете это число,
          то вы должны так же изменить и следующий параметр.
        </P
></DD
><DT
>priomap</DT
><DD
><P
>          Если ваша конфигурация не предусматривает наличие фильтров, выполняющих классификацию трафика, 
          то дисциплина PRIO присваивает приоритеты по-умолчанию.
        </P
><P
>          Все это работает точно так же, как и в случае с pfifo_fast.
        </P
></DD
></DL
></DIV
>
          Каждая полоса является классом и имеет свой дескриптор, начиная с  &lt;старший_номер&#62;:1 и заканчивая
          &lt;старший_номер&#62;:3, по-умолчанию. Таким образом, если дисциплине PRIO присвоен дескриптор
          12: , то класс-полоса с наивысшим приоритетом получит дескриптор 12:1.
        </P
><P
>          Повторюсь еще раз, полоса 0 получит младший номер дескриптора -- 1! Полоса 1 -- 2 и так далее.
        </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="SAMPLECONFIGURATION"
></A
>9.5.3.2. Пример конфигурации.</H3
><P
>          В качестве примера создадим такое дерево:
          <PRE
CLASS="SCREEN"
>             1:   корневая дисциплина
           / | \ 
          /  |  \
         /   |   \
       1:1  1:2  1:3    классы
        |    |    |
       10:  20:  30:    дисциплины
       sfq  tbf  sfq
полоса  0    1    2
          </PRE
>
          Объемный трафик будет обслуживаться дисциплиной 30: , интерактивный -- 20: или 10:.
        </P
><P
>          Конфигурирование:
          <PRE
CLASS="SCREEN"
># tc qdisc add dev eth0 root handle 1: prio 
## Эта команда создаст классы 1:1, 1:2, 1:3
  
# tc qdisc add dev eth0 parent 1:1 handle 10: sfq
# tc qdisc add dev eth0 parent 1:2 handle 20: tbf rate 20kbit buffer 1600 limit 3000
# tc qdisc add dev eth0 parent 1:3 handle 30: sfq     
          </PRE
>
          Теперь посмотрим -- что у нас получилось:
          <PRE
CLASS="SCREEN"
># tc -s qdisc ls dev eth0 
qdisc sfq 30: quantum 1514b 
 Sent 0 bytes 0 pkts (dropped 0, overlimits 0) 

 qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms 
 Sent 0 bytes 0 pkts (dropped 0, overlimits 0) 

 qdisc sfq 10: quantum 1514b 
 Sent 132 bytes 2 pkts (dropped 0, overlimits 0) 

 qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
 Sent 174 bytes 3 pkts (dropped 0, overlimits 0) 
          </PRE
>
          Как видите, через полосу 0 уже "проскочил" какой-то трафик, пока отрабатывали наши команды!
        </P
><P
>          Теперь выполним передачу достаточно большого объема данных неким инструментом, который корректным 
          образом устанавливает флаги TOS и проверим еще раз:
          <PRE
CLASS="SCREEN"
># scp tc ahu@10.0.0.11:./
ahu@10.0.0.11's password: 
tc                   100% |*****************************|   353 KB    00:00    
# tc -s qdisc ls dev eth0
qdisc sfq 30: quantum 1514b 
 Sent 384228 bytes 274 pkts (dropped 0, overlimits 0) 

 qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms 
 Sent 2640 bytes 20 pkts (dropped 0, overlimits 0) 

 qdisc sfq 10: quantum 1514b 
 Sent 2230 bytes 31 pkts (dropped 0, overlimits 0) 

 qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
 Sent 389140 bytes 326 pkts (dropped 0, overlimits 0) 
          </PRE
>
          На этот раз видно, что весь трафик был отправлен через дисциплину 30:, которая в нашем случае имеет 
          наименьший приоритет. Чтобы убедиться в том, что интерактивный трафик поступает в высокоприоритетные 
          полосы, выполним следующую команду:
          <PRE
CLASS="SCREEN"
># tc -s qdisc ls dev eth0
qdisc sfq 30: quantum 1514b 
 Sent 384228 bytes 274 pkts (dropped 0, overlimits 0) 

 qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms 
 Sent 2640 bytes 20 pkts (dropped 0, overlimits 0) 

 qdisc sfq 10: quantum 1514b 
 Sent 14926 bytes 193 pkts (dropped 0, overlimits 0) 

 qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
 Sent 401836 bytes 488 pkts (dropped 0, overlimits 0) 
          </PRE
>
          Как видите, все работает правильно, весь трафик был отправлен в 10: -- через самую высокоприоритетную 
          дисциплину.
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="THEFAMOUSCBQQDISC"
></A
>9.5.4. Дисциплина CBQ.</H2
><P
>          Как уже упоминалось ранее, CBQ -- одна из самых сложных дисциплин. Пожалуй я не погрешу против истины, 
          если заявлю, что это самая объемная, самая непонятная и самая запутанная дисциплина организации 
          очередей. Это не потому, что авторы алгоритма некомпетентны, а потому, что идеология этого алгоритма
          абсолютно не совпадает с идеологией Linux.
        </P
><P
>          Кроме того, что эта дисциплина является классовой, она так же может выполнять и шейпинг трафика,
          правда именно эта ее сторона является самым слабым местом. Если вы попробуете ограничить 10 мегабитный 
          канал величиной в 1 мегабит, то окажется, что соединение будет просто простаивать 90% всего времени.
          Вместо определения объема трафика, CBQ измеряет время в микросекундах между запросами и на основе 
          полученного времени рассчитывается средняя загруженность канала.
        </P
><P
>          Такой алгоритм работы не всегда дает нужные результаты. Например, что если сетевой интерфейс не может
          обеспечить полную загрузку канала на всю его возможную ширину, из-за некачественного драйвера? Как тогда
          правильно определить время простоя?
        </P
><P
>          Проблема становится еще острее, если вам приходится иметь дело с такими вещами, как
          PPP через Ethernet или PPTP через TCP/IP. Эффективная пропускная способность в данном случае может быть 
          определена как пропускная способность канала в пространство пользователя, а это величина очень не 
          маленькая.
        </P
><P
>          Те, кто близко сталкивался с CBQ отмечают, что эта дисциплина не всегда точна, и иногда допускает
          грубые просчеты при измерении времени.
        </P
><P
>          Однако, в других случаях она показывает неплохие результаты. Прочитав этот документ, вы сможете
          сконфигурировать эту дисциплину и получить неплохие результаты в случае отказа от шейпинга.
        </P
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="CBQSHAPINGINDETAIL"
></A
>9.5.4.1. Шейпинг в CBQ.</H3
><P
>            Как уже говорилось выше, ограничение пропускной способности в CBQ выполняется за счет определения 
            промежутка времени между прохождением соседних пакетов среднего размера.
          </P
><P
>            В процессе работы измеряется эффективное время простоя, как экспоненциальное взвешенное среднее по 
            скользящему окну. Кстати, UNIX рассчитывает величину loadaverage (средняя величина нагрузки) 
            аналогичным способом.
          </P
><P
>            Расчетное время простоя вычитается из взвешенного среднего, в результате получается величина
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
>. Полностью загруженный канал имеет величину <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> 
            равную нулю -- промежуток времени между пакетами точно совпадает с расчетным. В случае превышения 
            заданного ограничения, величина <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> становится отрицательной. Если 
            превышение достигает некоторого порога, CBQ приостанавливает передачу.
          </P
><P
>            С другой стороны, после нескольких часов простоя, величина <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> может 
            получиться слишком большой и это приведет к тому, что канал "распахнется" на всю ширину. Чтобы этого
            не происходило, величина <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> ограничивается числом 
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>maxidle</I
></SPAN
>.
          </P
><P
>            В случае перегрузки, теоретически, алгоритм CBQ должен приостанавить передачу на вычисленный 
            временной интервал, потом передать следующую порцию данных и снова остановиться. Но в реализации 
            алгоритма есть свои нюансы, смотрите ниже описание параметра <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>minburst</I
></SPAN
>.
          </P
><P
>            Рассмотрим параметры дисциплины CBQ, позволяющие настроить ограничение полосы пропускания:
  <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>avpkt</DT
><DD
><P
>          Усредненный размер одного пакета. Совместно с величиной <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>maxburst</I
></SPAN
> (которая 
          измеряется в пакетах) используется для вычисления значения <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>maxidle</I
></SPAN
>.
        </P
></DD
><DT
>bandwidth</DT
><DD
><P
>          Физическая пропускная способность устройства. Необходима для вычисления времени простоя.
        </P
></DD
><DT
>cell</DT
><DD
><P
>          Время, необходимое на передачу пакета через интерфейс может увеличиваться с определенным шагом. 
          Например, передача пакетов с размерами 800 и 806 байт займет одно и тоже время, а пакетов с размерами 
          810 байт -- немного больше. Данный параметр задает размер шага, с которым увеличивается расчетное время 
          передачи. Чаще всего устанавливается значение '8'. Значение должно быть степенью числа 2.
        </P
></DD
><DT
>maxburst</DT
><DD
><P
>          Параметр используется для вычисления значения <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>maxidle</I
></SPAN
>. Он задает количество 
          усредненных пакетов, которые будут обработаны до того, как значение <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> станет 
          равным нулю. Параметр <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>maxidle</I
></SPAN
> нельзя задать напрямую, только косвенно, с помощью 
          этого параметра.
        </P
></DD
><DT
>minburst</DT
><DD
><P
>          Как я уже говорил, в случае перегрузки, CBQ должна прекратить передачу данных. Идеальным решением 
          является ожидание в течение расчетного промежутка времени, после этого передать один пакет и снова 
          приостановить передачу. Однако, в Unix существует определенные сложности с измерением интервалов 
          времен, короче 10 мс, потому лучше увеличить промежуток ожидания, после которого можно будет 
          выполнить передачу уже не одного, а несколько пакетов, количество которых определяется параметром 
          <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>minburst</I
></SPAN
>. Соответственно, промежуток ожидания между передачей пакетов 
          увеличивается пропорционально значению данного параметра.
        </P
><P
>          Промежуток времени между передачей пакетов называется <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>offtime</I
></SPAN
>. Большие значения 
          параметра <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>minburst</I
></SPAN
> позволяют более точно ограничить полосу пропускания на 
          длительных временных интервалах, но на коротких интервалах трафик будет вести себя скачкообразно.
        </P
></DD
><DT
>minidle</DT
><DD
><P
>          Отрицательное значение <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> указывает, что канал перегружен, и нужно прекратить 
          передачу на время, пока <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> не увеличится достаточно для передачи следующего 
          пакета. Однако, это может вызвать длительные периоды ожидания после интенсивных всплесков трафика. В 
          таких случаях <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> присваивается значение параметра 
          <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>minidle</I
></SPAN
>.
        </P
><P
>          Величина <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>minidle</I
></SPAN
> измеряется в отрицательных микросекундах, следовательно значение 
          "10" говорит о том, что параметр <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>avgidle</I
></SPAN
> не может опуститься ниже -10 микросекунд.
        </P
></DD
><DT
>mpu</DT
><DD
><P
>          Минимальный размер пакета -- необходим, поскольку даже "пустой" пакет дополняется до 64 байт для 
          передачи по сети ethernet, и передача такого пакета занимает определенное время. Алгоритм CBQ должен 
          знать минимальный размер, чтобы правильно рассчитать время простоя.
        </P
></DD
><DT
>rate</DT
><DD
><P
>          Желаемая величина пропускной способности. Для данной дисциплины -- это "педаль газа"!
        </P
></DD
></DL
></DIV
>
            Внутрення реализация CBQ имеет ряд дополнительных настроек. Например, классы, в очередях которых нет
            данных, не опрашиваются. Для классов, допустивших перегрузку, понижается значение эффективного 
            приоритета. В принципе все достаточно грамотно, хотя и очень сложно.
          </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="CBQCLASSFULBEHAVIOUR"
></A
>9.5.4.2. Характеристики классов в CBQ.</H3
><P
>            Кроме ограничения полосы пропускания, CBQ имеет возможность классифицировать трафик, подобно 
            дисциплине PRIO, и назначать классам приоритеты.
          </P
><P
>            Каждый раз, когда нужно передать пакет, запускается процесс взвешенной циклической выборки (WRR) из 
            очередей, начиная с высокоприоритетных классов. Классы группируются по приоритетам, затем, после 
            выборки определенного количества данных из одного класса, выполняется попытка получить данные из 
            другого класса с тем же приоритетом.
          </P
><P
>            Следующие параметры позволяют управлять процессом выборки данных:
  <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>allot</DT
><DD
><P
>          Когда производится выбор пакета для передачи, CBQ начинает опрашивать свои подклассы в соответствии с 
          их приоритетами. Когда классу предоставляется возможность передачи, выбирается определенный объем 
          данных. Базовая единица этого объема определяется параметром <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>allot</I
></SPAN
>.
        </P
></DD
><DT
>prio</DT
><DD
><P
>          Приоритет. Дисциплина CBQ может присваивать классам приоритеты. Чем меньше значение -- тем выше 
          приоритет. Пока не будет обработан трафик с высшим приоритетом, трафик с меньшим приоритетом не 
          обрабатывается.
        </P
></DD
><DT
>weight</DT
><DD
><P
>          Вес. Каждому из имеющихся классов предоставляется возможность передать данные. Если у вас есть классы, 
          которые значительно отличаются полосой пропускания, имеет смысл разрешить классам с большой пропускной 
          способностью посылать за раз больше данных, чем классам с небольшой пропускной способностью
        </P
><P
>          Дисциплина CBQ вычисляет сумму весов всех классов и затем нормирует их полученной величиной, потэому, 
          в качестве весов, можно использовать любые значения: важно отношение этих значений. Обычно используется 
          простое правило: вес = полоса пропускания / 10. Для определения количества данных, посылаемых классом 
          за раз, нормированное значение умножается на величину <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>allot</I
></SPAN
>.
        </P
></DD
></DL
></DIV
>
            Обратите внимание: все внутренние классы дисциплины должны иметь одинаковый старший номер
            дескриптора!
          </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="CBQPARAMETERSTHATDETERMINELINKSHARINGBORROWI"
></A
>9.5.4.3. Параметры CBQ, управляющие характером заимствования.</H3
><P
>            Кроме простого ограничения полосы пропускания для определенных типов трафика, можно давать 
            возможность классам занимать часть полосы пропускания у других классов.
  <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Isolated/sharing</DT
><DD
><P
>          У класса, созданного с параметром <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>isolated</I
></SPAN
>, нельзя занимать полосу пропускания. 
          То есть другие классы, настроенные на заем доступной полосы пропускания никогда не смогут занять полосу 
          этого класса, даже если она будет свободной.
        </P
><P
>          Наоборот, класс созданный с параметром <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>sharing</I
></SPAN
> будет предоставлять неиспользуемую
          часть своей пропускной способности другим классам.
        </P
></DD
><DT
>bounded/borrow</DT
><DD
><P
>          Эти два параметра определяют, может ли класс занимать пропускающую способность других классов. Параметр 
          <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>bounded</I
></SPAN
> запрещает, а <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>borrow</I
></SPAN
> разрешает занимать неиспользуемую
          часть полосы пропускания классов, сконфигурированных с параметром <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>sharing</I
></SPAN
>.
        </P
></DD
></DL
></DIV
>
            Примером, когда используются классы с параметрами <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>bounded</I
></SPAN
> и 
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>isolated</I
></SPAN
>, может послужить ситуация использования одного канала двумя 
            организациями. В этом случае они действительно будут ограничены заданной полосой пропускания.
          </P
><P
>            Внутри каждого такого класса могут находиться подклассы с опциями <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>sharing</I
></SPAN
> и 
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>borrow</I
></SPAN
>. В этой ситуации заем будет выполняться в пределах родительского класса.
          </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN1256"
></A
>9.5.4.4. Пример конфигурирования.</H3
><P
>            <PRE
CLASS="SCREEN"
>               1:           корневая дисциплина
               |
              1:1           дочерний класс
             /   \
            /     \
          1:3     1:4       краевые классы
           |       |
          30:     40:       дисциплины
         (sfq)   (sfq)
            </PRE
>
            Рассмотрим реализацию следующего сценария. Необходимо ограничить полосу пропускания веб-трафика до 5 
            мегабит, а SMTP -- до 3 мегабит. Суммарная полоса пропускания не должна превышать 6 мегабит. На 
            сервере стоит 100-мегабитная сетевая карта, классы могут занимать пропускную способность друг у друга.
            <PRE
CLASS="SCREEN"
># tc qdisc add dev eth0 root handle 1:0 cbq bandwidth 100Mbit         \
  avpkt 1000 cell 8
# tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 100Mbit  \
  rate 6Mbit weight 0.6Mbit prio 8 allot 1514 cell 8 maxburst 20      \
  avpkt 1000 bounded
            </PRE
>
            В этой части устанавливается корневая дисциплина и класс 1:1, пропускная способность которого 
            ограничена величиной в 6 мегабит.
          </P
><P
>            Как видите, CBQ требует много больше настроек по сравнению с HTB.
            <PRE
CLASS="SCREEN"
># tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 100Mbit  \
  rate 5Mbit weight 0.5Mbit prio 5 allot 1514 cell 8 maxburst 20      \
  avpkt 1000                       
# tc class add dev eth0 parent 1:1 classid 1:4 cbq bandwidth 100Mbit  \
  rate 3Mbit weight 0.3Mbit prio 5 allot 1514 cell 8 maxburst 20      \
  avpkt 1000
            </PRE
>
            Здесь создаются два класса, управляющие веб и почтовым трафиками. Обратите внимание на то, как 
            указаны веса классов. Пропускная способность классов не ограничивается, но они подчинены классу 1:1,
            который имеет ограничение по полосе пропускания. Таким образом, сумма пропускных способностей этих 
            классов не сможет превысить ограничение родительского класса. Старшие номера дескрипторов дочерних 
            классов (classid) наследуют старший номер родительского класса.
            <PRE
CLASS="SCREEN"
># tc qdisc add dev eth0 parent 1:3 handle 30: sfq
# tc qdisc add dev eth0 parent 1:4 handle 40: sfq
            </PRE
>
            При создании, к каждому из классов, по-умолчанию  присоединяется дисциплина FIFO, однако, для более 
            равномерного распределения пропускной способности между соединениями, присоединим к каждому 
            из классов дисциплину обработки очереди SFQ.
            <PRE
CLASS="SCREEN"
># tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
  sport 80 0xffff flowid 1:3
# tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
  sport 25 0xffff flowid 1:4
            </PRE
>
            В заключение, трафик классифицируется с помощью фильтров и направляется в нужные классы.
          </P
><P
>            Обратите внимание: команда <B
CLASS="COMMAND"
>tc class add</B
> СОЗДАЕТ класс в пределах дисциплины, а 
            <B
CLASS="COMMAND"
>tc qdisc add</B
> -- добавляет дисциплину к классу.
          </P
><P
>            У вас может возникнуть резонный вопрос: "Что будет с трафиком, который не подпадает под условия
            установленных фильтров?". В этом случае трафик останется неклассифицированым и будет обработан 
            корневой дисциплиной 1:0, т.е. пройдет без ограничений.
          </P
><P
>            Если сумма SMTP+web трафиков превысят сконфигурированные 6 мегабит, то вся полоса пропускания будет 
            разделена между классами, в соответствии с их весами. Таким образом WEB-сервер получит 5/8 ширины 
            канала, а SMTP-сервер -- 3/8.
          </P
><P
>            В соответствии с данной конфигурацией можно утверждать, что WEB-сервер всегда будет иметь полосу, как 
            минимум 5/8*6=3.75 мегабита.
          </P
></DIV
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN1271"
></A
>9.5.4.5. Прочие параметры настройки CBQ: split и defmap.</H3
><P
>          Как уже говорилось выше, для классификации трафика, полноклассовые дисциплины используют фильтры.
        </P
><P
>          Но кроме фильтров, CBQ может предложить вам параметры split и defmap. Хотя назначение этих параметров 
          достаточно сложно понять, и к тому же они не являются жизненно необходимыми, тем не менее я постараюсь
          описать их.
        </P
><P
>          Так как наиболее часто классификация трафика производится только на основе поля TOS, в заголовке пакета,
          то предусматривается специальный синтаксис команд. Каждый раз, когда CBQ сталкивается с необходимостью
          определения -- в какую из очередей поставить пакет, она проверяет -- является ли этот узел "узлом 
          разбиения" и если это так, то выбирается подочередь с заданным приоритетом, который может быть 
          рассчитан исходя из значения поля TOS.
        </P
><P
>          Значение приоритета пакета складывается по "И" с параметром <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>defmap</I
></SPAN
> и проверяется --
          есть ли совпадение.  Проще говоря -- это самый простой способ создания высокоскоростных фильтров, 
          которые работают с незначительным числом приоритетов. С параметром <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>defmap</I
></SPAN
>, равным
          0xFF будет совпадать любой пакет, 0x00 -- ни один. Возможно пример настройки поможет вам полнее понять
          вышесказанное:
          <PRE
CLASS="SCREEN"
># tc qdisc add dev eth1 root handle 1: cbq bandwidth 10Mbit allot 1514 \
  cell 8 avpkt 1000 mpu 64
 
# tc class add dev eth1 parent 1:0 classid 1:1 cbq bandwidth 10Mbit    \
  rate 10Mbit allot 1514 cell 8 weight 1Mbit prio 8 maxburst 20        \
  avpkt 1000
          </PRE
>
          Самое обычное начало для CBQ. Значения для параметра <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>defmap</I
></SPAN
> можно
          определить из следующей таблицы:
          <PRE
CLASS="SCREEN"
>TC_PRIO..        Число  Значение поля TOS
-------------------------------------------------
BESTEFFORT         0    Maximize Reliablity (0x04) (Максисальная надежность)
FILLER             1    Minimize Cost (0x02)       (Минимальная стоимость)
BULK               2    Maximize Throughput (0x08) (Максимальная пропускная способность) 
INTERACTIVE_BULK   4                               
INTERACTIVE        6    Minimize Delay (0x10)      (Минимальная задержка)
CONTROL            7                               
          </PRE
>
          Уровень приоритета TC_PRIO.. рассчитывается исходя из значения поля TOS (за дополнительной информацией 
          о значениях приоритета пакета, обращайтесь к разделу <A
HREF="x852.html#PFIFO_FAST"
>pfifo_fast</A
>).
        </P
><P
>          Теперь создадим классы, через которые пойдет интерактивный и объемный трафик:
          <PRE
CLASS="SCREEN"
># tc class add dev eth1 parent 1:1 classid 1:2 cbq bandwidth 10Mbit     \
  rate 1Mbit allot 1514 cell 8 weight 100Kbit prio 3 maxburst 20        \
  avpkt 1000 split 1:0 defmap c0

# tc class add dev eth1 parent 1:1 classid 1:3 cbq bandwidth 10Mbit     \
  rate 8Mbit allot 1514 cell 8 weight 800Kbit prio 7 maxburst 20        \
  avpkt 1000 split 1:0 defmap 3f
          </PRE
>
          В данном случае "узлом разбиения" назначается дисциплина 1:0, это та точка, где будет делаться выбор.
          Число 0xC0 в двоичном представлении имеет вид 11000000, а 0x3F -- 00111111, таким образом оба класса 
          перекрывают весь диапазон возможных приоритетов. Первому классу будут соответствовать пакеты, приоритеты
          которых имеют 6 и/или 7 биты в установленном состоянии, что соответствует интерактивному и управляющему 
          трафику. Ко второму классу будут отнесены все остальные пакеты.
        </P
><P
>          Таблица выбора для узла 1:0 теперь будет иметь следующий вид:
          <PRE
CLASS="SCREEN"
>приоритет	класс
0		      1:3
1		      1:3
2		      1:3
3		      1:3
4		      1:3
5		      1:3
6		      1:2
7		      1:2
          </PRE
>
          Кроме того, можно изменять приоритеты отдельных видов трафика. Для этого используется команда вида:
          <B
CLASS="COMMAND"
>tc class change</B
>, например, чтобы повысить приоритет трафика best effort и 
          классифицировать его, как принадлежащий классу 1:2, нужно дать следующую команду:
          <PRE
CLASS="SCREEN"
># tc class change dev eth1 classid 1:2 cbq defmap 01/01
          </PRE
>
          В этом случае, таблица выбора будет иметь следующий вид:
          <PRE
CLASS="SCREEN"
>приоритет	класс
0		      1:2
1		      1:3
2		      1:3
3		      1:3
4		      1:3
5		      1:3
6		      1:2
7		      1:2
          </PRE
>
          FIXME: Корректность работы команды <B
CLASS="COMMAND"
>tc class change</B
> не проверена. Выводы были сделаны 
          исключительно на основе изучения исходных текстов.
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="HIERARCHICALTOKENBUCKET"
></A
>9.5.5. Hierarchical Token Bucket</H2
><P
>        Мартин Девера (Martin Devera) aka &lt;devik&#62; справедливо отмечает, что CBQ слишком сложна и слабо 
        оптимизирована для большинства типичных ситуаций. Его подход более точно соответствует конфигурациям,
        когда необходимо распределить заданную полосу пропускания между различными видами трафика на полосы 
        гарантированной ширины, с возможностью заимствования.
      </P
><P
>        HTB работает точно так же, как и CBQ, но, в отличие от последней, принцип работы основан не на вычислении
        времени простоя, а на определении объема трафика, что полностью соответствует названию Token Bucket 
        Filter. Эта дисциплина имеет незначительное число параметров настройки, которые достаточно хорошо описаны
        на сайте <A
HREF="http://luxik.cdi.cz/~devik/qos/htb/"
TARGET="_top"
>http://luxik.cdi.cz/~devik/qos/htb/</A
>.
      </P
><P
>        Хотя конфигурирование HTB -- задача достаточно сложная, тем не менее конфигурации хорошо масштабируются. 
        В случае же с CBQ процесс конфигурирования становится слишком сложным даже в самых простых случаях! 
        HTB3 теперь стала частью ядра (начиная с версий 2.4.20-pre1 и 2.5.31). Однако, вам может потребоваться
        пропатченная версия утилиты <B
CLASS="COMMAND"
>tc</B
>: старший номер версии HTB в ядре и пользовательских 
        утилит должны совпадать, в противном случае <B
CLASS="COMMAND"
>tc</B
> откажется работать с HTB.
      </P
><P
>        Если у вас установлено достаточно свежее или пропатченное ядро, вам определенно стоит посмотреть в 
        сторону HTB!
      </P
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN1300"
></A
>9.5.5.1. Пример конфигурации.</H3
><P
>        Конфигурация практически идентична вышеприведенному примеру:
        <PRE
CLASS="SCREEN"
># tc qdisc add dev eth0 root handle 1: htb default 30

# tc class add dev eth0 parent 1: classid 1:1 htb rate 6mbit burst 15k

# tc class add dev eth0 parent 1:1 classid 1:10 htb rate 5mbit burst 15k
# tc class add dev eth0 parent 1:1 classid 1:20 htb rate 3mbit ceil 6mbit burst 15k
# tc class add dev eth0 parent 1:1 classid 1:30 htb rate 1kbit ceil 6mbit burst 15k
        </PRE
>
        Автор рекомендует устанавливать дисциплину SFQ для этих классов:
        <PRE
CLASS="SCREEN"
># tc qdisc add dev eth0 parent 1:10 handle 10: sfq perturb 10
# tc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10
# tc qdisc add dev eth0 parent 1:30 handle 30: sfq perturb 10
        </PRE
>
        Добавим фильтры, которые будут выполнять классификацию трафика:
        <PRE
CLASS="SCREEN"
># U32="tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32"
# $U32 match ip dport 80 0xffff flowid 1:10
# $U32 match ip sport 25 0xffff flowid 1:20
        </PRE
>
        В результате получаем ясную и понятную конфигурацию -- никаких малопонятных чисел, никаких 
        недокументированных параметров.
      </P
><P
>        В HTB все выглядит достаточно прозрачно -- классы 10: и 20: имеют гарантированную пропускную способность, 
        при наличии свободной части пропускной способности они заимствуют ее в отношении 5:3.
      </P
><P
>        Неклассифицированый трафик будет отнесен к классу 30:, который имет достаточно небольшую ширину, но может 
        заимствовать незанятую часть канала.
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1013.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>В начало документа</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1308.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Терминология</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c834.html"
ACCESSKEY="U"
>К началу раздела</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Классификация пакетов с помощью фильтров.</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>