<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Random Early Detection (RED)</TITLE
><META http-equiv="Content-Type" content="text/html; charset=koi8-r"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Linux Advanced Routing &#38; Traffic Control HOWTO"
HREF="index.html"><LINK
REL="UP"
TITLE="Специализированные дисциплины управления очередями."
HREF="c2289.html"><LINK
REL="PREVIOUS"
TITLE="Ingress qdisc."
HREF="x2425.html"><LINK
REL="NEXT"
TITLE="Generic Random Early Detection."
HREF="x2457.html"><style type="text/css"> p {text-align:justify;} </style></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Advanced Routing &#38; Traffic Control HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2425.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Глава 14. Специализированные дисциплины управления очередями.</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2457.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="RANDOMEARLYDETECTIONRED"
></A
>14.5. Random Early Detection (RED)</H1
><P
>      Этот раздел служит в качестве введения в организацию очередей в магистральных сетях, которые зачастую
      имеют полосу пропускания более 100 мегабит, что требует иного подхода чем в случае с домашним ADSL-модемом.
    </P
><P
>      Нередко на маршрутизаторах в Интернет возникает так называемая проблема <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tail drops</I
></SPAN
> -- 
      отсечения конца очереди. Когда очередь полна, ни один вновь поступивший пакет туда уже не помещается, а 
      потому отбрасывается. Такое управление очередью приводит к повторной синхронизации параметров соединения.
      После синхронизации TCP сразу посылает столько пакетов, сколько допускает размер окна подтверждения.
      Подобный всплеск нагрузки опять приводит к отсечению конца очереди, что опять порождает необходимость
      повторной синхронизации... Такое хождение по кругу может продолжаться довольно долго.
    </P
><P
>      Чтобы избежать возникновения заторов, на маршрутизаторах зачастую организуются очереди большого размера.
      К сожалению, не смотря на то, что увеличение размеров очереди благоприятно сказывается на пропускной 
      способности, большие очереди могут приводить к увеличению времени задержки, что становится причиной 
      взрывоподобного поведения TCP-соединений.
    </P
><P
>      Проблема отсечения хвоста очереди с каждым днем становится все более неприятной. Для предотвращения 
      перегрузок, ядро Linux предоставляет в наше распоряжение механизм RED, сокращенно от Random Early Detect
      (Случайное Раннее Обнаружение), которое иногда называется как Random Early Drop (Случайное Раннее 
      Отсечение), последнее определение более точно описывает принцип работы.
    </P
><P
>      RED -- это не панацея от всех бед, но позволяет более "справедливо" разделить канал между TCP-соединениями.
    </P
><P
>      Он позволяет контролировать нагрузку с помощью выборочного случайного уничтожения некоторых пакетов до того,
      как очередь будет заполнена полностью, что заставляет протоколы, подобные TCP, снижать скорость передачи
      и предотвращает повторную синхронизацию. Кроме того, выборочная "потеря" пакетов помогает TCP быстрее
      найти подходящую скорость передачи данных, а так же удерживать размер очереди и время задержки на разумном 
      уровне. Вероятность "потери" пакета конкретного соединения прямо пропорциональна пропускной способности,
      используемой этим соединением, а не числу пакетов, т.е. большие пакеты уничтожаются чаще маленьких,  
      что дает достаточно справедливое распределение полосы пропускания.
    </P
><P
>      RED хорошо подходит для обслуживания очередей на магистральных линиях, где отслеживание сессий (с целью 
      справедливого распределения канала) является непозволительной роскошью.
    </P
><P
>      При работе с RED вы должны будете определиться со значениями трех параметров: <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Минимум (min),
      Максимум (max)</I
></SPAN
> и <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Превышение (burst)</I
></SPAN
>. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Минимум</I
></SPAN
> -- 
      это минимальный размер очереди в байтах, выше которого начнется выборочная потеря пакетов.
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Максимум</I
></SPAN
> -- это "мягкий" максимум, алгоритм будет пытаться удержать размер
      очереди ниже этого предела. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Превышение</I
></SPAN
> -- максимальное число пакетов,
      которые могут быть приняты в очередь сверх установленного максимального предела.
    </P
><P
>      Минимальный размер очереди рассчитывается, исходя из максимально допустимого времени задержки
      в очереди и пропускной способности канала. Например, на моем 64Кбит/сек (8 Кбайт/сек) соединении я хочу 
      получить максимальное время задержки 200 мсек, тогда 8 * 0.2 = 1.6 Кбайт (т.е. примерно 1600 байт).
      Если установить минимальный предел слишком маленьким, это приведет к снижению пропускной способности,
      слишком большим -- к увеличению времени задержки. Уменьшение размера очереди не может служить заменой
      уменьшению размера MTU, которое используется для уменьшения времени отклика на медленных линиях связи.
    </P
><P
>      Максимальный размер очереди нужно задавать по меньшей мере в два раза большим минимального, чтобы
      снизить вероятность повторной синхронизации. На медленных линиях, с небольшим минимальным
      пределом размера очереди, максимальный предел следует задавать в четыре, а иногда и более раз
      больше минимального.
    </P
><P
>      Предел превышения отвечает за поведение RED на пиковых нагрузках. Размер превышения должен устанавливаться
      больше, чем min/avpkt. Экспериментальным путем я пришел к выражению, устанавливающему размер превышения, 
      (min+min+max)/(3*avpkt), которое дает неплохие результаты.
    </P
><P
>      Кроме того, вам необходимо будет определиться с предельным размером очереди (limit) и средним размером 
      пакета (avpkt). По достижении очередью предельного размера, RED переходит к алгоритму "отсечения конца".
      Обычно я устанавливаю предельный размер очереди в 8 раз больше максимального. Значение 1000, для avpkt 
      (средний размер пакета), дает неплохие результаты на высокоскоростных линиях, при размере MTU = 1500.
    </P
><P
>      Техническое описание RED (авторы: Sally Floyd и Van Jacobson) вы найдете в документе
      <A
HREF="http://www.aciri.org/floyd/papers/red/red.html"
TARGET="_top"
>the paper on RED queueing</A
>.
    </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2425.html"
ACCESSKEY="P"
>Назад</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>В начало документа</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2457.html"
ACCESSKEY="N"
>Вперед</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Ingress qdisc.</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2289.html"
ACCESSKEY="U"
>К началу раздела</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Generic Random Early Detection.</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>