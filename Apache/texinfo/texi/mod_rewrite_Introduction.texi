Apache mod_rewrite Введение

Этот документ дополняет справочную документацию mod_rewrite. Он описывает основные понятия, необходимые для использования mod_rewrite. Другие документы более подробно описаны, но этот документ должен помочь новичку понять основы.


Вступление

Модуль Apache mod_rewrite - это очень мощный и сложный модуль, который обеспечивает способ манипулирования URL-адресами. С его помощью вы можете выполнять практически все типы перезаписи URL, которые могут вам понадобиться. Это, однако, несколько сложно, и может быть пугающим для новичка. Существует также тенденция рассматривать правила перезаписи как магическое заклинание, используя их, фактически не понимая, что они делают.

В этом документе делается попытка дать достаточную справочную информацию, чтобы понять следующее, а не просто слепо копировать.

Помните, что многие распространенные задачи манипулирования URL-адресами не требуют полной мощности и сложности mod_rewrite. Для простых задач см. mod_alias и документацию по сопоставлению URL-адресов с файловой системой.

Наконец, прежде чем продолжить, обязательно настройте уровень журнала mod_rewrite на один из уровней трассировки, используя директиву LogLevel. Хотя это может дать огромное количество информации, это необходимо для устранения проблем с конфигурацией mod_rewrite, поскольку она точно скажет вам, как обрабатывается каждое правило.

Регулярные выражения

mod_rewrite использует словарь регулярных выражений, совместимый с Perl. В этом документе мы не пытаемся предоставить подробную ссылку на регулярные выражения. Для этого мы рекомендуем справочные страницы PCRE, справочную страницу по регулярным выражениям Perl и Mastering Regular Expressions Джеффри Фридла.

В этом документе мы попытаемся предоставить достаточно словарного запаса регулярных выражений, чтобы вы, без особого труда, могли начать работу в надежде, что RewriteRules будет научными формулами, а не магическими заклинаниями.

Regex словарь

Ниже приведены минимальные строительные блоки, которые вам понадобятся для написания регулярных выражений и RewriteRules. Они, конечно, не представляют полный словарь регулярных выражений, но они являются хорошим началом для начала и должны помочь вам прочитать основные регулярные выражения, а также написать свои собственные.

@multitable @columnfractions .15 .40 .40
символ 	Описание соответствия 	Example
@item Символ @tab Описание соответствия @tab Пример использования
@item @code{.}
@tab Соответствует любому отдельному символу
@tab @code{c.t} будет соответствовать @cod{cat}, @cod{cot}, @cod{cut} и т.п.
@item @code{+}
@tab Повторяет предыдущее соответствие один или несколько раз
@tab @code{a+} соответствует @code{a}, @code{aa}, @code{aaa} и т.п.
@item @code{*}
@tab Повторяет предыдущее совпадение ноль или более раз.
@tab @code{a*} соответствует всем тем же вещам, что и @code{a+}, но также будет соответствовать пустой строке.
@item @code{?}
@tab Делает соответствие необязательным.
@tab @code{colou?r} будет соответствовать @code{color} и @code{colour}.
@item @code{^}
@tab Вызывается якорем, соответствует началу строки
@tab @code{^a} соответствует строке, которая начинается с @code{a}
@item @code{$}
@tab Другой якорь, соответствует концу строки.
@tab @code{a$} соответствует строке, которая заканчивается на @code{a}.
@item @code{( )}
@tab Группирует несколько символов в одну единицу и фиксирует совпадение для использования в обратной ссылке.
@tab @code{(ab)+} соответствует @code{ababab} - то есть @code{+} применяется к группе. Подробнее об обратных ссылках см. Ниже.
@item @code{[ ]}
@tab Класс символов - соответствует одному из символов
@tab @code{c[uoa]t} соответствует @code{cut}, @code{cot} или @code{cat}.
@item @code{[^ ]}
@tab Класс недопустимых символов - соответствует любому не указанному символу
@tab @code{c[^/]t} соответствует @code{cat} или @code{c=t} но не @code{c/t}
@end multitable

В mod_rewrite символ ! может использоваться перед регулярным выражением для его отрицания. Это означает, что строка будет считаться совпадающей, только если она не соответствует остальной части выражения.

Regex обратная ссылка наличие

Здесь следует помнить одну важную вещь: всякий раз, когда вы используете круглые скобки в @code{Pattern} (Шаблон) или в одном из @code{CondPattern}, создаются внутренние обратные ссылки, которые можно использовать со строками @code{$N} и @code{%N} (см. Ниже). Они доступны для создания параметра подстановки @code{Substitution} объекта @code{RewriteRule} или параметра @code{TestString} объекта @code{RewriteCond}.

Захваты в шаблонах @codr{RewriteRule} доступны (нелогично) всем предшествующим директивам @code{RewriteCond}, поскольку выражение @code@{RewriteRule} оценивается перед отдельными условиями.

На рисунке 1 показано, в какие места обратные ссылки передаются для расширения, а также показана последовательность сопоставления @code{RewriteRule}, @code{RewriteCond}. В следующих главах мы будем изучать, как использовать эти обратные ссылки, так что не расстраивайтесь, если сначала вам это покажется немного чуждым.

@image{./fig1,25cm,10cm}

Figure 1: Обратная ссылка через правило.
В этом примере запрос для @code{/test/1234} будет преобразован в @code{/admin.foo?page=test&id=1234&host=admin.example.com}.

Основы RewriteRule

RewriteRule состоит из трех аргументов, разделенных пробелами. Аргументы:
@enumerate
@item (Шаблон) Pattern: на какой входящий URLs должно влиять правило;
@item (Подстановка) Substitution: куда следует отправлять соответствующие запросы;
@item (Флаг) [flags]: варианты, влияющие на переписанный запрос.
@end enumerate

(Шаблон) Pattern - регулярное выражение. Первоначально (для первого правила перезаписи или до замены) сопоставляется с URL-путем входящего запроса (часть после имени хоста, но перед любым вопросительным знаком, указывающим начало строки запроса) или в каждом каталоге контекст, по отношению к пути запроса относительно каталога, для которого определено правило. Как только произошла подстановка, последующие правила сопоставляются с подставляемым значением.

@image{./fig2,25cm,10cm}

Figure 2: Синтакс директивы RewriteRule.

Подстановка Substitution сама по себе может быть одной из трех видов:

Полный путь файловой системы к ресурсу
@example
RewriteRule "^/games" "/usr/local/games/web"
@end example
Это сопоставляет запрос с произвольным местоположением в вашей файловой системе, очень похоже на директиву Alias.

Веб-путь к ресурсу
@example
RewriteRule "^/foo$" "/bar"
@end example

Если для @code{DocumentRoot} установлено значение /usr/local/apache2/htdocs, то эта директива будет отображать запросы для http://example.com/foo на путь /usr/local/apache2/htdocs/bar.

Абсолютный URL
@example
RewriteRule "^/product/view$" "http://site2.example.com/seeproduct.html" [R]
@end example

Это говорит клиенту сделать новый запрос для указанного URL.

Подстановка Substitution также может содержать обратные ссылки на части входящего URL-пути, соответствующие шаблону Pattern. Учтите следующее:
@example
RewriteRule "^/product/(.*)/view$" "/var/web/productdb/$1"
@end example
Переменная $1 будет заменена на любой текст, который соответствует выражению внутри скобки в шаблоне. Например, запрос на http://example.com/product/r14df/view будет сопоставлен с путем /var/web/productdb/r14df.

Если в скобках содержится более одного выражения, они доступны по порядку в переменных @code{$1}, @code{$2}, @code{$3} и т.п.

