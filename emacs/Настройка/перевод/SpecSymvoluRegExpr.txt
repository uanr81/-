34.3.1.1 Специальные символы в регулярных выражениях 
Вот список символов, которые являются особыми в регулярном выражении. 
‘.’ (Period)
    это специальный символ, который соответствует любому одиночному символу, кроме новой строки.
    Используя конкатенацию, мы можем делать регулярные выражения типа ‘a.b’, которые
    соответствуют любой трехсимвольной строке, которая начинается с ‘a’ и заканчивается на ‘b’. 
‘*’ 
    не является само по себе; это постфиксный оператор, который означает повторение
    повторяющегося регулярного выражения столько раз, сколько возможно. Таким образом,
    ‘o*’ соответствует любому числу ‘o’ (включая не ‘o’).
    
    ‘*’ всегда применяется к наименьшему (_smallest_) возможному предыдущему выражению. Таким
    образом, ‘fo*’ имеет повторяющееся ‘o’, а не повторяющееся ‘fo’.  Оно соответствует
    ‘f’, ‘fo’, ‘foo’, и т.д. 

    Сопоставление обрабатывает конструкцию ‘*’, сразу же сопоставляя столько повторений,
    сколько может быть найдено. Затем оно продолжает с остальной частью шаблона. Если это
    не удается, происходит откат, отбрасываются некоторые совпадения ‘*’ -модифицированной
    конструкции в надежде, что это позволит сопоставить остальную часть шаблона. Например,
    при сопоставлении ‘ca*ar’ с строкой ‘caaar’, ‘a*’ сначала пытается сопоставить все три
    ‘a’; но остальная часть шаблона - ‘ar’, и осталось только ‘r’, чтобы соответствовать,
    поэтому эта попытка не удалась. Следующая альтернатива - ‘a*’, чтобы соответствовать
    только двум ‘a’. С этим выбором остальная часть регулярного выражения совпадает успешно. 

    Предупреждение. Операторы вложенных повторений могут работать неопределенно долго,
    если они приводят к неоднозначному согласованию. Например, при попытке сопоставить
    регулярное выражение ‘\(x+y*\)*a’ с строкой
    ‘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz’ может занять несколько часов, прежде чем оно
    в конечном итоге потерпит неудачу. Emacs должен попробовать каждый способ группировки
    ‘x’, прежде чем заключить, что ничто не сработает. Хуже того, ‘\(x*\)*’ может
    соответствовать пустой строке бесконечно многими способами, поэтому это вызывает
    бесконечный цикл. Чтобы избежать этих проблем, тщательно проверьте вложенные повторения,
    чтобы убедиться, что они не вызывают такого рода отклонений. 

‘+’ 
    является постфиксным оператором, аналогичным ‘*’, за исключением того, что он должен
    соответствовать предыдущему выражению хотя бы один раз. Так, например, ‘ca+r’
    соответствует строкам ‘car’ и ‘caaaar’, но не строке ‘cr’, тогда как ‘ca*r’
    соответствует всем трем строкам. 

‘?’ 
    является постфиксным оператором, аналогичным ‘*’, за исключением того, что он
    должен совпадать с предыдущим выражением либо один раз, либо ни разу вовсе.
    Например, ‘ca?r’ соответствует ‘car’ или ‘cr’и ничему больше. 

‘*?’, ‘+?’, ‘??’
      Это не жадные (“non-greedy”) варианты операторов ‘*’, ‘+’ и ‘?’. Если эти
      операторы соответствуют наибольшей возможной подстроке (в соответствии с
      совпадением всего содержащего выражения), нежелательные варианты соответствуют
      наименьшей возможной подстроке (в соответствии с совпадением всего содержащего
      выражения).

      Например, регулярное выражение ‘c[ad]*a’, применяемое к строке ‘cdaaada’,
      соответствует всей строке; но регулярное выражение ‘c[ad]*?a’, примененное к
      той же строке, соответствует только ‘cda’. (Наименьшее возможное совпадение
      здесь для ‘[ad]*?’ позволяет совместить все выражение, равное ‘d’).

‘[ … ]’
      является альтернативой символов, которая начинается с ‘[’ и заканчивается ‘]’.
      В простейшем случае символы между двумя скобками - это перечисление того, чему может
      соответствовать совпадение.
      
      Таким образом, ‘[ad]’ соответствует либо ‘a’ либо ‘d’, и  ‘[ad]*’ соответствует любой
      строке, состоящей только из ‘a’ и ‘d’ (включая пустую строку). Из этого следует, что
      ‘c[ad]*r’ соответствует ‘cr’, ‘car’, ‘cdr’, ‘caddaar’ и т.д.

      Вы также можете указать диапазоны символов в альтернативе символов, написав
      начальный и конечный символы с помощью ‘-’ между ними. Таким образом, ‘[a-z]’
      соответствует любой строчной букве ASCII . Диапазоны могут быть перемешаны
      свободно с отдельными символами, как в ‘[a-z$%.]’, что соответствует любой
      строчной букве ASCII или ‘$’, ‘%’ или периоду.

      Если ‘case-fold-search’ is non-‘nil’, ‘[a-z]’ также соответствует прописным
      буквам. Обратите внимание, что диапазон, подобный ‘[a-z]’, не зависит от
      последовательности сортировки локали, он всегда представляет последовательность
      в порядке ASCII.

      Также обратите внимание, что обычные специальные символы регулярного выражения
      не являются особенными внутри альтернативы символов. Совершенно другой набор
      символов - это специальные внутренние симаолы альтернативы ‘]’, ‘-’ и ‘^’.

      Чтобы включить символ ‘]’ в альтернативный символ, вы должны сделать его первым
      символом. Например, ‘[]a]’ соответствует ‘]’ или ‘a’. Чтобы включить ‘-’,
      напишите ‘-’ в качестве первого или последнего символа альтернативы или поместите
      его после диапазона. Таким образом, ‘[]-]’ соответствует как ‘]’ так и ‘-’.
      (Как объясняется ниже, вы не можете использовать ‘\]’ для включения ‘]’ внутри
      альтернативы символа, так как ‘\’ там не является особым.)

      Чтобы включить ‘^’ в альтернативу символов, поместите его куда угодно, но не в
      начале. Если диапазон начинается с однобайтового символа C и заканчивается
      многобайтовым символом C2 , диапазон делится на две части: одна охватывает
      однобайтовые символы ‘C..?\377’, другая - многобайтные символы ‘C1..C2’, где c1 -
      первый символ кодировки, к которой принадлежит C2 .

      Альтернатива символа также может указывать именованные классы символов
      (см. Char Classes ). Это функция POSIX. Например, ‘[[:ascii:]]’ соответствует
      любому символу ASCII . Использование класса символов эквивалентно упоминанию
      каждого из символов этого класса; но последнее практически невозможно на практике,
      поскольку некоторые классы включают в себя тысячи разных символов.

‘[^ … ]’
      ‘[^’ начинает дополнять альтернативу символа. Это соответствует любому символу,
      кроме указанных. Таким образом, ‘[^a-z0-9A-Z]’ соответствует всем символам, кроме
      букв и цифр.
      ‘^’ не является особенным в альтернативе символа, если только он не первый
      символ. Символ, следующий за ‘^’, обрабатывается так, как если бы он был первым
      (другими словами, ‘-’ и ‘]’ не являются особыми там).

      Дополнительная альтернатива символа может соответствовать новой строке, если
      только новая строка не упоминается как один из символов, которые не соответствуют.
      Это в отличие от обработки регулярных выражений в программах,
      таких как grep. 

      Вы можете указать именованные классы символов, как и в альтернативах символов.
      Например, ‘[^[:ascii:]]’ соответствует любому не ASCII символу . См. Классы Char . 

‘^’ 
      При сопоставлении буфера ‘^’ соответствует пустой строке, но только в начале строки
      в соответствующем тексте (или в начале доступной части буфера). В противном случае
      он ничего не сможет сопоставить. Таким образом, ‘^foo’ соответствует ‘foo’, которое
      встречается в начале строки.

      При совпадении строки вместо буфера ‘^’ совпадает с началом строки или после символа
      новой строки.

      По причинам исторической совместимости ‘^’ может использоваться только в начале
      регулярного выражения или после ‘\(’, ‘\(?:’ или ‘\|’.

‘$’
	аналогичен ‘^’, но соответствует только в конце строки (или в конце доступной
	части буфера). Таким образом, ‘x+$’ соответствует строке одного или более ‘x’
	в конце строки.

	При сопоставлении строки вместо буфера ‘$’ совпадает в конце строки или перед
	символом новой строки.

	По причинам исторической совместимости ‘$’ может использоваться только в конце
	регулярного выражения или до ‘\)’ or ‘\|’.

‘\’
	имеет две функции: он цитирует специальные символы (включая ‘\’), и он вводит
	дополнительные специальные конструкции.

	Поскольку ‘\’ цитирует специальные символы, ‘\$’ является регулярным выражением,
	которое соответствует только ‘$’, а ‘\[’ - это регулярное выражение, которое
	соответствует только ‘[’ и т.д.

	Обратите внимание, что ‘\’ также имеет особое значение в синтаксисе чтения строк
	Lisp (см. « Тип строки» ) и должен быть указан с ‘\’. Например, регулярное
	выражение, соответствующее символу ‘\’, записывается ‘\\’. Чтобы написать строку
	Lisp, содержащую символы ‘\\’, синтаксис Lisp требует, чтобы вы процитировали
	каждый ‘\’ другим ‘\’. Следовательно, синтаксис чтения для регулярного выражения,
	соответствующего ‘\\’, равен ‘\\\\’.

Обратите внимание: для исторической совместимости специальные символы рассматриваются
как обычные, если они находятся в контекстах, где их особые значения не имеют смысла.
Например, ‘*foo’ трактует ‘*’ как обычный, поскольку нет предыдущего выражения, на
которое может действовать ‘*’. Это плохая практика зависимости поведения; В любом
случае, укажите специальный символ, независимо от того, где он появляется.

Поскольку ‘\’ не является особенным внутри альтернативы символа, он никогда не сможет
удалить особый смысл для ‘-’ или ‘]’. Поэтому вы не должны цитировать эти символы,
когда они не имеют особого значения. Это ничего не прояснит, так как обратная косая
черта может законно предшествовать этим символам, где они имеют особый смысл, как
в ‘[^\]’ (‘"[^\\]"’ для синтаксиса строки Lisp), который соответствует любому
одиночному символу, кроме обратного слэша.

На практике большинство ‘]’, которые встречаются в регулярных выражениях, закрывают
альтернативу символов и, следовательно, являются особыми. Однако иногда регулярное
выражение может пытаться сопоставить сложный шаблон литерала ‘[’ и ‘]’. В таких ситуациях
иногда бывает необходимо тщательно проанализировать регулярное выражение с самого начала,
чтобы определить, какие квадратные скобки заключают альтернативу символов. Например,
‘[^][]]’ состоит из дополненной альтернативы символов ‘[^][]’ (которая соответствует
любому одиночному символу, который не является квадратной скобкой), за которым следует
литерал ‘]’. 
Точные правила заключаются в том, что в начале регулярного выражения литерал ‘[’ является
специальным а ‘]’ нет. Это длится до первого неуказанного ‘[’, после чего мы находимся
в альтернативе символа; ‘[’ больше не является специальным (кроме случаев, когда он
запускает класс символов), но ‘]’ является особенным, если только он не сразу следует
за специальным ‘[’ или ‘[’ за которым следует ‘^’. Это длится до следующего специального
символа ‘]’, который не заканчивается символьным классом. Это завершает альтернативу
символов и восстанавливает обычный синтаксис регулярных выражений; unquoted ‘[’ снова
является специальным, а ‘]’ - нет.

34.3.1.2 Классы символов

Вот таблица классов, которые вы можете использовать в альтернативе символов, и что они означают:

‘[:ascii:]’
    Это соответствует любому символу ASCII (коды 0-127).
‘[:alnum:]’
    Это соответствует любой букве или цифре. Для многобайтовых символов он соответствует
    символам, свойство Unicode « Общая категория » (см. « Свойства символов» ) означает,
    что они являются символами алфавита или десятичного числа.
‘[:alpha:]’
    Это соответствует любой букве. Для многобайтовых символов он соответствует
    символам, свойство Unicode « Общая категория » (см. « Свойства символов» )
    означает, что они являются алфавитными символами.
‘[:blank:]’
    Это соответствует горизонтальному пробелу, как определено в Приложении C
    Технического стандарта № Юникода №18. В частности, он соответствует
    пробелам, табуляции и другим символам, свойство Unicode « общая категория »
    (см. « Свойства символов» ) указывает, что они являются разделителями
    разделителей.
‘[:cntrl:]’
    Это соответствует любому управляющему символу ASCII .
‘[:digit:]’
    Это соответствует от ‘0’ до ‘9’. Таким образом, ‘[-+[:digit:]]’
    соответствует любой цифре, а также «+» и «-».
‘[:graph:]’
    Это соответствует графическим символам - все, кроме символов
    пробела, ASCII и не ASCII управляющих символов, суррогатов и
    кодовых точек, не назначенных Unicode, как указано свойством
    « общая категория » Unicode (см. « Свойства символов» ).
‘[:lower:]’
    Это соответствует любой строчной букве, как определено текущей
    таблицей case (см. Таблицы случаев ). Если case-fold-search
    равен не nil , это также соответствует любой прописной букве.
‘[:multibyte:]’
    Это соответствует любому многобайтовому символу (см. Текстовые представления ).
‘[:nonascii:]’
    Это соответствует любому символу не ASCII .
‘[:print:]’
    Это соответствует любому печатному символу - либо пробелу, либо
    графическому символу, сопоставляемому ‘[:graph:]’.
‘[:punct:]’
    Это соответствует любому знаку пунктуации. (В настоящее время для
    многобайтовых символов он соответствует всем, что имеет синтаксис без слова.)
‘[:space:]’
    Это соответствует любому символу с синтаксисом пробела (см. Таблицу
    классов синтаксиса ).
‘[:unibyte:]’
    Это соответствует любому однобайтовому символу (см. Текстовые представления ).
‘[:upper:]’
    Это соответствует любой букве верхнего регистра, как определено текущей
    таблицей case (см. Таблицы случаев ). Если case-fold-search равен nil ,
    это также соответствует любой строчной букве.
‘[:word:]’
    Это соответствует любому символу с синтаксисом слова
    (см. Таблицу классов синтаксиса ).
‘[:xdigit:]’
    Это соответствует шестнадцатеричным цифрам: от ‘0’ до ‘9’, от  ‘a’ до ‘f’
    и от ‘A’ до ‘F’.
 
