edebug-mode Представляет собой интерактивную скомпилированную Lisp-функцию в
`edebug.el'.

(edebug-mode &optional ARG)

Режим для буферов Emacs Lisp во время Edebug.

В дополнение ко всем командам Emacs Lisp (кроме тех, которые изменяют
Буфер) существуют локальные и глобальные привязки ключей к нескольким Edebug
определенным командам.  E.g. `edebug-step-mode' связан с SPC
в буфере Edebug и C-x X SPC в любом буфере.

Также см. Привязки для буфера списка eval *edebug* в `edebug-eval-mode'.

команды буфера edebug :
клавиша         Связана
---             -------

C-c		Prefix Команда
C-x		Prefix Команда
ESC		Prefix Команда
SPC		`edebug-step-mode' Перейдите к следующей точки остановки
-		`negative-argument' Начните отрицательный числовой аргумент для
		следующей команды. C-u следующие цифры или знак минус заканчивает
		аргумент.
=		`edebug-temp-display-freq-count' Временно отобразить данные подсчета
		частоты для текущего определения. Он удаляется, когда вы нажимаете
		любой символ.
?		`edebug-help' описывает `edebug-mode'
B		`edebug-next-breakpoint' Переместите точку на следующую точку
		останова, или на начало, если ни нет дальше точек останова.
C		`edebug-Continue-fast-mode' Трассировка без ожидания на каждом шаге.
		Обновляет отображение в каждой точке останова, но не
		приостанавливает.
E		`edebug-visit-eval-list' Переключитесь в буфер списка оценок
G		`edebug-Go-nonstop-mode' Идти, оценивая без отладки. Вы можете
		использовать `edebug-stop', или любую команду редактирования, чтобы
		остановить
I		`edebug-instrument-callee' инструментирует определение функции или
		макроса, который должен быть вызван. Делайте это, когда остановились
		перед формой, или будет слишком поздно. Одним из побочных эффектов
		использования этой команды является то, что в следующий раз, когда
		вызывается функция или макрос, Edebug будет вызываться там же.
P		`edebug-view-outside' Измените конфигурацию внешнего окна.
		Используйте `edebug-where' для возврата
Q		`edebug-top-level-nonstop' Установите режим Go-nonstop и выйдите на
		верхний уровень. Это полезно для выхода, даже если `unwind-protect'
		код может быть выполнен
S		`edebug-stop' Остановите выполнение и не продолжайте. Полезно для
		выхода из цикла трассировки или продолжения.
T		`edebug-Trace-fast-mode' Трассировка без ожидания на каждом шаге.
		Обновляет отображение в каждой точке остановки, но не
		приостанавливает.
W		`edebug-toggle-save-windows' Переключает сохранение и восстановление
		окон. С префиксом, переключаться только для выбранного окна. В
		противном случае включается для всех окон.
X		`edebug-set-global-break-condition' задать в аргументе выражение
a		`abort-recursive-edit' Прервите команду, которая запросила этот
		рекурсивный ввод или ввод минибуфера.
b		`edebug-set-breakpoint' (edebug-set-breakpoint ARG) Установите точку
		останова для ближайшего выражения. С префикс аргументом сделайте
		его временной точкой останова.
c		`edebug-continue-mode' Начать режим продолжения. Паузы для
		`edebug-sit-for-seconds'в каждой точке разрыва.
d		edebug-backtrace Отобразить нерабочую обратную трассировку.
		Лучше чем ничего...
e		`edebug-eval-expression' (edebug-eval-expression EXPR) Вычислить
		выражение во внешней среде. Если интерактивный, приглашение для
		выражения. Вывести результат в минибуфере.
f		`edebug-forward-sexp'(edebug-forward-sexp ARG) Переходите от текущей
		точки до конца ARG выражения вперед. Если впереди нет ARG выражений,
		то `edebug-step-out'
g		`edebug-go-mode' (edebug-go-mode ARG) Идти, оценивая до перерыва. С
		префиксом ARG установите временной разрыв в текущей точке и идите.
h		`edebug-goto-here' Перейдите к первой точке остановки в точке или
		после текущей позиции точки.
i		`edebug-step-in' Шаг в определении функции или макроса, которые
		должны быть вызваны. Вначале делает `edebug-instrument-callee'
		для обеспечения инструментирования
n		`edebug-next-mode' Перейдите к следующей «после» точки останова.
o		`edebug-step-out' Переходите от текущей точки до конца содержащей
		выражение. Если нет содержащего выражения, который не является
		определением верхнего уровня, перейдите в конец последнего выражения
		если это одна и та же точка, затем шаг.
p		`edebug-bounce-point' (edebug-bounce-point ARG) Отбросьте точку в
		буфере внешнего тока. Если аргумент префикса ARG предоставлен,
		ожидайте столько секунд, прежде чем вернуться. По умолчанию
		используется одна секунда.
q		`top-level' Выйдите из всех уровней рекурсивного редактирования. Это
		также завершает работу всех активных минибуферов.
r		`edebug-previous-result' Распечатать предыдущий результат
t		`edebug-trace-mode' Начать режим трассировки. Паузы установленые
                `edebug-sit-for-seconds'в каждой точке останова
u		`edebug-unset-breakpoint' Очистить точку останова ближайшего
		выражения
v		`edebug-view-outside' Измените конфигурацию внешнего окна.
		Используйте `edebug-where' для возврата.
w		`edebug-where' Показывать окна отладки и где мы остановились
		в программе
x		`edebug-set-conditional-breakpoint'
		(edebug-set-conditional-breakpoint ARG CONDITION) Установите
		условную точку останова в ближайшем поле. Условие оценивается во
		внешнем контексте. С префикс аргументом сделайте её временной точкой
		останова.
DEL		`backward-delete-char-untabify'
		(backward-delete-char-untabify ARG &optional KILLP)Удаление символов
		назад, изменение вкладок в пробелы. Точное поведение зависит от
		`backward-delete-char-untabify-method'. Удалить символы ARG и убить
		(сохранить в kill ring), если KILLP не равен нулю. В интерактивном
		режиме ARG является префиксным аргументом (по умолчанию 1), а KILLP
		- t, если указан префикс аргумент.
C-c C-c		`edebug-go-mode' (edebug-go-mode ARG) Идти, оценивая до перерыва. С
    		префиксом ARG установите временной разрыв в текущей точке и идите.
C-c C-d		`edebug-unset-breakpoint' Очистить точку останова ближайшего
    		выражения
C-c C-l		`edebug-where' Показывать окна отладки и где мы остановились в
    		программе
C-c C-n		`edebug-next-mode' Перейдите к следующей «после» точки останова.
C-c C-s		`edebug-step-mode' Перейдите к следующей точки останова.
C-c C-t		??

C-x C-a		Prefix команда
C-x C-e		`edebug-eval-last-sexp' Оцените выражение до точки во внешней среде.
    		Печатать значение в минибуфере.
C-x SPC		`edebug-set-breakpoint' (edebug-set-breakpoint ARG)Установите точку
    		останова для ближайшего выражения. С префикс аргументом сделайте её
		временной точкой останова.
C-M-i		`completion-at-point' Выполняйте пометку вокруг точки. Метод
		завершения определяется по формуле `completion-at-point-functions'
C-M-q		`indent-pp-sexp' (indent-pp-sexp &optional ARG) Отступайте каждую
		строку списка, начинающуюся сразу после запятой, или красивую
		надпись. Префиксный аргумент определяет довольно-печать.
C-M-x		`eval-defun' (eval-defun EDEBUG-IT) Оцените форму верхнего уровня,
		содержащую точку, или после точки
		Если текущий defun - это фактически вызов `defvar', Затем
		сбрасывает переменную, используя ее выражение начального значения,
		даже если переменная уже имеет некоторое другое значение.(Обычно
		`defvar' не изменяет значение переменной, если оно уже имеет
		значение.
C-M-q		`indent-sexp' (indent-sexp &optional ENDPOS) Отступ каждой строки
		списка начинается сразу после точки. Если задан необязательный
		аргумент ENDPOS, отступ каждой строки останавливается, когда
		встречается ENDPOS.
  (Эта привязка в настоящее время затенена другим режимом)

C-M-q		`prog-indent-sexp' (prog-indent-sexp &optional DEFUN) Отступ после
		выражения. Когда в интерактивном режиме вызывается с префиксом,
		вместо этого вставляет вместо него defun.
  (Эта привязка в настоящее время затенена другим режимом)

C-x C-a C-c	`edebug-go-mode'(edebug-go-mode ARG)Идти, оценивая до перерыва. С
    		префиксом ARG установите временной разрыв в текущей точке и идите.
C-x C-a C-l	`edebug-where' Показывать окна отладки и где мы остановились в
    		программе.
C-x C-a C-n	`edebug-next-mode' Перейдите к следующей «после» точки останова.
C-x C-a C-s	`edebug-step-mode' Перейдите к следующей точки останова.



Глобальные команды с префиксом `global-edebug-prefix':
key             binding
---             -------

SPC		`edebug-step-mode' Перейти к следующей точки останова
=		`edebug-display-freq-count' Отображение данных подсчета частоты для
		каждой строки текущего определения. Счетчики частоты вставляются в
		виде строк комментариев после каждой строки, и вы можете отменить
		все вставки с помощью одной команды `undo'.
C		`edebug-Continue-fast-mode' Трассировка без ожидания на каждом шаге.
		Обновляет отображение в каждой точке останова, но не
		приостанавливает.
G		`edebug-Go-nonstop-mode' Идти, оценивая без отладки. Вы можете
		отменить `edebug-stop' или любой командой редактирования.
Q		`edebug-top-level-nonstop' Установите режим Go-nonstop и выйдите
		на верхний уровень. Это полезно для выхода, даже если может быть
		выполнен код `unwind-protect'.
T		`edebug-Trace-fast-mode' Трассировка без ожидания на каждом шаге.
		Обновляет отображение в каждой точке остановки, но не
		приостанавливает.
W		`edebug-toggle-save-windows' (edebug-toggle-save-windows ARG)
		Переключает сохранение и восстановление окон. С префиксом,
		переключаться только для выбранного окна. В противном случае
		переключаться для всех окон.
X		`edebug-set-global-break-condition'
		(edebug-set-global-break-condition EXPRESSION) установить в
		выражении.
a		`abort-recursive-edit' Прервите команду, которая запросила этот
		рекурсивный ввод или ввод минибуфера.
b		`edebug-set-breakpoint' (edebug-set-breakpoint ARG)Установите точку
		останова для ближайшего выражения. С префикс аргументом,сделайте
		её временной точкой останова 
c		`edebug-continue-mode' Начать режим продолжения
g		`edebug-go-mode' (edebug-go-mode ARG)Идти, оценивая до перерыва. С
		префиксом ARG установите временной разрыв в текущей точке и идите. 
q		`top-level' Выйдите из всех уровней рекурсивного редактирования. Это
		также завершает работу всех активных минибуферов.
t		`edebug-trace-mode'Начать режим трассировки.
u		`edebug-unset-breakpoint' очистить точку останова ближайшего
		выражения
w		`edebug-where' Показывать окна отладки и где мы остановились в
		программе.
x		`edebug-set-conditional-breakpoint'
		(edebug-set-conditional-breakpoint ARG CONDITION)Установите условную
		точку останова в ближайшем поле. Условие оценивается во внешнем
		контексте. С префикс аргументом сделайте его временной точкой
		останова. 



Опции:
`edebug-setup-hook'Документация: используются функции вызова до edebug. Каждый раз,
	когда устанавливается новое значение, Edebug будет вызывать эти функции
	один раз, а затем сбросит `edebug-setup-hook' до nil. Вы можете использовать
	это для загрузки спецификаций Edebug, связанных с используемым пакетом, но
	только когда вы также используете Edebug.
`edebug-all-defs'Если не-nil, вычисляемые формы определения инструментируются для
	Edebug. Это относится к `eval-defun' ,`eval-region', `eval-buffer' и
	`eval-current-buffer'. `Eval-region'также называется `eval-last-sexp' и
	`eval-print-last-sexp'.
`edebug-all-forms' не-nil означает, что оценка всех форм будет инструментированым
	для Edebug. Это не относится к загрузке или оценке в минибуфере.
	Используйте команду `edebug-all-forms' для переключения значения этой опции.
`edebug-save-windows' Если не-nil, Edebug сохраняет и восстанавливает конфигурацию
	окна. Это занимает некоторое время, поэтому, если вашей программе не
	волнует, что происходит с конфигурациями окон, лучше установить эту
	переменную в nil. Если значение является списком, сохраняются и
	восстанавливаются только перечисленные окна.
`edebug-save-displayed-buffer-points'Если не-nil, сохранить и восстановить точку во
	всех отображаемых буферах. Сохранение и восстановление точки в других
	буферах необходимо, если вы отлаживаете код, который изменяет точку буфера,
	отображаемую в невыбранном окне. Если Edebug или пользователь затем выбирает
	окно, точка буфера будет изменена на точку окна. Сохранение и восстановление
	точки во всех буферах дорого, так как для этого требуется дважды выбрать
	каждое окно, поэтому включите его только в случае необходимости.
`edebug-initial-mode' Режим начального запуска для Edebug, если не равен нулю. Если
	эта переменная не равна nil, она определяет начальный режим выполнения для
	Edebug, когда он впервые активирован. Возможными значениями являются step,
	next, go, Go-nonstop, trace, Trace-fast, continue и Continue-fast.
`edebug-trace' Non-nil означает трассировку ввода и выхода функции. Трассировка
	выводится в буфере с именем `*edebug-trace*', по одной функции или по
	выходу на строку, с отступом на уровне рекурсии.
`edebug-test-coverage' Если не-nil, Edebug проверяет охват всех выражений,
	отлаживаемых. Это делается путем сравнения результата каждого выражения с
	предыдущим результатом. Охват считается одобренным, если найдены два разных
	результата. Используйте `edebug-display-freq-count' для отображения частоты
	и информации о покрытии для определения.
`edebug-continue-kbd-macro' Если не-nil, продолжить определение или выполнение
	любого макроса клавиатуры. Используйте это с осторожностью, поскольку оно
	не отлаживается.
`edebug-print-length' Если не-nil, значение по умолчанию `print-length' для печати
	выводится в Edebug.
`edebug-print-level' Если не-nil, значение по умолчанию `print-level 'для печати
	выводится в Edebug.
`edebug-print-circle' Если не-nil, значение по умолчанию `print-circle' для печати
	выводится в Edebug.
`edebug-on-error' Значение привязано к `debug-on-error', пока Edebug активен. Если
	`debug-on-error' не равен nil, это значение все еще используется.Если
	значением является список имен сигналов, Edebug остановится, когда любая из
	этих ошибок будет передана из кода Lisp независимо от того, обрабатывается
	ли сигнал в `condition-case'. Эта опция полезна для отладки сигналов,
	находящихся в обработке, поскольку в противном случае они были бы упущены.
	После возобновления выполнения, ошибка снова сигнализируется.
`edebug-on-quit' Значение привязано к `debug-on-quit', в то время как Edebug
	активен.
`edebug-on-signal'
`edebug-unwrap-results' Не-nil, если Edebug должен развернуть результаты выражений.
	То есть, Edebug попытается удалить свою собственную инструментальную систему
	из результата. Это полезно при отладке макросов, где результаты выражений
	являются инструментальными выражениями. Но не делайте этого, когда
	результаты могут быть круглыми или результатом будет бесконечный цикл.
`edebug-global-break-condition' Если не-nil, выражение для проверки в каждой точке
	останова. Если результат не равен нулю, то перерыв. Ошибки игнорируются.
