@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2016 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Searching and Matching
@chapter Searching and Matching
@cindex searching

  GNU Emacs предоставляет два способа поиска через буфер для указанного
текста: поиск точных строк и поиск регулярных выражений. После
поиска с регулярными выражениями, вы можете изучить @dfn{match data} чтобы
определить, какой текст соответствует всему регулярному выражению или различным
его частям.

@menu
* String Search::         Поиск точного соответствия.
* Searching and Case::    Независимый от случая или существенный поиск.
* Regular Expressions::   Описание классов строк.
* Regexp Search::         Поиск соответствия регулярному выражению.
* POSIX Regexps::         Поиск POSIX-стиля для самого длинного совпадения.
* Match Data::            Выяснить, какая часть текста соответствует,
                                после поиска строки или регулярного выражения.
* Search and Replace::    Команды, выполняющие цикл, поиск и замену.
* Standard Regexps::      Полезные регулярные выражения для поиска предложений, страниц,...
@end menu

  @samp{skip-chars@dots{}} функции также выполняют своего рода поиск.
@xref{Skipping Characters}.  для изменения свойств поиска в настройках
свойства, see @ref{Property Search}.

@node String Search
@section Searching for Strings
@cindex string search

  Это примитивные функции для поиска по тексту в
буфере. Они предназначены для использования в программах, но вы можете их вызвать
в интерактивном режиме. Если вы это сделаете, они запросят строку поиска;
аргументы @var{limit} и @var{noerror} указывают на @code{nil}, и @var{repeat}
это 1.  Подробнее о интерактивном поиске, @pxref{Search,,
Searching and Replacement, emacs, The GNU Emacs Manual}.

  Эти функции поиска преобразуют строку поиска в многобайтовую, если
буфер многобайтовый; Они преобразуют строку поиска в unibyte, если
буфер является унибайтовым.  @xref{Text Representations}.

@deffn Command search-forward string &optional limit noerror count
Эта функция выполняет поиск вперед от точки для точного соответствия для
@var{string}.  В случае успеха она устанавливает точку в конце события
Found и возвращает новое значение точки. Если совпадение не найдено,
оценка и побочные эффекты зависят от @var{noerror} (see below).

В следующем примере точка начинается в начале
строки. затем @code{(search-forward "fox")} перемещает точку после последней
записи @samp{fox}:

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

Аргумент @var{limit} определяет привязку к поиску, и
становится позицией в текущем буфере. Отсутствие соответствия
эта позиция принимается.  Если @var{limit} опущено или @code{nil}, Это
по умолчанию доступная часть буфера.

@kindex search-failed
Что происходит, когда поиск не выполняется, зависит от значения
@var{noerror}.  Если @var{noerror} это @code{nil}, @code{search-failed}
сигнализирует ошибку.  Если @var{noerror} это @code{t}, @code{search-forward}
возвращает @code{nil} и ничего не делает.  Если @var{noerror} не является ни
@code{nil} ни @code{t}, тогда @code{search-forward} перемещает точку на
верхнюю границу и возвращает @code{nil}.
@c Я не вижу никакой перспективы, что это когда-либо изменится, и, откровенно говоря, нынешнее
@c поведение кажется лучше, поэтому нет необходимости упоминать об этом.
@ignore
(Теперь было бы более последовательным возвращение новой позиции точки
в этом случае, но некоторые существующие программы могут зависеть от значения
@code{nil}.)
@end ignore

Аргумент @var{noerror} влияет только на действительные поисковые запросы
нахождения соответствия. Недопустимые аргументы вызывают ошибки независимо от
@var{noerror}.

Если @var{count} - положительное число @var{n}, поиск выполнен
@var{n} раз; Каждый последующий поиск начинается в конце
предыдущего совпадения. Если все эти последующие поисковые запросы будут успешными,
вызов происходит вызов функции, перемещается точка и возвращается новое значение.
В противном случае вызов функции завершается неудачно, результаты зависят от значения
@var{noerror}, как описано выше.  Если @var{count} является отрицательным
числом -@var{n}, поиск выполнен @var{n} раз в обратном направлении
(назад).
@end deffn

@deffn Command search-backward string &optional limit noerror count
Эта функция выполняет поиск назад от точки для @var{string}.  это
например, @code {search-forward}, за исключением того, что он ищет
вперед. Обратный поиск оставляет точку в начале
совпадения.
@end deffn

@deffn Command word-search-forward string &optional limit noerror count
Эта функция выполняет поиск вперед от точки для соответствия слова для
@var{string}.  Если она находит совпадение, она устанавливает точку в конце
найденого совпадения и возвращает новое значение точки.

Соответствие слов @var{string} как последовательность слов, пренебрегая
пунктуацию, отделяющую их. Она ищет буфер для той же
последовательности слов. Каждое слово должно быть разным в буфере (поиск
слов @samp{ball} не соответствует слову @samp{balls}), но
детали пунктуации и пропусков игнорируются (searching for @samp{ball
boy} соответствует @samp{ball.  Boy!}).

В этом примере точка начинается в начале буфера;
поиск оставляет его между @samp{y} и @samp{!}.

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 39

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

Если @var{limit} не-@code{nil}, это должно быть положением в текущем
буфере; Оно определяет верхнюю границу поиска нахождения соответствий и
не расширяется после этой позиции.

Если @var{noerror} это @code{nil}, тогда @code{word-search-forward} сигнализирует
ошибку при поиске.  Если @var{noerror} это @code{t}, тогда 
вернет @code{nil} вместо того, чтобы сигнализировать об ошибке.  Если @var{noerror} это
ни @code{nil} и ни @code{t}, она перемещает точку @var{limit} (или
в конец доступной части буфера) и возвращает @code{nil}.

Если @var{count} - это положительное число, в котором указано, сколько последовательных
вхождений для поиска. Точка позиционируется в конце последнего
совпадения.  Если @var{count} - отрицательное число, поиск - назад
и точка позиционируется в начале последнего совпадения.

@findex word-search-regexp
Внутренне, @code{word-search-forward} и связанные функции используют
функцию @code{word-search-regexp} для преобразования @var{string} в
регулярное выражение, которое игнорирует пунктуацию.
@end deffn

@deffn Command word-search-forward-lax string &optional limit noerror count
Эта команда идентична @code{word-search-forward}, отлична тем что
начало или конец @var{string} не должно отвечать границе слова,
Если @var{string} начинается или заканчивается пробелом.
Например, поиск @samp{ball boy} соответствует @samp{ball boyee},
но не соответствует @samp{balls boy}.
@end deffn

@deffn Command word-search-backward string &optional limit noerror count
Эта функция выполняет поиск назад от точки для соответствия слова
@var{string}.  Эта функция аналогична @code{word-search-forward}
за исключением того, что она ищет назад и обычно оставляет точку на
в начале соответствия.
@end deffn

@deffn Command word-search-backward-lax string &optional limit noerror count
Эта команда идентична @code{word-search-backward}, и отличается тем что
начало или конец @var{string} не должно отвечать границе слова, 
если @var{string} начинается или заканчивается пробелом.
@end deffn

@node Searching and Case
@section Searching and Case
@cindex searching and case

  По умолчанию поиск в Emacs игнорирует регистр текста, в котором осуществляется
поиск ; Если вы указали поиск @samp{FOO}, тогда
@samp{Foo} или @samp{foo} также считается совпадением. Это относится и к
регулярным выражениям; таким образом, @samp{[aB]} находит соответствие @samp{a} или
@samp{A} или @samp{b} или @samp{B}.

  Если вы хотите изменить поведение этой функцию, установите переменную
@code{case-fold-search} в @code{nil}.  Тогда все буквы должны совпадать
всегда точно, включая регистр. Это локальная переменная буфера; Изменения
переменной влияет только на текущий буфер.  (@xref{Intro to
Buffer-Local}.)  Кроме того, вы можете изменить значение по умолчанию.
В коде Lisp вы чаще будете использовать @code{let} связывание
@code{case-fold-search} до желаемого значения.

  Обратите внимание, что функция инкрементного поиска на уровне пользователя обрабатывает 
отличие регистра по-разному. Когда строка поиска содержит только строчные
буквы, поиск игнорирует регистр, но когда строка поиска
содержит одну или несколько букв верхнего регистра, поиск становится
зависимым от регистра. Но это не имеет никакого отношения к поисковым
функциям, используемые в коде Lisp.  @xref{Incremental Search,,, emacs,
The GNU Emacs Manual}.

@defopt case-fold-search
Эта локальная переменная буфера определяет, следует ли игнорировать при
поиске регистр. Если переменная @code{nil} функции не игнорируют регистр; в противном случае
(И по умолчанию) они игнорируют регистр.
@end defopt

@defopt case-replace
Эта переменная определяет, как будет изменен регистр букв при замене в совпадении.
Если переменная @code{nil}, что означает использовать текст замены дословно.  Не-@code{nil} 
значение означает преобразование регистра заменяющего текста в соответствии с
текстом который заменяется.

Эта переменная используется путем передачи ее в качестве аргумента функции
@code{replace-match}.  @xref{Replacing Match}.
@end defopt

@node Regular Expressions
@section Regular Expressions
@cindex regular expression
@cindex regexp

  @dfn{regular expression}, или @dfn{regexp} для краткости - это шаблон, который
обозначает (возможно, бесконечное) множество строк. Поиск совпадений для
Regexp - очень мощная операция. В этом разделе объясняется, как писать
regexp. В следующем разделе говорится, как их искать.

@findex re-builder
@cindex regular expressions, developing
  Для интерактивной разработки регулярных выражений вы
может использовать @kbd{M-x re-builder} команду.  Это обеспечивает удобный
интерфейс для создания регулярных выражений, с обратной связью в отдельном буфере. 
Когда вы редактируете регулярное выражение, все его совпадения в целевом буфере выделены. 
Каждое подвыражение регулярного выражения показано на отдельном участке, что делает
проще проверить даже очень сложные регулярные выражения.

@menu
* Syntax of Regexps::       Правила написания регулярных выражений.
* Regexp Example::          Иллюстрация синтаксиса регулярных выражений.
* Regexp Functions::        Функции для работы с регулярными выражениями.
@end menu

@node Syntax of Regexps
@subsection Syntax of Regular Expressions
@cindex regexp syntax
@cindex syntax of regular expressions

  Регулярные выражения имеют синтаксис, в котором несколько символов
являются специальными конструкциями, а остальные - @dfn{ordinary}.  Обычный
символ - это простое регулярное выражение, которое соответствует этому символу
и ничего больше. Специальные символы это @samp{.}, @samp{*},
@samp{+}, @samp{?}, @samp{[}, @samp{^}, @samp{$}, и @samp{\}. Никакие новые
специальные символы не будут определены в будущем. Литерал
@samp{]} является специальным, если он заканчивает альтернативу символа (см. Ниже).
Литерал @samp{-} является особенным внутри альтернатив литерала.  
@samp{[:} и сбалансированый @samp{:]} заключит класс символа внутри
альтернатив символа. Любой другой литерал, появляющийся в обычном
выражении является обычным, если только ему не предшествует @samp{\}.

  Например, @samp{f} не является особым символом, поэтому он является обычным, и
следовательно @samp{f} является регулярным выражением, которое соответствует строке
@samp{f} и никакой другой строке.  (Оно делает @emph{not} соответствие строке
@samp{fg}, но он соответствует @emph{part} этой строки.) Аналогично,
@samp{o} является регулярным выражением, которое соответствует только @samp{o}.

  Любые два регулярных выражения @var{a} и @var{b} могут быть объединены.
Результатом является регулярное выражение, которое соответствует строке, если @var{a} 
начало этой строки и @var{b} остальная часть строки.

  В качестве простого примера мы можем конкатенировать регулярные выражения @samp{f}
и @samp{o} для получения регулярного выражения @samp {fo}, которое соответствует только
строке @samp{fo}.  Все еще тривиально. Чтобы сделать что-то более мощное, 
необходимо использовать одну из специальных конструкций регулярных выражений.

@menu
* Regexp Special::      Специальные символы в регулярных выражениях.
* Char Classes::        Классы символов, используемые в регулярных выражениях.
* Regexp Backslash::    Обратные последовательности в регулярных выражениях.
@end menu

@node Regexp Special
@subsubsection Special Characters in Regular Expressions
@cindex regexp, special characters in

  Вот список символов, которые являются особыми в регулярном
выражение.

@need 800
@table @asis
@item @samp{.}@: @r{(Period)}
@cindex @samp{.} in regexp
Это специальный символ, который соответствует любому одиночному символу, кроме новой строки.
Используя конкатенацию, мы можем сделать регулярное выражение типа @samp{a.b}, которому
соответствует любая трехсимвольная строка, которая начинается с @samp{a} и заканчивается
@samp{b}.

@item @samp{*}
@cindex @samp{*} in regexp
Не конструкция сама по себе, это постфиксный оператор, что означает
повторение регулярного выражения столько раз, сколько возможно.  Таким образом, 
@samp{o*} соответствует любому числу @samp{o}s (в том числе нулю @samp{o}s).

@samp{*} всегда относится к @emph{наименьшему} возможному предшествующему
выражению.  Таким образом, @samp{fo*} имеет повторяющийся @samp{o}, не повторяющийся
@samp{fo}.  Это соответствует @samp{f}, @samp{fo}, @samp{foo}, и так далее.

@cindex backtracking and regular expressions
Соответствие обрабатывается @samp{*} путем сопоставления, сразу, 
стольких повторений сколько можно найти. Затем продолжает с остальной частью
шаблона. Если это не удается, происходит обратное отслеживание, отбрасывая некоторые из
совпадений @samp{*}-модифицированных конструкций в надежде, что это 
позволит сопоставить остальную часть шаблона.  Для примера, в
согласовании @samp{ca*ar} со строкой @samp{caaar}, @samp{a*}
сначала пытается сопоставить все три @samp{a}s; но остальная часть шаблона
@samp{ar} и есть только @samp{r} слева, чтобы совместить, поэтому эта попытка не удалась.
Следующая альтернатива для @samp{a*} Чтобы соответствовать только двум @samp{a}s.  С
этим выбором, остальные регулярные выражения успешно совпадают.

@strong{Внимание:} Операторы вложенных повторений могут запускаться
бесконечно долгое время, если они приводят к неоднозначному согласованию. Для
примера, пытаясь сопоставить регулярное выражение @samp{\(x+y*\)*a}
строке @samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz} может потребовать
несколько часов, прежде чем это в конечном итоге потерпит неудачу. Emacs должен 
попробовать каждый способ руппируя @samp {x} ы, прежде чем заключить, что никто из них 
не больше соответствует.
Еще хуже, @samp{\(x*\)*} может бесконечно совпадать с нулевой строкой
множеством способов, поэтому это вызывает бесконечный цикл. Чтобы избежать этих проблем,
тщательно проверяйте вложенные повторения, чтобы убедиться, что они не
вызовут комбинаторные взрывы при отклонении
.

@item @samp{+}
@cindex @samp{+} in regexp
Является постфиксным оператором, аналогичным @samp{*} за исключением того, что он 
должен соответствовать предыдущему выражению хотя бы один раз. Так, например,, @samp{ca+r}
соответствует строкам @samp{car} и @samp{caaaar} но не строке
@samp{cr}, в то время как @samp{ca*r} соответствует всем трем строкам.

@item @samp{?}
@cindex @samp{?} in regexp
Является постфиксным оператором, аналогичным @samp{*} за исключением того, что он 
должен соответствовать предшествующему выражению либо один раз, либо вообще 
нет. Например, @samp{ca?r} соответствует @samp{car} или @samp{cr}; и ничему более.

@item @samp{*?}, @samp{+?}, @samp{??}
@cindex non-greedy repetition characters in regexp
Эти @dfn{non-greedy} варианты операторов @samp{*}, @samp{+}
и @samp{?}.  Где эти операторы соответствуют максимально возможной
подстроке (согласуясь с совпадением всего содержащего выражения),
Нежелательные варианты соответствуют наименьшей возможной подстроке
(В соответствии с совпадением всего содержащего выражения).

Например, регулярное выражение @samp{c[ad]*a} применимое к
строке @samp{cdaaada} соответствует всей строке; Но регулярные
выражение @samp{c[ad]*?a}, применяемое к той же строке, соответствует только
@samp{cda}.  (Наименьшее возможное совпадение здесь для @samp{[ad]*?} что
позволяет совместить все выражение @samp{d}.)

@item @samp{[ @dots{} ]}
@cindex character alternative (in regexp)
@cindex @samp{[} in regexp
@cindex @samp{]} in regexp
Выражение @dfn{character alternative}, которое начинается с @samp{[} и 
оканчивается @samp{]}.  В простейшем случае символы между
двух скобок - это то, что может соответствовать этой альтернативе.

Таким образом, @samp{[ad]} соответствует одному @samp{a} или одному @samp{d}, или
@samp{[ad]*} соответствует любой строке, состоящей только из @samp{a}s и @samp{d}s
(включая пустую строку).  Следовательно, что @samp{c[ad]*r}
соответствует @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, и т.д.

Вы также можете включить диапазоны символов в альтернативу символов,
записав начальный и конечный символ с помощью @samp{-} между ними.
Таким образом, @samp{[a-z]} соответствует любому символу нижнего регистра @acronym{ASCII} письма.
Диапазоны могут смешиваться свободно с отдельными символами, как в
@samp{[a-z$%.]}, который соответствует любому нижнему регистру @acronym{ASCII} письма
или @samp{$}, @samp{%} или пробелу.

Если @code{case-fold-search} не-@code{nil}, @samp{[a-z]} также
соответствует заглавным буквам. Обратите внимание, что диапазон, подобный 
@samp{[a-z]} не зависит от последовательности сортировки локали, она всегда представляет
последовательность в @acronym{ASCII} стандарте.
@c Это не было очевидно для меня, так как, например, руководство grep «Символьные
@c классы и выражения скобок "в частности отмечает обратное
@c поведение. Но эксперимент Emacs кажется незатронутым LC_COLLATE
@c в этой связи.

Также обратите внимание, что обычные специальные символы регулярного выражения не 
являются особыми внутри символов альтернативы. Установлен совершенно другой набор 
специальных символов внутри символов альтернативы: @samp{]}, @samp{-} and @samp{^}.

Включить литерал @samp{]} в альтернативу, можно указав его
первым символ. Например, @samp{[]a]} соответствует @samp{]} или @samp{a}.
Для включения @samp{-}, записывайте @samp{-} первым или последним 
символом альтернативы, или поместить его после пробела, таким образом, @samp{[]-]}
соответствует @samp{]} и @samp{-}.  (как объяснено ниже, вы не можете
использовать @samp{\]} включая литерал @samp{]} внутри альтернатив символа,
поскольку литерал @samp{\} там не спец символ.)

Для включения @samp{^} в альтернативе персонажей, поместите его куда угодно, но
не в начало.

@c Что, если он начинается с многобайтового и заканчивается однобайтом?
@c Это не похоже на что-либо...?
Если диапазон начинается с символа unibyte @var{c} и заканчивается
многобайтовым символом @var{c2}, диапазон делится на две части: один
охватывает однобайтовые символы @samp{@var{c}..?\377}, другой
многобайтовые символы @samp{@var{c1}..@var{c2}}, где @var{c1} это
первый символ кодировки, к которой @var{c2} принадлежит.

Альтернатива символа также может указывать именованные классы символов
(@pxref{Char Classes}).  Это функция POSIX. Например,
@samp{[[:ascii:]]} соответствует любому @acronym{ASCII} символу.
Использование класса символов эквивалентно упоминанию каждого из
символа в этом классе; Но на практике это практически невозможно,
поскольку некоторые классы включают тысячи разных символов.

@item @samp{[^ @dots{} ]}
@cindex @samp{^} in regexp
@samp{[^} вначале @dfn{complemented character alternative}.  Эта
соответствует любому символу, кроме указанных. таким образом,
@samp{[^a-z0-9A-Z]} соответствует всем символам кроме @emph{except} письма и
цифр.

@samp{^} не является особенным в альтернативе персонажа, если он не является первым
литералом. Следующий за любым литералом @samp{^} обрабатывается не так, как если бы он
первым (другими словами как @samp{-} и @samp{]} ).

В дополнение литерал может соответствовать новой строке, если только
новая строка не является упомянутой как один из символов, которым это не соответствуют. Это 
в отличие от обработка регулярных выражений в программах, таких как @code{grep}.

Вы можете указать именованные классы символов, как и в символе
альтернативы. Например, @samp{[^[:ascii:]]} соответствует любому
не-@acronym{ASCII} символу.  @xref{Char Classes}.

@item @samp{^}
@cindex beginning of line in regexp
При сопоставлении буферу, @samp{^} соответствует пустой строке, но только в
начале строки в согласованном тексте (или в начале
доступной части буфера). В противном случае это не соответствует
чему-нибудь. Таким образом, @samp{^foo} соответствует @samp{foo} которая находится в
начале строки.

При сопоставлении строки вместо буфера, @samp{^} соответствует
началу строки или после символа новой строки.

По причинам исторической совместимости, @samp{^} может использоваться только в
начале регулярного выражения или после @samp{\(}, @samp{\(?:}
или @samp{\|}.

@item @samp{$}
@cindex @samp{$} in regexp
@cindex end of line in regexp
похож на @samp{^} но соответствует только в конце строки (или
в конце доступной части буфера).  Таким образом, @samp{x+$}
соответствует из строке одного @samp{x} или более в конце строки.

При сопоставлении строки позиции буфера, @samp{$} соответствует в конце
строки или перед символом новой строки.

По причинам исторической совместимости, @samp{$} может использоваться только на
конце регулярного выражения или до @samp{\)} или @samp{\|}.

@item @samp{\}
@cindex @samp{\} in regexp
Имеет две функции: он цитирует специальные символы (в том числе
@samp{\}), и он вводит дополнительные специальные конструкции.

Потому как @samp{\} цитирует специальные символы, @samp{\$} является регулярным
выражением, которое соответствует только @samp{$}, и @samp{\[} является регулярным
выражением, которое соответствует только @samp{[}, и ни чему более.

Обратите внимание, что @samp{\} также имеет особое значение в синтаксисе чтения Lisp
строки (@pxref{String Type}), Например, регулярное выражение, соответствующее @samp{\} литералу
@samp{\\}.  Чтобы написать строку Lisp, содержащую символы
@samp{\\}, Синтаксис Lisp требует, чтобы вы процитировали каждый @samp{\} с другим
@samp{\}.  Поэтому синтаксис чтения для регулярного выражения
@samp{\} это @code{"\\\\"}.
@end table

@strong{Обратите внимание:} Для исторической совместимости специальные символы
рассматриваются как обычные, если они находятся в контекстах, где их особые
значения не имеют смысла. Например, @samp{*foo} воспримет @samp{*} в виде обычного
символа поскольку нет предыдущего выражения, на которое @samp{*}
может действовать. Это плохая практика использования этого поведения; Цитируйте
в любом случае, независимо от того, где он появляется.

Как @samp{\} не является особенным внутри альтернатив литерала, он не может
удалить специального значения @samp{-} или @samp{]}.  Так что вы
можете не цитировать эти литералы когда они не имеют особого значения
Это ничего не прояснит, так как обратная косая черта может
законно предшествуют этим персонажам, где они @emph{have} особое
значение, как в @samp{[^\]} (@code{"[^\\]"} для синтаксиса строки Lisp),
которое соответствует любому одиночному символу, кроме обратной косой черты.

На практике большинство @samp{]} которые встречаются в регулярных выражениях, закрывают
альтернативный символ и, следовательно, являются особыми. Однако иногда
регулярное выражение может попытаться сопоставить сложный шаблон литерала
@samp{[} и @samp{]}.  В таких ситуациях иногда может быть
необходимо тщательно проанализировать регулярное выражение с самого начала, чтобы 
определить квадратные скобки заключающие альтернативу символов. Например,
@samp{[^][]]} состоит из дополненной альтернативы символа
@samp{[^][]} (которое соответствует любому одиночному символу, который не является квадратной
скобкой), за которым следует буквальный символ @samp{]}.

Точные правила заключаются в том, что в начале регулярного выражения, @samp{[} является
специальным а @samp{]} нет.  Это длится до первого неуказанного
@samp{[}, после чего мы находимся в альтернативе символа; @samp{[} 
больше не является специальным (кроме случаев, когда он запускает класс символов), но @samp{]}
является особенным, если только он не @samp{[} или это
@samp{[} а затем @samp{^}.  Это продолжается до следующего специального
@samp{]} что не заканчивает класс символов. Это заканчивает характер
альтернативу символа и восстанавливает обычный синтаксис регулярных выражений;
Неупомянутый @samp{[} является особенным снова а @samp{]} нет.

@node Char Classes
@subsubsection Character Classes
@cindex character classes in regexp

  Вот таблица классов, которые вы можете использовать в альтернативе символов,
И что они означают:

@table @samp
@item [:ascii:]
Это соответствует любому @acronym{ASCII} символу (codes 0--127).
@item [:alnum:]
Это соответствует любой букве или цифре. Для многобайтовых символов это
соответствует символам, Unicode @samp{general-category} настройки
(@pxref{Character Properties}) указывает, что они являются алфавитными или
десятичными числами.
@item [:alpha:]
Это соответствует любой букве. Для многобайтовых символов это соответствует
символу, Unicode @samp{general-category} property
(@pxref{Character Properties}) указывает, что они являются алфавитными
символами.
@item [:blank:]
Это соответствует только пробелу и вкладке.
@item [:cntrl:]
Это соответствует любому @acronym{ASCII} контрольному символу.
@item [:digit:]
Это соответствует @samp{0} через @samp{9}.  таким образом, @samp{[-+[:digit:]]}
Соответствует любой цифре, а также @samp{+} и @samp{-}.
@item [:graph:]
Это соответствует графическим символам --- все, кроме пробелов,
@acronym{ASCII} и не-@acronym{ASCII} контрольным символам,
суррогатам и кодовым точкам, не назначенных Unicode, как указано
Unicode @samp{general-category} свойство (@pxref{Character
Properties}).
@item [:lower:]
Это соответствует любой строчной букве, которая определяется текущей регистровой
таблицей (@pxref{Case Tables}).  Если @code{case-fold-search} 
не-@code{nil}, это также соответствует любой прописной букве.
@item [:multibyte:]
Это соответствует любому многобайтовому символу (@pxref{Text Representations}).
@item [:nonascii:]
Это соответствует любому не-@acronym{ASCII} символу.
@item [:print:]
Это соответствует любому печатному символу  - пробелу или графическому
символу, сопоставляемый с @samp{[:graph:]}.
@item [:punct:]
Это соответствует любому знаку пунктуации. (В настоящее время для многобайтовых
символов, он соответствует любому, у которого есть неглавный синтаксис.)
@item [:space:]
Это соответствует любому символу с синтаксисом пробелов
(@pxref{Syntax Class Table}).
@item [:unibyte:]
Это соответствует любому однобайтовому символу (@pxref{Text Representations}).
@item [:upper:]
Это соответствует любой прописной букве, как определено текущей регистровой
таблицей (@pxref{Case Tables}).  Если @code{case-fold-search} 
не-@code{nil}, это также соответствует любой строчной букве.
@item [:word:]
Это соответствует любому символу, который имеет синтаксис слова (@pxref{Syntax Class
Table}).
@item [:xdigit:]
Это соответствует шестнадцатеричным цифрам: @samp{0} через @samp{9}, @samp{a}
через @samp{f} и @samp{A} через @samp{F}.
@end table

@node Regexp Backslash
@subsubsection Backslash Constructs in Regular Expressions
@cindex backslash in regular expressions

  По большей части, @samp{\} за которыми следуют только символы
это знак. Однако есть несколько исключений: некоторые
последовательности, начинающиеся с @samp{\} имеют особые значения. Здесь
таблица специальных @samp{\} конструкций.

@table @samp
@item \|
@cindex @samp{|} in regexp
@cindex regexp alternative
Указывает альтернативу.
Два регулярных выражения @var{a} и @var{b} с @samp{\|} 
между выражениями, соответствует любому, из @var{a} или
@var{b} символу.

Таким образом, @samp{foo\|bar} соответствует либо @samp{foo} либо @samp{bar}
и никакой другой строке.

@samp{\|} применяется к максимально возможным окружающим выражениям. Только
окружающая @samp{\( @dots{} \)} группировка может ограничить группирующую способность
@samp{\|}.

Если вам нужна полная возможность обратного отслеживания для обработки нескольких видов 
использования @samp{\|}, использовать функции регулярного выражения POSIX (@pxref{POSIX
Regexps}).

@item \@{@var{m}\@}
Является постфиксным оператором, который точно повторяет предыдущий шаблон @var{m}
раз. таким образом, @samp{x\@{5\@}} соответствует строке @samp{xxxxx}
и ничего больше.  @samp{c[ad]\@{3\@}r} соответствует строке, такой как
@samp{caaar}, @samp{cdddr}, @samp{cadar}, и так далее.

@item \@{@var{m},@var{n}\@}
Является более общим оператором постфикса, который указывает повторение с помощью
минимума @var{m} повторений и максимума @var{n} повторений.  Если @var{m}
опускается, минимальный 0; Если @var{n} опущено, нет
максимума.

Например, @samp{c[ad]\@{1,2\@}r} соответствует строкам @samp{car},
@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, и @samp{cddr}, и
ничего больше.@*
@samp{\@{0,1\@}} или @samp{\@{,1\@}} эквивалентно @samp{?}.@*
@samp{\@{0,\@}} или @samp{\@{,\@}} эквивалентно @samp{*}.@*
@samp{\@{1,\@}} эквивалентно @samp{+}.

@item \( @dots{} \)
@cindex @samp{(} in regexp
@cindex @samp{)} in regexp
@cindex regexp grouping
Представляет собой конструкцию группировки, которая выполняет три цели:

@enumerate
@item
Приложить множество @samp{\|} альтернативы для других операций. Таким образом,
регулярное выражение @samp{\(foo\|bar\)x} соответствуетr @samp{foox}
или @samp{barx}.

@item
Чтобы заключить сложное выражение для работы постфиксных операторов @samp{*},
@samp{+} и @samp{?}. Таким образом, @samp{ba\(na\)*} сответствует
@samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, и т.д. с любым
числом (ноль или более) @samp{na} строки.

@item
Чтобы сохранить совпавшую подстроку для дальнейшего использования
@samp{\@var{digit}} (смотри ниже).
@end enumerate

Последнее утверждение не является следствием идеи
скобок; Это отдельная функция, которая была назначена как
второе значение для построения того же @samp{\( @dots{} \)}, потому что на
практике, обычно не было конфликта между этими двумя значениями. Но
иногда возникает конфликт, и это привело к
несохраняющейся группе.

@item \(?: @dots{} \)
@cindex shy groups
@cindex non-capturing group
@cindex unnumbered group
@cindex @samp{(?:} in regexp
Это @dfn{shy group} конструкция.  Несохраняющаяся группа обслуживает первые две
цели обычной группы (контроль за гнездом других
операторов), но она не получает числа, поэтому вы не можете ссылаться на
её значение с @samp{\@var{digit}}.  Несохраняющиеся группы особенно
полезны для механически построенных регулярных выражений, поскольку они
могут быть добавлены автоматически без изменения нумерации обычных,
сохраняющихся групп.

Несохраняющиеся группы также называются @dfn{non-capturing} или @dfn{unnumbered
groups}.

@item \(?@var{num}: @dots{} \)
Это @dfn{explicitly numbered group} конструкция.  Нормальные группы получают
свой номер неявно, исходя из их положения, которое может быть
неудобно. Эта конструкция позволяет принудительно создать определенный
номер группы. Нет никаких особых ограничений на нумерацию,
например, вы можете иметь несколько групп с одинаковым номером, и в этом случае
последнее соответствие (то есть самое правое соответствие), ответит по номеру.
Неявно нумерованные группы всегда получают наименьшее целое число, большее
на один из любой предыдущей группы.

@item \@var{digit}
Совпадает с тем же текстом, который соответствует @var{digit}th возникшей
группировке (@samp{\( @dots{} \)}) конструкции.

Другими словами, после окончания группы совпадение запоминает
начало и конец текста, сопоставляемого этой группой. Позднее в
регулярном выражение, вы можете использовать @samp{\} с последующим @var{digit} используя
совпавший текст, что бы это ни было.

Строки, соответствующие первым девяти группирующим конструкциям, появляюются во
всех регулярных выражениях и передаются в функцию поиска или сопоставления и им
назначаются номера от 1 до 9 по порядку, в котором круглые скобки появляются в регулярном 
выражении. Таким образом, вы можете использовать от @samp{\1} до @samp{\9} ссылок на 
текст, сопоставляемый соответствующим группирующим конструкциям.

Например, @samp{\(.*\)\1} cоответствует любой строке, отличной от новой строки, которая
состоит из двух одинаковых половинок.  @samp{\(.*\)} соответствует первой
половине, и может быть чем угодно, но @samp{\1} должна точно соответствовать
совпавшему в первой половине тексту.

Если @samp{\( @dots{} \)} конструкция находит совпадение более одного раза (что может
например, если за ним следуют @samp{*}), только последнее
записывается совпадение.

Если конкретная структура группировки в регулярном выражении не была
в соответствии, например, если оно появляется внутри альтернативы, которая
не используется внутри повторения, которое повторялось ноль раз - тогда
соответствующая @samp{\@var{digit}} конструкция ничему не соответствует.
Используя искусственный пример, @samp{\(foo\(b*\)\|lose\)\2}
не может совпасть с @samp{lose}: второй альтернативы внутри большей
группы при сопоставлении его не определенной @samp{\2} и не может совпадать с
чем-нибудь. Но может совпадать @samp{foobb}, потому что первая
альтернатива соответствует @samp{foob} и @samp{\2} соответствует @samp{b}.

@item \w
@cindex @samp{\w} in regexp
Соответствует любому текстовому составу. Таблица синтаксиса редактора
определяет, какие это символы.  @xref{Syntax Tables}.

@item \W
@cindex @samp{\W} in regexp
Соответствует любому символу, который не является составной частью слова.

@item \s@var{code}
@cindex @samp{\s} in regexp
Соответствует любому символу, синтаксис которого это @var{code}.  Вот @var{code} это
символ, который представляет собой синтаксический код: таким образом, @samp{w} За слово
учредительный, @samp{-} для пробелов, @samp{(} для открытых круглых скобок,
и т.д. Чтобы представить простой синтаксис, используйте либо @samp{-} Или пробельный
символ.  @xref{Syntax Class Table}, для списка кодов синтаксиса и
символов, которые стоят за них.

@item \S@var{code}
@cindex @samp{\S} in regexp
Соответствует любому символу, синтаксис которого не является @var{code}.

@cindex category, regexp search for
@item \c@var{c}
Соответствует любому символу, чья категория @var{c}.  Вот @var{c} это
символ, который представляет категорию: таким образом, @samp{c} для китайских
символов или @samp{g} для греческих символов в стандартной таблицет категорий. 
Вы можете просмотреть список всех существующих в настоящее время категорий
введя @kbd{M-x describe-categories @key{RET}}.  Вы также можете определить
ваши собственные категории в дополнение к стандартным, используя
@code{define-category} функцию (@pxref{Categories}).

@item \C@var{c}
Соответствует любому символу, чья категория не является @var{c}.
@end table

  Следующие конструкции регулярных выражений соответствуют пустой строке --- то есть,
они не используют никаких символов --- но соответствуют зависимости от
контекста. Начало и конец доступной части буфера обрабатывается так, как если бы они были 
фактическим началом и концом буфера.

@table @samp
@item \`
@cindex @samp{\`} in regexp
Соответствует пустой строке, но только в начале
буфера или строки.

@item \'
@cindex @samp{\'} in regexp
Соответствует пустой строке, но только в конце
буфера или строки.

@item \=
@cindex @samp{\=} in regexp
Соответствует пустой строке, но только в точке.
(Эта конструкция не определяется при сопоставлении с строкой.)

@item \b
@cindex @samp{\b} in regexp
Соответствует пустой строке, но только в начале или
конце слова. таким образом, @samp{\bfoo\b} Соответствует любому вхождению
@samp{foo} как отдельного слова.  @samp{\bballs?\b} соответствует
@samp{ball} или @samp{balls} как отдельное слово.

@samp{\b} совпадает в начале или конце буфера (или строки)
независимо от того, какой текст появляется рядом с ним.

@item \B
@cindex @samp{\B} in regexp
Соответствует пустой строке, но @emph{not} в начале или в начале
конца слова, ни в начале, ни в конце буфера (или строки).

@item \<
@cindex @samp{\<} in regexp
Соответствует пустой строке, но только в начале слова.
@samp{\<} совпадение в начале буфера (или строки), только если
следует словосочетание.

@item \>
@cindex @samp{\>} in regexp
Соответствует пустой строке, но только в конце слова.  @samp{\>}
совпадение в конце буфера (или строки), только если конец содержит
словосочетание.

@item \_<
@cindex @samp{\_<} in regexp
Соответствует пустой строке, но только в начале символа.
Символ представляет собой последовательность одного или нескольких составляющих
слова или символа.  @samp{\_<} совпадение в начале буфера (или
строка), только если есть символ-составляющий.

@item \_>
@cindex @samp{\_>} in regexp
Соответствует пустой строке, но только в конце символа.  @samp{\_>}
совпадений в конце буфера (или строки), только если конец содержимого
с символьно-составляющим символом.
@end table

@kindex invalid-regexp
  Не каждая строка является допустимым регулярным выражением. Например, строка
которая заканчивается внутри альтернативы символа без прерывания @samp{]}
является недопустимым, и поэтому строка, которая заканчивается одним @samp{\}.  Если
недопустимое регулярное выражение передается любой из функций поиска,
@code{invalid-regexp} сигнализирует ошибку.

@node Regexp Example
@subsection Complex Regexp Example

  Вот сложное регулярное выражение, которое ранее использовалось Emacs для
нахождения конца предложения вместе с любыми пробелами. (В настоящее время Emacs 
использует аналогичные, но более сложные значения по умолчанию
Regexp, построенное функцией @code{sentence-end}.
@xref{Standard Regexps}.)

  Ниже мы сначала показываем regexp как строку в синтаксисе Lisp (
отличая пробелы от символов табуляции), а затем 
оцениваем результат. Строковая константа начинается и заканчивается
двойными кавычками.  @samp{\"} означает двойную кавычку как часть
строки, @samp{\\} для обратной косой черты как части строки, @samp{\t} для
табуляции и @samp{\n} для новой строки.

@example
@group
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|@ @ \\)[ \t\n]*"
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|@ @ \\)[
]*"
@end group
@end example

@noindent
В выходных данных табуляция и новая строка отображаются сами за себя.

  Это регулярное выражение состоит из четырех частей подряд и может быть
расшифровывается следующим образом:

@table @code
@item [.?!]
Первая часть шаблона - символьный класс, которая соответствует
любому из трех символов: точка, знак вопроса и восклицательный знак.
Соответствие должно начинаться с одного из этих трех символов. (Эта
является одним вариантом, где новое стандартное регулярное выражение, 
используемое Emacs, отличается от старого. Новое значение также позволяет не-@acronym{ASCII}
символы, заканчивть предложение без каких-либо пробелов.)

@item []\"')@}]*
Вторая часть шаблона соответствует любым закрывающим скобкам и знакам, ноль или более
которых могут следовать за точкой, вопросительным или восклицательным знаком.  @code{\"} 
является синтаксисом Lisp для двойной кавычки в строке.  @samp{*} в конце указывает, что 
предшествующая конструкция регулярного выражения (символьный класс в этом случае) может 
повторяется ноль или более раз.

@item \\($\\|@ $\\|\t\\|@ @ \\)
Третья часть шаблона соответствует пробелу, который следует за
концом предложения: конец строки (необязательно с пробелом) или
табуляция или два пробела. Двойные обратные косые черты обозначают круглые скобки и
вертикальные столбцы как синтаксис регулярных выражений; Круглые скобки ограничивают
группу а вертикальные полосы - отдельные альтернативы. Знак доллара используется для 
соответствия конца строки.

@item [ \t\n]*
Наконец, последняя часть шаблона соответствует любому дополнительному пробелу
длинее минимального, необходимого для завершения предложения.
@end table

@node Regexp Functions
@subsection Regular Expression Functions

  Эти функции работают на регулярных выражениях.

@cindex quote special characters in regexp
@defun regexp-quote string
Эта функция возвращает регулярное выражение, единственное точное совпадение которому
@var{string}.  Используя это регулярное выражение в @code{looking-at} будет
выполняется только в том случае, если следующие символы в буфере @var{string};
использование его в функции поиска будет успешным, если поиск текста
содержит @var{string}.  @xref{Regexp Search}.

Это позволяет запрашивать точное совпадение строк или поиск при вызове
функции, которая требует регулярное выражение.

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

Одно использование @code{regexp-quote} состоит в том, чтобы совместить точное совпадение
строк с контекстом, описываемым как регулярное выражение. Например, этот поиск
строки, которая является значением @var{string}, окруженную пробелами:

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example
@end defun

@cindex optimize regexp
@defun regexp-opt strings &optional paren
Эта функция возвращает эффективное регулярное выражение, которое будет соответствовать
любой из строк в списке @var{strings}. Это полезно, когда вам
необходимо выполнить согласование или поиск как можно быстрее - например,
для Font Lock mode@footnote{Note that @code{regexp-opt} не
гарантируют, что его результат является абсолютно эффективной возможной формой.
Регулярное выражение с ручной настройкой иногда может быть немного
более эффективен, но почти никогда не стоит усилий.
@c E.g., see http://debbugs.gnu.org/2816

Необязательный аргументt @var{paren} может быть любым из следующих:

строка
    Результирующему регулярному выражению предшествует @var{paren} и затем
    @samp{\)}, e.g. использование @samp{"\\(?1:"} производит явно пронумерованную группу.

@code{words}
   Полученное регулярное выражение окружено @samp{\<\(} и @samp{\)\>}.

@code{symbols}
    Полученное регулярное выражение окружено @samp{\_<\(} и @samp{\)\_>}
    (Это часто бывает целесообразным при обработке ключевых слов
    языка программирования и тому подобное).

не-@code{nil}
    Полученное регулярное выражение окружено @samp{\(} и @samp{\)}.

@code{nil}
    Полученное регулярное выражение окружено @samp{\(?:} и @samp{\)},
    Если необходимо убедиться, что оператор постфикса добавлен 
    он будет применяться ко всему выражению.

Полученное регулярное выражение @code{regexp-opt} эквивалентно, но обычно
более эффективно, чем упрощенная версия:

@example
(defun simplified-regexp-opt (strings &optional paren)
 (let ((parens (cond ((stringp paren)       (cons paren "\\)"))
                     ((eq paren 'words)    '("\\<\\(" . "\\)\\>"))
                     ((eq paren 'symbols) '("\\_<\\(" . "\\)\\_>"))
                     ((null paren)          '("\\(?:" . "\\)"))
                     (t                       '("\\(" . "\\)")))))
   (concat (car paren)
           (mapconcat 'regexp-quote strings "\\|")
           (cdr paren))))
@end example
@end defun

@defun regexp-opt-depth regexp
Эта функция возвращает общее количество конструкций группировки
(Заключенные в скобки выражения) в @var{regexp}.  Это не включает
ненумерованные группы (@pxref{Regexp Backslash}).
@end defun

@c Supposedly an internal regexp-opt function, but table.el uses it at least.
@defun regexp-opt-charset chars
Эта функция возвращает регулярное выражение, соответствующее символу в
списке символов @var{chars}.

@example
(regexp-opt-charset '(?a ?b ?c ?d ?e))
     @result{} "[a-e]"
@end example
@end defun

@c Internal functions: regexp-opt-group

@node Regexp Search
@section Regular Expression Searching
@cindex regular expression searching
@cindex regexp searching
@cindex searching for regexp

  В GNU Emacs вы можете найти следующие совпадения для регулярного
выражения (@pxref{Syntax of Regexps}) либо поэтапно, либо нет.
Для инкрементных команд поиска см. @ref{Regexp Search, , Regular
Expression Search, emacs, The GNU Emacs Manual}.  Здесь мы описываем
только функции поиска полезных в программах. Основной является
@code{re-search-forward}.

  Эти функции поиска преобразуют регулярное выражение в многобайтовое, если
буфер многобайтовый; Они преобразуют регулярное выражение в унибайт
если буфер однобайтовый.  @xref{Text Representations}.

@deffn Command re-search-forward regexp &optional limit noerror count
Эта функция выполняет поиск вперед в текущем буфере для строки
текст, которая соответствует регулярному выражению @var{regexp}.  
Функция пропускает любое количество текста, которое не соответствует
@var{regexp}, и оставляет точку в конце первого найденного совпадения.
Она возвращает новое значение точки.

Если @var{limit} не-@code{nil}, это должно быть положением в текущем
буфере и определять верхнюю границу поиска. Не совпадает
после этой позициии.  Если @var{limit} опущено
или @code{nil}, по умолчанию используется конец доступной части
буфера.

Как поведет себя @code{re-search-forward} при сбое поиска зависит от
значения @var{noerror}:

@table @asis
@item @code{nil}
Сигнализирует @code{search-failed} ошибку.
@item @code{t}
Не делает ничего и возвращает @code{nil}.
@item anything else
Переместит точку на @var{limit} (или конец доступной части
буфера) и вернет @code{nil}.
@end table

Аргумент @var{noerror} влияет только на действующие поисковые запросы,
нахождения соответствия. Недопустимые аргументы вызывают ошибки независимо от
@var{noerror}.

Если @var{count} - положительное число @var{n}, поиск выполняется
@var{n} раз; каждый последующий поиск начинается в конце
предыдущего совпадения. Если все эти последующие поисковые запросы будут успешными,
вызов функции преуспевает, перемещает точку и возвращает новое значение.
В противном случае вызов функции завершается неудачно, результаты зависят от значения
в @var{noerror}, как описано выше. Если @var{count} является отрицательным
числом -@var{n}, поиск выполняется @var{n} раз в обратном направлении
(Назад).

В следующем примере точка находится перед @samp{T}.
Оценка вызова поиска перемещает точку до конца этой строки (между
 @samp{t} в @samp{hat} и новой строкой).

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command re-search-backward regexp &optional limit noerror count
This function searches backward in the current buffer for a string of
text that is matched by the regular expression @var{regexp}, leaving
point at the beginning of the first text found.

This function is analogous to @code{re-search-forward}, but they are not
simple mirror images.  @code{re-search-forward} finds the match whose
beginning is as close as possible to the starting point.  If
@code{re-search-backward} were a perfect mirror image, it would find the
match whose end is as close as possible.  However, in fact it finds the
match whose beginning is as close as possible (and yet ends before the
starting point).  The reason for this is that matching a regular
expression at a given spot always works from beginning to end, and
starts at a specified beginning position.

A true mirror-image of @code{re-search-forward} would require a special
feature for matching regular expressions from end to beginning.  It's
not worth the trouble of implementing that.
@end deffn

@defun string-match regexp string &optional start
This function returns the index of the start of the first match for
the regular expression @var{regexp} in @var{string}, or @code{nil} if
there is no match.  If @var{start} is non-@code{nil}, the search starts
at that index in @var{string}.

For example,

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
The index of the first character of the
string is 0, the index of the second character is 1, and so on.

If this function finds a match, the index of the first character beyond
the match is available as @code{(match-end 0)}.  @xref{Match Data}.

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun string-match-p regexp string &optional start
This predicate function does what @code{string-match} does, but it
avoids modifying the match data.
@end defun

@defun looking-at regexp
This function determines whether the text in the current buffer directly
following point matches the regular expression @var{regexp}.  ``Directly
following'' means precisely that: the search is ``anchored'' and it can
succeed only starting with the first character following point.  The
result is @code{t} if so, @code{nil} otherwise.

This function does not move point, but it does update the match data.
@xref{Match Data}.  If you need to test for a match without modifying
the match data, use @code{looking-at-p}, described below.

In this example, point is located directly before the @samp{T}.  If it
were anywhere else, the result would be @code{nil}.

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@defun looking-back regexp limit &optional greedy
This function returns @code{t} if @var{regexp} matches the text
immediately before point (i.e., ending at point), and @code{nil} otherwise.

Because regular expression matching works only going forward, this is
implemented by searching backwards from point for a match that ends at
point.  That can be quite slow if it has to search a long distance.
You can bound the time required by specifying a non-@code{nil} value
for @var{limit}, which says not to search before @var{limit}.  In this
case, the match that is found must begin at or after @var{limit}.
Here's an example:

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     @result{} t
(looking-back "read \"" 4)
     @result{} nil
@end group
@end example

If @var{greedy} is non-@code{nil}, this function extends the match
backwards as far as possible, stopping when a single additional
previous character cannot be part of a match for @var{regexp}.  When
the match is extended, its starting position is allowed to occur
before @var{limit}.

@c http://debbugs.gnu.org/5689
As a general recommendation, try to avoid using @code{looking-back}
wherever possible, since it is slow.  For this reason, there are no
plans to add a @code{looking-back-p} function.
@end defun

@defun looking-at-p regexp
This predicate function works like @code{looking-at}, but without
updating the match data.
@end defun

@defvar search-spaces-regexp
If this variable is non-@code{nil}, it should be a regular expression
that says how to search for whitespace.  In that case, any group of
spaces in a regular expression being searched for stands for use of
this regular expression.  However, spaces inside of constructs such as
@samp{[@dots{}]} and @samp{*}, @samp{+}, @samp{?} are not affected by
@code{search-spaces-regexp}.

Since this variable affects all regular expression search and match
constructs, you should bind it temporarily for as small as possible
a part of the code.
@end defvar

@node POSIX Regexps
@section POSIX Regular Expression Searching

@cindex backtracking and POSIX regular expressions
  The usual regular expression functions do backtracking when necessary
to handle the @samp{\|} and repetition constructs, but they continue
this only until they find @emph{some} match.  Then they succeed and
report the first match found.

  This section describes alternative search functions which perform the
full backtracking specified by the POSIX standard for regular expression
matching.  They continue backtracking until they have tried all
possibilities and found all matches, so they can report the longest
match, as required by POSIX@.  This is much slower, so use these
functions only when you really need the longest match.

  The POSIX search and match functions do not properly support the
non-greedy repetition operators (@pxref{Regexp Special, non-greedy}).
This is because POSIX backtracking conflicts with the semantics of
non-greedy repetition.

@deffn Command posix-search-forward regexp &optional limit noerror count
This is like @code{re-search-forward} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end deffn

@deffn Command posix-search-backward regexp &optional limit noerror count
This is like @code{re-search-backward} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end deffn

@defun posix-looking-at regexp
This is like @code{looking-at} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end defun

@defun posix-string-match regexp string &optional start
This is like @code{string-match} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end defun

@node Match Data
@section The Match Data
@cindex match data

  Emacs keeps track of the start and end positions of the segments of
text found during a search; this is called the @dfn{match data}.
Thanks to the match data, you can search for a complex pattern, such
as a date in a mail message, and then extract parts of the match under
control of the pattern.

  Because the match data normally describe the most recent search only,
you must be careful not to do another search inadvertently between the
search you wish to refer back to and the use of the match data.  If you
can't avoid another intervening search, you must save and restore the
match data around it, to prevent it from being overwritten.

  Notice that all functions are allowed to overwrite the match data
unless they're explicitly documented not to do so.  A consequence is
that functions that are run implicitly in the background
(@pxref{Timers}, and @ref{Idle Timers}) should likely save and restore
the match data explicitly.

@menu
* Replacing Match::       Replacing a substring that was matched.
* Simple Match Data::     Accessing single items of match data,
                            such as where a particular subexpression started.
* Entire Match Data::     Accessing the entire match data at once, as a list.
* Saving Match Data::     Saving and restoring the match data.
@end menu

@node Replacing Match
@subsection Replacing the Text that Matched
@cindex replace matched text

  This function replaces all or part of the text matched by the last
search.  It works by means of the match data.

@cindex case in replacements
@defun replace-match replacement &optional fixedcase literal string subexp
This function performs a replacement operation on a buffer or string.

If you did the last search in a buffer, you should omit the
@var{string} argument or specify @code{nil} for it, and make sure that
the current buffer is the one in which you performed the last search.
Then this function edits the buffer, replacing the matched text with
@var{replacement}.  It leaves point at the end of the replacement
text.

If you performed the last search on a string, pass the same string as
@var{string}.  Then this function returns a new string, in which the
matched text is replaced by @var{replacement}.

If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses
the replacement text without case conversion; otherwise, it converts
the replacement text depending upon the capitalization of the text to
be replaced.  If the original text is all upper case, this converts
the replacement text to upper case.  If all words of the original text
are capitalized, this capitalizes all the words of the replacement
text.  If all the words are one-letter and they are all upper case,
they are treated as capitalized words rather than all-upper-case
words.

If @var{literal} is non-@code{nil}, then @var{replacement} is inserted
exactly as it is, the only alterations being case changes as needed.
If it is @code{nil} (the default), then the character @samp{\} is treated
specially.  If a @samp{\} appears in @var{replacement}, then it must be
part of one of the following sequences:

@table @asis
@item @samp{\&}
@cindex @samp{&} in replacement
This stands for the entire text being replaced.

@item @samp{\@var{n}}, where @var{n} is a digit
@cindex @samp{\@var{n}} in replacement
This stands for the text that matched the @var{n}th subexpression in
the original regexp.  Subexpressions are those expressions grouped
inside @samp{\(@dots{}\)}.  If the @var{n}th subexpression never
matched, an empty string is substituted.

@item @samp{\\}
@cindex @samp{\} in replacement
This stands for a single @samp{\} in the replacement text.

@item @samp{\?}
This stands for itself (for compatibility with @code{replace-regexp}
and related commands; @pxref{Regexp Replace,,, emacs, The GNU
Emacs Manual}).
@end table

@noindent
Any other character following @samp{\} signals an error.

The substitutions performed by @samp{\&} and @samp{\@var{n}} occur
after case conversion, if any.  Therefore, the strings they substitute
are never case-converted.

If @var{subexp} is non-@code{nil}, that says to replace just
subexpression number @var{subexp} of the regexp that was matched, not
the entire match.  For example, after matching @samp{foo \(ba*r\)},
calling @code{replace-match} with 1 as @var{subexp} means to replace
just the text that matched @samp{\(ba*r\)}.
@end defun

@defun match-substitute-replacement replacement &optional fixedcase literal string subexp
This function returns the text that would be inserted into the buffer
by @code{replace-match}, but without modifying the buffer.  It is
useful if you want to present the user with actual replacement result,
with constructs like @samp{\@var{n}} or @samp{\&} substituted with
matched groups.  Arguments @var{replacement} and optional
@var{fixedcase}, @var{literal}, @var{string} and @var{subexp} have the
same meaning as for @code{replace-match}.
@end defun

@node Simple Match Data
@subsection Simple Match Data Access

  This section explains how to use the match data to find out what was
matched by the last search or match operation, if it succeeded.

  You can ask about the entire matching text, or about a particular
parenthetical subexpression of a regular expression.  The @var{count}
argument in the functions below specifies which.  If @var{count} is
zero, you are asking about the entire match.  If @var{count} is
positive, it specifies which subexpression you want.

  Recall that the subexpressions of a regular expression are those
expressions grouped with escaped parentheses, @samp{\(@dots{}\)}.  The
@var{count}th subexpression is found by counting occurrences of
@samp{\(} from the beginning of the whole regular expression.  The first
subexpression is numbered 1, the second 2, and so on.  Only regular
expressions can have subexpressions---after a simple string search, the
only information available is about the entire match.

  Every successful search sets the match data.  Therefore, you should
query the match data immediately after searching, before calling any
other function that might perform another search.  Alternatively, you
may save and restore the match data (@pxref{Saving Match Data}) around
the call to functions that could perform another search.  Or use the
functions that explicitly do not modify the match data;
e.g., @code{string-match-p}.

@c This is an old comment and presumably there is no prospect of this
@c changing now.  But still the advice stands.
  A search which fails may or may not alter the match data.  In the
current implementation, it does not, but we may change it in the
future.  Don't try to rely on the value of the match data after a
failing search.

@defun match-string count &optional in-string
This function returns, as a string, the text matched in the last search
or match operation.  It returns the entire text if @var{count} is zero,
or just the portion corresponding to the @var{count}th parenthetical
subexpression, if @var{count} is positive.

If the last such operation was done against a string with
@code{string-match}, then you should pass the same string as the
argument @var{in-string}.  After a buffer search or match,
you should omit @var{in-string} or pass @code{nil} for it; but you
should make sure that the current buffer when you call
@code{match-string} is the one in which you did the searching or
matching.  Failure to follow this advice will lead to incorrect results.

The value is @code{nil} if @var{count} is out of range, or for a
subexpression inside a @samp{\|} alternative that wasn't used or a
repetition that repeated zero times.
@end defun

@defun match-string-no-properties count &optional in-string
This function is like @code{match-string} except that the result
has no text properties.
@end defun

@defun match-beginning count
If the last regular expression search found a match, this function
returns the position of the start of the matching text or of a
subexpression of it.

If @var{count} is zero, then the value is the position of the start of
the entire match.  Otherwise, @var{count} specifies a subexpression in
the regular expression, and the value of the function is the starting
position of the match for that subexpression.

The value is @code{nil} for a subexpression inside a @samp{\|}
alternative that wasn't used or a repetition that repeated zero times.
@end defun

@defun match-end count
This function is like @code{match-beginning} except that it returns the
position of the end of the match, rather than the position of the
beginning.
@end defun

  Here is an example of using the match data, with a comment showing the
positions within the text:

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{The beginning of the match}
     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}
@end group

@group
(match-beginning 2)       ; @r{The beginning of the match}
     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}
@end group

@group
(match-end 1)             ; @r{The end of the match}
     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}

(match-end 2)             ; @r{The end of the match}
     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}
@end group
@end example

  Here is another example.  Point is initially located at the beginning
of the line.  Searching moves point to between the space and the word
@samp{in}.  The beginning of the entire match is at the 9th character of
the buffer (@samp{T}), and the beginning of the match for the first
subexpression is at the 13th character (@samp{c}).

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (17 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
(In this case, the index returned is a buffer position; the first
character of the buffer counts as 1.)

@node Entire Match Data
@subsection Accessing the Entire Match Data

  The functions @code{match-data} and @code{set-match-data} read or
write the entire match data, all at once.

@defun match-data &optional integers reuse reseat
This function returns a list of positions (markers or integers) that
record all the information on the text that the last search matched.
Element zero is the position of the beginning of the match for the
whole expression; element one is the position of the end of the match
for the expression.  The next two elements are the positions of the
beginning and end of the match for the first subexpression, and so on.
In general, element
@ifnottex
number 2@var{n}
@end ifnottex
@tex
number {\mathsurround=0pt $2n$}
@end tex
corresponds to @code{(match-beginning @var{n})}; and
element
@ifnottex
number 2@var{n} + 1
@end ifnottex
@tex
number {\mathsurround=0pt $2n+1$}
@end tex
corresponds to @code{(match-end @var{n})}.

Normally all the elements are markers or @code{nil}, but if
@var{integers} is non-@code{nil}, that means to use integers instead
of markers.  (In that case, the buffer itself is appended as an
additional element at the end of the list, to facilitate complete
restoration of the match data.)  If the last match was done on a
string with @code{string-match}, then integers are always used,
since markers can't point into a string.

If @var{reuse} is non-@code{nil}, it should be a list.  In that case,
@code{match-data} stores the match data in @var{reuse}.  That is,
@var{reuse} is destructively modified.  @var{reuse} does not need to
have the right length.  If it is not long enough to contain the match
data, it is extended.  If it is too long, the length of @var{reuse}
stays the same, but the elements that were not used are set to
@code{nil}.  The purpose of this feature is to reduce the need for
garbage collection.

If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list
are reseated to point to nowhere.

As always, there must be no possibility of intervening searches between
the call to a search function and the call to @code{match-data} that is
intended to access the match data for that search.

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list &optional reseat
This function sets the match data from the elements of @var{match-list},
which should be a list that was the value of a previous call to
@code{match-data}.  (More precisely, anything that has the same format
will work.)

If @var{match-list} refers to a buffer that doesn't exist, you don't get
an error; that sets the match data in a meaningless but harmless way.

If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list
are reseated to point to nowhere.

@c TODO Make it properly obsolete.
@findex store-match-data
@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}.
@end defun

@node Saving Match Data
@subsection Saving and Restoring the Match Data

  When you call a function that may search, you may need to save
and restore the match data around that call, if you want to preserve the
match data from an earlier search for later use.  Here is an example
that shows the problem that arises if you fail to save the match data:

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{@code{foo} does more searching.}
(match-end 0)
     @result{} 61              ; @r{Unexpected result---not 48!}
@end group
@end example

  You can save and restore the match data with @code{save-match-data}:

@defmac save-match-data body@dots{}
This macro executes @var{body}, saving and restoring the match
data around it.  The return value is the value of the last form in
@var{body}.
@end defmac

  You could use @code{set-match-data} together with @code{match-data} to
imitate the effect of the special form @code{save-match-data}.  Here is
how:

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{Ok to change the original match data.}
    (set-match-data data)))
@end group
@end example

  Emacs automatically saves and restores the match data when it runs
process filter functions (@pxref{Filter Functions}) and process
sentinels (@pxref{Sentinels}).

@ignore
  Here is a function which restores the match data provided the buffer
associated with it still exists.

@smallexample
@group
(defun restore-match-data (data)
@c It is incorrect to split the first line of a doc string.
@c If there's a problem here, it should be solved in some other way.
  "Restore the match data DATA unless the buffer is missing."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{buffer is deleted.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Search and Replace
@section Search and Replace
@cindex replacement after search
@cindex searching and replacing

  If you want to find all matches for a regexp in part of the buffer,
and replace them, the best way is to write an explicit loop using
@code{re-search-forward} and @code{replace-match}, like this:

@example
(while (re-search-forward "foo[ \t]+bar" nil t)
  (replace-match "foobar"))
@end example

@noindent
@xref{Replacing Match,, Replacing the Text that Matched}, for a
description of @code{replace-match}.

  However, replacing matches in a string is more complex, especially
if you want to do it efficiently.  So Emacs provides a function to do
this.

@defun replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
This function copies @var{string} and searches it for matches for
@var{regexp}, and replaces them with @var{rep}.  It returns the
modified copy.  If @var{start} is non-@code{nil}, the search for
matches starts at that index in @var{string}, so matches starting
before that index are not changed.

This function uses @code{replace-match} to do the replacement, and it
passes the optional arguments @var{fixedcase}, @var{literal} and
@var{subexp} along to @code{replace-match}.

Instead of a string, @var{rep} can be a function.  In that case,
@code{replace-regexp-in-string} calls @var{rep} for each match,
passing the text of the match as its sole argument.  It collects the
value @var{rep} returns and passes that to @code{replace-match} as the
replacement string.  The match data at this point are the result
of matching @var{regexp} against a substring of @var{string}.
@end defun

  If you want to write a command along the lines of @code{query-replace},
you can use @code{perform-replace} to do the work.

@defun perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end
This function is the guts of @code{query-replace} and related
commands.  It searches for occurrences of @var{from-string} in the
text between positions @var{start} and @var{end} and replaces some or
all of them.  If @var{start} is @code{nil} (or omitted), point is used
instead, and the end of the buffer's accessible portion is used for
@var{end}.

If @var{query-flag} is @code{nil}, it replaces all
occurrences; otherwise, it asks the user what to do about each one.

If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is
considered a regular expression; otherwise, it must match literally.  If
@var{delimited-flag} is non-@code{nil}, then only replacements
surrounded by word boundaries are considered.

The argument @var{replacements} specifies what to replace occurrences
with.  If it is a string, that string is used.  It can also be a list of
strings, to be used in cyclic order.

If @var{replacements} is a cons cell, @w{@code{(@var{function}
. @var{data})}}, this means to call @var{function} after each match to
get the replacement text.  This function is called with two arguments:
@var{data}, and the number of replacements already made.

If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then
it specifies how many times to use each of the strings in the
@var{replacements} list before advancing cyclically to the next one.

If @var{from-string} contains upper-case letters, then
@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and
it uses the @var{replacements} without altering their case.

Normally, the keymap @code{query-replace-map} defines the possible
user responses for queries.  The argument @var{map}, if
non-@code{nil}, specifies a keymap to use instead of
@code{query-replace-map}.

This function uses one of two functions to search for the next
occurrence of @var{from-string}.  These functions are specified by the
values of two variables: @code{replace-re-search-function} and
@code{replace-search-function}.  The former is called when the
argument @var{regexp-flag} is non-@code{nil}, the latter when it is
@code{nil}.
@end defun

@defvar query-replace-map
This variable holds a special keymap that defines the valid user
responses for @code{perform-replace} and the commands that use it, as
well as @code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual
in two ways:

@itemize @bullet
@item
The key bindings are not commands, just symbols that are meaningful
to the functions that use this map.

@item
Prefix keys are not supported; each key binding must be for a
single-event key sequence.  This is because the functions don't use
@code{read-key-sequence} to get the input; instead, they read a single
event and look it up ``by hand''.
@end itemize
@end defvar

Here are the meaningful bindings for @code{query-replace-map}.
Several of them are meaningful only for @code{query-replace} and
friends.

@table @code
@item act
Do take the action being considered---in other words, ``yes''.

@item skip
Do not take action for this question---in other words, ``no''.

@item exit
Answer this question ``no'', and give up on the entire series of
questions, assuming that the answers will be ``no''.

@item exit-prefix
Like @code{exit}, but add the key that was pressed to
@code{unread-command-events} (@pxref{Event Input Misc}).

@item act-and-exit
Answer this question ``yes'', and give up on the entire series of
questions, assuming that subsequent answers will be ``no''.

@item act-and-show
Answer this question ``yes'', but show the results---don't advance yet
to the next question.

@item automatic
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction.

@item backup
Move back to the previous place that a question was asked about.

@item edit
Enter a recursive edit to deal with this question---instead of any
other action that would normally be taken.

@item edit-replacement
Edit the replacement for this question in the minibuffer.

@item delete-and-edit
Delete the text being considered, then enter a recursive edit to replace
it.

@item recenter
@itemx scroll-up
@itemx scroll-down
@itemx scroll-other-window
@itemx scroll-other-window-down
Perform the specified window scroll operation, then ask the same
question again.  Only @code{y-or-n-p} and related functions use this
answer.

@item quit
Perform a quit right away.  Only @code{y-or-n-p} and related functions
use this answer.

@item help
Display some help, then ask again.
@end table

@defvar multi-query-replace-map
This variable holds a keymap that extends @code{query-replace-map} by
providing additional keybindings that are useful in multi-buffer
replacements.  The additional bindings are:

@table @code
@item automatic-all
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction, for all remaining buffers.

@item exit-current
Answer this question ``no'', and give up on the entire series of
questions for the current buffer.  Continue to the next buffer in the
sequence.
@end table
@end defvar

@defvar replace-search-function
This variable specifies a function that @code{perform-replace} calls
to search for the next string to replace.  Its default value is
@code{search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{search-forward}
(@pxref{String Search}).
@end defvar

@defvar replace-re-search-function
This variable specifies a function that @code{perform-replace} calls
to search for the next regexp to replace.  Its default value is
@code{re-search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{re-search-forward}
(@pxref{Regexp Search}).
@end defvar

@node Standard Regexps
@section Standard Regular Expressions Used in Editing
@cindex regexps used standardly in editing
@cindex standard regexps used in editing

  This section describes some variables that hold regular expressions
used for certain purposes in editing:

@defopt page-delimiter
This is the regular expression describing line-beginnings that separate
pages.  The default value is @code{"^\014"} (i.e., @code{"^^L"} or
@code{"^\C-l"}); this matches a line that starts with a formfeed
character.
@end defopt

  The following two regular expressions should @emph{not} assume the
match always starts at the beginning of a line; they should not use
@samp{^} to anchor the match.  Most often, the paragraph commands do
check for a match only at the beginning of a line, which means that
@samp{^} would be superfluous.  When there is a nonzero left margin,
they accept matches that start after the left margin.  In that case, a
@samp{^} would be incorrect.  However, a @samp{^} is harmless in modes
where a left margin is never used.

@defopt paragraph-separate
This is the regular expression for recognizing the beginning of a line
that separates paragraphs.  (If you change this, you may have to
change @code{paragraph-start} also.)  The default value is
@w{@code{"[@ \t\f]*$"}}, which matches a line that consists entirely of
spaces, tabs, and form feeds (after its left margin).
@end defopt

@defopt paragraph-start
This is the regular expression for recognizing the beginning of a line
that starts @emph{or} separates paragraphs.  The default value is
@w{@code{"\f\\|[ \t]*$"}}, which matches a line containing only
whitespace or starting with a form feed (after its left margin).
@end defopt

@defopt sentence-end
If non-@code{nil}, the value should be a regular expression describing
the end of a sentence, including the whitespace following the
sentence.  (All paragraph boundaries also end sentences, regardless.)

If the value is @code{nil}, as it is by default, then the function
@code{sentence-end} constructs the regexp.  That is why you
should always call the function @code{sentence-end} to obtain the
regexp to be used to recognize the end of a sentence.
@end defopt

@defun sentence-end
This function returns the value of the variable @code{sentence-end},
if non-@code{nil}.  Otherwise it returns a default value based on the
values of the variables @code{sentence-end-double-space}
(@pxref{Definition of sentence-end-double-space}),
@code{sentence-end-without-period}, and
@code{sentence-end-without-space}.
@end defun
