@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2016 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Searching and Matching
@chapter Searching and Matching
@cindex searching

  GNU Emacs предоставляет два способа поиска через буфер для указанного
текста: поиск точных строк и поиск регулярных выражений. После
поиска с регулярными выражениями, вы можете изучить @dfn{match data} чтобы
определить, какой текст соответствует всему регулярному выражению или различным
его частям.

@menu
* String Search::         Поиск точного соответствия.
* Searching and Case::    Независимый от случая или существенный поиск.
* Regular Expressions::   Описание классов строк.
* Regexp Search::         Поиск соответствия регулярному выражению.
* POSIX Regexps::         Поиск POSIX-стиля для самого длинного совпадения.
* Match Data::            Выяснить, какая часть текста соответствует,
                                после поиска строки или регулярного выражения.
* Search and Replace::    Команды, выполняющие цикл, поиск и замену.
* Standard Regexps::      Полезные регулярные выражения для поиска предложений, страниц,...
@end menu

  @samp{skip-chars@dots{}} функции также выполняют своего рода поиск.
@xref{Skipping Characters}.  для изменения свойств поиска в настройках
свойства, see @ref{Property Search}.

@node String Search
@section Searching for Strings
@cindex string search

  Это примитивные функции для поиска по тексту в
буфере. Они предназначены для использования в программах, но вы можете их вызвать
в интерактивном режиме. Если вы это сделаете, они запросят строку поиска;
аргументы @var{limit} и @var{noerror} указывают на @code{nil}, и @var{repeat}
это 1.  Подробнее о интерактивном поиске, @pxref{Search,,
Searching and Replacement, emacs, The GNU Emacs Manual}.

  Эти функции поиска преобразуют строку поиска в многобайтовую, если
буфер многобайтовый; Они преобразуют строку поиска в unibyte, если
буфер является унибайтовым.  @xref{Text Representations}.

@deffn Command search-forward string &optional limit noerror count
Эта функция выполняет поиск вперед от точки для точного соответствия для
@var{string}.  В случае успеха она устанавливает точку в конце события
Found и возвращает новое значение точки. Если совпадение не найдено,
оценка и побочные эффекты зависят от @var{noerror} (see below).

В следующем примере точка начинается в начале
строки. затем @code{(search-forward "fox")} перемещает точку после последней
записи @samp{fox}:

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

Аргумент @var{limit} определяет привязку к поиску, и
становится позицией в текущем буфере. Отсутствие соответствия
эта позиция принимается.  Если @var{limit} опущено или @code{nil}, Это
по умолчанию доступная часть буфера.

@kindex search-failed
Что происходит, когда поиск не выполняется, зависит от значения
@var{noerror}.  Если @var{noerror} это @code{nil}, @code{search-failed}
сигнализирует ошибку.  Если @var{noerror} это @code{t}, @code{search-forward}
возвращает @code{nil} и ничего не делает.  Если @var{noerror} не является ни
@code{nil} ни @code{t}, тогда @code{search-forward} перемещает точку на
верхнюю границу и возвращает @code{nil}.
@c Я не вижу никакой перспективы, что это когда-либо изменится, и, откровенно говоря, нынешнее
@c поведение кажется лучше, поэтому нет необходимости упоминать об этом.
@ignore
(Теперь было бы более последовательным возвращение новой позиции точки
в этом случае, но некоторые существующие программы могут зависеть от значения
@code{nil}.)
@end ignore

Аргумент @var{noerror} влияет только на действительные поисковые запросы
нахождения соответствия. Недопустимые аргументы вызывают ошибки независимо от
@var{noerror}.

Если @var{count} - положительное число @var{n}, поиск выполнен
@var{n} раз; Каждый последующий поиск начинается в конце
предыдущего совпадения. Если все эти последующие поисковые запросы будут успешными,
вызов происходит вызов функции, перемещается точка и возвращается новое значение.
В противном случае вызов функции завершается неудачно, результаты зависят от значения
@var{noerror}, как описано выше.  Если @var{count} является отрицательным
числом -@var{n}, поиск выполнен @var{n} раз в обратном направлении
(назад).
@end deffn

@deffn Command search-backward string &optional limit noerror count
Эта функция выполняет поиск назад от точки для @var{string}.  это
например, @code {search-forward}, за исключением того, что он ищет
вперед. Обратный поиск оставляет точку в начале
совпадения.
@end deffn

@deffn Command word-search-forward string &optional limit noerror count
Эта функция выполняет поиск вперед от точки для соответствия слова для
@var{string}.  Если она находит совпадение, она устанавливает точку в конце
найденого совпадения и возвращает новое значение точки.

Соответствие слов @var{string} как последовательность слов, пренебрегая
пунктуацию, отделяющую их. Она ищет буфер для той же
последовательности слов. Каждое слово должно быть разным в буфере (поиск
слов @samp{ball} не соответствует слову @samp{balls}), но
детали пунктуации и пропусков игнорируются (searching for @samp{ball
boy} соответствует @samp{ball.  Boy!}).

В этом примере точка начинается в начале буфера;
поиск оставляет его между @samp{y} и @samp{!}.

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 39

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

Если @var{limit} не-@code{nil}, это должно быть положением в текущем
буфере; Оно определяет верхнюю границу поиска нахождения соответствий и
не расширяется после этой позиции.

Если @var{noerror} это @code{nil}, тогда @code{word-search-forward} сигнализирует
ошибку при поиске.  Если @var{noerror} это @code{t}, тогда 
вернет @code{nil} вместо того, чтобы сигнализировать об ошибке.  Если @var{noerror} это
ни @code{nil} и ни @code{t}, она перемещает точку @var{limit} (или
в конец доступной части буфера) и возвращает @code{nil}.

Если @var{count} - это положительное число, в котором указано, сколько последовательных
вхождений для поиска. Точка позиционируется в конце последнего
совпадения.  Если @var{count} - отрицательное число, поиск - назад
и точка позиционируется в начале последнего совпадения.

@findex word-search-regexp
Внутренне, @code{word-search-forward} и связанные функции используют
функцию @code{word-search-regexp} для преобразования @var{string} в
регулярное выражение, которое игнорирует пунктуацию.
@end deffn

@deffn Command word-search-forward-lax string &optional limit noerror count
Эта команда идентична @code{word-search-forward}, отлична тем что
начало или конец @var{string} не должно отвечать границе слова,
Если @var{string} начинается или заканчивается пробелом.
Например, поиск @samp{ball boy} соответствует @samp{ball boyee},
но не соответствует @samp{balls boy}.
@end deffn

@deffn Command word-search-backward string &optional limit noerror count
Эта функция выполняет поиск назад от точки для соответствия слова
@var{string}.  Эта функция аналогична @code{word-search-forward}
за исключением того, что она ищет назад и обычно оставляет точку на
в начале соответствия.
@end deffn

@deffn Command word-search-backward-lax string &optional limit noerror count
Эта команда идентична @code{word-search-backward}, и отличается тем что
начало или конец @var{string} не должно отвечать границе слова, 
если @var{string} начинается или заканчивается пробелом.
@end deffn

@node Searching and Case
@section Searching and Case
@cindex searching and case

  По умолчанию поиск в Emacs игнорирует регистр текста, в котором осуществляется
поиск ; Если вы указали поиск @samp{FOO}, тогда
@samp{Foo} или @samp{foo} также считается совпадением. Это относится и к
регулярным выражениям; таким образом, @samp{[aB]} находит соответствие @samp{a} или
@samp{A} или @samp{b} или @samp{B}.

  Если вы хотите изменить поведение этой функцию, установите переменную
@code{case-fold-search} в @code{nil}.  Тогда все буквы должны совпадать
всегда точно, включая регистр. Это локальная переменная буфера; Изменения
переменной влияет только на текущий буфер.  (@xref{Intro to
Buffer-Local}.)  Кроме того, вы можете изменить значение по умолчанию.
В коде Lisp вы чаще будете использовать @code{let} связывание
@code{case-fold-search} до желаемого значения.

  Обратите внимание, что функция инкрементного поиска на уровне пользователя обрабатывает 
отличие регистра по-разному. Когда строка поиска содержит только строчные
буквы, поиск игнорирует регистр, но когда строка поиска
содержит одну или несколько букв верхнего регистра, поиск становится
зависимым от регистра. Но это не имеет никакого отношения к поисковым
функциям, используемые в коде Lisp.  @xref{Incremental Search,,, emacs,
The GNU Emacs Manual}.

@defopt case-fold-search
Эта локальная переменная буфера определяет, следует ли игнорировать при
поиске регистр. Если переменная @code{nil} функции не игнорируют регистр; в противном случае
(И по умолчанию) они игнорируют регистр.
@end defopt

@defopt case-replace
Эта переменная определяет, как будет изменен регистр букв при замене в совпадении.
Если переменная @code{nil}, что означает использовать текст замены дословно.  Не-@code{nil} 
значение означает преобразование регистра заменяющего текста в соответствии с
текстом который заменяется.

Эта переменная используется путем передачи ее в качестве аргумента функции
@code{replace-match}.  @xref{Replacing Match}.
@end defopt

@node Regular Expressions
@section Regular Expressions
@cindex regular expression
@cindex regexp

  @dfn{regular expression}, или @dfn{regexp} для краткости - это шаблон, который
обозначает (возможно, бесконечное) множество строк. Поиск совпадений для
Regexp - очень мощная операция. В этом разделе объясняется, как писать
regexp. В следующем разделе говорится, как их искать.

@findex re-builder
@cindex regular expressions, developing
  Для интерактивной разработки регулярных выражений вы
может использовать @kbd{M-x re-builder} команду.  Это обеспечивает удобный
интерфейс для создания регулярных выражений, с обратной связью в отдельном буфере. 
Когда вы редактируете регулярное выражение, все его совпадения в целевом буфере выделены. 
Каждое подвыражение регулярного выражения показано на отдельном участке, что делает
проще проверить даже очень сложные регулярные выражения.

@menu
* Syntax of Regexps::       Правила написания регулярных выражений.
* Regexp Example::          Иллюстрация синтаксиса регулярных выражений.
* Regexp Functions::        Функции для работы с регулярными выражениями.
@end menu

@node Syntax of Regexps
@subsection Syntax of Regular Expressions
@cindex regexp syntax
@cindex syntax of regular expressions

  Регулярные выражения имеют синтаксис, в котором несколько символов
являются специальными конструкциями, а остальные - @dfn{ordinary}.  Обычный
символ - это простое регулярное выражение, которое соответствует этому символу
и ничего больше. Специальные символы это @samp{.}, @samp{*},
@samp{+}, @samp{?}, @samp{[}, @samp{^}, @samp{$}, и @samp{\}. Никакие новые
специальные символы не будут определены в будущем. Литерал
@samp{]} является специальным, если он заканчивает альтернативу символа (см. Ниже).
Литерал @samp{-} является особенным внутри альтернатив литерала.  
@samp{[:} и сбалансированый @samp{:]} заключит класс символа внутри
альтернатив символа. Любой другой литерал, появляющийся в обычном
выражении является обычным, если только ему не предшествует @samp{\}.

  Например, @samp{f} не является особым символом, поэтому он является обычным, и
следовательно @samp{f} является регулярным выражением, которое соответствует строке
@samp{f} и никакой другой строке.  (Оно делает @emph{not} соответствие строке
@samp{fg}, но он соответствует @emph{part} этой строки.) Аналогично,
@samp{o} является регулярным выражением, которое соответствует только @samp{o}.

  Любые два регулярных выражения @var{a} и @var{b} могут быть объединены.
Результатом является регулярное выражение, которое соответствует строке, если @var{a} 
начало этой строки и @var{b} остальная часть строки.

  В качестве простого примера мы можем конкатенировать регулярные выражения @samp{f}
и @samp{o} для получения регулярного выражения @samp {fo}, которое соответствует только
строке @samp{fo}.  Все еще тривиально. Чтобы сделать что-то более мощное, 
необходимо использовать одну из специальных конструкций регулярных выражений.

@menu
* Regexp Special::      Специальные символы в регулярных выражениях.
* Char Classes::        Классы символов, используемые в регулярных выражениях.
* Regexp Backslash::    Обратные последовательности в регулярных выражениях.
@end menu

@node Regexp Special
@subsubsection Special Characters in Regular Expressions
@cindex regexp, special characters in

  Вот список символов, которые являются особыми в регулярном
выражение.

@need 800
@table @asis
@item @samp{.}@: @r{(Period)}
@cindex @samp{.} in regexp
Это специальный символ, который соответствует любому одиночному символу, кроме новой строки.
Используя конкатенацию, мы можем сделать регулярное выражение типа @samp{a.b}, которому
соответствует любая трехсимвольная строка, которая начинается с @samp{a} и заканчивается
@samp{b}.

@item @samp{*}
@cindex @samp{*} in regexp
Не конструкция сама по себе, это постфиксный оператор, что означает
повторение регулярного выражения столько раз, сколько возможно.  Таким образом, 
@samp{o*} соответствует любому числу @samp{o}s (в том числе нулю @samp{o}s).

@samp{*} всегда относится к @emph{наименьшему} возможному предшествующему
выражению.  Таким образом, @samp{fo*} имеет повторяющийся @samp{o}, не повторяющийся
@samp{fo}.  Это соответствует @samp{f}, @samp{fo}, @samp{foo}, и так далее.

@cindex backtracking and regular expressions
Соответствие обрабатывается @samp{*} путем сопоставления, сразу, 
стольких повторений сколько можно найти. Затем продолжает с остальной частью
шаблона. Если это не удается, происходит обратное отслеживание, отбрасывая некоторые из
совпадений @samp{*}-модифицированных конструкций в надежде, что это 
позволит сопоставить остальную часть шаблона.  Для примера, в
согласовании @samp{ca*ar} со строкой @samp{caaar}, @samp{a*}
сначала пытается сопоставить все три @samp{a}s; но остальная часть шаблона
@samp{ar} и есть только @samp{r} слева, чтобы совместить, поэтому эта попытка не удалась.
Следующая альтернатива для @samp{a*} Чтобы соответствовать только двум @samp{a}s.  С
этим выбором, остальные регулярные выражения успешно совпадают.

@strong{Внимание:} Операторы вложенных повторений могут запускаться
бесконечно долгое время, если они приводят к неоднозначному согласованию. Для
примера, пытаясь сопоставить регулярное выражение @samp{\(x+y*\)*a}
строке @samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz} может потребовать
несколько часов, прежде чем это в конечном итоге потерпит неудачу. Emacs должен 
попробовать каждый способ руппируя @samp {x} ы, прежде чем заключить, что никто из них 
не больше соответствует.
Еще хуже, @samp{\(x*\)*} может бесконечно совпадать с нулевой строкой
множеством способов, поэтому это вызывает бесконечный цикл. Чтобы избежать этих проблем,
тщательно проверяйте вложенные повторения, чтобы убедиться, что они не
вызовут комбинаторные взрывы при отклонении
.

@item @samp{+}
@cindex @samp{+} in regexp
Является постфиксным оператором, аналогичным @samp{*} за исключением того, что он 
должен соответствовать предыдущему выражению хотя бы один раз. Так, например,, @samp{ca+r}
соответствует строкам @samp{car} и @samp{caaaar} но не строке
@samp{cr}, в то время как @samp{ca*r} соответствует всем трем строкам.

@item @samp{?}
@cindex @samp{?} in regexp
Является постфиксным оператором, аналогичным @samp{*} за исключением того, что он 
должен соответствовать предшествующему выражению либо один раз, либо вообще 
нет. Например, @samp{ca?r} соответствует @samp{car} или @samp{cr}; и ничему более.

@item @samp{*?}, @samp{+?}, @samp{??}
@cindex non-greedy repetition characters in regexp
Эти @dfn{non-greedy} варианты операторов @samp{*}, @samp{+}
и @samp{?}.  Где эти операторы соответствуют максимально возможной
подстроке (согласуясь с совпадением всего содержащего выражения),
Нежелательные варианты соответствуют наименьшей возможной подстроке
(В соответствии с совпадением всего содержащего выражения).

Например, регулярное выражение @samp{c[ad]*a} применимое к
строке @samp{cdaaada} соответствует всей строке; Но регулярные
выражение @samp{c[ad]*?a}, применяемое к той же строке, соответствует только
@samp{cda}.  (Наименьшее возможное совпадение здесь для @samp{[ad]*?} что
позволяет совместить все выражение @samp{d}.)

@item @samp{[ @dots{} ]}
@cindex character alternative (in regexp)
@cindex @samp{[} in regexp
@cindex @samp{]} in regexp
Выражение @dfn{character alternative}, которое начинается с @samp{[} и 
оканчивается @samp{]}.  В простейшем случае символы между
двух скобок - это то, что может соответствовать этой альтернативе.

Таким образом, @samp{[ad]} соответствует одному @samp{a} или одному @samp{d}, или
@samp{[ad]*} соответствует любой строке, состоящей только из @samp{a}s и @samp{d}s
(включая пустую строку).  Следовательно, что @samp{c[ad]*r}
соответствует @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, и т.д.

Вы также можете включить диапазоны символов в альтернативу символов,
записав начальный и конечный символ с помощью @samp{-} между ними.
Таким образом, @samp{[a-z]} соответствует любому символу нижнего регистра @acronym{ASCII} письма.
Диапазоны могут смешиваться свободно с отдельными символами, как в
@samp{[a-z$%.]}, который соответствует любому нижнему регистру @acronym{ASCII} письма
или @samp{$}, @samp{%} или пробелу.

Если @code{case-fold-search} не-@code{nil}, @samp{[a-z]} также
соответствует заглавным буквам. Обратите внимание, что диапазон, подобный 
@samp{[a-z]} не зависит от последовательности сортировки локали, она всегда представляет
последовательность в @acronym{ASCII} стандарте.
@c Это не было очевидно для меня, так как, например, руководство grep «Символьные
@c классы и выражения скобок "в частности отмечает обратное
@c поведение. Но эксперимент Emacs кажется незатронутым LC_COLLATE
@c в этой связи.

Также обратите внимание, что обычные специальные символы регулярного выражения не 
являются особыми внутри символов альтернативы. Установлен совершенно другой набор 
специальных символов внутри символов альтернативы: @samp{]}, @samp{-} and @samp{^}.

Включить литерал @samp{]} в альтернативу, можно указав его
первым символ. Например, @samp{[]a]} соответствует @samp{]} или @samp{a}.
Для включения @samp{-}, записывайте @samp{-} первым или последним 
символом альтернативы, или поместить его после пробела, таким образом, @samp{[]-]}
соответствует @samp{]} и @samp{-}.  (как объяснено ниже, вы не можете
использовать @samp{\]} включая литерал @samp{]} внутри альтернатив символа,
поскольку литерал @samp{\} там не спец символ.)

Для включения @samp{^} в альтернативе персонажей, поместите его куда угодно, но
не в начало.

@c Что, если он начинается с многобайтового и заканчивается однобайтом?
@c Это не похоже на что-либо...?
Если диапазон начинается с символа unibyte @var{c} и заканчивается
многобайтовым символом @var{c2}, диапазон делится на две части: один
охватывает однобайтовые символы @samp{@var{c}..?\377}, другой
многобайтовые символы @samp{@var{c1}..@var{c2}}, где @var{c1} это
первый символ кодировки, к которой @var{c2} принадлежит.

Альтернатива символа также может указывать именованные классы символов
(@pxref{Char Classes}).  Это функция POSIX. Например,
@samp{[[:ascii:]]} соответствует любому @acronym{ASCII} символу.
Использование класса символов эквивалентно упоминанию каждого из
символа в этом классе; Но на практике это практически невозможно,
поскольку некоторые классы включают тысячи разных символов.

@item @samp{[^ @dots{} ]}
@cindex @samp{^} in regexp
@samp{[^} вначале @dfn{complemented character alternative}.  Эта
соответствует любому символу, кроме указанных. таким образом,
@samp{[^a-z0-9A-Z]} соответствует всем символам кроме @emph{except} письма и
цифр.

@samp{^} не является особенным в альтернативе персонажа, если он не является первым
литералом. Следующий за любым литералом @samp{^} обрабатывается не так, как если бы он
первым (другими словами как @samp{-} и @samp{]} ).

В дополнение литерал может соответствовать новой строке, если только
новая строка не является упомянутой как один из символов, которым это не соответствуют. Это 
в отличие от обработка регулярных выражений в программах, таких как @code{grep}.

Вы можете указать именованные классы символов, как и в символе
альтернативы. Например, @samp{[^[:ascii:]]} соответствует любому
не-@acronym{ASCII} символу.  @xref{Char Classes}.

@item @samp{^}
@cindex beginning of line in regexp
При сопоставлении буферу, @samp{^} соответствует пустой строке, но только в
начале строки в согласованном тексте (или в начале
доступной части буфера). В противном случае это не соответствует
чему-нибудь. Таким образом, @samp{^foo} соответствует @samp{foo} которая находится в
начале строки.

При сопоставлении строки вместо буфера, @samp{^} соответствует
началу строки или после символа новой строки.

По причинам исторической совместимости, @samp{^} может использоваться только в
начале регулярного выражения или после @samp{\(}, @samp{\(?:}
или @samp{\|}.

@item @samp{$}
@cindex @samp{$} in regexp
@cindex end of line in regexp
похож на @samp{^} но соответствует только в конце строки (или
в конце доступной части буфера).  Таким образом, @samp{x+$}
соответствует из строке одного @samp{x} или более в конце строки.

При сопоставлении строки позиции буфера, @samp{$} соответствует в конце
строки или перед символом новой строки.

По причинам исторической совместимости, @samp{$} может использоваться только на
конце регулярного выражения или до @samp{\)} или @samp{\|}.

@item @samp{\}
@cindex @samp{\} in regexp
Имеет две функции: он цитирует специальные символы (в том числе
@samp{\}), и он вводит дополнительные специальные конструкции.

Потому как @samp{\} цитирует специальные символы, @samp{\$} является регулярным
выражением, которое соответствует только @samp{$}, и @samp{\[} является регулярным
выражением, которое соответствует только @samp{[}, и ни чему более.

Обратите внимание, что @samp{\} также имеет особое значение в синтаксисе чтения Lisp
строки (@pxref{String Type}), Например, регулярное выражение, соответствующее @samp{\} литералу
@samp{\\}.  Чтобы написать строку Lisp, содержащую символы
@samp{\\}, Синтаксис Lisp требует, чтобы вы процитировали каждый @samp{\} с другим
@samp{\}.  Поэтому синтаксис чтения для регулярного выражения
@samp{\} это @code{"\\\\"}.
@end table

@strong{Обратите внимание:} Для исторической совместимости специальные символы
рассматриваются как обычные, если они находятся в контекстах, где их особые
значения не имеют смысла. Например, @samp{*foo} воспримет @samp{*} в виде обычного
символа поскольку нет предыдущего выражения, на которое @samp{*}
может действовать. Это плохая практика использования этого поведения; Цитируйте
в любом случае, независимо от того, где он появляется.

Как @samp{\} не является особенным внутри альтернатив литерала, он не может
удалить специального значения @samp{-} или @samp{]}.  Так что вы
можете не цитировать эти литералы когда они не имеют особого значения
Это ничего не прояснит, так как обратная косая черта может
законно предшествуют этим персонажам, где они @emph{have} особое
значение, как в @samp{[^\]} (@code{"[^\\]"} для синтаксиса строки Lisp),
которое соответствует любому одиночному символу, кроме обратной косой черты.

На практике большинство @samp{]} которые встречаются в регулярных выражениях, закрывают
альтернативный символ и, следовательно, являются особыми. Однако иногда
регулярное выражение может попытаться сопоставить сложный шаблон литерала
@samp{[} и @samp{]}.  В таких ситуациях иногда может быть
необходимо тщательно проанализировать регулярное выражение с самого начала, чтобы 
определить квадратные скобки заключающие альтернативу символов. Например,
@samp{[^][]]} состоит из дополненной альтернативы символа
@samp{[^][]} (которое соответствует любому одиночному символу, который не является квадратной
скобкой), за которым следует буквальный символ @samp{]}.

Точные правила заключаются в том, что в начале регулярного выражения, @samp{[} является
специальным а @samp{]} нет.  Это длится до первого неуказанного
@samp{[}, после чего мы находимся в альтернативе символа; @samp{[} 
больше не является специальным (кроме случаев, когда он запускает класс символов), но @samp{]}
является особенным, если только он не @samp{[} или это
@samp{[} а затем @samp{^}.  Это продолжается до следующего специального
@samp{]} что не заканчивает класс символов. Это заканчивает характер
альтернативу символа и восстанавливает обычный синтаксис регулярных выражений;
Неупомянутый @samp{[} является особенным снова а @samp{]} нет.

@node Char Classes
@subsubsection Character Classes
@cindex character classes in regexp

  Вот таблица классов, которые вы можете использовать в альтернативе символов,
И что они означают:

@table @samp
@item [:ascii:]
Это соответствует любому @acronym{ASCII} символу (codes 0--127).
@item [:alnum:]
Это соответствует любой букве или цифре. Для многобайтовых символов это
соответствует символам, Unicode @samp{general-category} настройки
(@pxref{Character Properties}) указывает, что они являются алфавитными или
десятичными числами.
@item [:alpha:]
Это соответствует любой букве. Для многобайтовых символов это соответствует
символу, Unicode @samp{general-category} property
(@pxref{Character Properties}) указывает, что они являются алфавитными
символами.
@item [:blank:]
Это соответствует только пробелу и вкладке.
@item [:cntrl:]
Это соответствует любому @acronym{ASCII} контрольному символу.
@item [:digit:]
Это соответствует @samp{0} через @samp{9}.  таким образом, @samp{[-+[:digit:]]}
Соответствует любой цифре, а также @samp{+} и @samp{-}.
@item [:graph:]
Это соответствует графическим символам --- все, кроме пробелов,
@acronym{ASCII} и не-@acronym{ASCII} контрольным символам,
суррогатам и кодовым точкам, не назначенных Unicode, как указано
Unicode @samp{general-category} свойство (@pxref{Character
Properties}).
@item [:lower:]
Это соответствует любой строчной букве, которая определяется текущей регистровой
таблицей (@pxref{Case Tables}).  Если @code{case-fold-search} 
не-@code{nil}, это также соответствует любой прописной букве.
@item [:multibyte:]
Это соответствует любому многобайтовому символу (@pxref{Text Representations}).
@item [:nonascii:]
Это соответствует любому не-@acronym{ASCII} символу.
@item [:print:]
Это соответствует любому печатному символу  - пробелу или графическому
символу, сопоставляемый с @samp{[:graph:]}.
@item [:punct:]
Это соответствует любому знаку пунктуации. (В настоящее время для многобайтовых
символов, он соответствует любому, у которого есть неглавный синтаксис.)
@item [:space:]
Это соответствует любому символу с синтаксисом пробелов
(@pxref{Syntax Class Table}).
@item [:unibyte:]
Это соответствует любому однобайтовому символу (@pxref{Text Representations}).
@item [:upper:]
Это соответствует любой прописной букве, как определено текущей регистровой
таблицей (@pxref{Case Tables}).  Если @code{case-fold-search} 
не-@code{nil}, это также соответствует любой строчной букве.
@item [:word:]
Это соответствует любому символу, который имеет синтаксис слова (@pxref{Syntax Class
Table}).
@item [:xdigit:]
Это соответствует шестнадцатеричным цифрам: @samp{0} через @samp{9}, @samp{a}
через @samp{f} и @samp{A} через @samp{F}.
@end table

@node Regexp Backslash
@subsubsection Backslash Constructs in Regular Expressions
@cindex backslash in regular expressions

  По большей части, @samp{\} за которыми следуют только символы
это знак. Однако есть несколько исключений: некоторые
последовательности, начинающиеся с @samp{\} имеют особые значения. Здесь
таблица специальных @samp{\} конструкций.

@table @samp
@item \|
@cindex @samp{|} in regexp
@cindex regexp alternative
Указывает альтернативу.
Два регулярных выражения @var{a} и @var{b} с @samp{\|} 
между выражениями, соответствует любому, из @var{a} или
@var{b} символу.

Таким образом, @samp{foo\|bar} соответствует либо @samp{foo} либо @samp{bar}
и никакой другой строке.

@samp{\|} применяется к максимально возможным окружающим выражениям. Только
окружающая @samp{\( @dots{} \)} группировка может ограничить группирующую способность
@samp{\|}.

Если вам нужна полная возможность обратного отслеживания для обработки нескольких видов 
использования @samp{\|}, использовать функции регулярного выражения POSIX (@pxref{POSIX
Regexps}).

@item \@{@var{m}\@}
Является постфиксным оператором, который точно повторяет предыдущий шаблон @var{m}
раз. таким образом, @samp{x\@{5\@}} соответствует строке @samp{xxxxx}
и ничего больше.  @samp{c[ad]\@{3\@}r} соответствует строке, такой как
@samp{caaar}, @samp{cdddr}, @samp{cadar}, и так далее.

@item \@{@var{m},@var{n}\@}
Является более общим оператором постфикса, который указывает повторение с помощью
минимума @var{m} повторений и максимума @var{n} повторений.  Если @var{m}
опускается, минимальный 0; Если @var{n} опущено, нет
максимума.

Например, @samp{c[ad]\@{1,2\@}r} соответствует строкам @samp{car},
@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, и @samp{cddr}, и
ничего больше.@*
@samp{\@{0,1\@}} или @samp{\@{,1\@}} эквивалентно @samp{?}.@*
@samp{\@{0,\@}} или @samp{\@{,\@}} эквивалентно @samp{*}.@*
@samp{\@{1,\@}} эквивалентно @samp{+}.

@item \( @dots{} \)
@cindex @samp{(} in regexp
@cindex @samp{)} in regexp
@cindex regexp grouping
Представляет собой конструкцию группировки, которая выполняет три цели:

@enumerate
@item
Приложить множество @samp{\|} альтернативы для других операций. Таким образом,
регулярное выражение @samp{\(foo\|bar\)x} соответствуетr @samp{foox}
или @samp{barx}.

@item
Чтобы заключить сложное выражение для работы постфиксных операторов @samp{*},
@samp{+} и @samp{?}. Таким образом, @samp{ba\(na\)*} сответствует
@samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, и т.д. с любым
числом (ноль или более) @samp{na} строки.

@item
Чтобы сохранить совпавшую подстроку для дальнейшего использования
@samp{\@var{digit}} (смотри ниже).
@end enumerate

Последнее утверждение не является следствием идеи
скобок; Это отдельная функция, которая была назначена как
второе значение для построения того же @samp{\( @dots{} \)}, потому что на
практике, обычно не было конфликта между этими двумя значениями. Но
иногда возникает конфликт, и это привело к
несохраняющейся группе.

@item \(?: @dots{} \)
@cindex shy groups
@cindex non-capturing group
@cindex unnumbered group
@cindex @samp{(?:} in regexp
Это @dfn{shy group} конструкция.  Несохраняющаяся группа обслуживает первые две
цели обычной группы (контроль за гнездом других
операторов), но она не получает числа, поэтому вы не можете ссылаться на
её значение с @samp{\@var{digit}}.  Несохраняющиеся группы особенно
полезны для механически построенных регулярных выражений, поскольку они
могут быть добавлены автоматически без изменения нумерации обычных,
сохраняющихся групп.

Несохраняющиеся группы также называются @dfn{non-capturing} или @dfn{unnumbered
groups}.

@item \(?@var{num}: @dots{} \)
Это @dfn{explicitly numbered group} конструкция.  Нормальные группы получают
свой номер неявно, исходя из их положения, которое может быть
неудобно. Эта конструкция позволяет принудительно создать определенный
номер группы. Нет никаких особых ограничений на нумерацию,
например, вы можете иметь несколько групп с одинаковым номером, и в этом случае
последнее соответствие (то есть самое правое соответствие), ответит по номеру.
Неявно нумерованные группы всегда получают наименьшее целое число, большее
на один из любой предыдущей группы.

@item \@var{digit}
Совпадает с тем же текстом, который соответствует @var{digit}th возникшей
группировке (@samp{\( @dots{} \)}) конструкции.

Другими словами, после окончания группы совпадение запоминает
начало и конец текста, сопоставляемого этой группой. Позднее в
регулярном выражение, вы можете использовать @samp{\} с последующим @var{digit} используя
совпавший текст, что бы это ни было.

Строки, соответствующие первым девяти группирующим конструкциям, появляюются во
всех регулярных выражениях и передаются в функцию поиска или сопоставления и им
назначаются номера от 1 до 9 по порядку, в котором круглые скобки появляются в регулярном 
выражении. Таким образом, вы можете использовать от @samp{\1} до @samp{\9} ссылок на 
текст, сопоставляемый соответствующим группирующим конструкциям.

Например, @samp{\(.*\)\1} cоответствует любой строке, отличной от новой строки, которая
состоит из двух одинаковых половинок.  @samp{\(.*\)} соответствует первой
половине, и может быть чем угодно, но @samp{\1} должна точно соответствовать
совпавшему в первой половине тексту.

Если @samp{\( @dots{} \)} конструкция находит совпадение более одного раза (что может
например, если за ним следуют @samp{*}), только последнее
записывается совпадение.

Если конкретная структура группировки в регулярном выражении не была
в соответствии, например, если оно появляется внутри альтернативы, которая
не используется внутри повторения, которое повторялось ноль раз - тогда
соответствующая @samp{\@var{digit}} конструкция ничему не соответствует.
Используя искусственный пример, @samp{\(foo\(b*\)\|lose\)\2}
не может совпасть с @samp{lose}: второй альтернативы внутри большей
группы при сопоставлении его не определенной @samp{\2} и не может совпадать с
чем-нибудь. Но может совпадать @samp{foobb}, потому что первая
альтернатива соответствует @samp{foob} и @samp{\2} соответствует @samp{b}.

@item \w
@cindex @samp{\w} in regexp
Соответствует любому текстовому составу. Таблица синтаксиса редактора
определяет, какие это символы.  @xref{Syntax Tables}.

@item \W
@cindex @samp{\W} in regexp
Соответствует любому символу, который не является составной частью слова.

@item \s@var{code}
@cindex @samp{\s} in regexp
Соответствует любому символу, синтаксис которого это @var{code}.  Вот @var{code} это
символ, который представляет собой синтаксический код: таким образом, @samp{w} За слово
учредительный, @samp{-} для пробелов, @samp{(} для открытых круглых скобок,
и т.д. Чтобы представить простой синтаксис, используйте либо @samp{-} Или пробельный
символ.  @xref{Syntax Class Table}, для списка кодов синтаксиса и
символов, которые стоят за них.

@item \S@var{code}
@cindex @samp{\S} in regexp
Соответствует любому символу, синтаксис которого не является @var{code}.

@cindex category, regexp search for
@item \c@var{c}
Соответствует любому символу, чья категория @var{c}.  Вот @var{c} это
символ, который представляет категорию: таким образом, @samp{c} для китайских
символов или @samp{g} для греческих символов в стандартной таблицет категорий. 
Вы можете просмотреть список всех существующих в настоящее время категорий
введя @kbd{M-x describe-categories @key{RET}}.  Вы также можете определить
ваши собственные категории в дополнение к стандартным, используя
@code{define-category} функцию (@pxref{Categories}).

@item \C@var{c}
Соответствует любому символу, чья категория не является @var{c}.
@end table

  Следующие конструкции регулярных выражений соответствуют пустой строке --- то есть,
они не используют никаких символов --- но соответствуют зависимости от
контекста. Начало и конец доступной части буфера обрабатывается так, как если бы они были 
фактическим началом и концом буфера.

@table @samp
@item \`
@cindex @samp{\`} in regexp
Соответствует пустой строке, но только в начале
буфера или строки.

@item \'
@cindex @samp{\'} in regexp
Соответствует пустой строке, но только в конце
буфера или строки.

@item \=
@cindex @samp{\=} in regexp
Соответствует пустой строке, но только в точке.
(Эта конструкция не определяется при сопоставлении с строкой.)

@item \b
@cindex @samp{\b} in regexp
Соответствует пустой строке, но только в начале или
конце слова. таким образом, @samp{\bfoo\b} Соответствует любому вхождению
@samp{foo} как отдельного слова.  @samp{\bballs?\b} соответствует
@samp{ball} или @samp{balls} как отдельное слово.

@samp{\b} совпадает в начале или конце буфера (или строки)
независимо от того, какой текст появляется рядом с ним.

@item \B
@cindex @samp{\B} in regexp
Соответствует пустой строке, но @emph{not} в начале или в начале
конца слова, ни в начале, ни в конце буфера (или строки).

@item \<
@cindex @samp{\<} in regexp
Соответствует пустой строке, но только в начале слова.
@samp{\<} совпадение в начале буфера (или строки), только если
следует словосочетание.

@item \>
@cindex @samp{\>} in regexp
Соответствует пустой строке, но только в конце слова.  @samp{\>}
совпадение в конце буфера (или строки), только если конец содержит
словосочетание.

@item \_<
@cindex @samp{\_<} in regexp
Соответствует пустой строке, но только в начале символа.
Символ представляет собой последовательность одного или нескольких составляющих
слова или символа.  @samp{\_<} совпадение в начале буфера (или
строка), только если есть символ-составляющий.

@item \_>
@cindex @samp{\_>} in regexp
Соответствует пустой строке, но только в конце символа.  @samp{\_>}
совпадений в конце буфера (или строки), только если конец содержимого
с символьно-составляющим символом.
@end table

@kindex invalid-regexp
  Не каждая строка является допустимым регулярным выражением. Например, строка
которая заканчивается внутри альтернативы символа без прерывания @samp{]}
является недопустимым, и поэтому строка, которая заканчивается одним @samp{\}.  Если
недопустимое регулярное выражение передается любой из функций поиска,
@code{invalid-regexp} сигнализирует ошибку.

@node Regexp Example
@subsection Complex Regexp Example

  Вот сложное регулярное выражение, которое ранее использовалось Emacs для
нахождения конца предложения вместе с любыми пробелами. (В настоящее время Emacs 
использует аналогичные, но более сложные значения по умолчанию
Regexp, построенное функцией @code{sentence-end}.
@xref{Standard Regexps}.)

  Ниже мы сначала показываем regexp как строку в синтаксисе Lisp (
отличая пробелы от символов табуляции), а затем 
оцениваем результат. Строковая константа начинается и заканчивается
двойными кавычками.  @samp{\"} означает двойную кавычку как часть
строки, @samp{\\} для обратной косой черты как части строки, @samp{\t} для
табуляции и @samp{\n} для новой строки.

@example
@group
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|@ @ \\)[ \t\n]*"
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|@ @ \\)[
]*"
@end group
@end example

@noindent
В выходных данных табуляция и новая строка отображаются сами за себя.

  Это регулярное выражение состоит из четырех частей подряд и может быть
расшифровывается следующим образом:

@table @code
@item [.?!]
Первая часть шаблона - символьный класс, которая соответствует
любому из трех символов: точка, знак вопроса и восклицательный знак.
Соответствие должно начинаться с одного из этих трех символов. (Эта
является одним вариантом, где новое стандартное регулярное выражение, 
используемое Emacs, отличается от старого. Новое значение также позволяет не-@acronym{ASCII}
символы, заканчивть предложение без каких-либо пробелов.)

@item []\"')@}]*
Вторая часть шаблона соответствует любым закрывающим скобкам и знакам, ноль или более
которых могут следовать за точкой, вопросительным или восклицательным знаком.  @code{\"} 
является синтаксисом Lisp для двойной кавычки в строке.  @samp{*} в конце указывает, что 
предшествующая конструкция регулярного выражения (символьный класс в этом случае) может 
повторяется ноль или более раз.

@item \\($\\|@ $\\|\t\\|@ @ \\)
Третья часть шаблона соответствует пробелу, который следует за
концом предложения: конец строки (необязательно с пробелом) или
табуляция или два пробела. Двойные обратные косые черты обозначают круглые скобки и
вертикальные столбцы как синтаксис регулярных выражений; Круглые скобки ограничивают
группу а вертикальные полосы - отдельные альтернативы. Знак доллара используется для 
соответствия конца строки.

@item [ \t\n]*
Наконец, последняя часть шаблона соответствует любому дополнительному пробелу
длинее минимального, необходимого для завершения предложения.
@end table

@node Regexp Functions
@subsection Regular Expression Functions

  Эти функции работают на регулярных выражениях.

@cindex quote special characters in regexp
@defun regexp-quote string
Эта функция возвращает регулярное выражение, единственное точное совпадение которому
@var{string}.  Используя это регулярное выражение в @code{looking-at} будет
выполняется только в том случае, если следующие символы в буфере @var{string};
использование его в функции поиска будет успешным, если поиск текста
содержит @var{string}.  @xref{Regexp Search}.

Это позволяет запрашивать точное совпадение строк или поиск при вызове
функции, которая требует регулярное выражение.

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

Одно использование @code{regexp-quote} состоит в том, чтобы совместить точное совпадение
строк с контекстом, описываемым как регулярное выражение. Например, этот поиск
строки, которая является значением @var{string}, окруженную пробелами:

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example
@end defun

@cindex optimize regexp
@defun regexp-opt strings &optional paren
Эта функция возвращает эффективное регулярное выражение, которое будет соответствовать
любой из строк в списке @var{strings}. Это полезно, когда вам
необходимо выполнить согласование или поиск как можно быстрее - например,
для Font Lock mode@footnote{Note that @code{regexp-opt} не
гарантируют, что его результат является абсолютно эффективной возможной формой.
Регулярное выражение с ручной настройкой иногда может быть немного
более эффективен, но почти никогда не стоит усилий.
@c E.g., see http://debbugs.gnu.org/2816

Необязательный аргументt @var{paren} может быть любым из следующих:

строка
    Результирующему регулярному выражению предшествует @var{paren} и затем
    @samp{\)}, e.g. использование @samp{"\\(?1:"} производит явно пронумерованную группу.

@code{words}
   Полученное регулярное выражение окружено @samp{\<\(} и @samp{\)\>}.

@code{symbols}
    Полученное регулярное выражение окружено @samp{\_<\(} и @samp{\)\_>}
    (Это часто бывает целесообразным при обработке ключевых слов
    языка программирования и тому подобное).

не-@code{nil}
    Полученное регулярное выражение окружено @samp{\(} и @samp{\)}.

@code{nil}
    Полученное регулярное выражение окружено @samp{\(?:} и @samp{\)},
    Если необходимо убедиться, что оператор постфикса добавлен 
    он будет применяться ко всему выражению.

Полученное регулярное выражение @code{regexp-opt} эквивалентно, но обычно
более эффективно, чем упрощенная версия:

@example
(defun simplified-regexp-opt (strings &optional paren)
 (let ((parens (cond ((stringp paren)       (cons paren "\\)"))
                     ((eq paren 'words)    '("\\<\\(" . "\\)\\>"))
                     ((eq paren 'symbols) '("\\_<\\(" . "\\)\\_>"))
                     ((null paren)          '("\\(?:" . "\\)"))
                     (t                       '("\\(" . "\\)")))))
   (concat (car paren)
           (mapconcat 'regexp-quote strings "\\|")
           (cdr paren))))
@end example
@end defun

@defun regexp-opt-depth regexp
Эта функция возвращает общее количество конструкций группировки
(Заключенные в скобки выражения) в @var{regexp}.  Это не включает
ненумерованные группы (@pxref{Regexp Backslash}).
@end defun

@c Supposedly an internal regexp-opt function, but table.el uses it at least.
@defun regexp-opt-charset chars
Эта функция возвращает регулярное выражение, соответствующее символу в
списке символов @var{chars}.

@example
(regexp-opt-charset '(?a ?b ?c ?d ?e))
     @result{} "[a-e]"
@end example
@end defun

@c Internal functions: regexp-opt-group

@node Regexp Search
@section Regular Expression Searching
@cindex regular expression searching
@cindex regexp searching
@cindex searching for regexp

  В GNU Emacs вы можете найти следующие совпадения для регулярного
выражения (@pxref{Syntax of Regexps}) либо поэтапно, либо нет.
Для инкрементных команд поиска см. @ref{Regexp Search, , Regular
Expression Search, emacs, The GNU Emacs Manual}.  Здесь мы описываем
только функции поиска полезных в программах. Основной является
@code{re-search-forward}.

  Эти функции поиска преобразуют регулярное выражение в многобайтовое, если
буфер многобайтовый; Они преобразуют регулярное выражение в унибайт
если буфер однобайтовый.  @xref{Text Representations}.

@deffn Command re-search-forward regexp &optional limit noerror count
Эта функция выполняет поиск вперед в текущем буфере для строки
текст, которая соответствует регулярному выражению @var{regexp}.  
Функция пропускает любое количество текста, которое не соответствует
@var{regexp}, и оставляет точку в конце первого найденного совпадения.
Она возвращает новое значение точки.

Если @var{limit} не-@code{nil}, это должно быть положением в текущем
буфере и определять верхнюю границу поиска. Не совпадает
после этой позициии.  Если @var{limit} опущено
или @code{nil}, по умолчанию используется конец доступной части
буфера.

Как поведет себя @code{re-search-forward} при сбое поиска зависит от
значения @var{noerror}:

@table @asis
@item @code{nil}
Сигнализирует @code{search-failed} ошибку.
@item @code{t}
Не делает ничего и возвращает @code{nil}.
@item anything else
Переместит точку на @var{limit} (или конец доступной части
буфера) и вернет @code{nil}.
@end table

Аргумент @var{noerror} влияет только на действующие поисковые запросы,
нахождения соответствия. Недопустимые аргументы вызывают ошибки независимо от
@var{noerror}.

Если @var{count} - положительное число @var{n}, поиск выполняется
@var{n} раз; каждый последующий поиск начинается в конце
предыдущего совпадения. Если все эти последующие поисковые запросы будут успешными,
вызов функции преуспевает, перемещает точку и возвращает новое значение.
В противном случае вызов функции завершается неудачно, результаты зависят от значения
в @var{noerror}, как описано выше. Если @var{count} является отрицательным
числом -@var{n}, поиск выполняется @var{n} раз в обратном направлении
(Назад).

В следующем примере точка находится перед @samp{T}.
Оценка вызова поиска перемещает точку до конца этой строки (между
 @samp{t} в @samp{hat} и новой строкой).

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command re-search-backward regexp &optional limit noerror count
Эта функция выполняет поиск назад в текущем буфере для строки
текста, который соответствует регулярному выражению @var{regexp}, оставляет
точку в начале первого найденного текста.

Эта функция аналогична @code{re-search-forward}, но они не
простые зеркальные отображения.  @code{re-search-forward} находит соответствие, чье
начало как можно ближе к начальной точке. Если
@code{re-search-backward} была идеальным зеркальным изображением, она нашла бы то
что заканчивается как можно ближе. Однако на самом деле она находит
соответствие, начало которого как можно ближе (и все же заканчивается до
отправной точке). Причина этого в том, что сопоставление регулярных
выражение в данном месте всегда работает от начала до конца, и
начинается в указанной начальной позиции.

Истинное зеркальное изображение @code{re-search-forward} потребует
функцию для сопоставления регулярному выражению от конца до начала. Это
того не стоит.
@end deffn

@defun string-match regexp string &optional start
Эта функция возвращает индекс начала первого совпадения для
регулярного выражения @var{regexp} в @var{string}, или @code{nil} если
нет совпадения.  Если @var{start} не-@code{nil}, поиск начинается
с этого индекса в @var{string}.

Например,

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
Индекс первого символа
cтроки равен 0, индекс второго символа равен 1 и т. Д.

Если эта функция находит совпадение, индекс первого символа за пределами
соответствия доступен как @code{(match-end 0)}.  @xref{Match Data}.

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun string-match-p regexp string &optional start
Эта предикатная функция делает то, что @code{string-match} , но 
избегает изменения данных соответствия.
@end defun

@defun looking-at regexp
Эта функция определяет, непосредственно ли текст в текущем буфере
следующий за точкой соответствует регулярному выражению @var{regexp}.  ``Directly
following'' означает именно это: поиск ``anchored'' и он может
быть успешным только начиная с первого символа следующей точки.
Результатом является @code{t} если так, @code{nil} в противном случае.

Эта функция не перемещает точку, но обновляет данные соответствия.
@xref{Match Data}.  Если вам нужно проверить соответствие, не изменяя
данные соответствия, используйте @code{looking-at-p}, описано ниже.

В этом примере точка расположена непосредственно перед @samp{T}.  Если она
была бы где-то еще, результатом был бы @code{nil}.

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@defun looking-back regexp limit &optional greedy
Эта функция возвращает @code{t} если @var{regexp} соответствует тексту
непосредственно перед точкой (т. е. заканчивающегося в точке), и @code{nil} в противном случае.

Поскольку регулярное соответствие выражений работает только в будущем, это
реализуется путем поиска назад от точки для соответствия, которая заканчивается на
точке. Это может быть довольно медленным, если нужно искать на большие расстояния.
Вы можете связать время, требуемое, указав не-@code{nil} значение
для @var{limit}, в котором указывается @var{limit}.  В этом
случае, найденное совпадение должно начинаться с или после @var{limit}.
Вот пример:

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     @result{} t
(looking-back "read \"" 4)
     @result{} nil
@end group
@end example

Если @var{greedy} не-@code{nil}, Эта функция расширяет соответствие
назад, насколько это возможно, останавливаясь, когда один дополнительный
предыдущий символ не может быть частью соответствия для @var{regexp}.  Когда
совпадение продолжается, его исходное положение разрешено
до @var{limit}.

@c http://debbugs.gnu.org/5689
В качестве общей рекомендации старайтесь избегать использования @code{looking-back}
где это возможно, поскольку она медленная. По этой причине не
планируется добавить @code{looking-back-p} функцию.
@end defun

@defun looking-at-p regexp
Эта функция предикат работает как @code{looking-at}, но без
обновления данных соответствия.
@end defun

@defvar search-spaces-regexp
Если эта переменная не-@code{nil}, это должно быть регулярное выражение
в котором говорится, как искать пробелы. В этом случае для любая группы
пробелов в обычном выражении, которое искали  используется
это регулярное выражение. Однако пропуски внутри конструкций, таких как
@samp{[@dots{}]} и @samp{*}, @samp{+}, @samp{?} не затрагиваются
@code{search-spaces-regexp}.

Поскольку эта переменная влияет на поиск и поиск конструкций регулярных 
выражений, вы должны временно привязать его как можно к меньшей
части кода.
@end defvar

@node POSIX Regexps
@section POSIX Regular Expression Searching

@cindex backtracking and POSIX regular expressions
  Обычно обычные функции регулярных выражений возвращаются назад
для обработки @samp{\|} и конструкции повторения, но они продолжают
это только пока они не находят @emph{some} совпадение. Затем они преуспевают и
сообщают о найденном первом совпадении.

  В этом разделе описываются альтернативные функции поиска, которые выполняют
полный откат, указанный стандартом POSIX для регулярного выражения
соответствия. Они продолжают отступать, пока они не попробовали все
возможности и нашли все совпадения, чтобы они могли сообщать о самых длинных
соответствиях, как требуется POSIX @. Это намного медленнее, поэтому используйте эту
функциональность только тогда, когда вам действительно нужно самое длинное совпадение.

  Функции поиска и сопоставления POSIX не поддерживают
неживые операторы повторения (@pxref{Regexp Special, non-greedy}).
Это связано с тем, что обратное отслеживание POSIX противоречит семантике
не-жадного повторения.

@deffn Command posix-search-forward regexp &optional limit noerror count
Это похоже на @code{re-search-forward} за исключением того, что она выполняет полный
Backtracking, указанный стандартом POSIX для соответствия  регулярному выражению.
@end deffn

@deffn Command posix-search-backward regexp &optional limit noerror count
Это похоже на @code{re-search-backward} за исключением того, что она выполняет полный
Backtracking, указанный стандартом POSIX для соответствия  регулярному выражению.
@end deffn

@defun posix-looking-at regexp
Это похоже на @code{looking-at} за исключением того, что она выполняет полный
Backtracking, указанный стандартом POSIX для соответствия  регулярному выражению.
@end defun

@defun posix-string-match regexp string &optional start
Это похоже на @code{string-match} за исключением того, что она выполняет полный
Backtracking, указанный стандартом POSIX для соответствия регулярному выражению.
@end defun

@node Match Data
@section The Match Data
@cindex match data

  Emacs отслеживает начальную и конечную позиции сегментов
текста, найденного во время поиска; Это называется @dfn{match data}.
Благодаря данным соответствия вы можете искать сложный шаблон, такой как
дата в почтовом сообщении, а затем извлечь части
управления шаблона.

  Поскольку данные соответствия обычно описывают только самый последний поиск,
вы должны быть осторожны, чтобы не делать другого поиска в случайном порядке между
поиском, на который вы хотите вернуться, и использование данных соответствия. если 
нельзя избежать другого промежуточного поиска, вы должны сохранить и восстановить
сопоставленные данные вокруг него, чтобы предотвратить его перезапись.

  Обратите внимание, что всем функциям разрешено перезаписывать данные соответствия
если они явно не документированы, чтобы этого не делать. Следствием является
функции, которые выполняются неявно, скорее всего,  в фоновом режиме
(@pxref{Timers}, и @ref{Idle Timers}) , сохраниющие и восстанавливающие
данные соответствия явно.

@menu
* Replacing Match::       Замена подстроки, которая была сопоставлена.
* Simple Match Data::     Доступ к отдельным элементам данных соответствия,
                            yапример, когда начинается конкретное подвыражение.
* Entire Match Data::     Доступ ко всем данным соответствия сразу, как списку.
* Saving Match Data::     Сохранение и восстановление данных соответствия.
@end menu

@node Replacing Match
@subsection Replacing the Text that Matched
@cindex replace matched text

  Эта функция заменяет все или часть текста, сопоставляемого последним
поиск. Она работает с помощью данных сопоставления.

@cindex case in replacements
@defun replace-match replacement &optional fixedcase literal string subexp
Эта функция выполняет операцию замены в буфере или строке.

Если вы выполнили последний поиск в буфере, вы должны опустить
@var{string} аргумент или указать @code{nil} для этого, и убедится, что
текущий буфер - тот, в котором вы выполнили последний поиск.
Затем эта функция редактирует буфер, заменяя согласованный текст на
@var{replacement}.  Он оставляет точку в конце замененного
текста.

Если вы выполнили последний поиск в строке, передайте ту же строку, что и
@var{string}.  Затем эта функция возвращает новую строку, в которой
согласованный текст заменяется на @var{replacement}.

Если @var{fixedcase} не-@code{nil}, тогда @code{replace-match} использует
заменяющий текст без преобразования кода; В противном случае он преобразует
заменяющий текст в зависимости от регистра текста который
был заменен. Если исходный текст является верхним регистром, это преобразует
заменяющий текст на верхний регистр. Если все слова исходного текста
заглавные, это делает заглавными все слова замены
текст. Если все слова однобуквенные и все они имеют верхний регистр,
они рассматриваются как заглавные слова, а не все слова в верхнем регистре.

Если @var{literal} не-@code{nil}, тогда @var{replacement} вставляется
без изменений, которые изменяются по мере необходимости.
Если это @code{nil} (по умолчанию), то персонаж @samp{\} понимается
специально. Если @samp{\} появляется в @var{replacement}, то это должно быть
часть одной из следующих последовательностей:

@table @asis
@item @samp{\&}
@cindex @samp{&} in replacement
Это означает, что весь текст будет заменен.

@item @samp{\@var{n}}, where @var{n} is a digit
@cindex @samp{\@var{n}} in replacement
Это означает, что текст соответствует @var{n}th подвыражению в
исходном регулярном выражении. Подвыражения - это выражения, сгруппированные
внутри @samp{\(@dots{}\)}.  Если @var{n}th подвыражение никогда не
сопоставлено, заменяется пустой строкой.

@item @samp{\\}
@cindex @samp{\} in replacement
Это означает, что @samp{\} в заменяющем тексте.

@item @samp{\?}
Это само по себе (для совместимости с @code{replace-regexp}
и соответствию командам; @pxref{Regexp Replace,,, emacs, The GNU
Emacs Manual}).
@end table

@noindent
Любой другой символ, следующий @samp{\} сигнализирует о ошибке.

Замены, выполняемые @samp{\&} и @samp{\@var{n}} происходят
после конвертации конвертация, если есть. Поэтому строки, которые они заменяют
никогда не конвертируются в регистр.

Если @var{subexp} не-@code{nil}, который говорит, чтобы заменить просто
номер подвыражения @var{subexp} регулярного выражения, которое было сопоставлено, а не
всё соответствие. Например, после сопоставления @samp{foo \(ba*r\)},
вызвав @code{replace-match} с 1 как @var{subexp} Означает заменить
просто текст, который соответствует @samp{\(ba*r\)}.
@end defun

@defun match-substitute-replacement replacement &optional fixedcase literal string subexp
Эта функция возвращает текст, который будет вставлен в буфер
от @code{replace-match}, но без изменения буфера. Это
полезно, если вы хотите представить пользователю фактический результат замены,
С конструкциями типа @samp{\@var{n}} или @samp{\&} замещения
согласованным группам. Аргументы @var{replacement} и необязательные
@var{fixedcase}, @var{literal}, @var{string} и @var{subexp}, имеют
то же значение, что и для @code{replace-match}.
@end defun

@node Simple Match Data
@subsection Simple Match Data Access

  В этом разделе объясняется, как использовать данные соответствия, чтобы узнать, что 
соответствовало последней успешной операции поиска или совпадению.

  Вы можете узнать обо всем соответствующем тексте или о конкретном
вложенном подвыражение регулярного выражения.  @var{count}
аргумент в нижеприведенных функциях указывает, в каких именно.  Если @var{count} является
ноль, вы спрашиваете о целом соответствии.  Если @var{count} является
положительный, он определяет, какое подвыражение вы хотите.

  Напомним, что подвыражениями регулярного выражения являются
выражения, сгруппированные круглыми скобками, @samp{\(@dots{}\)}.  Это
@var{count}ое подвыражение определяется путем подсчета вхождений
@samp{\(} от начала всего регулярного выражения. Первое
подвыражение пронумеровано 1, второе 2 и т. д. Только регулярные
выражения могут иметь подвыражения - при простом поиске строк
доступна только информация о целом совпадении.

  Каждый успешный поиск устанавливает данные соответствия. Поэтому вы должны
запрашивать данные соответствия сразу после поиска, перед вызовом любой
другая функция, которая может выполнять другой поиск. Кроме того, вы
можете сохранять и восстанавливать данные соответствия (@pxref{Saving Match Data}) при
вызове функций, которые могут выполнять другой поиск. Или используйте
функции, которые явно не изменяют данные соответствия;
так как , @code{string-match-p}.

@c Это старый комментарий, и, по-видимому,
@c теперь все меняется. Но все же советы стоят.
  Поиск, который не удался, может или не может изменить данные соответствия. в
текущей реализации, это не так, но мы можем изменить это в
будущем. Не пытайтесь полагаться на значение данных соответствия после
неудачного поиска.

@defun match-string count &optional in-string
Эта функция возвращает в качестве строки текст, сопоставленный в последнем поиске
или операции сопряжения. Он возвращает весь текст, если @var{count} это ноль,
или только часть, соответствующую @var{count} указывающему на
подвыражение, если @var{count} является положительным.

Если последняя такая операция была выполнена против строки с
@code{string-match}, то вы должны передать ту же строку, что и
аргумент @var{in-string}.  После поиска или совпадения буфера,
вы должны опустить @var{in-string} или укаывать на @code{nil} для этого; но ты
должен убедиться, что текущий буфер при вызове
@code{match-string} это тот, в котором вы выполняли поиск или
соответствия. Несоблюдение этого совета приведет к неправильным результатам.

Значение @code{nil} если @var{count} находится за пределами допустимого диапазона или
подвыражение внутри альтернативы @samp{\|}, которое не использовалась, или ни разу
не повторялось.
@end defun

@defun match-string-no-properties count &optional in-string
Эта функция подобна @code{match-string} за исключением того, что результат
не имеет текстовых свойств.
@end defun

@defun match-beginning count
Если последний поиск регулярного выражения нашел совпадение, эта функция
возвращает позицию начала соответствующего текста или
подвыражения.

Если @var{count} это ноль, то значение представляет собой позицию начала
всего совпадения. В противном случае, @var{count} указывает подвыражение в
регулярном выражении, а значение функции - это начало
положения совпадения для этого подвыражения.

Значение @code{nil} для подвыражения внутри @samp{\|}
альтернативы, которая не использовалась, или повторялось ноль раз.
@end defun

@defun match-end count
Эта функция подобна @code{match-beginning} за исключением того, что он возвращает
положение конца соответствия, а не положение
начала.
@end defun

  Ниже приведен пример использования данных сопоставления с комментарием, показывающим
позиции в тексте:

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{The beginning of the match}
     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}
@end group

@group
(match-beginning 2)       ; @r{The beginning of the match}
     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}
@end group

@group
(match-end 1)             ; @r{The end of the match}
     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}

(match-end 2)             ; @r{The end of the match}
     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}
@end group
@end example

  Вот еще один пример. Точка первоначально расположена в начале
строки. Поиск перемещает точку между пропуском и словом
@samp{in}.  Начало всего соответствия - 9-й символ
буфера (@samp{T}), и начало совпадения для первого
подвыражения на 13-м символе (@samp{c}).

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (17 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
(В этом случае возвращаемый индекс является буферной позицией; первый
символ буфера считается равным 1.)

@node Entire Match Data
@subsection Accessing the Entire Match Data

  Функции @code{match-data} и @code{set-match-data} читают или
записывают все данные совпадения, все сразу.

@defun match-data &optional integers reuse reseat
Эта функция возвращает список позиций (маркеров или целых чисел), в который
записана вся информация о тексте, который соответствует последнему поиску.
Элемент 0 - это позиция начала совпадения для
целого выражения; Element one - это позиция конца соответствия
для выражения. Следующие два элемента - это позиции
начала и конца совпадения для первого подвыражения и т. д.
В общем, элемент
@ifnottex
number 2@var{n}
@end ifnottex
@tex
number {\mathsurround=0pt $2n$}
@end tex
corresponds to @code{(match-beginning @var{n})}; and
element
@ifnottex
number 2@var{n} + 1
@end ifnottex
@tex
number {\mathsurround=0pt $2n+1$}
@end tex
corresponds to @code{(match-end @var{n})}.

Обычно все элементы являются маркерами или @code{nil}, но если
@var{integers} не-@code{nil}, Это означает вместо этого использовать целые числа
маркеров. (В этом случае сам буфер добавляется как
дополнительный элемент в конце списка, чтобы облегчить
восстановления данных соответствия.) Если последнее совпадение было выполнено на
строке с @code{string-match}, то целые числа всегда используются,
поскольку маркеры не могут указывать на строку.

Если @var{reuse} не-@code{nil}, это должен быть список. В таком случае,
@code{match-data} сохраняет данные соответствия в @var{reuse}.  То есть,
@var{reuse} деструктивно изменено.  @var{reuse} может не
имеют правильную длину. Если этого не достаточно длинно, чтобы содержать совпадение
данных, это расширяется. Если он слишком длинный, длина @var{reuse}
остается неизменной, но элементы, которые не были использованы,
@code{nil}.  Цель этой функции - уменьшить необходимость
вывоза мусора.

Если @var{reseat} не-@code{nil}, все маркеры в @var{reuse} списке
переустановливаются, чтобы указать в никуда.

Как всегда, не должно быть возможности промежуточных поисков между
вызовом функции поиска и вызовом @code{match-data} то есть
предназначенных для доступа к данным соответствия для этого поиска.

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list &optional reseat
Эта функция устанавливает данные соответствия из элементов @var{match-list},
который должен быть списком, который был значением предыдущего вызова
@code{match-data}.  (Точнее, все, что имеет тот же формат
будет работать.)

Если @var{match-list} ссылается на буфер, который не существует, вы не получаете
ошибки; устанавливание данные сопоставления бессмысленным, но безвредным способом.

Если @var{reseat} не-@code{nil}, все маркеры на @var{match-list} списке
переустанавливаются, чтобы указать в никуда.

@c TODO Make it properly obsolete.
@findex store-match-data
@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}.
@end defun

@node Saving Match Data
@subsection Saving and Restoring the Match Data

  Когда вы вызываете функцию, которая может выполнять поиск, вам может потребоваться сэкономить
и восстановить совпадающие данные вокруг этого вызова, если вы хотите сохранить
сопоставленные данные из более раннего поиска для последующего использования. Вот пример
который показывает проблему, возникающую, если вы не можете сохранить данные соответствия:

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{@code{foo} does more searching.}
(match-end 0)
     @result{} 61              ; @r{Unexpected result---not 48!}
@end group
@end example

  Вы можете сохранять и восстанавливать данные соответствия с помощью @code{save-match-data}:

@defmac save-match-data body@dots{}
Этот макрос выполняет @var{body}, сохраняет и восстанавливает сопоставленные
данные вокруг него. Возвращаемое значение - это значение последней формы в
@var{body}.
@end defmac

  Вы можете использовать @code{set-match-data} вместе с @code{match-data} в
подражании эффекту особой формы @code{save-match-data}.  Здесь
как:

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{Ok to change the original match data.}
    (set-match-data data)))
@end group
@end example

  Emacs автоматически сохраняет и восстанавливает данные соответствия при запуске
функций фильтра процесса (@pxref{Filter Functions}) и временных
(@pxref{Sentinels}).

@ignore
  Вот функция, которая восстанавливает данные соответствия при условии, что буфер
связанный с ним все еще существует.

@smallexample
@group
(defun restore-match-data (data)
@c It is incorrect to split the first line of a doc string.
@c If there's a problem here, it should be solved in some other way.
  "Restore the match data DATA unless the buffer is missing."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{buffer is deleted.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Search and Replace
@section Search and Replace
@cindex replacement after search
@cindex searching and replacing

  Если вы хотите найти все совпадения для регулярного выражения в части буфера,
и заменитю их, лучший способ - написать явный цикл, используя
@code{re-search-forward} и @code{replace-match}, как это:

@example
(while (re-search-forward "foo[ \t]+bar" nil t)
  (replace-match "foobar"))
@end example

@noindent
@xref{Replacing Match,, Replacing the Text that Matched}, для
описание @code{replace-match}.

  Однако замена совпадений в строке более сложна, особенно
если вы хотите сделать это эффективно. Таким образом, Emacs предоставляет функцию для 
выполнения этого.

@defun replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
Эта функция копирует @var{string} и ищет для нее совпадения
@var{regexp}, и заменяет их @var{rep}.  Она возвращает
измененную копию.  Если @var{start} не-@code{nil}, поиск
совпадений начинаются с этого индекса в @var{string}, Поэтому совпадения до
этого индекса не изменятся.

Эта функция использует @code{replace-match} для того чтобы сделать замену, для
этого передаютсч необязательные аргументы @var{fixedcase}, @var{literal} и
@var{subexp} вместе с @code{replace-match}.

Instead of a string, @var{rep} can be a function.  In that case,
@code{replace-regexp-in-string} calls @var{rep} for each match,
passing the text of the match as its sole argument.  It collects the
value @var{rep} returns and passes that to @code{replace-match} as the
replacement string.  The match data at this point are the result
of matching @var{regexp} against a substring of @var{string}.
@end defun

  If you want to write a command along the lines of @code{query-replace},
you can use @code{perform-replace} to do the work.

@defun perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end
This function is the guts of @code{query-replace} and related
commands.  It searches for occurrences of @var{from-string} in the
text between positions @var{start} and @var{end} and replaces some or
all of them.  If @var{start} is @code{nil} (or omitted), point is used
instead, and the end of the buffer's accessible portion is used for
@var{end}.

If @var{query-flag} is @code{nil}, it replaces all
occurrences; otherwise, it asks the user what to do about each one.

If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is
considered a regular expression; otherwise, it must match literally.  If
@var{delimited-flag} is non-@code{nil}, then only replacements
surrounded by word boundaries are considered.

The argument @var{replacements} specifies what to replace occurrences
with.  If it is a string, that string is used.  It can also be a list of
strings, to be used in cyclic order.

If @var{replacements} is a cons cell, @w{@code{(@var{function}
. @var{data})}}, this means to call @var{function} after each match to
get the replacement text.  This function is called with two arguments:
@var{data}, and the number of replacements already made.

If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then
it specifies how many times to use each of the strings in the
@var{replacements} list before advancing cyclically to the next one.

If @var{from-string} contains upper-case letters, then
@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and
it uses the @var{replacements} without altering their case.

Normally, the keymap @code{query-replace-map} defines the possible
user responses for queries.  The argument @var{map}, if
non-@code{nil}, specifies a keymap to use instead of
@code{query-replace-map}.

This function uses one of two functions to search for the next
occurrence of @var{from-string}.  These functions are specified by the
values of two variables: @code{replace-re-search-function} and
@code{replace-search-function}.  The former is called when the
argument @var{regexp-flag} is non-@code{nil}, the latter when it is
@code{nil}.
@end defun

@defvar query-replace-map
This variable holds a special keymap that defines the valid user
responses for @code{perform-replace} and the commands that use it, as
well as @code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual
in two ways:

@itemize @bullet
@item
The key bindings are not commands, just symbols that are meaningful
to the functions that use this map.

@item
Prefix keys are not supported; each key binding must be for a
single-event key sequence.  This is because the functions don't use
@code{read-key-sequence} to get the input; instead, they read a single
event and look it up ``by hand''.
@end itemize
@end defvar

Here are the meaningful bindings for @code{query-replace-map}.
Several of them are meaningful only for @code{query-replace} and
friends.

@table @code
@item act
Do take the action being considered---in other words, ``yes''.

@item skip
Do not take action for this question---in other words, ``no''.

@item exit
Answer this question ``no'', and give up on the entire series of
questions, assuming that the answers will be ``no''.

@item exit-prefix
Like @code{exit}, but add the key that was pressed to
@code{unread-command-events} (@pxref{Event Input Misc}).

@item act-and-exit
Answer this question ``yes'', and give up on the entire series of
questions, assuming that subsequent answers will be ``no''.

@item act-and-show
Answer this question ``yes'', but show the results---don't advance yet
to the next question.

@item automatic
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction.

@item backup
Move back to the previous place that a question was asked about.

@item edit
Enter a recursive edit to deal with this question---instead of any
other action that would normally be taken.

@item edit-replacement
Edit the replacement for this question in the minibuffer.

@item delete-and-edit
Delete the text being considered, then enter a recursive edit to replace
it.

@item recenter
@itemx scroll-up
@itemx scroll-down
@itemx scroll-other-window
@itemx scroll-other-window-down
Perform the specified window scroll operation, then ask the same
question again.  Only @code{y-or-n-p} and related functions use this
answer.

@item quit
Perform a quit right away.  Only @code{y-or-n-p} and related functions
use this answer.

@item help
Display some help, then ask again.
@end table

@defvar multi-query-replace-map
This variable holds a keymap that extends @code{query-replace-map} by
providing additional keybindings that are useful in multi-buffer
replacements.  The additional bindings are:

@table @code
@item automatic-all
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction, for all remaining buffers.

@item exit-current
Answer this question ``no'', and give up on the entire series of
questions for the current buffer.  Continue to the next buffer in the
sequence.
@end table
@end defvar

@defvar replace-search-function
This variable specifies a function that @code{perform-replace} calls
to search for the next string to replace.  Its default value is
@code{search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{search-forward}
(@pxref{String Search}).
@end defvar

@defvar replace-re-search-function
This variable specifies a function that @code{perform-replace} calls
to search for the next regexp to replace.  Its default value is
@code{re-search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{re-search-forward}
(@pxref{Regexp Search}).
@end defvar

@node Standard Regexps
@section Standard Regular Expressions Used in Editing
@cindex regexps used standardly in editing
@cindex standard regexps used in editing

  This section describes some variables that hold regular expressions
used for certain purposes in editing:

@defopt page-delimiter
This is the regular expression describing line-beginnings that separate
pages.  The default value is @code{"^\014"} (i.e., @code{"^^L"} or
@code{"^\C-l"}); this matches a line that starts with a formfeed
character.
@end defopt

  The following two regular expressions should @emph{not} assume the
match always starts at the beginning of a line; they should not use
@samp{^} to anchor the match.  Most often, the paragraph commands do
check for a match only at the beginning of a line, which means that
@samp{^} would be superfluous.  When there is a nonzero left margin,
they accept matches that start after the left margin.  In that case, a
@samp{^} would be incorrect.  However, a @samp{^} is harmless in modes
where a left margin is never used.

@defopt paragraph-separate
This is the regular expression for recognizing the beginning of a line
that separates paragraphs.  (If you change this, you may have to
change @code{paragraph-start} also.)  The default value is
@w{@code{"[@ \t\f]*$"}}, which matches a line that consists entirely of
spaces, tabs, and form feeds (after its left margin).
@end defopt

@defopt paragraph-start
This is the regular expression for recognizing the beginning of a line
that starts @emph{or} separates paragraphs.  The default value is
@w{@code{"\f\\|[ \t]*$"}}, which matches a line containing only
whitespace or starting with a form feed (after its left margin).
@end defopt

@defopt sentence-end
If non-@code{nil}, the value should be a regular expression describing
the end of a sentence, including the whitespace following the
sentence.  (All paragraph boundaries also end sentences, regardless.)

If the value is @code{nil}, as it is by default, then the function
@code{sentence-end} constructs the regexp.  That is why you
should always call the function @code{sentence-end} to obtain the
regexp to be used to recognize the end of a sentence.
@end defopt

@defun sentence-end
This function returns the value of the variable @code{sentence-end},
if non-@code{nil}.  Otherwise it returns a default value based on the
values of the variables @code{sentence-end-double-space}
(@pxref{Definition of sentence-end-double-space}),
@code{sentence-end-without-period}, and
@code{sentence-end-without-space}.
@end defun
