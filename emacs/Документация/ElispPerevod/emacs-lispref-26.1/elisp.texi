\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename /home/uanr81/shkola/emacs/Документация/ElispPerevod/info/elisp.info

@ifset VOL1
@set volflag
@set voltitle Volume 1
@end ifset

@ifset VOL2
@set volflag
@set voltitle Volume 2
@end ifset

@ifset volflag
@settitle GNU Emacs Lisp Reference Manual: @value{voltitle}
@end ifset
@ifclear volflag
@settitle GNU Emacs Lisp Reference Manual
@end ifclear
@include docstyle.texi

@c %**end of header

@c See two-volume-cross-refs.txt.
@tex
@ifset VOL1
\message{Formatting for two volume edition...Volume 1...}
%
% Read special toc file, set up in two-volume.make.
\gdef\tocreadfilename{elisp1-toc-ready.toc}
%
% Don't make outlines, they're not needed and \readdatafile can't pay
% attention to the special definition above.
\global\let\pdfmakeoutlines=\relax
%
% Start volume 1 chapter numbering at 1; this must be listed as chapno0.
\global\chapno=0
@end ifset
@ifset VOL2
\message{Formatting for two volume edition...Volume 2...}
%
% Read special toc file, set up in two-volume.make.
\gdef\tocreadfilename{elisp2-toc-ready.toc}
%
% Don't make outlines, they're not needed and \readdatafile can't pay
% attention to the special definition above.
\global\let\pdfmakeoutlines=\relax
%
% Start volume 2 chapter numbering at 27; this must be listed as chapno26
\global\chapno=26
@end ifset
@end tex


@c Version of the manual and of Emacs.
@c (See comments for EDITION in emacs.texi)
@set VERSION  3.1
@include emacsver.texi
@set DATE October 2014

@c in general, keep the following line commented out, unless doing a
@c copy of this manual that will be published.  The manual should go
@c onto the distribution in the full, 8.5 x 11" size.
@c @set smallbook

@ifset volflag
@smallbook
@end ifset

@ifset smallbook
@smallbook
@end ifset

@c per rms and peterb, use 10pt fonts for the main text, mostly to
@c save on paper cost.
@c Do this inside @tex for now, so current makeinfo does not complain.
@tex
@ifset smallbook
@fonttextsize 10
@end ifset
\global\hbadness=6666 % don't worry about not-too-underfull boxes
@end tex

@c Combine indices.
@synindex cp fn
@syncodeindex vr fn
@syncodeindex ky fn
@syncodeindex pg fn
@c We use the "type index" to index new functions and variables.
@c @syncodeindex tp fn

@copying
@iftex
This is edition @value{VERSION} of the @cite{GNU Emacs Lisp Reference Manual},@*
@end iftex
@ifnottex
This is the @cite{GNU Emacs Lisp Reference Manual}
@end ifnottex
corresponding to Emacs version @value{EMACSVER}.

Copyright @copyright{} 1990--1996, 1998--2018 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License,'' with the
Front-Cover Texts being ``A GNU Manual,'' and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.''
@end quotation
@end copying

@dircategory Emacs lisp
@direntry
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
@end direntry

@titlepage
@title GNU Emacs Lisp Reference Manual
@ifset volflag
@subtitle @value{voltitle}
@end ifset
@subtitle For Emacs Version @value{EMACSVER}
@subtitle Revision @value{VERSION}, @value{DATE}

@author by Bil Lewis, Dan LaLiberte, Richard Stallman,
@author the GNU Manual Group, et al.
@page
@vskip 0pt plus 1filll
@insertcopying

@sp 2
Published by the Free Software Foundation @*
51 Franklin St, Fifth Floor @*
Boston, MA 02110-1301 @*
USA @*
ISBN 1-882114-74-4

@sp 2
Cover art by Etienne Suvasa.
@end titlepage


@c Print the tables of contents
@summarycontents
@contents


@ifnottex
@node Top
@top Emacs Lisp

@ifset WWW_GNU_ORG
@html
<p>The homepage for GNU Emacs is at
<a href="/software/emacs/">https://www.gnu.org/software/emacs/</a>.<br>
For information on using Emacs, refer to the
<a href="/software/emacs/manual/emacs.html">Emacs Manual</a>.<br>
To view this manual in other formats, click
<a href="/software/emacs/manual/elisp.html">here</a>.
@end html
@end ifset

@insertcopying
@end ifnottex

@menu
* Introduction::            Введение и соглашения.

* Lisp Data Types::         Типы данных объектов в Emacs Lisp.
* Numbers::                 Числа и арифметические функции.
* Strings and Characters::  Строки и функции, которые работают над ними.
* Lists::                   Списки, ячейки cons и связанные с ними функции.
* Sequences Arrays Vectors::  Списки, строки и векторы называются
                              последовательностями. Некоторые функции действуют
                              на любую последовательность. Здесь также
                              приводится описание векторов.
* Records::                 Составные объекты с определенными
                            программистами типами.
* Hash Tables::             Очень быстрые таблицы поиска.
* Symbols::                 Символы обозначают имена, уникально.

* Evaluation::              Как оцениваются выражения Lisp.
* Control Structures::      Условные, циклы, нелокальные выходы.
* Variables::               Использование символов в программах для
                            обозначения значений.
* Functions::               Функция - это программа Lisp, которая может
                            быть вызвана из других функций.
* Macros::                  Макросы - это способ расширить язык Lisp.
* Customization::           Настройка переменных и настройка отображения.

* Loading::                 Чтение файлов Lisp-кода в Lisp.
* Byte Compilation::        Компиляция делает программы более быстрыми.
* Debugging::               Инструменты и советы по отладке программ Lisp.

* Read and Print::          Преобразование объектов Lisp в текст и обратно.
* Minibuffers::             Использование минибуфера для чтения ввода.
* Command Loop::            Как работает контур команды редактора и как
                            вы можете вызвать его подпрограммы.
* Keymaps::                 Определение привязок от ключей к командам.
* Modes::                   Определение основных и второстепенных режимов.
* Documentation::           Написание и использование строк документации.

* Files::                   Доступ к файлам.
* Backups and Auto-Saving:: Управление созданием резервных копий и
                            автоматическим сохранением файлов.
* Buffers::                 Создание и использование объектов буфера.
* Windows::                 Манипулирование окнами и отображение буферов.
* Frames::                  Создание нескольких окон на системном уровне.
* Positions::               Позиции буфера и функции движения.
* Markers::                 Маркеры представляют позиции и автоматически
                            обновляются при изменении текста.

* Text::                    Изучение и изменение текста в буферах.
* Non-ASCII Characters::    Текст, не содержащий ASCII в буферах и строках.
* Searching and Matching::  Поиск буферов для строк или регулярных выражений.
* Syntax Tables::           Таблица синтаксиса управляет разбором слов и списков.
* Abbrevs::                 Как работает режим Abbrev и его структуры данных.

* Threads::                 Параллельность в Emacs Lisp.
* Processes::               Запуск и связь с подпроцессами.
* Display::                 Особенности управления экраном.
* System Interface::        Получение идентификатора пользователя, типа
                            системы, переменных среды и т. Д.

* Packaging::               Подготовка кода Lisp для распространения.

Приложенеия

* Antinews::                Информация для пользователей, понижающих рейтинг до Emacs 25.
* GNU Free Documentation License:: Лицензия на эту документацию.
* GPL::                     Условия копирования и изменения GNU Emacs.
* Tips::                    Консультирование и кодирование для Emacs Lisp.
* GNU Emacs Internals::     Запуск и завершение Emacs; внутренние
                            структуры данных.
* Standard Errors::         Список некоторых стандартных символов ошибки.
* Standard Keymaps::        Список некоторых стандартных раскладок.
* Standard Hooks::          Список некоторых стандартных переменных.

* Index::                   Индекс включает понятия, функции, переменные
                            и другие термины.

@ignore
* New Symbols::             Новые функции и переменные в Emacs @value{EMACSVER}.
@end ignore

@c НЕ изменяйте следующие 3 строки! У них должна быть правильная идентификация
@c этой формы с помощью «texinfo-multiple-files-update». В частности, подробная
@c строка заголовка меню ДОЛЖНА быть идентичной значению «texinfo-master-menu-
@c header». См. Texnfo-upd.el.

@detailmenu
 --- The Detailed Node Listing ---
 ---------------------------------

Вот и другие узлы, которые являются подузнями тех, которые уже перечислены,
упомянутые здесь, чтобы вы могли добраться до них за один шаг:

Вступление

* Caveats::                 Недостатки и запрос о помощи.
* Lisp History::            Emacs Lisp происходит от Maclisp.
* Conventions::             Как отформатировано руководство.
* Version Info::            Какая версия Emacs запущена?
* Acknowledgments::         Авторы, редакторы и спонсоры этого руководства.

Условные обозначения

* Some Terms::              Объяснение терминов, которые мы используем в этом
                            руководстве.
* nil and t::               Как используются символы @code{nil} и @code{t}.
* Evaluation Notation::     Формат, который мы используем для примеров оценки.
* Printing Notation::       Формат, который мы используем, когда примеры
                            печатают текст.
* Error Messages::          Формат, который мы используем для примеров ошибок.
* Buffer Text Notation::    Формат, который мы используем для содержимого
                            буфера в примерах.
* Format of Descriptions::  Обозначение для описания функций, переменных и т.Д.

Формат описания

* A Sample Function Description::  Описание мнимой функции, @code{foo}.
* A Sample Variable Description::  Описание мнимой переменной, @code{electric-future-map}.

Типы данных Lisp

* Printed Representation::  Как объекты Lisp представлены в виде текста.
* Comments::                Комментарии и их соглашения о форматировании.
* Programming Types::       Типы, найденные во всех системах Lisp.
* Editing Types::           Типы, специфичные для Emacs.
* Circular Objects::        Прочитайте синтаксис для круговой структуры.
* Type Predicates::         Тесты, связанные с типами.
* Equality Predicates::     Испытания равенства между любыми двумя объектами.

Типы программирования

* Integer Type::        Числа без дробных частей.
* Floating-Point Type:: Числа с дробными частями и с большим диапазоном.
* Character Type::      Представление букв, цифр и управляющих символов.
* Symbol Type::         Многоцелевой объект, который ссылается на список
                        функций, переменных или свойств и имеет уникальный
                        идентификатор.
* Sequence Type::       Оба списка и массивы классифицируются как
                        последовательности.
* Cons Cell Type::      Минусы и списки (которые сделаны из cons-ячеек).
* Array Type::          Массивы включают строки и векторы.
* String Type::         Массив символов (эффективный).
* Vector Type::         Одномерные массивы.
* Char-Table Type::     Одномерные разреженные массивы, индексированные
                        символами.
* Bool-Vector Type::    Одномерные массивы @code{t} или @code{nil}.
* Hash Table Type::     Супер-быстрые таблицы поиска.
* Function Type::       Кусок исполняемого кода, который вы можете вызвать
                        из другого места.
* Macro Type::          Метод расширения выражения в другое выражение, более
                        фундаментальный, но менее симпатичный.
* Primitive Function Type::     Функция, написанная на C, вызываемая из Lisp.
* Byte-Code Type::      Функция, написанная в Lisp, затем скомпилирована.
* Record Type::         Составные объекты с определенными программистами типами.
* Type Descriptors::    Объекты, содержащие информацию о типах.
* Autoload Type::       Тип, используемый для автоматической загрузки редко
                        используемых функций.
* Finalizer Type::      Запускает код, когда он больше не доступен.

Символьный Тип

* Basic Char Syntax::       Синтаксис для регулярных символов.
* General Escape Syntax::   Как указать символы по их кодам.
* Ctl-Char Syntax::         Синтаксис для управляющих символов.
* Meta-Char Syntax::        Синтаксис для метасимволов.
* Other Char Bits::         Синтаксис для гипер-, супер- и альт-символов.

Cons Cell and List Types

* Box Diagrams::            Рисование изображений списков.
* Dotted Pair Notation::    Общий синтаксис для cons-ячеек.
* Association List Type::   Специально составленный список.

Строковый Тип

* Syntax for Strings::      Как указать строки Lisp.
* Non-ASCII in Strings::    Международные символы в строках.
* Nonprinting Characters::  Буквенные непечатаемые символы в строках.
* Text Props and Strings::  Строки с текстовыми свойствами.

Типы Редактора

* Buffer Type::             Основной объект редактирования.
* Marker Type::             Позиция в буфере.
* Window Type::             Буферы отображаются в окнах.
* Frame Type::              Окно подразделяет фреймы.
* Terminal Type::           Терминальное устройство отображает фреймы.
* Window Configuration Type::  Запись способа разделения кадра.
* Frame Configuration Type::   Запись состояния всех кадров.
* Process Type::            Подпроцесс Emacs, работающий на базовой ОС.
* Thread Type::             Поток выполнения Emacs Lisp.
* Mutex Type::              Исключительная блокировка синхронизации потоков.
* Condition Variable Type::    Переменная условия для синхронизации потоков.
* Stream Type::             Получать или отправлять символы.
* Keymap Type::             Какую функцию вызывает нажатие клавиши.
* Overlay Type::            Как отображается оверлей.
* Font Type::               Шрифты для отображения текста.

Числа

* Integer Basics::          Представление и диапазон целых чисел.
* Float Basics::            Представление и диапазон значений с плавающей запятой.
* Predicates on Numbers::   Тестирование чисел.
* Comparison of Numbers::   Предикаты равенства и неравенства.
* Numeric Conversions::     Преобразование float в integer и наоборот.
* Arithmetic Operations::   Как добавить, вычесть, умножить и разделить.
* Rounding Operations::     Явное округление чисел с плавающей запятой.
* Bitwise Operations::      Логический и, или, не, сдвиг.
* Math Functions::          Тригонометрические, экспоненциальные и
                            логарифмические функции.
* Random Numbers::          Получение случайных целых чисел, предсказуемых
                            или нет.

Строки и Символы

* String Basics::           Основные свойства строк и символов.
* Predicates for Strings::  Проверка того, является ли объект строкой или
                            символом.
* Creating Strings::        Функции для выделения новых строк.
* Modifying Strings::       Изменение содержимого существующей строки.
* Text Comparison::         Сравнение символов или строк.
* String Conversion::       Преобразование символов в строки и наоборот.
* Formatting Strings::      @code{format}: Аналог Emacs @code{printf}.
* Case Conversion::         Функции преобразования регистра.
* Case Tables::             Настройка преобразования регистра.

Списки

* Cons Cells::              Как списки сделаны из cons-ячеек.
* List-related Predicates:: Является ли этот объект списком? Сравнение двух
                            списков.
* List Elements::           Извлечение фрагментов списка.
* Building Lists::          Создание структуры списка.
* List Variables::          Изменение списков, хранящихся в переменных.
* Modifying Lists::         Хранение новых произведений в существующем списке.
* Sets And Lists::          Список может представлять собой конечный
                            математический набор.
* Association Lists::       Список может представлять собой конечное отношение
                            или отображение.
* Property Lists::          Список парных элементов.

Изменение существующей структуры списка

* Setcar::                  Замена элемента в списке.
* Setcdr::                  Замена части основы списка.
                            Это можно использовать для удаления или добавления
                            элементов.
* Rearrangement::           Переупорядочение элементов в списке;
                            объединение списков.

Списки свойств

* Plists and Alists::       Сравнение преимуществ списков свойств и списков
                            ассоциаций.
* Plist Access::            Доступ к спискам свойств, хранящимся в другом месте.

Последовательности, массивы и векторы

* Sequence Functions::      Функции, которые принимают любую последовательность.
* Arrays::                  Характеристики массивов в Emacs Lisp.
* Array Functions::         Функции специально для массивов.
* Vectors::                 Специальные характеристики векторов Emacs Lisp.
* Vector Functions::        Функции специально для векторов.
* Char-Tables::             Как работать с char-tables.
* Bool-Vectors::            Как работать с bool-векторами.
* Rings::                   Управление кольцом фиксированного размера объектов.

документация

* Record Functions::        Функции для записей.
* Backward Compatibility::  Совместимость для cl-defstruct.

Хэш-таблицы

* Creating Hash::           Функции для создания хеш-таблиц.
* Hash Access::             Чтение и запись содержимого хэш-таблицы.
* Defining Hash::           Определение новых методов сравнения.
* Other Hash::              Разнообразный.

Символы

* Symbol Components::       Символы имеют имена, значения, определения
                            функций и списки свойств.
* Definitions::             В определении говорится, как будет использоваться
                            символ.
* Creating Symbols::        Как символы сохраняются уникальными.
* Symbol Properties::       Каждый символ имеет список свойств для записи
                            различной информации.

Свойства символа

* Symbol Plists::           Доступ к свойствам символа.
* Standard Properties::     Стандартные значения свойств символа.

Оценка

* Intro Eval::              Оценка в схеме вещей.
* Forms::                   Как оцениваются различные типы объектов.
* Quoting::                 Избегать оценки (поставить константы в программу).
* Backquote::               Простое построение структуры списка.
* Eval::                    Как явно вызывать интерпретатор Lisp.

Виды форм

* Self-Evaluating Forms::   Формы, которые оцениваются сами собой.
* Symbol Forms::            Символы оцениваются как переменные.
* Classifying Lists::       Как различать различные виды форм списка.
* Function Indirection::    Когда символ появляется первым списка, мы находим
                            действительную функцию через символ.
* Function Forms::          Формы, вызывающие функции.
* Macro Forms::             Формы, вызывающие макросы.
* Special Forms::           Специальные формы - своеобразные примитивы,
                            большинство из которых чрезвычайно важны.
* Autoloading::             Функции, установленные для загрузки файлов,
                            содержащих их реальные определения.

Контрольные структуры

* Sequencing::              Оценка в текстовом порядке.
* Conditionals::            @code{if}, @code{cond}, @code{when}, @code{unless}.
* Combining Conditions::    @code{and}, @code{or}, @code{not}.
* Iteration::               @code{while} петли.
* Generators::              Общие последовательности и сопрограммы.
* Nonlocal Exits::          Выпрыгивание из последовательности.

Conditionals

* Pattern matching case statement::  Как пользоваться @code{pcase}.

Нелокальные выходы

* Catch and Throw::         Нелокальные выходы для собственных целей программы.
* Examples of Catch::       Показывается, как можно записать такие нелокальные
                            выходы.
* Errors::                  Как сигнализировать и обрабатывать ошибки.
* Cleanups::                Организация запуска формы очистки при
                            возникновении ошибки.

Ошибки

* Signaling Errors::        Как сообщить об ошибке.
* Processing of Errors::    Что Emacs делает, когда вы сообщаете об ошибке.
* Handling Errors::         Как вы можете уловить ошибки и продолжить
                            выполнение.
* Error Symbols::           Как ошибки классифицируются для их захвата.

переменные

* Global Variables::        Переменные значения, которые существуют постоянно,
                            везде.
* Constant Variables::      Переменные, которые никогда не меняются.
* Local Variables::         Значения переменных, которые существуют только
                            временно.
* Void Variables::          Символы, которые не имеют значений.
* Defining Variables::      Определение говорит, что символ используется как
                            переменная.
* Tips for Defining::       О чем вы должны думать, когда вы определяете
                            переменную.
* Accessing Variables::     Изучение значений переменных, имена которых
                            известны только во время выполнения.
* Setting Variables::       Сохранение новых значений в переменных.
* Watching Variables::      Запуск функции при изменении переменной.
* Variable Scoping::        Как Lisp выбирает среди локальных и глобальных
                            значений.
* Buffer-Local Variables::  Значения переменных действуют только в одном буфере.
* File Local Variables::    Обработка списков локальных переменных в файлах.
* Directory Local Variables:: Локальные переменные, общие для всех файлов в
                              каталоге.
* Connection Local Variables::  Локальные переменные, общие для удаленных
                                подключений.
* Variable Aliases::        Переменные, которые являются псевдонимами для
                            других переменных.
* Variables with Restricted Values::  Непостоянные переменные, значение которых
                                      может быть @emph{not} произвольным
                                      объектом Lisp.
* Generalized Variables::   Расширение понятия переменных.

Правила для определения переменных привязок

* Dynamic Binding::         Значение по умолчанию для привязки локальных
                            переменных в Emacs.
* Dynamic Binding Tips::    Избегайте проблем с динамической привязкой.
* Lexical Binding::         Другой тип привязки локальной переменной.
* Using Lexical Binding::   Как включить лексическое связывание.

Локальные переменные буфера

* Intro to Buffer-Local::   Введение и концепции.
* Creating Buffer-Local::   Создание и уничтожение буферов-локальных привязок.
* Default Value::           Значение по умолчанию отображается в буферах,
                            которые не имеют собственных локальных значений
                            буфера.

Обобщенные переменные

* Setting Generalized Variables::   Макрос @code{setf}.
* Adding Generalized Variables::    Определение новых форм @code{setf}.

Функции

* What Is a Function::      Функции Лиспа против примитивов; терминология.
* Lambda Expressions::      Как функции выражаются как объекты Lisp.
* Function Names::          Символом может служить имя функции.
* Defining Functions::      Выражения Lisp для определения функций.
* Calling Functions::       Как использовать существующую функцию.
* Mapping Functions::       Применение функции к каждому элементу списка и т.д.
* Anonymous Functions::     Лямбда-выражения - это функции без имен.
* Generic Functions::       Полиморфизм, стиль Emacs.
* Function Cells::          Доступ или определение функции символа.
* Closures::                Функции, которые включают лексическую среду.
* Advising Functions::      Добавление к определению функции.
* Obsolete Functions::      Объявление устаревших функций.
* Inline Functions::        Определение функций, которые компилятор будет
                            расширять inline.
* Declare Form::            Добавление дополнительной информации о функции.
* Declaring Functions::     Сообщение компилятору о том, что функция определена.
* Function Safety::         Определение того, безопасна ли функция для вызова.
* Related Topics::          Перекрестные ссылки на конкретные примитивы Lisp,
                            которые имеют особое значение для работы функций.

Лямбда-выражения

* Lambda Components::       Части лямбда-выражения.
* Simple Lambda::           Простой пример.
* Argument List::           Детали и особенности списков аргументов.
* Function Documentation::  Как разместить документацию в функции.

Консультирование функций Emacs Lisp

* Core Advising Primitives::  Примитивы для управления советами.
* Advising Named Functions::  Консультирование названных функций.
* Advice combinators::        Способы составления совета.
* Porting old advice::        Адаптация кода с использованием старой defadvice.

Макросы

* Simple Macro::            Простой пример.
* Expansion::               Как, когда и почему макросы расширяются.
* Compiling Macros::        Как макросы расширяются компилятором.
* Defining Macros::         Как написать определение макроса.
* Problems with Macros::    Не оценивайте макрокоманды слишком много раз. Не
                            скрывайте переменные пользователя.
* Indenting Macros::        Указание способа вызова макросов с отступом.

Общие проблемы с использованием макросов

* Wrong Time::             Делайте работу в расширении, а не в макросе.
* Argument Evaluation::    Расширение должно оценивать каждый макрос один раз.
* Surprising Local Vars::  Локальные переменные привязки в расширении требуют
                           особого внимания.
* Eval During Expansion::  Не оценивайте их; положить их в расширение.
* Repeated Expansion::     Избегайте зависимости от того, сколько раз было
                           сделано расширение.

Настройки параметров

* Common Keywords::         Общие аргументы ключевых слов для всех видов
                            объявлений настройки.
* Group Definitions::       Написание определений групп настройки.
* Variable Definitions::    Объявление параметров пользователя.
* Customization Types::     Указание типа пользовательской опции.
* Applying Customizations:: Функции для применения настроек настройки.
* Custom Themes::           Написание пользовательских тем.

Типы настроек

* Simple Types::            Простые типы настройки: sexp, integer и т.д.
* Composite Types::         Создавайте новые типы из других типов или данных.
* Splicing into Lists::     Объединение элементов в список с помощью
                            @code{:inline}.
* Type Keywords::           Параметров ключевых слов в типе настройки.
* Defining New Types::      Дайте вашему типу имя.

загрузка

* How Programs Do Loading:: Функция @code{load} и другие.
* Load Suffixes::           Подробности о суффиксах @code{load}.
* Library Search::          Поиск библиотеки для загрузки.
* Loading Non-ASCII::       Non-@acronym{ASCII} в файлах Emacs Lisp.
* Autoload::                Настройка функции автозагрузки.
* Repeated Loading::        Меры предосторожности при загрузке файла дважды.
* Named Features::          Загрузка библиотеки, если она еще не загружена.
* Where Defined::           Поиск того, какой файл определил определенный
                            символ.
* Unloading::               Как выгрузить загруженную библиотеку.
* Hooks for Loading::       Предоставление кода для запуска при загрузке
                            определенных библиотек.
* Dynamic Modules::         Модули предоставляют дополнительные примитивы Lisp.

Байт-компиляция

* Speed of Byte-Code::      Пример ускорения работы с байтовой компиляцией.
* Compilation Functions::   Функции байт компиляции.
* Docs and Compilation::    Динамическая загрузка строк документации.
* Dynamic Loading::         Динамическая загрузка отдельных функций.
* Eval During Compile::     Код, который будет оцениваться при компиляции.
* Compiler Errors::         Обработка сообщений об ошибках компилятора.
* Byte-Code Objects::       Тип данных, используемый для байт-скомпилированных
                            функций.
* Disassembly::             Дизассемблирование байт-кода; как читать байт-код.

Отладка программ Lisp

* Debugger::                Отладчик для оценщика Emacs Lisp.
* Edebug::                  Исходный уровень Emacs Lisp отладчик.
* Syntax Errors::           Как найти синтаксические ошибки.
* Test Coverage::           Убедитесь, что вы проверили все участки в
                            своем коде.
* Profiling::               Измерение ресурсов, используемых вашим кодом.

Отладчик Lisp

* Error Debugging::         Запуск отладчика при возникновении ошибки.
* Infinite Loops::          Остановка и отладка программы, которая не
                            завершается.
* Function Debugging::      Запуск его при вызове определенной функции.
* Variable Debugging::      Ввод его при изменении переменной.
* Explicit Debug::          Ввод его в определенный момент в программе.
* Using Debugger::          Что делает отладчик; что вы видите во время этого.
* Debugger Commands::       Команды, используемые в отладчике.
* Invoking the Debugger::   Как вызвать функцию @code{debug}.
* Internals of Debugger::   Подпрограммы отладчика и глобальные переменные.

Edebug

* Using Edebug::            Введение в использование Edebug.
* Instrumenting::           Вы должны настроить свой код, чтобы отладить его
                            с помощью Edebug.
* Edebug Execution Modes::  Режимы выполнения, останавкиь более или менее часто.
* Jumping::                 Команды для перехода в указанное место.
* Edebug Misc::             Различные команды.
* Breaks::                  Установка точек останова для остановки программы.
* Trapping Errors::         Ловушка ошибок с Edebug.
* Edebug Views::            Обзор внутри и снаружи Edebug.
* Edebug Eval::             Оценка выражений в Edebug.
* Eval List::               Выражения, значения которых отображаются каждый
                            раз, когда вы вводите Edebug.
* Printing in Edebug::      Настройка вывода.
* Trace Buffer::            Как создать вывод трассировки в буфере.
* Coverage Testing::        Как проверить охват оценки.
* The Outside Context::     Данные, которые Edebug сохраняет и восстанавливает.
* Edebug and Macros::       Указание способа обработки вызовов макросов.
* Edebug Options::          Опционные переменные для настройки Edebug.

Перерывы

* Breakpoints::             Точки останова в точках остановки.
* Global Break Condition::  Разрыв на событии.
* Source Breakpoints::      Встраивание точек останова в исходный код.

Внешний контекст

* Checking Whether to Stop::Когда Эдебуг решает, что делать.
* Edebug Display Update::   Когда Edebug обновляет дисплей.
* Edebug Recursive Edit::   Когда Edebug прекращает выполнение.

Эдебуг и макросы

* Instrumenting Macro Calls::Основная проблема.
* Specification List::      Как определить сложные шаблоны оценки.
* Backtracking::            Что делает Edebug при совпадении.
* Specification Examples::  Чтобы помочь понять спецификации.

Отладка недействительного синтаксиса Lisp

* Excess Open::             Как найти ложный открытый или отсутствующий.
* Excess Close::            Как найти ложный закрытый или отсутствующий открытый.

Чтение и печать объектов Lisp

* Streams Intro::           Обзор потоков, чтение и печать.
* Input Streams::           Различные типы данных, которые могут использоваться в
                            качестве входных потоков.
* Input Functions::         Функции для чтения объектов Lisp из текста.
* Output Streams::          Различные типы данных, которые могут использоваться в
                            качестве выходных потоков.
* Output Functions::        Функции для печати объектов Lisp в виде текста.
* Output Variables::        Переменные, которые управляют функциями печати.

Minibuffers

* Intro to Minibuffers::    Основная информация о минибуферах.
* Text from Minibuffer::    Как читать прямую текстовую строку.
* Object from Minibuffer::  Как читать объект Lisp или выражение.
* Minibuffer History::      Запись предыдущих входов минибуфера, чтобы пользователь мог
                            их повторно использовать.
* Initial Input::           Указание начального содержимого для минибуфера.
* Completion::              Как вызвать и настроить завершение.
* Yes-or-No Queries::       Задавая вопрос простым ответом.
* Multiple Queries::        Задавая ряд подобных вопросов.
* Reading a Password::      Чтение пароля с терминала.
* Minibuffer Commands::     Команды, используемые в качестве привязок клавиш в минибуферах.
* Minibuffer Windows::      Работает на специальных окнах минибуфера.
* Minibuffer Contents::     Как такие команды получают доступ к тексту минибуфера.
* Recursive Mini::          Разрешена ли рекурсивная запись в минибуфер.
* Minibuffer Misc::         Различные крючки и переменные настройки.

Завершение

* Basic Completion::        Низкоуровневые функции для завершения строк.
* Minibuffer Completion::   Вызов минибуфера с завершением.
* Completion Commands::     Команды Minibuffer, которые завершают работу.
* High-Level Completion::   Удобные особые случаи завершения (имена буфера чтения, имена
                            переменных и т.д.).
* Reading File Names::      Использование завершения для чтения имен файлов и команд
                            оболочки.
* Completion Variables::    Переменные, контролирующие поведение завершения.
* Programmed Completion::   Написание собственной функции завершения.
* Completion in Buffers::   Заполнение текста в обычных буферах.

Командный цикл

* Command Overview::    Как командный цикл считывает команды.
* Defining Commands::   Указание того, как функция должна читать аргументы.
* Interactive Call::    Вызов команды, чтобы он читал аргументы.
* Distinguish Interactive::     Выполнение команды отличает интерактивные вызовы.
* Command Loop Info::   Переменные, заданные в командной строке для проверки.
* Adjusting Point::     Настройка точки после команды.
* Input Events::        Какой ввод выглядит, когда вы его читаете.
* Reading Input::       Как читать входные события с клавиатуры или мыши.
* Special Events::      События обрабатываются немедленно и индивидуально.
* Waiting::             Ожидание ввода пользователем или истекшего времени.
* Quitting::            Как работает @kbd{C-g}. Как поймать или отложить выход.
* Prefix Command Arguments::    Как работают команды для установки префиксов args.
* Recursive Editing::   Ввод рекурсивного редактирования и почему вы обычно не должны.
* Disabling Commands::  Как командный цикл обрабатывает отключенные команды.
* Command History::     Как настраивается история команд и как осуществляется доступ к ней.
* Keyboard Macros::     Как реализованы клавиатурные макросы.

Определение команд

* Using Interactive::       Общие правила для @code{interactive}.
* Interactive Codes::       Стандартные буквенные коды для чтения аргументов различными
                            способами.
* Interactive Examples::    Примеры чтения интерактивных аргументов.
* Generic Commands::        Выберите один из вариантов команды.


Входные события

* Keyboard Events::         Обычные символы - клавиши с символами на них.
* Function Keys::           Функциональные клавиши - клавиши с именами, а не символами.
* Mouse Events::            Обзор событий мыши.
* Click Events::            Нажатие и отпускание кнопки мыши.
* Drag Events::             Перемещение мыши до отпускания кнопки.
* Button-Down Events::      Кнопка была нажата и еще не выпущена.
* Repeat Events::           Двойной и тройной щелчок (или перетаскивание или вниз).
* Motion Events::           Просто двигайте мышь, не нажимая кнопку.
* Focus Events::            Перемещение мыши между кадрами.
* Misc Events::             Другие события, которые система может генерировать.
* Event Examples::          Примеры списков событий мыши.
* Classifying Events::      Поиск ключей модификатора в символе события. Типы событий.
* Accessing Mouse::         Функции для извлечения информации из событий мыши.
* Accessing Scroll::        Функции для получения информации о событиях полосы прокрутки.
* Strings of Events::       Особые соображения для размещения событий символа клавиатуры
                            в строке.

Чтение ввода

* Key Sequence Input::      Как читать одну последовательность клавиш.
* Reading One Event::       Как читать только одно событие.
* Event Mod::               Как Emacs изменяет события по мере их чтения.
* Invoking the Input Method::   Как чтение события использует метод ввода.
* Quoted Character Input::  Попросить пользователя указать символ.
* Event Input Misc::        Как перечитать или выбросить входные события.

Таблицы ключей

* Key Sequences::           Ключевые последовательности как объекты Lisp.
* Keymap Basics::           Основные понятия раскладок.
* Format of Keymaps::       Какая карта клавиатуры выглядит как объект Lisp.
* Creating Keymaps::        Функции для создания и копирования раскладок.
* Inheritance and Keymaps:: Как одна keymap может наследовать привязки другой раскладки.
* Prefix Keys::             Определение ключа с раскладкой в ​​качестве определения.
* Active Keymaps::          Как Emacs ищет активные раскладки клавиатуры для привязки
                            ключей.
* Searching Keymaps::       Псевдо-Lisp резюме поиска активных карт.
* Controlling Active Maps:: Каждый буфер имеет локальную раскладку для переопределения
                            стандартных (глобальных) привязок. Малый режим также
                            может их переопределить.
* Key Lookup::              Поиск привязки ключа в одной ключевой карте.
* Functions for Key Lookup::    Как запросить ключевой поиск.
* Changing Key Bindings::   Переопределение ключа в ключевой карте.
* Remapping Commands::      Клавиатура может переводить одну команду в другую.
* Translation Keymaps::     Ключи для перевода последовательностей событий.
* Key Binding Commands::    Интерактивные интерфейсы для переопределения ключей.
* Scanning Keymaps::        Просмотр всех раскладок, для печати справки.
* Menu Keymaps::            Определение меню в виде раскладки.

Клавиши меню

* Defining Menus::          Как создать раскладку, которая определяет меню.
* Mouse Menus::             Как пользователи приводят в действие меню с помощью мыши.
* Keyboard Menus::          Как пользователи приводят в действие меню с помощью клавиатуры.
* Menu Example::            Создание простого меню.
* Menu Bar::                Как настроить панель меню.
* Tool Bar::                Панель инструментов представляет собой ряд изображений.
* Modifying Menus::         Как добавить новые элементы в меню.
* Easy Menu::               Удобный макрос для определения меню.

Определение меню

* Simple Menu Items::       Простой вид привязки клавиш меню.
* Extended Menu Items::     Более сложные определения пунктов меню.
* Menu Separators::         Рисование горизонтальной линии через меню.
* Alias Menu Items::        Использование псевдонимов команд в пунктах меню.

Основные и второстепенные режимы

* Hooks::              Как использовать крючки; как писать код, который предоставляет
                       крючки.
* Major Modes::        Определение основных режимов.
* Minor Modes::        Определение второстепенных режимов.
* Mode Line Format::   Настройка текста, отображаемого в строке режима.
* Imenu::              Предоставление меню определений, сделанных в буфере.
* Font Lock Mode::     Как режимы могут выделять текст в соответствии с синтаксисом.
* Auto-Indentation::   Как научить Emacs отступов для основного режима.
* Desktop Save Mode::  Как режимы могут сохранять состояние буфера между сеансами Emacs.

Крючки

* Running Hooks::      Как запустить крючок.
* Setting Hooks::      Как поместить функции на крючок или удалить их.

Основные режимы

* Major Mode Conventions::  Соглашения о кодировании для раскладок и т.д.
* Auto Major Mode::         Как Emacs автоматически выбирает основной режим.
* Mode Help::               Определение способа использования режима.
* Derived Modes::           Определение нового основного режима на основе
                            другого основного режима.
* Basic Major Modes::       Режимы, из которых часто происходят другие режимы.
* Mode Hooks::              Крюки запускаются в конце основных функций режима.
* Tabulated List Mode::     Родительский режим для буферов, содержащих табличные данные.
* Generic Modes::           Определение простого основного режима, поддерживающего
                            синтаксис комментариев и режим блокировки шрифтов.
* Example Major Modes::     Текстовый режим и режимы Лиспа.

Дополнительные режимы

* Minor Mode Conventions::  Советы по написанию второстепенного режима.
* Keymaps and Minor Modes:: Как второстепенный режим может иметь свою собственную
                            раскладку.
* Defining Minor Modes::    Удобное средство для определения второстепенных режимов.

Формат режима строки 

* Mode Line Basics::        Основные идеи управления линией режима.
* Mode Line Data::          Структура данных, которая управляет линией режима.
* Mode Line Top::           Переменная верхнего уровня, mode-line-format.
* Mode Line Variables::     Переменные, используемые в этой структуре данных.
* %-Constructs::            Ввод информации в линию режима.
* Properties in Mode::      Использование текстовых свойств в строке режима.
* Header Lines::            Как линия режима, но вверху.
* Emulating Mode Line::     Форматирование текста в виде строки режима.

Режим блокировки шрифтов

* Font Lock Basics::        Обзор настройки Font Lock.
* Search-based Fontification::  Обозначение на основе регулярных выражений.
* Customizing Keywords::    Настройка пользовательской настройки.
* Other Font Lock Variables::   Дополнительные возможности настройки.
* Levels of Font Lock::     Каждый режим может определять альтернативные уровни, чтобы
                            пользователь мог выбирать более или менее.
* Precalculated Fontification:: Как программы Lisp, которые создают содержимое буфера,
                                также могут указать, как его размножать.
* Faces for Font Lock::     Специальные лица специально для Font Lock.
* Syntactic Font Lock::     Fontification на основе синтаксических таблиц.
* Multiline Font Lock::     Как заставить Font Lock правильно выделять
                            многострочные конструкции.

Многострочные блокировки шрифтов

* Font Lock Multiline::     Маркировка многострочных фрагментов с текстовым свойством.
* Region to Refontify::     Контроль того, какая область будет изменена после
                            изменения буфера.

Автоматический отступ кода

* SMIE::                    Простой мыслящий движок отступа.

Простой Minded Indentation Engine

* SMIE setup::              Настройка и функции SMIE.
* Operator Precedence Grammars:: Очень простая методика синтаксического анализа.
* SMIE Grammar::            Определение грамматики языка.
* SMIE Lexer::              Определение токенов.
* SMIE Tricks::             Работа над ограничениями парсера.
* SMIE Indentation::        Указание правил отступов.
* SMIE Indentation Helpers:: Вспомогательные функции для правил отступов.
* SMIE Indentation Example:: Примеры правил отступов.
* SMIE Customization::      Настройка отступов.

Документация

* Documentation Basics::    Где doc строки определены и сохранены.
* Accessing Documentation:: Как программы Lisp могут получить доступ к строкам документа.
* Keys in Documentation::   Подстановка текущих привязок клавиш.
* Text Quoting Style::      Котировки в строках и сообщениях.
* Describing Characters::   Создание печатных описаний непечатаемых символов и
                            последовательностей клавиш.
* Help Functions::          Подпрограммы, используемые средствами помощи Emacs.

Файлы

* Visiting Files::          Чтение файлов в буферы Emacs для редактирования.
* Saving Buffers::          Написание измененных буферов обратно в файлы.
* Reading from Files::      Чтение файлов в буферы без посещения.
* Writing to Files::        Написание новых файлов из частей буферов.
* File Locks::              Блокировка и разблокировка файлов, чтобы предотвратить
                            одновременное редактирование двумя людьми.
* Information about Files:: Проверка наличия, доступности, размера файлов.
* Changing Files::          Переименование файлов, изменение разрешений и т.д.
* File Names::              Разложение и расширение имен файлов.
* Contents of Directories:: Получение списка файлов в каталоге.
* Create/Delete Dirs::      Создание и удаление каталогов.
* Magic File Names::        Специальная обработка для определенных имен файлов.
* Format Conversion::       Преобразование в различные форматы файлов и из них.

Просмотр файлов

* Visiting Functions::      Обычные функции интерфейса для посещения.
* Subroutines of Visiting:: Подпрограммы нижнего уровня, которые они используют.

Информация о файлах

* Testing Accessibility::   Является ли данный файл доступным для чтения? Writable?
* Kinds of Files::          Это каталог? Символическая ссылка?
* Truenames::               Устранение символических ссылок из имени файла.
* File Attributes::         Размер файла, время модификации и т.д.
* Extended Attributes::     Расширенные атрибуты файлов для контроля доступа.
* Locating Files::          Как найти файл в стандартных местах.

Имена файлов

* File Name Components::    Часть каталога имени файла, а остальное.
* Relative File Names::     Некоторые имена файлов относятся к текущему каталогу.
* Directory Names::         A directory's name as a directory
                              is different from its name as a file.
* File Name Expansion::     Converting relative file names to absolute ones.
* Unique File Names::       Generating names for temporary files.
* File Name Completion::    Finding the completions for a given file name.
* Standard File Names::     If your package uses a fixed file name,
                              how to handle various operating systems simply.

File Format Conversion

* Format Conversion Overview::   @code{insert-file-contents} and @code{write-region}.
* Format Conversion Round-Trip:: Using @code{format-alist}.
* Format Conversion Piecemeal::  Specifying non-paired conversion.

Backups and Auto-Saving

* Backup Files::            How backup files are made; how their names
                              are chosen.
* Auto-Saving::             How auto-save files are made; how their
                              names are chosen.
* Reverting::               @code{revert-buffer}, and how to customize
                              what it does.

Backup Files

* Making Backups::          How Emacs makes backup files, and when.
* Rename or Copy::          Two alternatives: renaming the old file
                              or copying it.
* Numbered Backups::        Keeping multiple backups for each source file.
* Backup Names::            How backup file names are computed; customization.

Buffers

* Buffer Basics::           What is a buffer?
* Current Buffer::          Designating a buffer as current
                              so that primitives will access its contents.
* Buffer Names::            Accessing and changing buffer names.
* Buffer File Name::        The buffer file name indicates which file
                              is visited.
* Buffer Modification::     A buffer is @dfn{modified} if it needs to be saved.
* Modification Time::       Determining whether the visited file was changed
                              behind Emacs's back.
* Read Only Buffers::       Modifying text is not allowed in a
                              read-only buffer.
* Buffer List::             How to look at all the existing buffers.
* Creating Buffers::        Functions that create buffers.
* Killing Buffers::         Buffers exist until explicitly killed.
* Indirect Buffers::        An indirect buffer shares text with some
                              other buffer.
* Swapping Text::           Swapping text between two buffers.
* Buffer Gap::              The gap in the buffer.

Windows

* Basic Windows::           Basic information on using windows.
* Windows and Frames::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window's size.
* Resizing Windows::        Changing the sizes of windows.
* Preserving Window Sizes:: Preserving the size of windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Recombining Windows::     Preserving the frame layout when splitting and
                              deleting windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer.
* Choosing Window::         How to choose a window for displaying a buffer.
* Display Action Functions:: Subroutines for @code{display-buffer}.
* Choosing Window Options:: Extra options affecting how buffers are displayed.
* Window History::          Each window remembers the buffers displayed in it.
* Dedicated Windows::       How to avoid displaying another buffer in
                              a specific window.
* Quitting Windows::        How to restore the state prior to displaying a
                              buffer.
* Side Windows::            Special windows on a frame's sides.
* Atomic Windows::          Preserving parts of the window layout.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Converting coordinates to windows.
* Mouse Window Auto-selection:: Automatically selecting windows with the mouse.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.

Side Windows

* Displaying Buffers in Side Windows:: An action function for displaying
                              buffers in side windows.
* Side Window Options and Functions:: Further tuning of side windows.
* Frame Layouts with Side Windows:: Setting up frame layouts with side
                              windows.

Frames

* Creating Frames::         Creating additional frames.
* Multiple Terminals::      Displaying on several different devices.
* Frame Geometry::          Geometric properties of frames.
* Frame Parameters::        Controlling frame size, position, font, etc.
* Terminal Parameters::     Parameters common for all frames on terminal.
* Frame Titles::            Automatic updating of frame titles.
* Deleting Frames::         Frames last until explicitly deleted.
* Finding All Frames::      How to examine all existing frames.
* Minibuffers and Frames::  How a frame finds the minibuffer to use.
* Input Focus::             Specifying the selected frame.
* Visibility of Frames::    Frames may be visible or invisible, or icons.
* Raising and Lowering::    Raising, Lowering and Restacking Frames.
* Frame Configurations::    Saving the state of all frames.
* Child Frames::            Making a frame the child of another.
* Mouse Tracking::          Getting events that say when the mouse moves.
* Mouse Position::          Asking where the mouse is, or moving it.
* Pop-Up Menus::            Displaying a menu for the user to select from.
* Dialog Boxes::            Displaying a box to ask yes or no.
* Pointer Shape::           Specifying the shape of the mouse pointer.
* Window System Selections::Transferring text to and from other X clients.
* Drag and Drop::           Internals of Drag-and-Drop implementation.
* Color Names::             Getting the definitions of color names.
* Text Terminal Colors::    Defining colors for text terminals.
* Resources::               Getting resource values from the server.
* Display Feature Testing:: Determining the features of a terminal.

Frame Geometry

* Frame Layout::            Basic layout of frames.
* Frame Font::              The default font of a frame and how to set it.
* Frame Position::          The position of a frame on its display.
* Frame Size::              Specifying and retrieving a frame's size.
* Implied Frame Resizing::  Implied resizing of frames and how to prevent it.

Frame Parameters

* Parameter Access::        How to change a frame's parameters.
* Initial Parameters::      Specifying frame parameters when you make a frame.
* Window Frame Parameters:: List of frame parameters for window systems.
* Geometry::                Parsing geometry specifications.

Window Frame Parameters

* Basic Parameters::        Parameters that are fundamental.
* Position Parameters::     The position of the frame on the screen.
* Size Parameters::         Frame's size.
* Layout Parameters::       Size of parts of the frame, and
                              enabling or disabling some parts.
* Buffer Parameters::       Which buffers have been or should be shown.
* Frame Interaction Parameters::  Parameters for interacting with other
                              frames.
* Mouse Dragging Parameters::  Parameters for resizing and moving
                              frames with the mouse.
* Management Parameters::   Communicating with the window manager.
* Cursor Parameters::       Controlling the cursor appearance.
* Font and Color Parameters:: Fonts and colors for the frame text.

Positions

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Narrowing::               Restricting editing to a portion of the buffer.

Motion

* Character Motion::        Moving in terms of characters.
* Word Motion::             Moving in terms of words.
* Buffer End Motion::       Moving to the beginning or end of the buffer.
* Text Lines::              Moving in terms of lines of text.
* Screen Lines::            Moving in terms of lines as displayed.
* List Motion::             Moving by parsing lists and sexps.
* Skipping Characters::     Skipping characters belonging to a certain set.

Markers

* Overview of Markers::     The components of a marker, and how it relocates.
* Predicates on Markers::   Testing whether an object is a marker.
* Creating Markers::        Making empty markers or markers at certain places.
* Information from Markers::Finding the marker's buffer or character position.
* Marker Insertion Types::  Two ways a marker can relocate when you
                              insert where it points.
* Moving Markers::          Moving the marker to a new buffer or position.
* The Mark::                How the mark is implemented with a marker.
* The Region::              How to access the region.

Text

* Near Point::              Examining text in the vicinity of point.
* Buffer Contents::         Examining text in a general fashion.
* Comparing Text::          Comparing substrings of buffers.
* Insertion::               Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::                Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::           Where removed text sometimes is saved for
                              later use.
* Undo::                    Undoing changes to the text of a buffer.
* Maintaining Undo::        How to enable and disable undo information.
                              How to control how much information is kept.
* Filling::                 Functions for explicit filling.
* Margins::                 How to specify margins for filling commands.
* Adaptive Fill::           Adaptive Fill mode chooses a fill prefix
                              from context.
* Auto Filling::            How auto-fill mode is implemented to break lines.
* Sorting::                 Functions for sorting parts of the buffer.
* Columns::                 Computing horizontal positions, and using them.
* Indentation::             Functions to insert or adjust indentation.
* Case Changes::            Case conversion of parts of the buffer.
* Text Properties::         Assigning Lisp property lists to text characters.
* Substitution::            Replacing a given character wherever it appears.
* Registers::               How registers are implemented.  Accessing
                              the text or position stored in a register.
* Transposition::           Swapping two portions of a buffer.
* Decompression::           Dealing with compressed data.
* Base 64::                 Conversion to or from base 64 encoding.
* Checksum/Hash::           Computing cryptographic hashes.
* GnuTLS Cryptography::     Cryptographic algorithms imported from GnuTLS.
* Parsing HTML/XML::        Parsing HTML and XML.
* Atomic Changes::          Installing several buffer changes atomically.
* Change Hooks::            Supplying functions to be run when text is changed.

The Kill Ring

* Kill Ring Concepts::      What text looks like in the kill ring.
* Kill Functions::          Functions that kill text.
* Yanking::                 How yanking is done.
* Yank Commands::           Commands that access the kill ring.
* Low-Level Kill Ring::     Functions and variables for kill ring access.
* Internals of Kill Ring::  Variables that hold kill ring data.

Indentation

* Primitive Indent::        Functions used to count and insert indentation.
* Mode-Specific Indent::    Customize indentation for different modes.
* Region Indent::           Indent all the lines in a region.
* Relative Indent::         Indent the current line based on previous lines.
* Indent Tabs::             Adjustable, typewriter-like tab stops.
* Motion by Indent::        Move to first non-blank character.

Text Properties

* Examining Properties::    Looking at the properties of one character.
* Changing Properties::     Setting the properties of a range of text.
* Property Search::         Searching for where a property changes value.
* Special Properties::      Particular properties with special meanings.
* Format Properties::       Properties for representing formatting of text.
* Sticky Properties::       How inserted text gets properties from
                              neighboring text.
* Lazy Properties::         Computing text properties in a lazy fashion
                              only when text is examined.
* Clickable Text::          Using text properties to make regions of text
                              do something when you click on them.
* Fields::                  The @code{field} property defines
                              fields within the buffer.
* Not Intervals::           Why text properties do not use
                              Lisp-visible text intervals.

Parsing HTML and XML

* Document Object Model::   Access, manipulate and search the @acronym{DOM}.

Non-@acronym{ASCII} Characters

* Text Representations::    How Emacs represents text.
* Disabling Multibyte::     Controlling whether to use multibyte characters.
* Converting Representations::  Converting unibyte to multibyte and vice versa.
* Selecting a Representation::  Treating a byte sequence as unibyte or multi.
* Character Codes::         How unibyte and multibyte relate to
                                codes of individual characters.
* Character Properties::    Character attributes that define their
                                behavior and handling.
* Character Sets::          The space of possible character codes
                                is divided into various character sets.
* Scanning Charsets::       Which character sets are used in a buffer?
* Translation of Characters::   Translation tables are used for conversion.
* Coding Systems::          Coding systems are conversions for saving files.
* Input Methods::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* Locales::                 Interacting with the POSIX locale.

Coding Systems

* Coding System Basics::    Basic concepts.
* Encoding and I/O::        How file I/O functions handle coding systems.
* Lisp and Coding Systems:: Functions to operate on coding system names.
* User-Chosen Coding Systems::  Asking the user to choose a coding system.
* Default Coding Systems::  Controlling the default choices.
* Specifying Coding Systems::   Requesting a particular coding system
                                    for a single file operation.
* Explicit Encoding::       Encoding or decoding text without doing I/O.
* Terminal I/O Encoding::   Use of encoding for terminal I/O.

Searching and Matching

* String Search::           Search for an exact match.
* Searching and Case::      Case-independent or case-significant searching.
* Regular Expressions::     Describing classes of strings.
* Regexp Search::           Searching for a match for a regexp.
* POSIX Regexps::           Searching POSIX-style for the longest match.
* Match Data::              Finding out which part of the text matched,
                              after a string or regexp search.
* Search and Replace::      Commands that loop, searching and replacing.
* Standard Regexps::        Useful regexps for finding sentences, pages,...

Regular Expressions

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.
* Regexp Functions::        Functions for operating on regular expressions.

Syntax of Regular Expressions

* Regexp Special::          Special characters in regular expressions.
* Char Classes::            Character classes used in regular expressions.
* Regexp Backslash::        Backslash-sequences in regular expressions.

The Match Data

* Replacing Match::         Replacing a substring that was matched.
* Simple Match Data::       Accessing single items of match data,
                              such as where a particular subexpression started.
* Entire Match Data::       Accessing the entire match data at once, as a list.
* Saving Match Data::       Saving and restoring the match data.

Syntax Tables

* Syntax Basics::           Basic concepts of syntax tables.
* Syntax Descriptors::      How characters are classified.
* Syntax Table Functions::  How to create, examine and alter syntax tables.
* Syntax Properties::       Overriding syntax with text properties.
* Motion and Syntax::       Moving over characters with certain syntaxes.
* Parsing Expressions::     Parsing balanced expressions
                              using the syntax table.
* Syntax Table Internals::  How syntax table information is stored.
* Categories::              Another way of classifying character syntax.

Syntax Descriptors

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.

Parsing Expressions

* Motion via Parsing::      Motion functions that work by parsing.
* Position Parse::          Determining the syntactic state of a position.
* Parser State::            How Emacs represents a syntactic state.
* Low-Level Parsing::       Parsing across a specified region.
* Control Parsing::         Parameters that affect parsing.

Abbrevs and Abbrev Expansion

* Abbrev Tables::           Creating and working with abbrev tables.
* Defining Abbrevs::        Specifying abbreviations and their expansions.
* Abbrev Files::            Saving abbrevs in files.
* Abbrev Expansion::        Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::  Abbrev tables used by various major modes.
* Abbrev Properties::       How to read and set abbrev properties.
                            Which properties have which effect.
* Abbrev Table Properties:: How to read and set abbrev table properties.
                            Which properties have which effect.

Threads

* Basic Thread Functions::  Basic thread functions.
* Mutexes::                 Mutexes allow exclusive access to data.
* Condition Variables::     Inter-thread events.

Processes

* Subprocess Creation::     Functions that start subprocesses.
* Shell Arguments::         Quoting an argument to pass it to a shell.
* Synchronous Processes::   Details of using synchronous subprocesses.
* Asynchronous Processes::  Starting up an asynchronous subprocess.
* Deleting Processes::      Eliminating an asynchronous subprocess.
* Process Information::     Accessing run-status and other attributes.
* Input to Processes::      Sending input to an asynchronous subprocess.
* Signals to Processes::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* Output from Processes::   Collecting output from an asynchronous subprocess.
* Sentinels::               Sentinels run when process run-status changes.
* Query Before Exit::       Whether to query if exiting will kill a process.
* System Processes::        Accessing other processes running on your system.
* Transaction Queues::      Transaction-based communication with subprocesses.
* Network::                 Opening network connections.
* Network Servers::         Network servers let Emacs accept net connections.
* Datagrams::               UDP network connections.
* Low-Level Network::       Lower-level but more general function
                              to create connections and servers.
* Misc Network::            Additional relevant functions for net connections.
* Serial Ports::            Communicating with serial ports.
* Byte Packing::            Using bindat to pack and unpack binary data.

Receiving Output from Processes

* Process Buffers::         By default, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Decoding Output::         Filters can get unibyte or multibyte strings.
* Accepting Output::        How to wait until process output arrives.

Low-Level Network Access

* Network Processes::       Using @code{make-network-process}.
* Network Options::         Further control over network connections.
* Network Feature Testing:: Determining which network features work on
                              the machine you are using.

Packing and Unpacking Byte Arrays

* Bindat Spec::             Describing data layout.
* Bindat Functions::        Doing the unpacking and packing.
* Bindat Examples::         Samples of what bindat.el can do for you!

Emacs Display

* Refresh Screen::          Clearing the screen and redrawing everything on it.
* Forcing Redisplay::       Forcing redisplay.
* Truncation::              Folding or wrapping long text lines.
* The Echo Area::           Displaying messages at the bottom of the screen.
* Warnings::                Displaying warning messages for the user.
* Invisible Text::          Hiding part of the buffer text.
* Selective Display::       Hiding part of the buffer text (the old way).
* Temporary Displays::      Displays that go away automatically.
* Overlays::                Use overlays to highlight parts of the buffer.
* Size of Displayed Text::  How large displayed text is.
* Line Height::             Controlling the height of lines.
* Faces::                   A face defines a graphics style
                              for text characters: font, colors, etc.
* Fringes::                 Controlling window fringes.
* Scroll Bars::             Controlling scroll bars.
* Window Dividers::         Separating windows visually.
* Display Property::        Enabling special display features.
* Images::                  Displaying images in Emacs buffers.
* Buttons::                 Adding clickable buttons to Emacs buffers.
* Abstract Display::        Emacs's Widget for Object Collections.
* Blinking::                How Emacs shows the matching open parenthesis.
* Character Display::       How Emacs displays individual characters.
* Beeping::                 Audible signal to the user.
* Window Systems::          Which window system is being used.
* Tooltips::                Tooltip display in Emacs.
* Bidirectional Display::   Display of bidirectional scripts, such as
                              Arabic and Farsi.

The Echo Area

* Displaying Messages::     Explicitly displaying text in the echo area.
* Progress::                Informing user about progress of a long operation.
* Logging Messages::        Echo area messages are logged for the user.
* Echo Area Customization:: Controlling the echo area.

Reporting Warnings

* Warning Basics::          Warnings concepts and functions to report them.
* Warning Variables::       Variables programs bind to customize
                              their warnings.
* Warning Options::         Variables users set to control display of warnings.
* Delayed Warnings::        Deferring a warning until the end of a command.

Overlays

* Managing Overlays::       Creating and moving overlays.
* Overlay Properties::      How to read and set properties.
                              What properties do to the screen display.
* Finding Overlays::        Searching for overlays.

Faces

* Face Attributes::         What is in a face?
* Defining Faces::          How to define a face.
* Attribute Functions::     Functions to examine and set face attributes.
* Displaying Faces::        How Emacs combines the faces specified for
                              a character.
* Face Remapping::          Remapping faces to alternative definitions.
* Face Functions::          How to define and examine faces.
* Auto Faces::              Hook for automatic face assignment.
* Basic Faces::             Faces that are defined by default.
* Font Selection::          Finding the best available font for a face.
* Font Lookup::             Looking up the names of available fonts
                              and information about them.
* Fontsets::                A fontset is a collection of fonts
                              that handle a range of character sets.
* Low-Level Font::          Lisp representation for character display fonts.

Fringes

* Fringe Size/Pos::         Specifying where to put the window fringes.
* Fringe Indicators::       Displaying indicator icons in the window fringes.
* Fringe Cursors::          Displaying cursors in the right fringe.
* Fringe Bitmaps::          Specifying bitmaps for fringe indicators.
* Customizing Bitmaps::     Specifying your own bitmaps to use in the fringes.
* Overlay Arrow::           Display of an arrow to indicate position.

The @code{display} Property

* Replacing Specs::         Display specs that replace the text.
* Specified Space::         Displaying one space with a specified width.
* Pixel Specification::     Specifying space width or height in pixels.
* Other Display Specs::     Displaying an image; adjusting the height,
                              spacing, and other properties of text.
* Display Margins::         Displaying text or images to the side of
                              the main text.

Images

* Image Formats::           Supported image formats.
* Image Descriptors::       How to specify an image for use in @code{:display}.
* XBM Images::              Special features for XBM format.
* XPM Images::              Special features for XPM format.
* ImageMagick Images::      Special features available through ImageMagick.
* Other Image Types::       Various other formats are supported.
* Defining Images::         Convenient ways to define an image for later use.
* Showing Images::          Convenient ways to display an image once
                              it is defined.
* Multi-Frame Images::      Some images contain more than one frame.
* Image Cache::             Internal mechanisms of image display.

Buttons

* Button Properties::       Button properties with special meanings.
* Button Types::            Defining common properties for classes of buttons.
* Making Buttons::          Adding buttons to Emacs buffers.
* Manipulating Buttons::    Getting and setting properties of buttons.
* Button Buffer Commands::  Buffer-wide commands and bindings for buttons.

Abstract Display

* Abstract Display Functions::  Functions in the Ewoc package.
* Abstract Display Example::    Example of using Ewoc.

Character Display

* Usual Display::       The usual conventions for displaying characters.
* Display Tables::      What a display table consists of.
* Active Display Table::  How Emacs selects a display table to use.
* Glyphs::              How to define a glyph, and what glyphs mean.
* Glyphless Chars::     How glyphless characters are drawn.

Operating System Interface

* Starting Up::             Customizing Emacs startup processing.
* Getting Out::             How exiting works (permanent or temporary).
* System Environment::      Distinguish the name and kind of system.
* User Identification::     Finding the name and user id of the user.
* Time of Day::             Getting the current time.
* Time Conversion::         Converting a time from numeric form to
                              calendrical data and vice versa.
* Time Parsing::            Converting a time from numeric form to text
                              and vice versa.
* Processor Run Time::      Getting the run time used by Emacs.
* Time Calculations::       Adding, subtracting, comparing times, etc.
* Timers::                  Setting a timer to call a function at a
                              certain time.
* Idle Timers::             Setting a timer to call a function when Emacs has
                              been idle for a certain length of time.
* Terminal Input::          Accessing and recording terminal input.
* Terminal Output::         Controlling and recording terminal output.
* Sound Output::            Playing sounds on the computer's speaker.
* X11 Keysyms::             Operating on key symbols for X Windows.
* Batch Mode::              Running Emacs without terminal interaction.
* Session Management::      Saving and restoring state with
                              X Session Management.
* Desktop Notifications::   Desktop notifications.
* File Notifications::      File notifications.
* Dynamic Libraries::       On-demand loading of support libraries.
* Security Considerations:: Running Emacs in an unfriendly environment.

Starting Up Emacs

* Startup Summary::         Sequence of actions Emacs performs at startup.
* Init File::               Details on reading the init file.
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command-Line Arguments::  How command-line arguments are processed,
                              and how you can customize them.

Getting Out of Emacs

* Killing Emacs::           Exiting Emacs irreversibly.
* Suspending Emacs::        Exiting Emacs reversibly.

Terminal Input

* Input Modes::             Options for how input is processed.
* Recording Input::         Saving histories of recent or all input events.

Preparing Lisp code for distribution

* Packaging Basics::        The basic concepts of Emacs Lisp packages.
* Simple Packages::         How to package a single .el file.
* Multi-file Packages::     How to package multiple files.
* Package Archives::        Maintaining package archives.

Tips and Conventions

* Coding Conventions::      Conventions for clean and robust programs.
* Key Binding Conventions:: Which keys should be bound by which programs.
* Programming Tips::        Making Emacs code fit smoothly in Emacs.
* Compilation Tips::        Making compiled code run fast.
* Warning Tips::            Turning off compiler warnings.
* Documentation Tips::      Writing readable documentation strings.
* Comment Tips::            Conventions for writing comments.
* Library Headers::         Standard headers for library packages.

GNU Emacs Internals

* Building Emacs::          How the dumped Emacs is made.
* Pure Storage::            Kludge to make preloaded Lisp functions shareable.
* Garbage Collection::      Reclaiming space for Lisp objects no longer used.
* Stack-allocated Objects:: Temporary conses and strings on C stack.
* Memory Usage::            Info about total size of Lisp objects made so far.
* C Dialect::               What C variant Emacs is written in.
* Writing Emacs Primitives::  Writing C code for Emacs.
* Object Internals::        Data formats of buffers, windows, processes.
* C Integer Types::         How C integer types are used inside Emacs.

Object Internals

* Buffer Internals::        Components of a buffer structure.
* Window Internals::        Components of a window structure.
* Process Internals::       Components of a process structure.
@end detailmenu
@end menu

@ifclear VOL2
@include intro.texi
@include objects.texi
@include numbers.texi
@include strings.texi

@include lists.texi
@include sequences.texi
@include records.texi
@include hash.texi
@include symbols.texi
@include eval.texi

@include control.texi
@include variables.texi
@include functions.texi
@include macros.texi

@include customize.texi
@include loading.texi
@include compile.texi

@c This includes edebug.texi.
@include debugging.texi
@include streams.texi
@include minibuf.texi
@include commands.texi

@include keymaps.texi
@include modes.texi
@include help.texi
@include files.texi

@include backups.texi

@end ifclear

@c ================ Beginning of Volume 2 ================
@ifclear VOL1

@include buffers.texi
@include windows.texi
@include frames.texi

@include positions.texi
@include markers.texi
@include text.texi
@include nonascii.texi

@include searching.texi
@include syntax.texi
@include abbrevs.texi
@include threads.texi
@include processes.texi

@include display.texi
@include os.texi

@include package.texi

@c appendices

@include anti.texi
@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include doclicense.texi
@node GPL
@appendix GNU General Public License
@include gpl.texi
@include tips.texi
@include internals.texi
@include errors.texi
@include maps.texi
@include hooks.texi

@include index.texi

@end ifclear

@ignore
@node New Symbols
@unnumbered New Symbols Since the Previous Edition

@printindex tp
@end ignore

@bye


These words prevent "local variables" above from confusing Emacs.
