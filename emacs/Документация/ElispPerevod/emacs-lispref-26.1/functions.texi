@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2018 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter Functions

  Программа на Лиспе состоит в основном из функций на Лиспе.
  Эта глава объясняет, что такое функции, как они принимают
  аргументы и как их определять.

@menu
* What Is a Function::          Функции Lisp против примитивов; терминология.
* Lambda Expressions::          Как функции выражаются как объекты Lisp.
* Function Names::              Символ может служить именем функции.
* Defining Functions::          Лисп-выражения для определения функций.
* Calling Functions::           Как использовать существующую функцию.
* Mapping Functions::           Применение функции к каждому элементу списка и т.п.
* Anonymous Functions::         Лямбда-выражения - это функции без имен.
* Generic Functions::           Полиморфизм в стиле Emacs.
* Function Cells::              Доступ или определение функции определения символа.
* Closures::                    Функции, которые заключают в себе лексическую среду.
* Advising Functions::          Добавление к определению функции.
* Obsolete Functions::          Объявление функций устаревшими.
* Inline Functions::            Функции, которые компилятор будет расширять встроенными.
* Declare Form::                Добавление дополнительной информации о функции.
* Declaring Functions::         Сообщаем компилятору, что функция определена.
* Function Safety::             Определение, безопасна ли функция для вызова.
* Related Topics::              Перекрестные ссылки на конкретные примитивы Lisp, которые
                                имеют особое отношение к тому, как работают функции.
@end menu

@node What Is a Function
@section What Is a Function?

@cindex return value
@cindex value of function
@cindex argument
  В общем смысле функция - это правило для выполнения вычислений с заданными входными
  значениями, называемыми @dfn{arguments}. Результат вычисления называется @dfn{value}
  или @dfn{return value} функции. Вычисления также могут иметь побочные эффекты,
  такие как длительные изменения значений переменных или содержимого структур данных.

  На большинстве компьютерных языков у каждой функции есть имя. Но в Лиспе функция в
  самом строгом смысле не имеет имени: это объект, который может быть связан с символом
  @emph{optionally}, который служит именем функции. @xref{Function Names}. Когда функции
  присваивается имя, мы обычно также называем этот символ как ``function'' (например, мы
  ссылаемся на ``the function @code{car}''). В этом руководстве различие между именем
  функции и самим объектом функции, как правило, не имеет значения, но мы отметим,
  где это уместно.

  Некоторые функционально-подобные объекты, называемые @dfn{special forms} и
  @dfn{macros}, также принимают аргументы для выполнения вычислений. Однако, как
  объясняется ниже, они не считаются функциями в Emacs Lisp.

  Вот важные термины для функций и функционально-подобных объектов:

@table @dfn
@item lambda expression
Функция (в строгом смысле, то есть объект функции), которая написана
на Лиспе. Описаны в следующем разделе.
@ifnottex
@xref{Lambda Expressions}.
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
Функция, которая вызывается из Lisp, но на самом деле написана в C@.
Примитивы также называются @dfn{built-in functions} или @dfn{subrs}.
Примеры включают такие функции, как @code{car} и @code{append}. Кроме
того, все специальные формы (см. Ниже) также считаются примитивами.

Обычно функция реализуется как примитив, потому что она является
фундаментальной частью Lisp (например, @code{car}), или потому, что
она обеспечивает низкоуровневый интерфейс для служб операционной
системы, или потому что она должна работать быстро. В отличие от
функций, определенных в Lisp, примитивы могут быть изменены или
добавлены только путем изменения исходных кодов C и перекомпиляции
Emacs. Смотрите @ref{Writing Emacs Primitives}.

@item special form
Примитив, который похож на функцию, но не оценивает все свои аргументы
обычным способом. Он может оценивать только некоторые из аргументов или
может оценивать их в необычном порядке или несколько раз. Примеры
включают в себя @code{if}, @code{and}, и @code{while}.
@xref{Special Forms}.

@item macro
@cindex macro
Конструкция, определенная в Lisp, которая отличается от функции тем,
что переводит выражение Lisp в другое выражение, которое должно оцениваться
вместо исходного выражения. Макросы позволяют программистам на Лиспе делать
то, что могут делать специальные формы.
@xref{Macros}.

@item command
@cindex command
Объект, который может быть вызван через примитив @code{command-execute},
обычно из-за того, что пользователь вводит последовательность клавиш
@dfn{bound} для этой команды. @xref{Interactive Call}. Команда обычно
является функцией; если функция написана на Лиспе, она превращается в
команду в форме @code{interactive} в определении функции
(@pxref{Defining Commands}). Команды, которые являются функциями, также
могут вызываться из выражений Lisp, как и другие функции.

Макросы клавиатуры (строки и векторы) также являются командами,
даже если они не являются функциями. @xref{Keyboard Macros}. Мы говорим,
что символ является командой, если его функциональная ячейка содержит
команду (@pxref{Symbol Components});
такой @dfn{named command} может быть вызван с
@kbd{M-x}.

@item closure
Функциональный объект, который очень похож на лямбда-выражение, за
исключением того, что он также включает в себя среду привязки
лексических переменных.
@xref{Closures}.

@item byte-code function
Функция, которая была скомпилирована байтовым компилятором.
@xref{Byte-Code Type}.

@item autoload object
@cindex autoload object
Заполнитель для реальной функции. Если вызывается объект автозагрузки,
Emacs загружает файл, содержащий определение реальной функции, а затем
вызывает настоящую функцию. @xref{Autoload}.
@end table

  Вы можете использовать функцию @code{functionp}, чтобы проверить,
  является ли объект функцией:

@defun functionp object
Эта функция возвращает @code{t}, если @var{object} - это функция любого
типа, т.е. она может быть передана в @code{funcall}. Обратите внимание,
что @code{functionp} возвращает @code{t} для символов, которые являются
именами функций, и возвращает @code{nil} для специальных форм.
@end defun

  Также можно узнать, сколько аргументов ожидает произвольная функция:

@defun func-arity function
Эта функция предоставляет информацию о списке аргументов указанного
@var{function}. Возвращаемое значение является cons-ячейкой вида
@w{@code{(@var{min}. @var{max})}}, где @var{min} - минимальное
количество аргументов, а @var {max} - либо максимальное количество
аргументов, либо символ @code {many} для функций с аргументами
@code{&rest}, либо символ @code{unevalled}, если @var{function}
является особой формой.

Обратите внимание, что эта функция может возвращать неточные
результаты в некоторых ситуациях, например:

@itemize @minus
@item
Функции, определенные с помощью @code{apply-partially} (@pxref{Calling
Functions, apply-partially}).

@item
Функции, которые рекомендуется использовать @code{advice-add} (@pxref{Advising
Named Functions}).

@item
Функции, которые определяют список аргументов динамически, как часть их кода.
@end itemize

@end defun

@noindent
В отличие от @code{functionp}, следующие три функции @emph{not} рассматривают
символ как определение своей функции.

@defun subrp object
Эта функция возвращает @code{t}, если @var{object} является встроенной функцией
(i.e., a Lisp primitive).

@example
@group
(subrp 'message)            ; @r{@code{message} это символ,}
     @result{} nil                 ;   @r{не объект subr.}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
Эта функция возвращает @code{t}, если @var{object}
является функцией байт-кода. Например:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun subr-arity subr
Это работает как @code{func-arity}, но только для встроенных
функций и без косвенного обращения символа. Это сигнализирует
об ошибке для не встроенных функций. Мы рекомендуем использовать
@code{func-arity} вместо этого.
@end defun

@node Lambda Expressions
@section Lambda Expressions
@cindex lambda expression

  Лямбда-выражение - это функциональный объект,
  написанный на Лиспе. Вот пример:

@example
(lambda (x)
  "Вернуть гиперболический косинус X."
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
В Emacs Lisp такой список является допустимым
выражением, которое оценивает функциональный объект.

  Лямбда-выражение само по себе не имеет имени;
  это @dfn{anonymous function}. Хотя лямбда-выражения
  можно использовать таким образом
  (@pxref{Anonymous Functions}), они чаще ассоциируются
  с символами для создания @dfn{named functions}
  (@pxref{Function Names}). Прежде чем углубляться в эти детали,
  в следующих подразделах описываются компоненты лямбда-выражения
  и их действия.

@menu
* Lambda Components::           Части лямбда-выражения.
* Simple Lambda::               Простой пример.
* Argument List::               Подробности и особенности списков аргументов.
* Function Documentation::      Как поместить документацию в функцию.
@end menu

@node Lambda Components
@subsection Components of a Lambda Expression

  Лямбда-выражение представляет собой список, который выглядит следующим образом:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  Первым элементом лямбда-выражения всегда является символ
  @code{lambda}. Это указывает на то, что список представляет
  функцию. Функции, которые определены @code{lambda},
  заключаются в том, что другие списки, предназначенные для других
  целей, не будут случайно интерпретироваться в качестве функций.

  Второй элемент - это список символов --- имена переменных аргументов.
  Это называется @dfn{lambda list}. Когда вызывается функция Lisp,
  значения аргументов сопоставляются с переменными в лямбда-списке,
  которым присваиваются локальные привязки с указанными значениями.
  @xref{Local Variables}.

  Строка документации - это строковый объект Lisp, помещенный в
  определение функции для описания функции справочных средств
  Emacs.  @xref{Function Documentation}.

  Интерактивная декларация представляет собой список вида
  @code{(interactive @var{code-string})}. Это объявляет, как
  предоставить аргументы, если функция используется в интерактивном
  режиме. Функции с этим объявлением называются @dfn{commands};
  они могут быть вызваны с использованием @kbd{M-x} или привязаны
  к ключу. Функции, не предназначенные для такого вызова, не
  должны иметь интерактивных объявлений. @xref{Defining Commands},
  о том, как написать интерактивную декларацию.

@cindex body of function
  Остальные элементы - это @dfn{body} функции: код на Лиспе для
  выполнения работы функции (или, как сказал бы программист на Лиспе,
  `` список форм Лисп для оценки ''). Значение, возвращаемое функцией,
  является значением, возвращаемым последним элементом тела.

@node Simple Lambda
@subsection A Simple Lambda Expression Example

  Рассмотрим следующий пример:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
Мы можем вызвать эту функцию, передав ее в @code{funcall}, например так:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
Этот вызов оценивает тело лямбда-выражения с переменной @code{a},
связанной с 1, @code{b}, связанной с 2, и @code{c}, связанной с 3.
Оценка тела добавляет эти три числа, производя результат 6;
следовательно, этот вызов функции возвращает значение 6.

  Обратите внимание, что аргументы могут быть результатами других
  вызовов функций, как в этом примере:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
Это оценивает аргументы @code{1}, @code{(* 2 3)} и @code{(- 5 4)}
слева направо. Затем он применяет лямбда-выражение к значениям
аргументов 1, 6 и 1, чтобы получить значение 8.

  Как показывают эти примеры, вы можете использовать форму с
  лямбда-выражением в качестве @sc{car} для создания локальных переменных
  и присвоения им значений. В старые времена Лиспа этот метод был
  единственным способом связать и инициализировать локальные переменные.
  Но в настоящее время для этой цели понятнее использовать специальную
  форму @code{let} (@pxref{Local Variables}). Лямбда-выражения в основном
  используются как анонимные функции для передачи в качестве аргументов
  другим функциям (@pxref{Anonymous Functions}) или хранятся как
  определения символьных функций для создания именованных
  функций (@pxref{Function Names}).

@node Argument List
@subsection Other Features of Argument Lists
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  Наша простая для примера функция, @code{(lambda (a b c) (+ a b c))},
  задает три переменные аргумента, поэтому она должна вызываться с тремя
  аргументами: если вы попытаетесь вызвать ее только с двумя аргументами
  или четырьмя аргументами, вы получите ошибку
  @code{wrong-number-of-arguments} (@pxref {Errors}).

  Часто удобно написать функцию, которая позволяет опустить определенные
  аргументы. Например, функция @code{substring} принимает три аргумента -
  строку, начальный индекс и конечный индекс - но третий аргумент по
  умолчанию равен @var{length} строки, если вы его опускаете. Некоторым
  функциям также удобно принимать неопределенное количество аргументов,
  как это делают функции @code{list} и @code{+}.

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  Чтобы указать необязательные аргументы, которые могут быть опущены при
  вызове функции, просто включите ключевое слово @code{&optional} перед
  необязательными аргументами. Чтобы указать список из нуля или более
  дополнительных аргументов, включите ключевое слово @code{&rest} перед
  одним последним аргументом.

  Таким образом, полный синтаксис для списка аргументов выглядит
  следующим образом:

@example
@group
(@var{required-vars}@dots{}
 @r{[}&optional @var{optional-vars}@dots{}@r{]}
 @r{[}&rest @var{rest-var}@r{]})
@end group
@end example

@noindent
Квадратные скобки указывают, что предложения @code{&optional} и @code{&rest}
и переменные, которые следуют за ними, являются необязательными.

  Для вызова функции требуется один фактический аргумент для каждого из
  @var{required-vars}. Могут быть реальные аргументы для нуля или более
  @var{optional-vars}, и не может быть никаких реальных аргументов, кроме
  тех случаев, когда в лямбда-списке используется @code{&rest}. В этом
  случае может быть любое количество дополнительных фактических аргументов.

  Если фактические аргументы для необязательных и остальных переменных опущены,
  то по умолчанию они всегда равны @code{nil}. Функция не может различить явный
  аргумент @code{nil} и опущенный аргумент. Тем не менее, тело функции может считать
  @code{nil} сокращением для некоторого другого значимого значения. Это то, что
  делает @code{substring}; @code{nil} в качестве третьего аргумента для
  @code{substring} означает использование длины предоставленной строки.

@cindex CL note---default optional arg
@quotation
@b{Common Lisp note:} Common Lisp позволяет функции указывать, какое
значение по умолчанию использовать, когда опциональный аргумент опущен;
Emacs Lisp всегда использует @code{nil}. Emacs Lisp не поддерживает
переменные @code{supplied-p}, которые сообщают вам, был ли аргумент
передан явно.
@end quotation

  Например, список аргументов, который выглядит так:

@example
(a b &optional c d &rest e)
@end example

@noindent
связывает @code{a} и @code{b} с первыми двумя фактическими аргументами, которые
необходимы. Если предоставлен еще один или два аргумента, @code{c} и @code{d} связаны
с ними соответственно; любые аргументы после первых четырех собираются в список, и
@code{e} привязывается к этому списку. Если есть только два аргумента, @code{c}
будет @code{nil}; если два или три аргумента, @code{d} - это @code{nil}; если
четыре аргумента или меньше, @code{e} будет @code{nil}.

  Невозможно иметь обязательные аргументы после необязательных - это не
  имеет смысла. Чтобы понять, почему это так, предположим, что @code{c}
  в примере был необязательным, а @code{d} - обязательным. Предположим,
  даны три фактических аргумента; для какой переменной будет третий аргумент?
  Будет ли он использоваться для @var {c} или для @var{d}? Можно поспорить
  за обе возможности. Точно так же не имеет смысла иметь больше аргументов
  (обязательных или необязательных) после аргумента @code{&rest}.

  Вот несколько примеров списков аргументов и правильных вызовов:

@example
(funcall (lambda (n) (1+ n))        ; @r{Один требуется:}
         1)                         ; @r{требует ровно одного аргумента.}
     @result{} 2
(funcall (lambda (n &optional n1)   ; @r{Один обязательный и один необязательный:}
           (if n1 (+ n n1) (1+ n))) ; @r{1 или 2 аргумента.}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns)       ; @r{Один требуется и один отдых:}
           (+ n (apply '+ ns)))     ; @r{1 или больше аргументов.}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection Documentation Strings of Functions
@cindex documentation of function

  Лямбда-выражение может необязательно иметь @dfn{documentation string}
  сразу после лямбда-списка. Эта строка не влияет на выполнение функции;
  это своего рода комментарий, но систематизированный комментарий, который
  на самом деле появляется в мире Lisp и может быть использован средствами
  помощи Emacs. @xref{Documentation}, для того, как получить доступ к
  строке документации.

  Рекомендуется предоставлять строки документации для всех функций в вашей
  программе, даже для тех, которые вызываются только из вашей программы.
  Строки документации похожи на комментарии, за исключением того,
  что они легче доступны.

  Первая строка строки документации должна стоять отдельно, потому что
  @code{apropos} отображает только эту первую строку. Он должен состоять
  из одного или двух полных предложений, которые суммируют назначение функции.

  Начало строки документации обычно имеет отступ в исходном файле, но
  поскольку эти пробелы идут перед начальной двойной кавычкой, они не
  являются частью строки. Некоторые люди практикуют делать отступы для
  любых дополнительных строк строки, чтобы текст располагался в исходном
  коде программы. @emph{That is a mistake.} Отступ следующих строк
  находится внутри строки; то, что выглядит хорошо в исходном коде, будет
  выглядеть ужасно при отображении командами справки.

  Вы можете задаться вопросом, как строка документации может быть
  необязательной, поскольку за ней следуют обязательные компоненты
  функции (тело). Так как вычисление строки возвращает эту строку без
  каких-либо побочных эффектов, это не имеет никакого эффекта, если она
  не является последней формой в теле. Таким образом, на практике нет
  никакой путаницы между первой формой тела и строкой документации;
  если единственной формой тела является строка, то она служит и как
  возвращаемое значение, и как документация.

  Последняя строка строки документации может указывать соглашения
  о вызовах, отличные от фактических аргументов функции.
  Напишите текст так:

@example
\(fn @var{arglist})
@end example

@noindent
после пустой строки, в начале строки, без новой строки после нее внутри строки
документации. (The @samp{\} используется, чтобы избежать путаницы в командах
движения Emacs.) Указанное таким образом соглашение о вызовах появляется в
справочных сообщениях вместо тех, которые получены из фактических
аргументов функции.

  Эта функция особенно полезна для определений макросов, поскольку аргументы,
  записанные в определении макросов, часто не соответствуют тому, как
  пользователи думают о частях вызова макроса.

  Не используйте эту функцию, если вы хотите отказаться от соглашения о
  вызовах и отдать предпочтение тому, который вы рекламируете в приведенной выше
  спецификации. Вместо этого используйте объявление @code{advertised-calling-convention}
  (@pxref{Declare Form}) или @code{set-advertised-calling-convention}
  (@pxref{Obsolete Functions}), потому что эти два заставят байтовый компилятор
  выдавать предупреждающее сообщение, когда он компилирует программы на Лиспе,
  которые используют устаревшее соглашение о вызовах.

@node Function Names
@section Naming a Function
@cindex function definition
@cindex named function
@cindex function name

  Символ может служить именем функции. Это происходит, когда @dfn{function cell}
  (@pxref{Symbol Components}) символа содержит функциональный объект
  (например, лямбда-выражение). Тогда сам символ становится действительной,
  вызываемой функцией, эквивалентной функциональному объекту в его
  функциональной ячейке.

  Содержимое ячейки функции также называется @dfn{function definition} символа.
  Процедура использования определения функции символа вместо символа называется
  @dfn{symbol function indirection}; см. @ref{Function Indirection}. Если вы не
  дали символу определение функции, его ячейка функции называется @dfn{void}, и ее
  нельзя использовать в качестве функции.

  На практике почти все функции имеют имена и называются их именами. Вы можете
  создать именованную функцию Lisp, определив лямбда-выражение и поместив его в
  ячейку функции (@pxref{Function Cells}). Однако чаще используется специальная
  форма @code{defun}, описанная в следующем разделе.
@ifnottex
@xref{Defining Functions}.
@end ifnottex

  Мы даем имена функций, потому что к ним удобно обращаться по их именам в выражениях
  Lisp. Кроме того, именованная функция Lisp может легко ссылаться на себя - она ​​может
  быть рекурсивной. Кроме того, на примитивы можно ссылаться только в текстовом виде по
  их именам, поскольку примитивные функциональные объекты
  (@pxref{Primitive Function Type}) не имеют синтаксиса чтения.

  Функция не должна иметь уникального имени. Данный функциональный объект
  @emph{usually} появляется в ячейке функции только одного символа, но это всего
  лишь соглашение. Его легко хранить в нескольких символах, используя @code{fset};
  тогда каждый из символов является допустимым именем для той же функции.

  Обратите внимание, что символ, используемый в качестве имени функции, также
  может использоваться как переменная; эти два использования символа независимы и
  не конфликтуют. (Это не так на некоторых диалектах Лиспа, таких как Scheme.)

  По соглашению, если символ функции состоит из двух имен, разделенных @samp{--},
  функция предназначена для внутреннего использования, а первая часть именует файл,
  определяющий функцию. Например, функция с именем @code{vc-git--rev-parse} является
  внутренней функцией, определенной в @file{vc-git.el}. Функции внутреннего
  использования, написанные на C, имеют имена, оканчивающиеся на @samp{-internal},
  например, @code{bury-buffer-internal}. Код Emacs, представленный до 2018 года,
  может следовать другим соглашениям об именах внутреннего использования, которые
  постепенно прекращаются.

@node Defining Functions
@section Defining Functions
@cindex defining a function

  Обычно мы даем имя функции при ее первом создании. Это называется
  @dfn{defining a function}, и это делается с помощью макроса @code{defun}.

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun} - это обычный способ определения новых функций Lisp.
Он определяет символ @var{name} как функцию со списком аргументов
@var{args} и формами тела, заданными @var{body}. Ни @var{name}, ни
@var{args} не следует заключать в кавычки.

@var{doc}, если присутствует, должен быть строкой, определяющей строку
документации функции (@pxref{Function Documentation}). @var{declare}, если
имеется, должен быть формой @code{declare}, определяющей метаданные функции
(@pxref{Declare Form}). @var{interactive}, если он присутствует, должен быть
формой @code{interactive}, определяющей, как функция должна вызываться в
интерактивном режиме (@pxref{Interactive Call}).

Возвращаемое значение @code{defun} не определено.

вот несколько примеров:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Wrong number of arguments.
@end group

@group
(defun capitalize-backwards ()
  "Upcase последняя буква слова в точке."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

@cindex override existing functions
@cindex redefine existing functions
Будьте осторожны, чтобы не переопределить существующие функции непреднамеренно.
@code{defun} переопределяет даже примитивные функции, такие как @code{car}, без
каких-либо колебаний или уведомлений. Emacs не мешает вам сделать это, потому
что переопределение функции иногда выполняется намеренно, и нет никакого способа
отличить преднамеренное переопределение от непреднамеренного переопределения.
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
Эта функция определяет символ @var{name} как функцию с определением
@var{definition} (которая может быть любой допустимой лисповской функцией).
Её возвращаемое значение - @emph{undefined}.

Если @var{doc} не является @code{nil}, он становится функциональной документацией
@var{name}. В противном случае используется любая документация, предоставленная
@var{definition}.

@cindex defalias-fset-function property
Внутренне, @code{defalias} обычно использует @code{fset}, чтобы установить
определение. Однако, если @var{name} имеет свойство @code{defalias-fset-function},
соответствующее значение используется как функция для вызова вместо @code{fset}.

Правильное место для использования @code{defalias} - это место, где определяется
конкретное имя функции, особенно когда это имя явно появляется в загружаемом исходном
файле. Это потому, что @code{defalias} записывает, какой файл определил функцию,
так же, как @code{defun}
(@pxref{Unloading}).

Напротив, в программах, которые манипулируют определениями функций для других
целей, лучше использовать @code{fset}, который не ведет такие записи.
@xref{Function Cells}.
@end defun

  Вы не можете создать новую примитивную функцию с помощью @code{defun} или
  @code{defalias}, но вы можете использовать их для изменения определения функции
  любого символа, даже такого, как @code{car} или @code{x-popup-menu}, чье обычное
  определение является примитивом. Однако это рискованно: например, почти невозможно
  переопределить @code{car}, не сломав полностью Lisp. Переопределение скрытой функции,
  такой как @code{x-popup-menu}, менее опасно, но все равно может работать не так, как
  вы ожидаете. Если к примитиву поступают вызовы из кода C, они напрямую вызывают
  определение C примитива, поэтому изменение определения символа на них не повлияет.

  Смотрите также @code{defsubst}, который определяет функцию, подобную @code{defun},
  и указывает компилятору Lisp выполнить встроенное расширение над ней.
@xref{Inline Functions}.

  Кроме того, вы можете определить функцию, предоставив код, который будет встроен
  в нее как макрос компилятора. Следующие макросы делают это возможным.

@c FIXME: Может ли define-inline использовать интерактивную спецификацию?
@defmac define-inline name args [doc] [declare] body@dots{}
Определите функцию @var{name}, предоставив код, который выполняет ее
вставку, как макрос компилятора. Функция примет список аргументов @var{args}
и будет иметь указанный @var{body}.

Если присутствует, @var{doc} должен быть строкой документации функции
(@pxref{Function Documentation}); @var{declare}, если он присутствует, должен
иметь форму @code{declare} (@pxref{Declare Form}), определяющую метаданные функции.
@end defmac

Функции, определенные через @code{define-inline}, имеют несколько преимуществ
по отношению к макросам, определенным @code{defsubst} или @code{defmacro}:

@itemize @minus
@item
Они могут быть переданы в @code{mapcar} (@pxref{Mapping Functions}).

@item
Они более эффективны.

@item
Их можно использовать как @dfn{place forms} для хранения значений
(@pxref{Generalized Variables}).

@item
Они ведут себя более предсказуемо, чем @code{cl-defsubst}
(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs
Lisp}).
@end itemize

Как и @code{defmacro}, функция, встроенная в @code{define-inline}, наследует
правила области видимости, динамические или лексические, от сайта вызова.
@xref{Variable Scoping}.

Следующие макросы должны использоваться в теле функции, определенной
@code{define-inline}.

@defmac inline-quote expression
Цитировать @var{expression} для @code{define-inline}. Это похоже на обратную
цитату (@pxref{Backquote}), но цитирует код и принимает только @code{,}, а
не @code{,@@}.
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
Это похоже на @code{let} (@pxref{Local Variables}): он устанавливает локальные
переменные, как указано в @var{bindings}, а затем оценивает @var{body} с учетом этих
привязок. Каждый элемент @var{bindings} должен быть либо символом, либо списком вида
@w{@code{(@var{var} @var{expr})}}; Результатом является оценка @var{expr} и привязка
@var{var} к результату. Хвост @var{bindings} может быть либо @code{nil}, либо символом,
который должен содержать список аргументов, в этом случае каждый аргумент оценивается,
и символ связывается с результирующим списком.
@end defmac

@defmac inline-const-p expression
Вернуть non-@code{nil}, если значение @var{expression} уже известно.
@end defmac

@defmac inline-const-val expression
Вернуть значение @var{expression}.
@end defmac

@defmac inline-error format &rest args
Подайте ошибку, форматируя @var{args} в соответствии с @var{format}.
@end defmac

Вот пример использования @code{define-inline}:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
Это эквивалентно

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Calling Functions
@section Calling Functions
@cindex function invocation
@cindex calling a function

  Определение функций - это только полдела. Функции ничего не делают, пока вы
  не обнаружите их, то есть не скажете им запускаться. Вызов функции также
  известен как @dfn{invocation}.

  Наиболее распространенным способом вызова функции является оценка списка. Например,
  при оценке списка @code{(concat "a" "b")} вызывается функция @code{concat} с
  аргументами @code{"a"} и @code{"b"}. @xref{Evaluation}, для описания оценки.

  Когда вы пишете список в виде выражения в вашей программе, вы указываете, какую
  функцию вызывать и сколько аргументов для ее предоставления в тексте программы. Обычно
  это именно то, что вы хотите. Иногда вам нужно вычислить во время выполнения, какую
  функцию вызывать. Для этого используйте функцию @code{funcall}. Когда вам также нужно
  определить во время выполнения, сколько аргументов нужно передать, используйте
  @code{apply}.

@defun funcall function &rest arguments
@code{funcall} вызывает @var{function} с помощью @var{arguments} и возвращает все,
что возвращает @var{function}.

Поскольку @code{funcall} является функцией, все ее аргументы, включая @var{function},
оцениваются до вызова @code {funcall}. Это означает, что вы можете использовать любое
выражение для получения вызываемой функции. Это также означает, что @code{funcall} не
видит выражения, которые вы пишете для @var{arguments}, а только их значения. Эти
значения @emph{not} оцениваются во второй раз в процессе вызова @var{function}; операция
@code{funcall} похожа на обычную процедуру вызова функции, после того как ее аргументы
уже оценены.

Аргумент @var{function} должен быть либо функцией Лиспа, либо примитивной функцией.
Специальные формы и макросы не допускаются, потому что они имеют смысл только при
наличии выражений аргументов без оценки. @code{funcall} не может предоставить их, потому
что, как мы видели выше, он никогда не знает их в первую очередь.

Если вам нужно использовать @code{funcall} для вызова команды и заставить ее вести
себя так, как будто она вызывается в интерактивном режиме, используйте
@code{funcall-interactively} (@pxref{Interactive Call}).

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Invalid function: #<subr and>
@end group
@end example

Сравните эти примеры с примерами @code{apply}.
@end defun

@defun apply function &rest arguments
@code{apply} вызывает @var{function} с @var{arguments}, точно так же, как
@code{funcall}, но с одним отличием: последний из @var{arguments} - это список
объектов, которые передаются в @var{function} как отдельные аргументы, а не как один
список. Мы говорим, что @code{apply} @dfn{spreads} этот список, так что каждый отдельный
элемент становится аргументом.

@code{apply} возвращает результат вызова @var{function}. Как и в случае с
@code{funcall}, @var{function} должен быть либо функцией Lisp, либо примитивной
функцией; специальные формы и макросы не имеют смысла в @code{apply}.

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

Для интересного примера использования @code{apply}, см. @ref{Definition of mapcar}.
@end defun

@cindex partial application of functions
@cindex currying
  Иногда полезно зафиксировать некоторые аргументы функции при определенных значениях
  и оставить остальные аргументы, когда функция на самом деле вызывается. Акт фиксации
  некоторых аргументов функции называется @dfn{partial application} из
  function@footnote{Это связано, но отличается от @dfn{currying}, который преобразует
  функцию, которая принимает несколько аргументов таким образом, что она может быть
  вызвана как цепочка функций, каждая из которых имеет один аргумент.}. Результатом
  является новая функция, которая принимает остальные аргументы и вызывает исходную
  функцию со всеми объединенными аргументами.

  Вот как сделать частичное применение в Emacs Lisp:

@defun apply-partially func &rest args
Эта функция возвращает новую функцию, которая при вызове будет вызывать @var{func} со
списком аргументов, составленным из @var{args}, и дополнительными аргументами, указанными
во время вызова. Если @var{func} принимает аргументы @var{n}, то вызов
@code{apply-partially} с аргументами @w{@code{@var{m} < @var{n}}} создаст новую
функцию аргументов @w{@code{@var{n} - @var{m}}}.

Вот как мы можем определить встроенную функцию @code{1+}, если она не существует,
используя @code{apply-partially} и @code{+}, другую встроенную функцию:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Увеличение аргумента на единицу.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  Обычно функции Lisp принимают функции в качестве аргументов или находят их в структурах
  данных (особенно в переменных хуков и списках свойств) и вызывают их, используя
  @code{funcall} или @code{apply}. Функции, которые принимают аргументы функции, часто
  называются @dfn{functionals}.

  Иногда, когда вы вызываете функционал, полезно предоставить функцию no-op в
  качестве аргумента. Вот два разных типа неоперативной функции:

@defun identity arg
Эта функция возвращает @var{arg} и не имеет побочных эффектов.
@end defun

@defun ignore &rest args
Эта функция игнорирует любые аргументы и возвращает @code{nil}.
@end defun

  Некоторые функции являются видимыми для пользователя @dfn{commands}, которые можно
  вызывать в интерактивном режиме (обычно с помощью последовательности клавиш). Можно
  вызвать такую ​​команду точно так же, как если бы она была вызвана в интерактивном режиме,
  используя функцию @code{call-interactively}.  @xref{Interactive Call}.

@node Mapping Functions
@section Mapping Functions
@cindex mapping functions

  @dfn{mapping function} применяет данную функцию (специальную форму или макрос
  @emph{not}) к каждому элементу списка или другой коллекции. Emacs Lisp имеет
  несколько таких функций; в этом разделе описываются @code{mapcar}, @code{mapc},
  @code{mapconcat} и @code{mapcan}, какая карта над списком.
  @xref{Definition of mapatoms}, для функции @code{mapatoms}, отображающей символы
  в obarray. @xref{Definition of maphash}, для функции @code{maphash}, которая
  отображает связи ключ/значение в хеш-таблице.

  Эти функции отображения не допускают использование таблиц символов, поскольку
  таблица символов представляет собой разреженный массив, номинальный диапазон индексов
  которого очень велик. Чтобы отобразить таблицу символов так, чтобы она правильно
  соотносилась с ее разреженной природой, используйте функцию @code{map-char-table}
  (@pxref{Char-Tables}).

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar} применяет @var{function} к каждому элементу @var{sequence} по
очереди и возвращает список результатов.

Аргумент @var{sequence} может быть любой последовательностью, кроме таблицы символов;
то есть список, вектор, bool-вектор или строка. Результатом всегда является список.
Длина результата равна длине @var{sequence}. Например:

@example
@group
(mapcar 'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar '1+ [1 2 3])
     @result{} (2 3 4)
(mapcar 'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{Call each function in @code{my-hooks}.}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Примените FUNCTION к последующим автомобилям всех ARGS.
  Вернуть список результатов."
  ;; @r{Если список не исчерпан,}
  (if (not (memq nil args))
      ;; @r{apply function to @sc{car}s.}
      (cons (apply function (mapcar 'car args))
            (apply 'mapcar* function
                   ;; @r{рекурсия для остальных элементов.}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* 'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapcan function sequence
Эта функция применяет @var{function} к каждому элементу @var{sequence}, как и
@code{mapcar}, но вместо сбора результатов в список она возвращает один список со всеми
элементами результатов (которые должны быть списками), изменяя результаты (используя
@code{nconc}; @pxref{Rearrangement}). Как и в случае с @code{mapcar}, @var{sequence}
может быть любого типа, кроме таблицы символов.

@example
@group
;; @r{Сравните это:}
(mapcar 'list '(a b c d))
     @result{} ((a) (b) (c) (d))
;; @r{with this:}
(mapcan 'list '(a b c d))
     @result{} (a b c d)
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc} похож на @code{mapcar} за исключением того, что @var{function}
используется только для побочных эффектов - возвращаемые значения игнорируются, а
не собираются в список. @code{mapc} всегда возвращает @var{sequence}.
@end defun

@defun mapconcat function sequence separator
@code{mapconcat} применяет @var{function} к каждому элементу @var{sequence}; результаты,
которые должны быть последовательностями символов (строки, векторы или списки),
объединяются в возвращаемое значение одной строки. Между каждой парой последовательностей
результатов @code{mapconcat} вставляет символы из @var{separator}, которые также должны
быть строкой, вектором или списком символов.  @xref{Sequences Arrays Vectors}.

Аргумент @var{function} должен быть функцией, которая может принимать один аргумент и
возвращать последовательность символов: строку, вектор или список. Аргумент @var{sequence}
может быть любой последовательностью, кроме таблицы символов; то есть список, вектор,
bool-вектор или строка.

@example
@group
(mapconcat 'symbol-name
           '(Кот в мешке)
           " ")
     @result{} "Кот в мешке"
@end group

@group
(mapconcat (function (lambda (x) (format "%c" (1+ x))))
           "HAL-8000"
           "")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section Anonymous Functions
@cindex anonymous function

  Хотя функции обычно определяются с помощью @code{defun} и именования одновременно,
  иногда удобно использовать явное лямбда-выражение --- @dfn{anonymous function}.
  Анонимные функции действуют везде, где есть имена функций. Они часто назначаются как
  значения переменных или как аргументы функций; например, вы можете передать его в
  качестве аргумента @var{function} в @code{mapcar}, который применяет эту функцию к
  каждому элементу списка (@pxref{Mapping Functions}). @xref{describe-symbols example},
  для реалистичного примера этого.

  При определении лямбда-выражения, которое будет использоваться в качестве анонимной
  функции, вы в принципе можете использовать любой метод для построения списка. Но обычно
  вы должны использовать макрос @code{lambda}, или специальную форму @code{function}, или
  синтаксис чтения @code{#'}:

@defmac lambda args [doc] [interactive] body@dots{}
Этот макрос возвращает анонимную функцию со списком аргументов @var{args}, строкой
документации @var{doc} (если есть), интерактивной спецификацией @var{interactive}
(если есть) и формами тела, предоставленными @var{body}.

По сути, этот макрос заставляет формы @code{lambda} самостоятельно заключать в
кавычки: вычисление формы, у которой @sc{car} равен @code{lambda}, дает саму форму:

@example
(lambda (x) (* x x))
     @result{} (lambda (x) (* x x))
@end example

Форма @code{lambda} имеет еще один эффект: она сообщает оценщику Emacs и байт-компилятору,
что ее аргумент является функцией, используя @code{function} в качестве подпрограммы
(см. Ниже).
@end defmac

@defspec function function-object
@cindex function quoting
Эта специальная форма возвращает @var{function-object} без ее оценки. В этом она похожа
на @code{quote} (@pxref{Quoting}). Но в отличие от @code{quote}, она также служит
примечанием для оценщика Emacs и байтового компилятора, что @var{function-object}
предназначена для использования в качестве функции. Предполагая, что
@var{function-object} является допустимым лямбда-выражением, это имеет два эффекта:

@itemize
@item
Когда код компилируется байтом, @var{function-object} компилируется в объект
функции байт-кода (@pxref{Byte Compilation}).

@item
Когда лексическое связывание включено, @var{function-object} преобразуется
в замыкание.  @xref{Closures}.
@end itemize
@end defspec

@cindex @samp{#'} syntax
Синтаксис чтения @code{#'} является сокращением для использования
@code{function}. Следующие формы все эквивалентны:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  В следующем примере мы определяем функцию @code{change-property}, которая
  принимает функцию в качестве третьего аргумента, за которой следует функция
  @code{double-property}, которая использует @code{change-property}, передавая ей
  анонимную функцию:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
Обратите внимание, что мы не цитируем форму @code{lambda}.

  Если вы скомпилируете приведенный выше код, анонимная функция также скомпилируется.
  Этого бы не произошло, если бы, скажем, вы создали анонимную функцию, заключив ее
  в список:

@c Не цитируйте эту лямбду!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
В этом случае анонимная функция сохраняется как лямбда-выражение в скомпилированном коде.
Байт-компилятор не может предположить, что этот список является функцией, даже если он
выглядит так, поскольку он не знает, что @code{change-property} намеревается
использовать его как функцию.

@node Generic Functions
@section Generic Functions
@cindex generic functions
@cindex polymorphism

  Функции, определенные с использованием @code{defun}, имеют жестко заданный набор
  предположений о типах и ожидаемых значениях их аргументов. Например, функция, которая
  была разработана для обработки значений своего аргумента, которые являются либо числами,
  либо списками чисел, потерпит неудачу или сообщит об ошибке, если вызывается со
  значением любого другого типа, например вектором или строкой. Это происходит потому, что
  реализация функции не подготовлена ​​для работы с типами, отличными от тех, которые были
  приняты во время проектирования.

  Напротив, объектно-ориентированные программы используют @dfn{polymorphic functions}:
  набор специализированных функций с одинаковым именем, каждая из которых была написана
  для определенного набора типов аргументов. Какая из функций фактически вызывается,
  определяется во время выполнения на основе типов фактических аргументов.

@cindex CLOS
  Emacs обеспечивает поддержку полиморфизма. Как и в других средах Lisp, в частности
  Common Lisp и его Common Lisp Object System (@acronym{CLOS}), эта поддержка основана
  на @dfn{generic functions}. Общие функции Emacs тесно связаны с @acronym{CLOS}, включая
  использование похожих имен, поэтому, если у вас есть опыт работы с @acronym{CLOS},
  остальная часть этого раздела будет звучать очень знакомо.

  Универсальная функция задает абстрактную операцию, определяя ее имя и список аргументов,
  но (обычно) не реализуя. Фактическая реализация для нескольких определенных классов
  аргументов обеспечивается @dfn{methods}, который должен быть определен отдельно. Каждый
  метод, который реализует обобщенную функцию, имеет то же имя, что и обобщенная функция,
  но определение метода указывает, какие аргументы он может обработать с помощью
  @dfn{specializing} аргументов, определенных обобщенной функцией. Эти
  @dfn{argument specializers} могут быть более или менее конкретными; например, тип
  @code{string} более специфичен, чем более общий тип, такой как @code{sequence}.

  Обратите внимание, что в отличие от основанных на сообщениях ОО-языков, таких как
  C@t{++} и Simula, методы, которые реализуют универсальные функции, не принадлежат
  классу, они принадлежат универсальной функции, которую они реализуют.

  Когда вызывается универсальная функция, она выбирает применимые методы, сравнивая
  фактические аргументы, передаваемые вызывающей стороной, со специализированными
  аргументами каждого метода. Метод применим, если фактические аргументы вызова совместимы
  со специализаторами метода. Если применимо более одного метода, они объединяются с
  использованием определенных правил, описанных ниже, и затем комбинация обрабатывает
  вызов.

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
Этот макрос определяет обобщенную функцию с указанными @var{name} и @var{arguments}. Если
присутствует @var{body}, он обеспечивает реализацию по умолчанию. Если присутствует
@var{documentation} (так должно быть всегда), он указывает строку документации для
универсальной функции в форме @code{(:documentation @var{docstring})}. Необязательный
@var{options-and-methods} может иметь одну из следующих форм:

@table @code
@item (declare @var{declarations})
Форма объявления, как описано в @ref{Declare Form}.
@item (:argument-precedence-order &rest @var{args})
Эта форма влияет на порядок сортировки для объединения применимых методов. Обычно,
когда два метода сравниваются во время объединения, аргументы метода проверяются слева
направо, и первый метод, специализатор аргумента которого является более конкретным,
предшествует другому. Порядок, определенный этой формой, переопределяет это, и аргументы
рассматриваются в соответствии с их порядком в этой форме, а не слева направо.
@item (:method [@var{qualifiers}@dots{}] args &rest body)
Эта форма определяет метод как @code{cl-defmethod}.
@end table
@end defmac

@defmac cl-defmethod name [qualifier] arguments &rest [docstring] body
Этот макрос определяет конкретную реализацию для универсальной функции, называемой
@var{name}. Код реализации задается @var{body}. Если присутствует, @var{docstring} - это
строка документации для метода. Список @var{arguments}, который должен быть одинаковым
во всех методах, реализующих универсальную функцию, и должен соответствовать списку
аргументов этой функции, предоставляет специализаторы аргументов в форме @code{(@var{arg}
@var{spec})}, где @var{arg} - это имя аргумента, указанное в вызове @code{cl-defgeneric},
и @var{spec} - это одна из следующих форм специализаций:

@table @code
@item @var{type}
Этот специализатор требует, чтобы аргумент имел заданный @var{type}, один из
типов из иерархии типов, описанной ниже.
@item (eql @var{object})
Этот специализатор требует, чтобы аргумент был @code{eql} для данного @var{object}.
@item (head @var{object})
Аргумент должен быть cons-ячейкой, у которой @code {car} от @code{eql} до
@var{object}.
@item @var{struct-type}
Аргумент должен быть экземпляром класса с именем @var{struct-type}, определенного с
помощью @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp Extensions for
GNU Emacs Lisp}), или одного из его дочерних классов.
@end table

Альтернативно, специализированный аргумент может иметь форму
@code{&context (@var{expr} @var{spec})}, и в этом случае значение @var{expr}
должно быть совместимо со специализатором, предоставленным @var{spec}; @var{spec}
может быть любой из форм, описанных выше. Другими словами, эта форма специалиста
использует значение @var{expr} вместо аргументов для решения, применим ли метод.
Например, @code{&context (overwrite-mode (eql t))} сделает метод совместимым
только при включенном @code{overwrite-mode}.

Специалист по типу, @code{(@var{arg} @var{type})}, может указать один из
@dfn{system types} в следующем списке. Когда указан родительский тип, аргумент, тип
которого является любым из его более конкретных дочерних типов, а также внуков, внуков
и т.д., Также будет совместимым.

@table @code
@item integer
Родительский тип: @code{number}.
@item number
@item null
Родительский тип: @code{symbol}
@item symbol
@item string
Родительский тип: @code{array}.
@item array
Родительский тип: @code{sequence}.
@item cons
Родительский тип: @code{list}.
@item list
Родительский тип: @code{sequence}.
@item marker
@item overlay
@item float
Родительский тип: @code{number}.
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
Родительский тип: @code{array}.
@item bool-vector
Родительский тип: @code{array}.
@item vector
Родительский тип: @code{array}.
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

Необязательный @var{qualifier} позволяет комбинировать несколько применимых методов.
Если он отсутствует, определенный метод является методом @dfn{primary}, отвечающим за
обеспечение первичной реализации универсальной функции для специализированных
аргументов. Вы также можете определить @dfn{auxiliary methods}, используя одно из
следующих значений как @var{qualifier}:

@table @code
@item :before
Этот вспомогательный метод будет выполняться до основного метода. Точнее, все
методы @code{:before} будут выполняться до основного, в наиболее специфичном
первом порядке.
@item :after
Этот вспомогательный метод будет выполняться после основного метода. Точнее, все
такие методы будут выполняться после основного, в наиболее определенном последнем
порядке.
@item :around
Этот вспомогательный метод запускает @emph{instead} основного метода. Наиболее
специфический из таких методов будет запущен перед любым другим методом. Такие методы
обычно используют @code{cl-call-next-method}, описанный ниже, для вызова других
вспомогательных или первичных методов.
@item :extra @var{string}
Это позволяет вам добавлять больше методов, отличающихся @var{string}, для тех же
самых специализаторов и классификаторов.
@end table
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
Каждый раз, когда вызывается универсальная функция, она создает @dfn{effective method},
который будет обрабатывать этот вызов путем объединения применимых методов, определенных
для функции. Процесс поиска применимых методов и создания эффективного метода называется
@dfn{dispatch}. Применимыми методами являются те, все из которых специализируются,
совместимы с фактическими аргументами вызова. Поскольку все аргументы должны быть
совместимы со специализаторами, все они определяют, применим ли метод. Методы, которые
явно специализируют более одного аргумента, называются @dfn{multiple-dispatch methods}.

Применяемые методы сортируются в порядке их объединения. Метод, у которого самый левый
специализатор аргументов является самым конкретным, будет первым в порядке. (Указание
@code{:argument-precedence-order} как части @code{cl-defmethod} переопределяет это, как
описано выше.) Если тело метода вызывает @code{cl-call-next-method}, будет запущен
следующий наиболее специфичный метод. Если существуют применимые методы @code{:around},
наиболее специфичные из них будут выполняться первыми; он должен вызвать
@code{cl-call-next-method} для запуска любого из менее специфичных методов @code{:around}.
Затем методы @code{:before} выполняются в порядке их специфичности, за которым следует
основной метод, и, наконец, методы @code{:after} в обратном порядке их специфичности.

@defun cl-call-next-method &rest args
При вызове из лексического тела основного или вспомогательного метода @code{:around}
вызовите следующий применимый метод для той же универсальной функции. Обычно он вызывается
без аргументов, что означает вызов следующего применимого метода с теми же аргументами,
что и вызывающий метод. В противном случае, вместо этого используются указанные
аргументы.
@end defun

@defun cl-next-method-p
Эта функция, когда вызывается из лексического тела основного или вспомогательного
метода @code{:around}, возвращает не-@code{nil}, если есть следующий метод для вызова.
@end defun


@node Function Cells
@section Accessing Function Cell Contents

  @dfn{function definition} символа - это объект, хранящийся в функциональной ячейке
  символа. Описанные здесь функции осуществляют доступ, тестирование и установку
  функциональной ячейки символов.

  Смотрите также функцию @code{indirect-function}.  @xref{Definition of
indirect-function}.

@defun symbol-function symbol
@kindex void-function
Это возвращает объект в ячейке функции @var{symbol}. Он не проверяет, является ли
возвращенный объект допустимой функцией.

Если ячейка функции пуста, возвращаемое значение - @code{nil}. Чтобы отличить ячейку
функции, которая является пустой, и ячейкой, установленной на @code{nil}, используйте
@code{fboundp} (см. Ниже).

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} (lambda (n) (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  Если вы никогда не давали символу никакого определения функции, мы говорим, что
  ячейка функции этого символа - @dfn{void}. Другими словами, в ячейке функции нет
  объекта Лисп. Если вы попытаетесь вызвать символ как функцию, Emacs сообщит об ошибке
  @code{void-function}.

  Обратите внимание, что void - это не то же самое, что @code {nil} или символ
  @code{void}. Символы @code{nil} и @code{void} являются объектами Lisp и могут быть
  сохранены в ячейке функции так же, как и любой другой объект (и они могут быть
  действительными функциями, если вы определяете их по очереди с помощью @code{defun}).
  Ячейка пустой функции не содержит никаких объектов.

  Вы можете проверить пустотность определения функции символа с помощью @code{fboundp}.
  После того, как вы дали символу определение функции, вы можете снова сделать его
  недействительным, используя @code{fmakunbound}.

@defun fboundp symbol
Эта функция возвращает @code{t}, если символ имеет объект в своей ячейке функции, в
противном случае @code{nil}. Он не проверяет, является ли объект допустимой функцией.
@end defun

@defun fmakunbound symbol
Эта функция делает ячейку функции @var{symbol}'s недействительной, поэтому последующая
попытка доступа к этой ячейке вызовет ошибку @code{void-function}. Возвращает
@var{symbol}. (См. Также @code{makunbound}, в @ref{Void Variables}.)

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void: foo
@end group
@end example
@end defun

@defun fset symbol definition
Эта функция хранит @var{definition} в ячейке функции @var{symbol}. Результат -
@var{definition}. Обычно @var {определение} должно быть функцией или именем функции,
но это не проверяется. Аргумент @var{symbol} - это обычный оцененный аргумент.

Основное использование этой функции в качестве подпрограммы - конструкции, которые
определяют или изменяют функции, такие как @code{defun} или @code{advice-add}
(@pxref{Advising Functions}). Вы также можете использовать его, чтобы дать символу
определение функции, которое не является функцией, например, макрос клавиатуры
(@pxref{Keyboard Macros}):

@example
;; @r{Определить именованный макрос клавиатуры.}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

Если вы хотите использовать @code{fset} для создания альтернативного имени для
функции, рассмотрите возможность использования @code{defalias}.
@xref{Definition of defalias}.
@end defun

@node Closures
@section Closures

  Как объяснено в @ref{Variable Scoping}, Emacs может по желанию включить лексическое
  связывание переменных. Когда лексическое связывание включено, любая именованная функция,
  которую вы создаете (например, с помощью @code{defun}), а также любая анонимная функция,
  которую вы создаете с помощью макроса @code{lambda} или специальной формы @code{function}
  или синтаксиса @code{#'} (@pxref{Anonymous Functions}), автоматически преобразуется в
  @dfn{closure} ,

@cindex closure
  Замыкание - это функция, которая также содержит запись лексической среды, которая
  существовала, когда функция была определена. Когда она вызывается, любые ссылки на
  лексические переменные в его определении используют сохраненную лексическую среду. Во
  всех других отношениях замыкания ведут себя подобно обычным функциям; в частности, они
  могут вызываться так же, как и обычные функции.

  @xref{Lexical Binding}, для примера использования замыкание.

  В настоящее время объект замыкания Emacs Lisp представлен списком с символом
  @code{closure} в качестве первого элемента, списком, представляющим лексическую среду
  как второй элемент, а списком аргументов и телом являются оставшиеся элементы:

@example
;; @r{лексическое связывание включено.}
(lambda (x) (* x x))
     @result{} (closure (t) (x) (* x x))
@end example

@noindent
Однако тот факт, что внутренняя структура замыкания открыта для остального мира Lisp,
считается внутренней деталью реализации. По этой причине мы не рекомендуем непосредственно
проверять или изменять структуру замыкающих объектов.

@node Advising Functions
@section Advising Emacs Lisp Functions
@cindex advising functions
@cindex piece of advice

Когда вам нужно изменить функцию, определенную в другой библиотеке, или когда вам нужно
изменить хук, такой как @code{@var{foo}-function}, фильтр процесса или, в основном, любую
переменную или поле объекта, которое содержит значение функции, вы можете использовать
соответствующую функцию-установщик, такую ​​как @code{fset} или @code{defun} для именованных
функций, @code{setq} для переменных хука или @code{set-process-filter} для фильтров
процесса, но они часто слишком тупые, полностью отбрасывая предыдущее значение.

  Функция @dfn{advice} позволяет добавить к существующему определению функции, используя
  @dfn{advising the function}. Это более чистый метод, чем переопределение всей функции.

Система рекомендаций Emacs предоставляет для этого два набора примитивов: базовый набор
для значений функций, хранящихся в переменных и полях объектов (с соответствующими
примитивами @code{add-function} и @code{remove-function}), и другой набор, наслоенный
поверх него для именованных функций (с основными примитивами, являющимися
@code{advice-add} и @code{advice-remove}).

Например, чтобы отследить вызовы к фильтру процесса процесса @var{proc}, вы
можете использовать:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

Это приведет к тому, что выходные данные процесса будут переданы в
@code{my-tracing-function} перед передачей в исходный фильтр процесса.
@code{my-tracing-function} получает те же аргументы, что и исходная функция. Когда вы
закончите с этим, вы можете вернуться к неизведанному поведению с помощью:

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

Точно так же, если вы хотите отследить выполнение функции с именем
@code{display-buffer}, вы можете использовать:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

Здесь @code{his-tracing-function} вызывается вместо исходной функции и получает
исходную функцию (в дополнение к аргументам этой функции) в качестве аргумента, поэтому
он может вызывать ее, если и когда это необходимо. Когда вы устали видеть этот вывод,
вы можете вернуться к неотслеживаемому поведению с помощью:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

Аргументы @code{:before} и @code{:around}, использованные в приведенных выше примерах,
определяют, как составляются две функции, поскольку существует много разных способов
сделать это. Добавленная функция также называется частью @emph{advice}.

@menu
* Core Advising Primitives::    Примитивы манипулируют советами.
* Advising Named Functions::    Консультирование именованных функций.
* Advice combinators::          Способы составить совет.
* Porting old advice::          Адаптация кода с использованием старого defadvice.
@end menu

@node Core Advising Primitives
@subsection Primitives to manipulate advices
@cindex advice, add and remove

@defmac add-function where place function &optional props
Этот макрос - удобный способ добавить совет @var{function} к функции, хранящейся в
@var{place} (@pxref{Generalized Variables}).

@var{where} определяет, как @var{function} составляется с существующей функцией,
например, должен ли @var{function} вызываться до или после исходной функции.
@xref{Advice combinators}, для списка доступных способов составить две функции.

При изменении переменной (имя которой обычно заканчивается на @code{-function}), вы можете
выбрать, будет ли @var{function} использоваться глобально или только в текущем буфере:
если @var{place} является просто символом, то @var{function} добавляется к глобальному
значению @var{place}. Если @var{place} имеет вид @code{(local @var{symbol})}, где
@var{symbol} - это выражение, которое возвращает имя переменной, то @var{function} будет
добавлен только в текущий буфер. Наконец, если вы хотите изменить лексическую переменную,
вам придется использовать @code{(var @var{variable})}.

Каждая функция, добавленная с помощью @code{add-function}, может сопровождаться списком
ассоциаций свойств @var{props}. В настоящее время только два из этих свойств имеют
особое значение:

@table @code
@item name
Это дает название рекомендации, которую @code{remove-function} может использовать для
определения, какую функцию удалить. Обычно используется, когда @var{function} является
анонимной функцией.

@item depth
Здесь указывается, как заказать совет, если есть несколько советов. По умолчанию глубина
равна 0. Глубина 100 указывает, что этот совет должен быть как можно глубже, тогда как
глубина @minus{}100 указывает, что он должен оставаться как самый внешний фрагмент. Когда
два совета указывают одинаковую глубину, последний добавленный будет самым внешним.

Для рекомендации @code{:before} быть самым внешним означает, что этот совет будет
выполняться первым, а не любым другим советом, в то время как самый внутренний означает,
что он будет выполняться непосредственно перед исходной функцией, при этом никакой другой
совет не будет выполняться между собой и исходной функцией. Аналогично, для рекомендации
@code{:after} самый внутренний означает, что он будет выполняться сразу после исходной
функции, без других промежуточных рекомендаций, в то время как самый внешний означает, что
он будет выполнен в конце после всех других рекомендаций. Внутренний совет @code{:override}
будет переопределять только исходную функцию, и другие советы будут применяться к нему,
тогда как самый внешний совет @code{:override} будет переопределять не только исходную
функцию, но и все другие рекомендации, примененные к ней.
@end table

Если @var{function} не является интерактивным, тогда объединенная функция наследует
интерактивную спецификацию, если таковая имеется, исходной функции. Иначе, объединенная
функция будет интерактивной и будет использовать интерактивную спецификацию @var{function}.
Единственное исключение: если интерактивная спецификация @var{function} является функцией
(а не выражением или строкой), то интерактивной спецификацией объединенной функции будет
вызов этой функции с единственным аргументом интерактивной спецификации исходной функции.
Чтобы интерпретировать спецификацию, полученную в качестве аргумента, используйте
@code{advice-eval-interactive-spec}.

Примечание: интерактивная спецификация @var{function} будет применяться к объединенной
функции и, следовательно, должна подчиняться соглашению о вызовах объединенной функции,
а не @var{function}. Во многих случаях это не имеет значения, поскольку они идентичны,
но это имеет значение для @code{:around}, @code{:filter-args} и @code{filter-return},
где @var{function}.
@end defmac

@defmac remove-function place function
Этот макрос удаляет @var {function} из функции, хранящейся в @var{place}. Это
работает, только если @var{function} был добавлен к @var{place} с помощью
@code{add-function}.

@var{function} сравнивается с функциями, добавленными в @var{place} с использованием
@code{equal}, чтобы попытаться заставить его работать также с лямбда-выражениями. Кроме
того, он сравнивается также со свойством @code{name} функций, добавленных в @var{place},
что может быть более надежным, чем сравнение лямбда-выражений с использованием @code{equal}.
@end defmac

@defun advice-function-member-p advice function-def
Вернуть non-@code{nil}, если @var{advice} уже находится в @var{function-def}. Как и в
случае с @code{remove-function} выше, вместо @var{advice}, являющейся фактической
функцией, он также может быть @code{name} из совета.
@end defun

@defun advice-function-mapc f function-def
Вызовите функцию @var{f} для каждого совета, который был добавлен в @var{function-def}.
@var{f} вызывается с двумя аргументами: функцией совета и ее свойствами.
@end defun

@defun advice-eval-interactive-spec spec
Оцените интерактивный @var{spec} так же, как интерактивный вызов функции с такой
спецификацией, и затем верните соответствующий список аргументов, который был построен.
Например, @code{(advice-eval-interactive-spec "r\nP")} вернет список из трех элементов,
содержащий границы региона и текущий префиксный аргумент.
@end defun

@node Advising Named Functions
@subsection Advising Named Functions
@cindex advising named functions

Обычное использование консультирование - для именованных функций и макросов. Вы можете
просто использовать @code{add-function} как в:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  Но вы должны использовать для этого @code{advice-add} и @code{advice-remove}. Этот
  отдельный набор функций для управления консультациями, применяемым к именованным функциям,
  предлагает следующие дополнительные функции по сравнению с @code{add-function}: они
  знают, как обращаться с макросами и автоматически загружаемыми функциями, они позволяют
  @code{describe-function} сохранять исходную строку документации, а также документировать
  добавленные консультации, и они позволяют вам добавлять и удалять крнсультации еще до
  того, как функция будет определена.

  @code{advice-add} может быть полезен для изменения поведения существующих вызовов
  существующей функции без необходимости переопределения всей функции. Тем не менее, это
  может быть источником ошибок, поскольку существующие вызывающие функции могут принимать
  старое поведение и работать некорректно, когда поведение изменяется консультированием.
  Консультирование может также вызвать путаницу при отладке, если человек, выполняющий
  отладку, не замечает или не помнит, что функция была изменена консультированием.

  По этим причинам, консультирование должено быть зарезервировано для случаев, когда
  вы не можете изменить поведение функции любым другим способом. Если возможно сделать
  то же самое с помощью крючка, это предпочтительнее (@pxref{Hooks}). Если вы просто
  хотите изменить  действие определенного ключа, лучше написать новую команду и
  переназначить привязки клавиш старой команды к новой (@pxref{Remapping Commands}). В
  частности, собственные исходные файлы Emacs не должны содержать консультирований по
  функциям в Emacs. (В настоящее время есть несколько исключений из этого соглашения,
  но мы стремимся исправить их.)

  Специальные формы (@pxref{Special Forms}) не могут быть консультированы, однако макросы
  могут быть так же, как функции. Конечно, это не повлияет на код, который уже был
  развернут макросом, поэтому перед развертыванием макроса необходимо убедиться, что
  консультирование установлено.

  Можно посоветовать примитив (@pxref{What Is a Function}), но обычно @emph{not}
  должен делать это по двум причинам. Во-первых, некоторые примитивы используются
  механизмом консультирования, и консультацмм по ним могут вызвать бесконечную
  рекурсию. Во-вторых, многие примитивы вызываются непосредственно из C, и такие вызовы
  игнорируют консультирование; следовательно, каждый оказывается в запутанной ситуации,
  когда некоторые вызовы (происходящие из кода Lisp) подчиняются консультации, а другие
  вызовы (из кода C) - нет.

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
Этот макрос определяет консультирование и добавляет её в функцию с именем @var{symbol}.
Консультирование - анонимная функция, если @var{name} - это @code{nil} или функция с
именем @code{symbol@@name}. Смотрите @code{advice-add} для объяснения других аргументов.
@end defmac

@defun advice-add symbol where function &optional props
Добавьте совет @var{function} в именованную функцию @var{symbol}. @var{where} и
@var{props} имеют то же значение, что и для @code{add-function}
(@pxref{Core Advising Primitives}).
@end defun

@defun advice-remove symbol function
Удалите совет @var{function} из названной функции @var{symbol}. @var{function}
также может быть советом @code{name}.
@end defun

@defun advice-member-p function symbol
Вернуть non-@code{nil}, если консультирование @var{function} уже находится в
именованной функции @var{symbol}. @var{function} также может быть консультированием
@code{name}.
@end defun

@defun advice-mapc function symbol
Вызывайте @var{function} для каждой консультации, которая была добавлена к именованой
функции @var{symbol}. @var{function} вызывается с двумя аргументами: функцией
консультирования и ее свойствами.
@end defun

@node Advice combinators
@subsection Ways to compose advice

Вот различные возможные значения для аргумента @var{where} для @code{add-function} и
@code{advice-add}, указывающие, как следует составлять консультирование @var{function} и
исходную функцию.

@table @code
@item :before
Вызовите @var{function} перед старой функцией. Обе функции получают одинаковые аргументы,
а возвращаемое значение композиции является возвращаемым значением старой функции.
Более конкретно, состав этих двух функций ведет себя так:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar} @var{function})} сопоставим для
однофункциональных крючков с @code{(add-hook '@var{hookvar} @var{function})}
для обычных крючков.

@item :after
Вызовите @var{function} после старой функции. Обе функции получают одинаковые
аргументы, а возвращаемое значение композиции является возвращаемым значением старой
функции. Более конкретно, состав этих двух функций ведет себя так:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar} @var{function})} сопоставим для однофункциональных
крюков с @code{(add-hook '@var{hookvar} @var{function} 'append)} для обычных крюков.

@item :override
Это полностью заменяет старую функцию новой. Старая функция, конечно, может быть
восстановлена, если позже вы вызовете @code{remove-function}.

@item :around
Вызовите @var{function} вместо старой функции, но предоставьте старую функцию в
качестве дополнительного аргумента для @var{function}. Это самая гибкая композиция.
Например, он позволяет вам вызывать старую функцию с разными аргументами, или много раз,
или внутри привязки let, или вы можете иногда делегировать работу старой функции, а иногда
полностью ее переопределять. Более конкретно, состав этих двух функций ведет себя так:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
Вызовите @var{function} перед старой функцией и не вызывайте старую функцию, если
@var{function} возвращает @code{nil}. Обе функции получают одинаковые аргументы, а
возвращаемое значение композиции является возвращаемым значением старой функции. Более
конкретно, состав этих двух функций ведет себя так:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar} @var{function})} сопоставим для
однофункциональных крючков с @code{(add-hook '@var{hookvar} @var{function})}, когда
@var {hookvar} запускается через @code{run-hook-with-args-until-failure}.

@item :before-until
Вызывайте @var{function} перед старой функцией и вызывайте старую функцию только в том
случае, если @var{function} возвращает @code{nil}. Более конкретно, состав этих двух
функций ведет себя так:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar} @var{function})} сопоставим для
однофункциональных крючков с @code{(add-hook '@var{hookvar} @var{function})}, когда
@var{hookvar} запускается через @code{run-hook-with-args-until-success}.

@item :after-while
Вызывайте @var{function} после старой функции и только если старая функция вернула
не-@code{nil}. Обе функции получают одинаковые аргументы, а возвращаемое значение
композиции является возвращаемым значением @var{function}. Более конкретно, состав
этих двух функций ведет себя так:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar} @var{function})} сопоставим для
однофункциональных крючков с @code{(add-hook '@var{hookvar} @var{function} 'append)},
когда @var{hookvar} запускается через @code{run-hook-with-args-until-failure}.

@item :after-until
Вызывайте @var{function} после старой функции и только в том случае, если старая
функция вернула @code{nil}. Более конкретно, состав этих двух функций ведет себя так:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar} @var{function})} сопоставим для
однофункциональных хуков с @code{(add-hook '@var{hookvar} @var{function} 'append)},
когда @var{hookvar} запускается через @code{run-hook-with-args-until-success}.

@item :filter-args
Сначала вызовите @var{function} и используйте результат (который должен быть списком) в
качестве новых аргументов для передачи старой функции. Более конкретно, состав этих двух
функций ведет себя так:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
Сначала вызовите старую функцию и передайте результат в @var{function}. Более
конкретно, состав этих двух функций ведет себя так:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting old advice
@subsection Adapting code using the old defadvice
@cindex old advices, porting
@c NB: Следующие записи индекса намеренно избегают ``old'' (old), прилагательное,
@c которое не приходит в голову тем, кто вырос на ‘defadvice’ (defadvice) et al. Для
@c тех людей этот способ - ``current'' (текущий).
@c Они обнаруживают его старость, читая этот узел.
@cindex advices, porting from @code{defadvice}
@findex defadvice
@findex ad-activate

Во многих кодах используется старый механизм @code{defadvice}, который во многом
устарел благодаря новому @code{advice-add}, реализация и семантика которого
значительно проще.

Старое консультирование, такое как:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Вставьте пустую строку при движении вверх от верхней строки."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

можно было бы перевести в новом механизме консультирования в простую функцию:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Вставьте пустую строку при движении вверх от верхней строки."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

Очевидно, что это на самом деле не изменяет @code{previous-line}. Для этого нужно
старое консультирование:
@example
(ad-activate 'previous-line)
@end example
в то время как новый механизм консультирования сработает:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

Обратите внимание, что @code{ad-activate} имел глобальный эффект: он активировал все
консультации, включенные для указанной функции. Если вы хотите активировать или
деактивировать только определенную часть, вам нужно было @emph{enable} или @emph{disable}
с помощью @code{ad-enable-advice} и @code{ad-disable-advice}. Новый механизм устраняет
это различие.

Обзор консультирования, такого как:

@example
(defadvice foo (around foo-around)
  "Игнорировать регистр в `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

может изменить на на:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Игнорировать регистр в `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

Что касается @emph{class} консультированию, обратите внимание, что новое @code{:before} не
совсем эквивалентен старому @code{before}, потому что в старом вы можете изменить
аргументы функции (например, с помощью @code{ad-set-arg}), и это повлияет на значения
аргументов, видимые исходной функцией, тогда как в новом @code{:before} изменение
аргумента с помощью @code{setq} в консультирования не влияет на аргументы, видимые в
исходной функции.При переносе консультирования @code{before}, в котором основывались на
этом поведении, вам нужно вместо этого превратить его в новое консультирование
@code{:around} или @code{:filter-args}.

Точно так же старое консультирование @code{after} могло изменить возвращаемое значение
путем изменения @code{ad-return-value}, тогда как в новом консультировании @code{:after}
не может, поэтому при портировании такого старого консультирования @code{after} вам
нужно вместо этого превратить его в новое @code{:around} или @code{:filter-return}.

@node Obsolete Functions
@section Declaring Functions Obsolete
@cindex obsolete functions

  Вы можете пометить именованную функцию как @dfn{obsolete}, что означает, что она
  может быть удалена в будущем. Это заставляет Emacs предупреждать, что функция устарела
  всякий раз, когда она выполняет байт-компиляцию кода, содержащего эту функцию, и
  всякий раз, когда она отображает документацию для этой функции. Во всех других
  отношениях устаревшая функция ведет себя как любая другая функция.

  Самый простой способ пометить функцию как устаревшую - это поместить форму
  @code{(declare (obsolete @dots{}))} в функцию @code{defun} definition.
  @xref{Declare Form}. В качестве альтернативы вы можете использовать функцию
  @code{make-obsolete}, описанную ниже.

  Макрос (@pxref{Macros}) также может быть помечен как устаревший с помощью
  @code{make-obsolete}; это имеет тот же эффект, что и для функции. Псевдоним для функции
  или макроса также может быть помечен как устаревший; это делает сам псевдоним устаревшим,
  а не функцию или макрос, к которому он разрешает.

@defun make-obsolete obsolete-name current-name &optional when
Эта функция помечает @var{obsolete-name} как устаревшее. @var{obsolete-name} должен
быть символом, называющим функцию или макрос, или псевдонимом для функции или макроса.

Если @var{current-name} является символом, в предупреждающем сообщении указывается
использовать @var{current-name} вместо @var{obsolete-name}. @var{current-name} не
должен быть псевдонимом для @var{obsolete-name}; это может быть другая функция со
схожей функциональностью. @var{current-name} также может быть строкой, которая служит
предупреждением. Сообщение должно начинаться со строчной буквы и заканчиваться точкой.
Это также может быть @code{nil}, в этом случае в предупреждающем сообщении не содержится
никаких дополнительных подробностей.

Если предоставлено, @var{when} должен быть строкой, указывающей, когда функция была
впервые сделана устаревшей - например, дата или номер выпуска.
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name &optional when doc
Этот вспомогательный макрос помечает функцию @var{obsolete-name} как устаревшую, а также
определяет ее как псевдоним для функции @var{current-name}. Это эквивалентно следующему:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

Кроме того, вы можете пометить конкретное соглашение о вызовах для
функции как устаревшее:

@defun set-advertised-calling-convention function signature when
Эта функция указывает список аргументов @var{signature} как правильный способ вызова
@var{function}. Это заставляет байт-компилятор Emacs выдавать предупреждение всякий раз,
когда он сталкивается с программой Emacs Lisp, которая вызывает @var{function} любым
другим способом (однако, он все еще позволит скомпилировать байты кода). @var{when} должен
быть строкой, указывающей, когда переменная была впервые сделана устаревшей (обычно строка
номера версии).

Например, в старых версиях Emacs функция @code{sit-for} принимала
три аргумента, например

@example
  (sit-for seconds milliseconds nodisp)
@end example

Однако вызов @code{sit-for} таким способом считается устаревшим (@pxref{Waiting}).
Старое соглашение о вызовах как это устарело:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example
@end defun

@node Inline Functions
@section Inline Functions
@cindex inline functions

  @dfn{inline function} - это функция, которая работает так же, как обычная функция, за
  исключением одной вещи: когда вы байт-компилируете вызов функции
  (@pxref{Byte Compilation}), определение функции расширяется до вызывающей стороны.
  Чтобы определить встроенную функцию, используйте @code{defsubst} вместо @code{defun}.

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
Этот макрос определяет встроенную функцию. Его синтаксис точно такой же, как
@code{defun} (@pxref{Defining Functions}).
@end defmac

  Если встрамвать функцию часто, ее вызовы выполняются быстрее. Но это также имеет
  недостатки. С одной стороны, это снижает гибкость; если вы измените определение функции,
  уже встроенные вызовы по-прежнему будут использовать старое определение, пока вы не
  перекомпилируете их.

  Еще один недостаток заключается в том, что выполнение большой встроенной функции
  может увеличить размер скомпилированного кода как в файлах, так и в памяти. Поскольку
  преимущество быстрых встроенных функций является максимальным для небольших функций,
  обычно не следует делать большие встроенные функции.

  Кроме того, встроенные функции не ведут себя хорошо в отношении отладки, трассировки и
  консультирования (@pxref{Advising Functions}). Поскольку простота отладки и гибкость
  переопределения функций являются важными функциями Emacs, вы не должны делать функцию
  встроенной, даже если она небольшая, если только ее скорость не очень важна, и вы
  рассчитали время для проверки того, что использование @code{defun} действительно имеет
  проблемы с производительностью.

  После того, как встроенная функция определена, ее встроенное расширение может быть
  выполнено позже в том же файле, как макросы.

  Можно использовать @code{defmacro} для определения макроса для расширения в тот же код,
  который будет выполнять встроенная функция (@pxref{Macros}). Но макрос может быть
  ограничен прямым использованием в выражениях - макрос нельзя вызывать с помощью
  @code{apply}, @code{mapcar} и так далее. Кроме того, требуется некоторая работа для
  преобразования обычной функции в макрос. Преобразовать его во встроенную функцию легко;
  просто замените @code{defun} на @code{defsubst}. Поскольку каждый аргумент встроенной
  функции вычисляется ровно один раз, вам не нужно беспокоиться о том, сколько раз тело
  использует аргументы, как вы это делаете для макросов.

  В качестве альтернативы @code{defsubst} вы можете использовать @code{define-inline}
  для определения функций через их исчерпывающий макрос компилятора.
  @xref{Defining Functions, define-inline}.

@node Declare Form
@section The @code{declare} Form
@findex declare

  @code{declare} - это специальный макрос, который можно использовать для добавления
  мета-свойств к функции или макросу: например, пометить его как устаревший или
  присвоить его формам специальное соглашение об отступах @key{TAB}
  в режиме Emacs Lisp.

@anchor{Definition of declare}
@defmac declare specs@dots{}
Этот макрос игнорирует свои аргументы и оценивает его как @code{nil}; это не имеет
никакого эффекта во время выполнения. Однако, когда форма @code{declare} встречается в
аргументе @var{declare} определения функции @code{defun} или @code{defsubst}
(@pxref{Defining Functions}) или определения макроса @code{defmacro}
(@pxref{Defining Macros}), она добавляет свойства, указанные @var{specs}, в функцию
или макрос. Эта работа специально выполняется @code{defun}, @code{defsubst} и
@code{defmacro}.

Каждый элемент в @var{specs} должен иметь форму @code{(@var{property}
@var{args}@dots{})}, которая не должна заключаться в кавычки. Они имеют
следующие эффекты:

@table @code
@item (advertised-calling-convention @var{signature} @var{when})
Это действует как вызов @code{set-advertised-calling-convention}
(@pxref{Obsolete Functions}); @var{signature} определяет правильный список аргументов для
вызова функции или макроса, а @var{when} должен быть строкой, указывающей, когда старый
список аргументов был впервые сделан устаревшим.

@item (debug @var{edebug-form-spec})
Это действительно только для макросов. При переходе по макросу с
помощью Edebug используйте @var{edebug-form-spec}.
@xref{Instrumenting Macro Calls}.

@item (doc-string @var{n})
Это используется при определении функции или макроса, который сам будет использоваться
для определения сущностей, таких как функции, макросы или переменные. Это указывает на то,
что аргумент @var{n}, если таковой имеется, должен рассматриваться как строка
документации.

@item (indent @var{indent-spec})
Отступы вызова этой функции или макроса в соответствии с @var{indent-spec}. Обычно это
используется для макросов, хотя работает и для функций.
@xref{Indenting Macros}.

@item (interactive-only @var{value})
Установите для свойства @code{interactive-only} функции значение @var{value}.
@xref{The interactive-only property}.

@item (obsolete @var{current-name} @var{when})
Пометьте функцию или макрос как устаревшую, аналогично вызову @code{make-obsolete}
(@pxref{Obsolete Functions}). @var{current-name} должен быть символом (в этом случае
предупреждающее сообщение говорит об использовании вместо этого), строкой (определяющей
предупреждающее сообщение) или @code{nil} (в этом случае предупреждающее сообщение не
дает дополнительных подробностей). @var{when} должен быть строкой, указывающей, когда
функция или макрос были впервые сделаны устаревшими.

@item (compiler-macro @var{expander})
Это может использоваться только для функций и указывает компилятору использовать
@var{expander} в качестве функции оптимизации. При встрече с вызовом функции вида
@code{(@var{function} @var{args}@dots{})} макроэкспандер вызовет @var{expander} с этой
формой, а также с @var{args}@dots{}, и @var{expander} может либо вернуть новое выражение
для использования вместо вызова функции, либо он может вернуть только Форма неизменна,
чтобы указать, что вызов функции должен быть оставлен в покое. @var{expander} может быть
символом или формой @code{(lambda (@var{arg}) @var{body})}, и в этом случае @var{arg}
будет содержать исходное выражение вызова функции, а к (неоцененным) аргументам функции
можно получить доступ с помощью формальных аргументов функции.

@item (gv-expander @var{expander})
Объявите @var{expander} как функцию для обработки вызовов макроса (или функции) как
обобщенной переменной, аналогично @code{gv-define-expander}. @var{expander} может быть
символом или иметь форму @code{(lambda (@var{arg}) @var{body})}, и в этом случае эта
функция будет дополнительно иметь доступ к аргументам макроса (или функции).

@item (gv-setter @var{setter})
Объявите @var{setter} как функцию для обработки вызовов макроса (или функции) как
обобщенной переменной. @var{setter} может быть символом, в этом случае он будет передан
в @code{gv-define-simple-setter}, или он может иметь форму @code{(lambda (@var{arg})
@var{body})}, и в этом случае эта функция будет дополнительно иметь доступ к аргументам
макроса (или функции), и она будет передана в @code{gv-define-setter}.

@end table

@end defmac

@node Declaring Functions
@section Telling the Compiler that a Function is Defined
@cindex function declaration
@cindex declaring functions
@findex declare-function

Байт-компиляция файла часто выдает предупреждения о функциях, о которых не знает
компилятор (@pxref{Compiler Errors}). Иногда это указывает на реальную проблему, но
обычно рассматриваемые функции определяются в других файлах, которые будут загружены при
запуске этого кода. Например, байтовая компиляция @file{simple.el} используется для
предупреждения:

@example
simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
    defined.
@end example

Фактически, @code{shell-mode} используется только в функции, которая выполняет
@code{(require 'shell)} перед вызовом @code{shell-mode}, поэтому @code{shell-mode}
будет определен правильно во время выполнения. Когда вы знаете, что такое предупреждение
не указывает на реальную проблему, полезно подавить предупреждение. Это делает новые
предупреждения, которые могут означать реальные проблемы, более заметными. Вы делаете
это с помощью @code{declare-function}.

Все, что вам нужно сделать, это добавить оператор @code{declare-function} перед первым
использованием рассматриваемой функции:

@example
(declare-function shell-mode "shell" ())
@end example

Это говорит о том, что @code{shell-mode} определен в @file{shell.el} (@samp{.el} можно
опустить). Компилятор считает само собой разумеющимся, что этот файл действительно
определяет функцию, и не проверяет.

  Необязательный третий аргумент определяет список аргументов @code{shell-mode}. В этом
  случае он не принимает аргументов (@code{nil} отличается от не указания значения). В
  других случаях это может быть что-то вроде @code{(file &optional overwrite)}. Вам не
  нужно указывать список аргументов, но если вы это сделаете, байтовый компилятор может
  проверить, что вызовы соответствуют объявлению.

@defmac declare-function function file &optional arglist fileonly
Скажите байтовому компилятору, что предполагается, что @var{function} определен в файле
@var{file}. Необязательный третий аргумент @var{arglist} - это либо @code{t}, то есть
список аргументов не указан, либо список формальных параметров в том же стиле, что и
@code{defun}. Пропущенный @var{arglist} по умолчанию - @code{t}, а не @code{nil}; это
нетипичное поведение для пропущенных аргументов, и это означает, что для предоставления
четвертого, но не третьего аргумента необходимо указать @code{t} для заполнителя третьего
аргумента вместо обычного @code{nil}. Необязательный четвертый аргумент @var{fileonly}
non-@code{nil} означает проверку только того, что @var{file} существует, а не то, что он
фактически определяет @var{function}.
@end defmac

  Чтобы убедиться, что эти функции действительно объявлены там, где, как говорит
  @code{declare-function}, они есть, используйте @code{check-declare-file}, чтобы
  проверить все вызовы @code{declare-function} в одном исходном файле, или используйте
  @code{check-declare-directory}, чтобы проверить все файлы в определенной директории.

  Эти команды находят файл, который должен содержать определение функции, используя
  @code{locate-library}; если это не находит файл, они расширяют имя файла определения
  относительно каталога файла, который содержит вызов @code{declare-function}.

  Вы также можете сказать, что функция является примитивом, указав имя файла,
  оканчивающееся на @samp{.c} или @samp{.m}. Это полезно только тогда, когда вы вызываете
  примитив, который определен только в определенных системах. Большинство примитивов
  всегда определены, поэтому они никогда не будут предупреждать вас.

  Иногда файл может дополнительно использовать функции из внешнего пакета. Если вы
  ставите префикс имени файла в операторе @code{declare-function} с помощью
  @samp{ext:}, то он будет проверен, если он найден, в противном случае будет
  пропущен без ошибок.

  Есть некоторые определения функций, которые @samp{check-declare} не понимает (например,
  @code{defstruct} и некоторые другие макросы). В таких случаях вы можете передать
  не-@code{nil} аргумент @var{fileonly} в @code{declare-function}, что означает только
  проверку того, что файл существует, а не то, что он фактически определяет функцию.
  Обратите внимание, что для этого без указания списка аргументов необходимо установить
  для аргумента @var{arglist} значение @code{t} (поскольку @code{nil} означает пустой
  список аргументов, а не неопределенный).

@node Function Safety
@section Determining whether a Function is Safe to Call
@cindex function safety
@cindex safety of functions

Некоторые основные режимы, такие как SES, вызывают функции, которые хранятся в
пользовательских файлах. (@inforef{Top, ,ses}, для получения дополнительной информации
об SES@.) Пользовательские файлы иногда имеют плохие родословные - вы можете получить
электронную таблицу от кого-то, с кем вы только что познакомились, или вы можете получить
ее по электронной почте от кого-то, кого вы никогда не встречали. Поэтому рискованно
вызывать функцию, исходный код которой хранится в пользовательском файле, пока вы не
определите, что она безопасна.

@defun unsafep form &optional unsafep-vars
Возвращает @code{nil}, если @var{form} является выражением Lisp @dfn{safe}, или возвращает
список, в котором описано, почему это может быть небезопасно. Аргумент @var{unsafep-vars}
представляет собой список символов, которые, как известно, имеют временные привязки на
данный момент; он в основном используется для внутренних рекурсивных вызовов. Текущий
буфер является неявным аргументом, который предоставляет список локальных привязок
буфера.
@end defun

Быстро и просто, @code{unsafep} делает очень легкий анализ и отклоняет многие выражения
Lisp, которые на самом деле безопасны. Нет известных случаев, когда @code{unsafep}
возвращает @code{nil} для небезопасного выражения. Однако безопасное выражение Lisp
может возвращать строку со свойством @code{display}, содержащую ассоциированное выражение
Lisp, которое будет выполнено после вставки строки в буфер. Это связанное выражение может
быть вирусом. Чтобы быть в безопасности, вы должны удалить свойства из всех строк,
рассчитанных по коду пользователя, прежде чем вставлять их в буферы.

@ignore
Что такое безопасное выражение на Лиспе? По сути, это выражение, которое вызывает 
только встроенные функции без побочных эффектов (или только безобидные). Безобидные 
побочные эффекты включают отображение сообщений и изменение неопасных локальных 
переменных буфера (но не глобальных переменных).

@table @dfn
@item Безопасное выражение
@itemize
@item
Атом или цитируемая вещь.
@item
Вызов безопасной функции (см. Ниже), если все ее аргументы являются 
безопасными выражениями.
@item
Одна из специальных форм @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, и @code{unwind-protect}], если все его аргументы безопасны.
@item
Форма, которая создает временные привязки (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, или
@code{let*}), если все аргументы безопасны и символы для привязки не 
являются явно рискованными (смотри @pxref{File Local Variables}).
@item
Назначение с использованием @code{add-to-list}, @code{setq}, @code{push}, или
@code{pop}, если все аргументы безопасны, и назначаемые символы не являются 
явно рискованными, и у них уже есть временные или локальные привязки буфера.
@item
Один из [apply, mapc, mapcar, mapconcat], если первый аргумент - это 
безопасная явная лямбда, а другие аргументы - это безопасные выражения.
@end itemize

@item Безопасная функция
@itemize
@item
Лямбда, содержащая безопасные выражения.
@item
Символ в списке @code{safe-functions}, поэтому пользователь говорит, что это безопасно.
@item
Символ с не-@code{nil} свойством @code{side-effect-free}.
@item
Символ с не-@code{nil} свойством @code{safe-function}. Значение @code{t} указывает 
на функцию, которая безопасна, но имеет безобидные побочные эффекты. Другие значения 
когда-нибудь будут указывать на функции с классами побочных эффектов, которые не 
всегда безопасны.
@end itemize

Свойства @code{side-effect-free} и @code{safe-function} предоставляются для 
встроенных функций, а также для низкоуровневых функций и макросов, определенных в 
@file{subr.el}. Вы можете назначить эти свойства для функций, которые вы пишете.
@end table
@end ignore

@node Related Topics
@section Other Topics Related to Functions

  Вот таблица нескольких функций, которые выполняют функции, связанные с вызовом
  функций и определениями функций. Они документированы в другом месте, но мы даем
  перекрестные ссылки здесь.

@table @code
@item apply
Смотри @ref{Calling Functions}.

@item autoload
Смотри @ref{Autoload}.

@item call-interactively
Смотри @ref{Interactive Call}.

@item called-interactively-p
Смотри @ref{Distinguish Interactive}.

@item commandp
Смотри @ref{Interactive Call}.

@item documentation
Смотри @ref{Accessing Documentation}.

@item eval
Смотри @ref{Eval}.

@item funcall
Смотри @ref{Calling Functions}.

@item function
Смотри @ref{Anonymous Functions}.

@item ignore
Смотри @ref{Calling Functions}.

@item indirect-function
Смотри @ref{Function Indirection}.

@item interactive
Смотри @ref{Using Interactive}.

@item interactive-p
Смотри @ref{Distinguish Interactive}.

@item mapatoms
Смотри @ref{Creating Symbols}.

@item mapcar
Смотри @ref{Mapping Functions}.

@item map-char-table
Смотри @ref{Char-Tables}.

@item mapconcat
Смотри @ref{Mapping Functions}.

@item undefined
Смотри @ref{Functions for Key Lookup}.
@end table
