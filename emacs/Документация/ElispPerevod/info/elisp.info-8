This is elisp.info, produced by makeinfo version 6.1 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp.info,  Node: Mouse Window Auto-selection,  Next: Window Configurations,  Prev: Coordinates and Windows,  Up: Windows

28.27 Mouse Window Auto-selection
=================================

The following option allows to automatically select the window under the
mouse pointer.  This accomplishes a policy similar to that of window
managers that give focus to a frame (and thus trigger its subsequent
selection) whenever the mouse pointer enters its window-system window
(*note Input Focus::).

 -- User Option: mouse-autoselect-window
     If this variable is non-‘nil’, Emacs will try to automatically
     select the window under the mouse pointer.  The following values
     are meaningful:

     A positive number
          This specifies a delay in seconds after which auto-selection
          triggers.  The window under the mouse pointer is selected
          after the mouse has remained in it for the entire duration of
          the delay.

     A negative number
          A negative number has a similar effect as a positive number,
          but selects the window under the mouse pointer only after the
          mouse pointer has remained in it for the entire duration of
          the absolute value of that number and in addition has stopped
          moving.

     Other value
          Any other non-‘nil’ value means to select a window
          instantaneously as soon as the mouse pointer enters it.

     In either case, the mouse pointer must enter the text area of a
     window in order to trigger its selection.  Dragging the scroll bar
     slider or the mode line of a window conceptually should not cause
     its auto-selection.

     Mouse auto-selection selects the minibuffer window only if it is
     active, and never deselects the active minibuffer window.

   Mouse auto-selection can be used to emulate a focus follows mouse
policy for child frames (*note Child Frames::) which usually are not
tracked by the window manager.  This requires to set the value of
‘focus-follows-mouse’ (*note Input Focus::) to a non-‘nil’ value.  If
the value of ‘focus-follows-mouse’ is ‘auto-raise’, entering a child
frame with the mouse will raise it automatically above all other child
frames of that frame’s parent frame.


File: elisp.info,  Node: Window Configurations,  Next: Window Parameters,  Prev: Mouse Window Auto-selection,  Up: Windows

28.28 Window Configurations
===========================

A “window configuration” records the entire layout of one frame—all
windows, their sizes, which buffers they contain, how those buffers are
scrolled, and their value of point; also their fringes, margins, and
scroll bar settings.  It also includes the value of
‘minibuffer-scroll-window’.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

   You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration.  *Note Frame Configurations::.

 -- Function: current-window-configuration &optional frame
     This function returns a new object representing FRAME’s current
     window configuration.  The default for FRAME is the selected frame.
     The variable ‘window-persistent-parameters’ specifies which window
     parameters (if any) are saved by this function.  *Note Window
     Parameters::.

 -- Function: set-window-configuration configuration
     This function restores the configuration of windows and buffers as
     specified by CONFIGURATION, for the frame that CONFIGURATION was
     created for.

     The argument CONFIGURATION must be a value that was previously
     returned by ‘current-window-configuration’.  The configuration is
     restored in the frame from which CONFIGURATION was made, whether
     that frame is selected or not.  In some rare cases this may trigger
     execution of the ‘window-size-change-functions’ (*note Window
     Hooks::) even if the size of windows did not change at all.  The
     ‘window-configuration-change-hook’ functions will be called if and
     only if at least one window was added to or deleted from the frame.

     If the frame from which CONFIGURATION was saved is dead, all this
     function does is restore the three variables ‘window-min-height’,
     ‘window-min-width’ and ‘minibuffer-scroll-window’.  In this case,
     the function returns ‘nil’.  Otherwise, it returns ‘t’.

     Here is a way of using this function to get the same effect as
     ‘save-window-excursion’:

          (let ((config (current-window-configuration)))
            (unwind-protect
                (progn (split-window-below nil)
                       ...)
              (set-window-configuration config)))

 -- Macro: save-window-excursion forms...
     This macro records the window configuration of the selected frame,
     executes FORMS in sequence, then restores the earlier window
     configuration.  The return value is the value of the final form in
     FORMS.

     Most Lisp code should not use this macro; ‘save-selected-window’ is
     typically sufficient.  In particular, this macro cannot reliably
     prevent the code in FORMS from opening new windows, because new
     windows might be opened in other frames (*note Choosing Window::),
     and ‘save-window-excursion’ only saves and restores the window
     configuration on the current frame.

     Do not use this macro in ‘window-size-change-functions’; exiting
     the macro triggers execution of ‘window-size-change-functions’,
     leading to an endless loop.

 -- Function: window-configuration-p object
     This function returns ‘t’ if OBJECT is a window configuration.

 -- Function: compare-window-configurations config1 config2
     This function compares two window configurations as regards the
     structure of windows, but ignores the values of point and the saved
     scrolling positions—it can return ‘t’ even if those aspects differ.

     The function ‘equal’ can also compare two window configurations; it
     regards configurations as unequal if they differ in any respect,
     even a saved point.

 -- Function: window-configuration-frame config
     This function returns the frame for which the window configuration
     CONFIG was made.

   Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file ‘winner.el’ for some more operations on windows configurations.

   The objects returned by ‘current-window-configuration’ die together
with the Emacs process.  In order to store a window configuration on
disk and read it back in another Emacs session, you can use the
functions described next.  These functions are also useful to clone the
state of a frame into an arbitrary live window
(‘set-window-configuration’ effectively clones the windows of a frame
into the root window of that very frame only).

 -- Function: window-state-get &optional window writable
     This function returns the state of WINDOW as a Lisp object.  The
     argument WINDOW must be a valid window and defaults to the root
     window of the selected frame.

     If the optional argument WRITABLE is non-‘nil’, this means to not
     use markers for sampling positions like ‘window-point’ or
     ‘window-start’.  This argument should be non-‘nil’ when the state
     will be written to disk and read back in another session.

     Together, the argument WRITABLE and the variable
     ‘window-persistent-parameters’ specify which window parameters are
     saved by this function.  *Note Window Parameters::.

   The value returned by ‘window-state-get’ can be used in the same
session to make a clone of a window in another window.  It can be also
written to disk and read back in another session.  In either case, use
the following function to restore the state of the window.

 -- Function: window-state-put state &optional window ignore
     This function puts the window state STATE into WINDOW.  The
     argument STATE should be the state of a window returned by an
     earlier invocation of ‘window-state-get’, see above.  The optional
     argument WINDOW can be either a live window or an internal window
     (*note Windows and Frames::) and defaults to the selected one.  If
     WINDOW is not live, it is replaced by a live window before putting
     STATE into it.

     If the optional argument IGNORE is non-‘nil’, it means to ignore
     minimum window sizes and fixed-size restrictions.  If IGNORE is
     ‘safe’, this means windows can get as small as one line and/or two
     columns.

   The functions ‘window-state-get’ and ‘window-state-put’ also allow to
exchange the contents of two live windows.  The following function does
precisely that:

 -- Command: window-swap-states &optional window-1 window-2 size
     This command swaps the states of the two live windows WINDOW-1 and
     WINDOW-2.  WINDOW-1 must specify a live window and defaults to the
     selected one.  WINDOW-2 must specify a live window and defaults to
     the window following WINDOW-1 in the cyclic ordering of windows,
     excluding minibuffer windows and including live windows on all
     visible frames.

     Optional argument SIZE non-‘nil’ means to try swapping the sizes of
     WINDOW-1 and WINDOW-2 as well.  A value of ‘height’ means to swap
     heights only, a value of ‘width’ means to swap widths only, while
     ‘t’ means to swap both widths and heights, if possible.  Frames are
     not resized by this function.


File: elisp.info,  Node: Window Parameters,  Next: Window Hooks,  Prev: Window Configurations,  Up: Windows

28.29 Window Parameters
=======================

This section describes how window parameters can be used to associate
additional information with windows.

 -- Function: window-parameter window parameter
     This function returns WINDOW’s value for PARAMETER.  The default
     for WINDOW is the selected window.  If WINDOW has no setting for
     PARAMETER, this function returns ‘nil’.

 -- Function: window-parameters &optional window
     This function returns all parameters of WINDOW and their values.
     The default for WINDOW is the selected window.  The return value is
     either ‘nil’, or an association list whose elements have the form
     ‘(PARAMETER . VALUE)’.

 -- Function: set-window-parameter window parameter value
     This function sets WINDOW’s value of PARAMETER to VALUE and returns
     VALUE.  The default for WINDOW is the selected window.

   By default, the functions that save and restore window configurations
or the states of windows (*note Window Configurations::) do not care
about window parameters.  This means that when you change the value of a
parameter within the body of a ‘save-window-excursion’, the previous
value is not restored when that macro exits.  It also means that when
you restore via ‘window-state-put’ a window state saved earlier by
‘window-state-get’, all cloned windows have their parameters reset to
‘nil’.  The following variable allows you to override the standard
behavior:

 -- Variable: window-persistent-parameters
     This variable is an alist specifying which parameters get saved by
     ‘current-window-configuration’ and ‘window-state-get’, and
     subsequently restored by ‘set-window-configuration’ and
     ‘window-state-put’.  *Note Window Configurations::.

     The CAR of each entry of this alist is a symbol specifying the
     parameter.  The CDR should be one of the following:

     ‘nil’
          This value means the parameter is saved neither by
          ‘window-state-get’ nor by ‘current-window-configuration’.

     ‘t’
          This value specifies that the parameter is saved by
          ‘current-window-configuration’ and (provided its WRITABLE
          argument is ‘nil’) by ‘window-state-get’.

     ‘writable’
          This means that the parameter is saved unconditionally by both
          ‘current-window-configuration’ and ‘window-state-get’.  This
          value should not be used for parameters whose values do not
          have a read syntax.  Otherwise, invoking ‘window-state-put’ in
          another session may fail with an ‘invalid-read-syntax’ error.

   Some functions (notably ‘delete-window’, ‘delete-other-windows’ and
‘split-window’), may behave specially when the window specified by their
WINDOW argument has a parameter whose name is equal to the function’s
name.  You can override such special behavior by binding the following
variable to a non-‘nil’ value:

 -- Variable: ignore-window-parameters
     If this variable is non-‘nil’, some standard functions do not
     process window parameters.  The functions currently affected by
     this are ‘split-window’, ‘delete-window’, ‘delete-other-windows’,
     and ‘other-window’.

     An application can bind this variable to a non-‘nil’ value around
     calls to these functions.  If it does so, the application is fully
     responsible for correctly assigning the parameters of all involved
     windows when exiting that function.

   The following parameters are currently used by the window management
code:

‘delete-window’
     This parameter affects the execution of ‘delete-window’ (*note
     Deleting Windows::).

‘delete-other-windows’
     This parameter affects the execution of ‘delete-other-windows’
     (*note Deleting Windows::).

‘no-delete-other-windows’
     This parameter marks the window as not deletable by
     ‘delete-other-windows’ (*note Deleting Windows::).

‘split-window’
     This parameter affects the execution of ‘split-window’ (*note
     Splitting Windows::).

‘other-window’
     This parameter affects the execution of ‘other-window’ (*note
     Cyclic Window Ordering::).

‘no-other-window’
     This parameter marks the window as not selectable by ‘other-window’
     (*note Cyclic Window Ordering::).

‘clone-of’
     This parameter specifies the window that this one has been cloned
     from.  It is installed by ‘window-state-get’ (*note Window
     Configurations::).

‘window-preserved-size’
     This parameter specifies a buffer, a direction where ‘nil’ means
     vertical and ‘t’ horizontal, and a size in pixels.  If this window
     displays the specified buffer and its size in the indicated
     direction equals the size specified by this parameter, then Emacs
     will try to preserve the size of this window in the indicated
     direction.  This parameter is installed and updated by the function
     ‘window-preserve-size’ (*note Preserving Window Sizes::).

‘quit-restore’
     This parameter is installed by the buffer display functions (*note
     Choosing Window::) and consulted by ‘quit-restore-window’ (*note
     Quitting Windows::).  It contains four elements:

     The first element is one of the symbols ‘window’, meaning that the
     window has been specially created by ‘display-buffer’; ‘frame’, a
     separate frame has been created; ‘same’, the window has only ever
     displayed this buffer; or ‘other’, the window showed another buffer
     before.  ‘frame’ and ‘window’ affect how the window is quit, while
     ‘same’ and ‘other’ affect the redisplay of buffers previously shown
     in this window.

     The second element is either one of the symbols ‘window’ or
     ‘frame’, or a list whose elements are the buffer shown in the
     window before, that buffer’s window start and window point
     positions, and the window’s height at that time.  If that buffer is
     still live when the window is quit, then the function
     ‘quit-restore-window’ reuses the window to display the buffer.

     The third element is the window selected at the time the parameter
     was created.  If ‘quit-restore-window’ deletes the window passed to
     it as argument, it then tries to reselect this window.

     The fourth element is the buffer whose display caused the creation
     of this parameter.  ‘quit-restore-window’ deletes the specified
     window only if it still shows that buffer.

     See the description of ‘quit-restore-window’ in *note Quitting
     Windows:: for details.

‘window-side window-slot’
     These parameters are used for implementing side windows (*note Side
     Windows::).

‘window-atom’
     This parameter is used for implementing atomic windows, see *note
     Atomic Windows::.

‘mode-line-format’
     This parameter replaces the value of the buffer-local variable
     ‘mode-line-format’ (*note Mode Line Basics::) of this window’s
     buffer whenever this window is displayed.  The symbol ‘none’ means
     to suppress display of a mode line for this window.  Display and
     contents of the mode line on other windows showing this buffer are
     not affected.

‘header-line-format’
     This parameter replaces the value of the buffer-local variable
     ‘header-line-format’ (*note Mode Line Basics::) of this window’s
     buffer whenever this window is displayed.  The symbol ‘none’ means
     to suppress display of a header line for this window.  Display and
     contents of the header line on other windows showing this buffer
     are not affected.

‘min-margins’
     The value of this parameter is a cons cell whose CAR and CDR, if
     non-‘nil’, specify the minimum values (in columns) for the left and
     right margin of this window.  When present, Emacs will use these
     values instead of the actual margin widths for determining whether
     a window can be split or shrunk horizontally.

     Emacs never auto-adjusts the margins of any window after splitting
     or resizing it.  It is the sole responsibility of any application
     setting this parameter to adjust the margins of this window as well
     as those of any new window that inherits this window’s margins due
     to a split.  Both ‘window-configuration-change-hook’ and
     ‘window-size-change-functions’ (*note Window Hooks::) should be
     employed for this purpose.

     This parameter was introduced in Emacs version 25.1 to support
     applications that use large margins to center buffer text within a
     window and should be used, with due care, exclusively by those
     applications.  It might be replaced by an improved solution in
     future versions of Emacs.


File: elisp.info,  Node: Window Hooks,  Prev: Window Parameters,  Up: Windows

28.30 Hooks for Window Scrolling and Changes
============================================

This section describes how a Lisp program can take action whenever a
window displays a different part of its buffer or a different buffer.
There are three actions that can change this: scrolling the window,
switching buffers in the window, and changing the size of the window.
The first two actions run ‘window-scroll-functions’; the last runs
‘window-size-change-functions’.

 -- Variable: window-scroll-functions
     This variable holds a list of functions that Emacs should call
     before redisplaying a window with scrolling.  Displaying a
     different buffer in the window also runs these functions.

     This variable is not a normal hook, because each function is called
     with two arguments: the window, and its new display-start position.
     At the time of the call, the display-start position of the window
     argument is already set to its new value, and the buffer to be
     displayed in the window is already set as the current buffer.

     These functions must take care when using ‘window-end’ (*note
     Window Start and End::); if you need an up-to-date value, you must
     use the UPDATE argument to ensure you get it.

     *Warning:* don’t use this feature to alter the way the window is
     scrolled.  It’s not designed for that, and such use probably won’t
     work.

 -- Function: run-window-scroll-functions &optional window
     This function calls ‘window-scroll-functions’ for the specified
     WINDOW, which defaults to the selected window.

 -- Variable: window-size-change-functions
     This variable holds a list of functions to be called if the size of
     any window changes for any reason.  The functions are called once
     per redisplay, and once for each frame on which size changes have
     occurred.

     Each function receives the frame as its sole argument.  To find out
     whether a specific window has changed size, compare the return
     values of ‘window-pixel-width-before-size-change’ and
     ‘window-pixel-width’ respectively
     ‘window-pixel-height-before-size-change’ and ‘window-pixel-height’
     for that window (*note Window Sizes::).

     These function are usually only called when at least one window was
     added or has changed size since the last time this hook was run for
     the associated frame.  In some rare cases this hook also runs when
     a window that was added intermittently has been deleted afterwards.
     In these cases none of the windows on the frame will appear to have
     changed its size.

     You may use ‘save-selected-window’ in these functions (*note
     Selecting Windows::).  However, do not use ‘save-window-excursion’
     (*note Window Configurations::); exiting that macro counts as a
     size change, which would cause these functions to be called again.

 -- Variable: window-configuration-change-hook
     A normal hook that is run every time the window configuration of a
     frame changes.  Window configuration changes include splitting and
     deleting windows, and the display of a different buffer in a
     window.  Resizing the frame or individual windows do not count as
     configuration changes.  Use ‘window-size-change-functions’, see
     above, when you want to track size changes that are not caused by
     the deletion or creation of windows.

     The buffer-local value of this hook is run once for each window on
     the affected frame, with the relevant window selected and its
     buffer current.  The global value of this hook is run once for the
     modified frame, with that frame selected.

 -- Function: run-window-configuration-change-hook &optional frame
     This function runs ‘window-configuration-change-hook’ for the
     specified FRAME, which defaults to the selected frame.

   In addition, you can use ‘jit-lock-register’ to register a Font Lock
fontification function, which will be called whenever parts of a buffer
are (re)fontified because a window was scrolled or its size changed.
*Note Other Font Lock Variables::.


File: elisp.info,  Node: Frames,  Next: Positions,  Prev: Windows,  Up: Top

29 Frames
*********

A “frame” is a screen object that contains one or more Emacs windows
(*note Windows::).  It is the kind of object called a “window” in the
terminology of graphical environments; but we can’t call it a “window”
here, because Emacs uses that word in a different way.  In Emacs Lisp, a
“frame object” is a Lisp object that represents a frame on the screen.
*Note Frame Type::.

   A frame initially contains a single main window and/or a minibuffer
window; you can subdivide the main window vertically or horizontally
into smaller windows.  *Note Splitting Windows::.

   A “terminal” is a display device capable of displaying one or more
Emacs frames.  In Emacs Lisp, a “terminal object” is a Lisp object that
represents a terminal.  *Note Terminal Type::.

   There are two classes of terminals: “text terminals” and “graphical
terminals”.  Text terminals are non-graphics-capable displays, including
‘xterm’ and other terminal emulators.  On a text terminal, each Emacs
frame occupies the terminal’s entire screen; although you can create
additional frames and switch between them, the terminal only shows one
frame at a time.  Graphical terminals, on the other hand, are managed by
graphical display systems such as the X Window System, which allow Emacs
to show multiple frames simultaneously on the same display.

   On GNU and Unix systems, you can create additional frames on any
available terminal, within a single Emacs session, regardless of whether
Emacs was started on a text or graphical terminal.  Emacs can display on
both graphical and text terminals simultaneously.  This comes in handy,
for instance, when you connect to the same session from several remote
locations.  *Note Multiple Terminals::.

 -- Function: framep object
     This predicate returns a non-‘nil’ value if OBJECT is a frame, and
     ‘nil’ otherwise.  For a frame, the value indicates which kind of
     display the frame uses:

     ‘t’
          The frame is displayed on a text terminal.
     ‘x’
          The frame is displayed on an X graphical terminal.
     ‘w32’
          The frame is displayed on a MS-Windows graphical terminal.
     ‘ns’
          The frame is displayed on a GNUstep or Macintosh Cocoa
          graphical terminal.
     ‘pc’
          The frame is displayed on an MS-DOS terminal.

 -- Function: frame-terminal &optional frame
     This function returns the terminal object that displays FRAME.  If
     FRAME is ‘nil’ or unspecified, it defaults to the selected frame.

 -- Function: terminal-live-p object
     This predicate returns a non-‘nil’ value if OBJECT is a terminal
     that is live (i.e., not deleted), and ‘nil’ otherwise.  For live
     terminals, the return value indicates what kind of frames are
     displayed on that terminal; the list of possible values is the same
     as for ‘framep’ above.

   On a graphical terminal we distinguish two types of frames: A normal
“top-level frame” is a frame whose window-system window is a child of
the window-system’s root window for that terminal.  A child frame is a
frame whose window-system window is the child of the window-system
window of another Emacs frame.  *Note Child Frames::.

* Menu:

* Creating Frames::             Creating additional frames.
* Multiple Terminals::          Displaying on several different devices.
* Frame Geometry::              Geometric properties of frames.
* Frame Parameters::            Controlling frame size, position, font, etc.
* Terminal Parameters::         Parameters common for all frames on terminal.
* Frame Titles::                Automatic updating of frame titles.
* Deleting Frames::             Frames last until explicitly deleted.
* Finding All Frames::          How to examine all existing frames.
* Minibuffers and Frames::      How a frame finds the minibuffer to use.
* Input Focus::                 Specifying the selected frame.
* Visibility of Frames::        Frames may be visible or invisible, or icons.
* Raising and Lowering::        Raising, Lowering and Restacking Frames.
* Frame Configurations::        Saving the state of all frames.
* Child Frames::                Making a frame the child of another.
* Mouse Tracking::              Getting events that say when the mouse moves.
* Mouse Position::              Asking where the mouse is, or moving it.
* Pop-Up Menus::                Displaying a menu for the user to select from.
* Dialog Boxes::                Displaying a box to ask yes or no.
* Pointer Shape::               Specifying the shape of the mouse pointer.
* Window System Selections::    Transferring text to and from other X clients.
* Drag and Drop::               Internals of Drag-and-Drop implementation.
* Color Names::                 Getting the definitions of color names.
* Text Terminal Colors::        Defining colors for text terminals.
* Resources::                   Getting resource values from the server.
* Display Feature Testing::     Determining the features of a terminal.


File: elisp.info,  Node: Creating Frames,  Next: Multiple Terminals,  Up: Frames

29.1 Creating Frames
====================

To create a new frame, call the function ‘make-frame’.

 -- Command: make-frame &optional parameters
     This function creates and returns a new frame, displaying the
     current buffer.

     The PARAMETERS argument is an alist that specifies frame parameters
     for the new frame.  *Note Frame Parameters::.  If you specify the
     ‘terminal’ parameter in PARAMETERS, the new frame is created on
     that terminal.  Otherwise, if you specify the ‘window-system’ frame
     parameter in PARAMETERS, that determines whether the frame should
     be displayed on a text terminal or a graphical terminal.  *Note
     Window Systems::.  If neither is specified, the new frame is
     created in the same terminal as the selected frame.

     Any parameters not mentioned in PARAMETERS default to the values in
     the alist ‘default-frame-alist’ (*note Initial Parameters::);
     parameters not specified there default from the X resources or its
     equivalent on your operating system (*note X Resources: (emacs)X
     Resources.).  After the frame is created, this function applies any
     parameters specified in ‘frame-inherited-parameters’ (see below) it
     has no assigned yet, taking the values from the frame that was
     selected when ‘make-frame’ was called.

     Note that on multi-monitor displays (*note Multiple Terminals::),
     the window manager might position the frame differently than
     specified by the positional parameters in PARAMETERS (*note
     Position Parameters::).  For example, some window managers have a
     policy of displaying the frame on the monitor that contains the
     largest part of the window (a.k.a. the “dominating” monitor).

     This function itself does not make the new frame the selected
     frame.  *Note Input Focus::.  The previously selected frame remains
     selected.  On graphical terminals, however, the windowing system
     may select the new frame for its own reasons.

 -- Variable: before-make-frame-hook
     A normal hook run by ‘make-frame’ before it creates the frame.

 -- Variable: after-make-frame-functions
     An abnormal hook run by ‘make-frame’ after it created the frame.
     Each function in ‘after-make-frame-functions’ receives one
     argument, the frame just created.

   Note that any functions added to these hooks by your initial file are
usually not run for the initial frame, since Emacs reads the initial
file only after creating that frame.  However, if the initial frame is
specified to use a separate minibuffer frame (*note Minibuffers and
Frames::), the functions will be run for both, the minibuffer-less and
the minibuffer frame.

 -- Variable: frame-inherited-parameters
     This variable specifies the list of frame parameters that a newly
     created frame inherits from the currently selected frame.  For each
     parameter (a symbol) that is an element in this list and has not
     been assigned earlier when processing ‘make-frame’, the function
     sets the value of that parameter in the created frame to its value
     in the selected frame.


File: elisp.info,  Node: Multiple Terminals,  Next: Frame Geometry,  Prev: Creating Frames,  Up: Frames

29.2 Multiple Terminals
=======================

Emacs represents each terminal as a “terminal object” data type (*note
Terminal Type::).  On GNU and Unix systems, Emacs can use multiple
terminals simultaneously in each session.  On other systems, it can only
use a single terminal.  Each terminal object has the following
attributes:

   • The name of the device used by the terminal (e.g., ‘:0.0’ or
     ‘/dev/tty’).

   • The terminal and keyboard coding systems used on the terminal.
     *Note Terminal I/O Encoding::.

   • The kind of display associated with the terminal.  This is the
     symbol returned by the function ‘terminal-live-p’ (i.e., ‘x’, ‘t’,
     ‘w32’, ‘ns’, or ‘pc’).  *Note Frames::.

   • A list of terminal parameters.  *Note Terminal Parameters::.

   There is no primitive for creating terminal objects.  Emacs creates
them as needed, such as when you call ‘make-frame-on-display’ (described
below).

 -- Function: terminal-name &optional terminal
     This function returns the file name of the device used by TERMINAL.
     If TERMINAL is omitted or ‘nil’, it defaults to the selected
     frame’s terminal.  TERMINAL can also be a frame, meaning that
     frame’s terminal.

 -- Function: terminal-list
     This function returns a list of all live terminal objects.

 -- Function: get-device-terminal device
     This function returns a terminal whose device name is given by
     DEVICE.  If DEVICE is a string, it can be either the file name of a
     terminal device, or the name of an X display of the form
     ‘HOST:SERVER.SCREEN’.  If DEVICE is a frame, this function returns
     that frame’s terminal; ‘nil’ means the selected frame.  Finally, if
     DEVICE is a terminal object that represents a live terminal, that
     terminal is returned.  The function signals an error if its
     argument is none of the above.

 -- Function: delete-terminal &optional terminal force
     This function deletes all frames on TERMINAL and frees the
     resources used by it.  It runs the abnormal hook
     ‘delete-terminal-functions’, passing TERMINAL as the argument to
     each function.

     If TERMINAL is omitted or ‘nil’, it defaults to the selected
     frame’s terminal.  TERMINAL can also be a frame, meaning that
     frame’s terminal.

     Normally, this function signals an error if you attempt to delete
     the sole active terminal, but if FORCE is non-‘nil’, you are
     allowed to do so.  Emacs automatically calls this function when the
     last frame on a terminal is deleted (*note Deleting Frames::).

 -- Variable: delete-terminal-functions
     An abnormal hook run by ‘delete-terminal’.  Each function receives
     one argument, the TERMINAL argument passed to ‘delete-terminal’.
     Due to technical details, the functions may be called either just
     before the terminal is deleted, or just afterwards.

   A few Lisp variables are “terminal-local”; that is, they have a
separate binding for each terminal.  The binding in effect at any time
is the one for the terminal that the currently selected frame belongs
to.  These variables include ‘default-minibuffer-frame’,
‘defining-kbd-macro’, ‘last-kbd-macro’, and ‘system-key-alist’.  They
are always terminal-local, and can never be buffer-local (*note
Buffer-Local Variables::).

   On GNU and Unix systems, each X display is a separate graphical
terminal.  When Emacs is started from within the X window system, it
uses the X display specified by the ‘DISPLAY’ environment variable, or
by the ‘--display’ option (*note (emacs)Initial Options::).  Emacs can
connect to other X displays via the command ‘make-frame-on-display’.
Each X display has its own selected frame and its own minibuffer
windows; however, only one of those frames is _the_ selected frame at
any given moment (*note Input Focus::).  Emacs can even connect to other
text terminals, by interacting with the ‘emacsclient’ program.  *Note
(emacs)Emacs Server::.

   A single X server can handle more than one display.  Each X display
has a three-part name, ‘HOSTNAME:DISPLAYNUMBER.SCREENNUMBER’.  The first
part, HOSTNAME, specifies the name of the machine to which the display
is physically connected.  The second part, DISPLAYNUMBER, is a
zero-based number that identifies one or more monitors connected to that
machine that share a common keyboard and pointing device (mouse, tablet,
etc.).  The third part, SCREENNUMBER, identifies a zero-based screen
number (a separate monitor) that is part of a single monitor collection
on that X server.  When you use two or more screens belonging to one
server, Emacs knows by the similarity in their names that they share a
single keyboard.

   Systems that don’t use the X window system, such as MS-Windows, don’t
support the notion of X displays, and have only one display on each
host.  The display name on these systems doesn’t follow the above 3-part
format; for example, the display name on MS-Windows systems is a
constant string ‘w32’, and exists for compatibility, so that you could
pass it to functions that expect a display name.

 -- Command: make-frame-on-display display &optional parameters
     This function creates and returns a new frame on DISPLAY, taking
     the other frame parameters from the alist PARAMETERS.  DISPLAY
     should be the name of an X display (a string).

     Before creating the frame, this function ensures that Emacs is set
     up to display graphics.  For instance, if Emacs has not processed X
     resources (e.g., if it was started on a text terminal), it does so
     at this time.  In all other respects, this function behaves like
     ‘make-frame’ (*note Creating Frames::).

 -- Function: x-display-list
     This function returns a list that indicates which X displays Emacs
     has a connection to.  The elements of the list are strings, and
     each one is a display name.

 -- Function: x-open-connection display &optional xrm-string
          must-succeed
     This function opens a connection to the X display DISPLAY, without
     creating a frame on that display.  Normally, Emacs Lisp programs
     need not call this function, as ‘make-frame-on-display’ calls it
     automatically.  The only reason for calling it is to check whether
     communication can be established with a given X display.

     The optional argument XRM-STRING, if not ‘nil’, is a string of
     resource names and values, in the same format used in the
     ‘.Xresources’ file.  *Note X Resources: (emacs)X Resources.  These
     values apply to all Emacs frames created on this display,
     overriding the resource values recorded in the X server.  Here’s an
     example of what this string might look like:

          "*BorderWidth: 3\n*InternalBorder: 2\n"

     If MUST-SUCCEED is non-‘nil’, failure to open the connection
     terminates Emacs.  Otherwise, it is an ordinary Lisp error.

 -- Function: x-close-connection display
     This function closes the connection to display DISPLAY.  Before you
     can do this, you must first delete all the frames that were open on
     that display (*note Deleting Frames::).

   On some multi-monitor setups, a single X display outputs to more than
one physical monitor.  You can use the functions
‘display-monitor-attributes-list’ and ‘frame-monitor-attributes’ to
obtain information about such setups.

 -- Function: display-monitor-attributes-list &optional display
     This function returns a list of physical monitor attributes on
     DISPLAY, which can be a display name (a string), a terminal, or a
     frame; if omitted or ‘nil’, it defaults to the selected frame’s
     display.  Each element of the list is an association list,
     representing the attributes of a physical monitor.  The first
     element corresponds to the primary monitor.  The attribute keys and
     values are:

     ‘geometry’
          Position of the top-left corner of the monitor’s screen and
          its size, in pixels, as ‘(X Y WIDTH HEIGHT)’.  Note that, if
          the monitor is not the primary monitor, some of the
          coordinates might be negative.

     ‘workarea’
          Position of the top-left corner and size of the work area
          (usable space) in pixels as ‘(X Y WIDTH HEIGHT)’.  This may be
          different from ‘geometry’ in that space occupied by various
          window manager features (docks, taskbars, etc.) may be
          excluded from the work area.  Whether or not such features
          actually subtract from the work area depends on the platform
          and environment.  Again, if the monitor is not the primary
          monitor, some of the coordinates might be negative.

     ‘mm-size’
          Width and height in millimeters as ‘(WIDTH HEIGHT)’

     ‘frames’
          List of frames that this physical monitor dominates (see
          below).

     ‘name’
          Name of the physical monitor as STRING.

     ‘source’
          Source of the multi-monitor information as STRING; e.g.,
          ‘XRandr’ or ‘Xinerama’.

     X, Y, WIDTH, and HEIGHT are integers.  ‘name’ and ‘source’ may be
     absent.

     A frame is “dominated” by a physical monitor when either the
     largest area of the frame resides in that monitor, or (if the frame
     does not intersect any physical monitors) that monitor is the
     closest to the frame.  Every (non-tooltip) frame (whether visible
     or not) in a graphical display is dominated by exactly one physical
     monitor at a time, though the frame can span multiple (or no)
     physical monitors.

     Here’s an example of the data produced by this function on a
     2-monitor display:

            (display-monitor-attributes-list)
            ⇒
            (((geometry 0 0 1920 1080) ;; Left-hand, primary monitor
              (workarea 0 0 1920 1050) ;; A taskbar occupies some of the height
              (mm-size 677 381)
              (name . "DISPLAY1")
              (frames #<frame emacs@host *Messages* 0x11578c0>
                      #<frame emacs@host *scratch* 0x114b838>))
             ((geometry 1920 0 1680 1050) ;; Right-hand monitor
              (workarea 1920 0 1680 1050) ;; Whole screen can be used
              (mm-size 593 370)
              (name . "DISPLAY2")
              (frames)))

 -- Function: frame-monitor-attributes &optional frame
     This function returns the attributes of the physical monitor
     dominating (see above) FRAME, which defaults to the selected frame.


File: elisp.info,  Node: Frame Geometry,  Next: Frame Parameters,  Prev: Multiple Terminals,  Up: Frames

29.3 Frame Geometry
===================

The geometry of a frame depends on the toolkit that was used to build
this instance of Emacs and the terminal that displays the frame.  This
chapter describes these dependencies and some of the functions to deal
with them.  Note that the FRAME argument of all of these functions has
to specify a live frame (*note Deleting Frames::).  If omitted or ‘nil’,
it specifies the selected frame (*note Input Focus::).

* Menu:

* Frame Layout::            Basic layout of frames.
* Frame Font::              The default font of a frame and how to set it.
* Frame Position::          The position of a frame on its display.
* Frame Size::              Specifying and retrieving a frame’s size.
* Implied Frame Resizing::  Implied resizing of frames and how to prevent it.


File: elisp.info,  Node: Frame Layout,  Next: Frame Font,  Up: Frame Geometry

29.3.1 Frame Layout
-------------------

A visible frame occupies a rectangular area on its terminal’s display.
This area may contain a number of nested rectangles, each serving a
different purpose.  The drawing below sketches the layout of a frame on
a graphical terminal:

             <------------ Outer Frame Width ----------->
             ____________________________________________
          ^(0)  ________ External/Outer Border _______   |
          | |  |_____________ Title Bar ______________|  |
          | | (1)_____________ Menu Bar ______________|  | ^
          | | (2)_____________ Tool Bar ______________|  | ^
          | | (3) _________ Internal Border ________  |  | ^
          | |  | |   ^                              | |  | |
          | |  | |   |                              | |  | |
     Outer  |  | | Inner                            | |  | Native
     Frame  |  | | Frame                            | |  | Frame
     Height |  | | Height                           | |  | Height
          | |  | |   |                              | |  | |
          | |  | |<--+--- Inner Frame Width ------->| |  | |
          | |  | |   |                              | |  | |
          | |  | |___v______________________________| |  | |
          | |  |___________ Internal Border __________|  | v
          v |___________ External/Outer Border __________|
                <-------- Native Frame Width -------->


   In practice not all of the areas shown in the drawing will or may be
present.  The meaning of these areas is described below.

‘Outer Frame’
     The “outer frame” is a rectangle comprising all areas shown in the
     drawing.  The edges of that rectangle are called the “outer edges”
     of the frame.  Together, the “outer width” and “outer height” of
     the frame specify the “outer size” of that rectangle.

     Knowing the outer size of a frame is useful for fitting a frame
     into the working area of its display (*note Multiple Terminals::)
     or for placing two frames adjacent to each other on the screen.
     Usually, the outer size of a frame is available only after the
     frame has been mapped (made visible, *note Visibility of Frames::)
     at least once.  For the initial frame or a frame that has not been
     created yet, the outer size can be only estimated or must be
     calculated from the window-system’s or window manager’s defaults.
     One workaround is to obtain the differences of the outer and native
     (see below) sizes of a mapped frame and use them for calculating
     the outer size of the new frame.

     The position of the upper left corner of the outer frame (indicated
     by ‘(0)’ in the drawing above) is the “outer position” of the
     frame.  The outer position of a graphical frame is also referred to
     as “the position” of the frame because it usually remains unchanged
     on its display whenever the frame is resized or its layout is
     changed.

     The outer position is specified by and can be set via the ‘left’
     and ‘top’ frame parameters (*note Position Parameters::).  For a
     normal, top-level frame these parameters usually represent its
     absolute position (see below) with respect to its display’s origin.
     For a child frame (*note Child Frames::) these parameters represent
     its position relative to the native position (see below) of its
     parent frame.  For frames on text terminals the values of these
     parameters are meaningless and always zero.

‘External Border’
     The “external border” is part of the decorations supplied by the
     window manager.  It is typically used for resizing the frame with
     the mouse and is therefore not shown on “fullboth” and maximized
     frames (*note Size Parameters::).  Its width is determined by the
     window manager and cannot be changed by Emacs’ functions.

     External borders don’t exist on text terminal frames.  For
     graphical frames, their display can be suppressed by setting the
     ‘override-redirect’ or ‘undecorated’ frame parameter (*note
     Management Parameters::).

‘Outer Border’
     The “outer border” is a separate border whose width can be
     specified with the ‘border-width’ frame parameter (*note Layout
     Parameters::).  In practice, either the external or the outer
     border of a frame are displayed but never both at the same time.
     Usually, the outer border is shown only for special frames that are
     not (fully) controlled by the window manager like tooltip frames
     (*note Tooltips::), child frames (*note Child Frames::) and
     ‘undecorated’ or ‘override-redirect’ frames (*note Management
     Parameters::).

     Outer borders are never shown on text terminal frames and on frames
     generated by GTK+ routines.  On MS-Windows, the outer border is
     emulated with the help of a one pixel wide external border.
     Non-toolkit builds on X allow to change the color of the outer
     border by setting the ‘border-color’ frame parameter (*note Layout
     Parameters::).

‘Title Bar’
     The “title bar”, a.k.a. “caption bar”, is also part of the window
     manager’s decorations and typically displays the title of the frame
     (*note Frame Titles::) as well as buttons for minimizing,
     maximizing and deleting the frame.  It can be also used for
     dragging the frame with the mouse.  The title bar is usually not
     displayed for fullboth (*note Size Parameters::), tooltip (*note
     Tooltips::) and child frames (*note Child Frames::) and doesn’t
     exist for terminal frames.  Display of the title bar can be
     suppressed by setting the ‘override-redirect’ or the ‘undecorated’
     frame parameters (*note Management Parameters::).

‘Menu Bar’
     The menu bar (*note Menu Bar::) can be either internal (drawn by
     Emacs itself) or external (drawn by the toolkit).  Most builds
     (GTK+, Lucid, Motif and MS-Windows) rely on an external menu bar.
     NS also uses an external menu bar which, however, is not part of
     the outer frame.  Non-toolkit builds can provide an internal menu
     bar.  On text terminal frames, the menu bar is part of the frame’s
     root window (*note Windows and Frames::).  As a rule, menu bars are
     never shown on child frames (*note Child Frames::).  Display of the
     menu bar can be suppressed by setting the ‘menu-bar-lines’
     parameter (*note Layout Parameters::) to zero.

     Whether the menu bar is wrapped or truncated whenever its width
     becomes too large to fit on its frame depends on the toolkit .
     Usually, only Motif and MS-Windows builds can wrap the menu bar.
     When they (un-)wrap the menu bar, they try to keep the outer height
     of the frame unchanged, so the native height of the frame (see
     below) will change instead.

‘Tool Bar’
     Like the menu bar, the tool bar (*note Tool Bar::) can be either
     internal (drawn by Emacs itself) or external (drawn by a toolkit).
     The GTK+ and NS builds have the tool bar drawn by the toolkit.  The
     remaining builds use internal tool bars.  With GTK+ the tool bar
     can be located on either side of the frame, immediately outside the
     internal border, see below.  Tool bars are usually not shown for
     child frames (*note Child Frames::).  Display of the tool bar can
     be suppressed by setting the ‘tool-bar-lines’ parameter (*note
     Layout Parameters::) to zero.

     If the variable ‘auto-resize-tool-bars’ is non-‘nil’, Emacs wraps
     the internal tool bar when its width becomes too large for its
     frame.  If and when Emacs (un-)wraps the internal tool bar, it by
     default keeps the outer height of the frame unchanged, so the
     native height of the frame (see below) will change instead.  Emacs
     built with GTK+, on the other hand, never wraps the tool bar but
     may automatically increase the outer width of a frame in order to
     accommodate an overlong tool bar.

‘Native Frame’
     The “native frame” is a rectangle located entirely within the outer
     frame.  It excludes the areas occupied by an external or outer
     border, the title bar and any external menu or tool bar.  The edges
     of the native frame are called the “native edges” of the frame.
     Together, the “native width” and “native height” of a frame specify
     the “native size” of the frame.

     The native size of a frame is the size Emacs passes to the
     window-system or window manager when creating or resizing the frame
     from within Emacs.  It is also the size Emacs receives from the
     window-system or window manager whenever these resize the frame’s
     window-system window, for example, after maximizing the frame by
     clicking on the corresponding button in the title bar or when
     dragging its external border with the mouse.

     The position of the top left corner of the native frame specifies
     the “native position” of the frame.  (1)–(3) in the drawing above
     indicate that position for the various builds:

          (1) non-toolkit and terminal frames

          (2) Lucid, Motif and MS-Windows frames

          (3) GTK+ and NS frames

     Accordingly, the native height of a frame may include the height of
     the tool bar but not that of the menu bar (Lucid, Motif,
     MS-Windows) or those of the menu bar and the tool bar (non-toolkit
     and text terminal frames).

     The native position of a frame is the reference position for
     functions that set or return the current position of the mouse
     (*note Mouse Position::) and for functions dealing with the
     position of windows like ‘window-edges’, ‘window-at’ or
     ‘coordinates-in-window-p’ (*note Coordinates and Windows::).  It
     also specifies the (0, 0) origin for locating and positioning child
     frames within this frame (*note Child Frames::).

     Note also that the native position of a frame usually remains
     unaltered on its display when removing or adding the window manager
     decorations by changing the frame’s ‘override-redirect’ or
     ‘undecorated’ parameter (*note Management Parameters::).

‘Internal Border’
     The internal border is a border drawn by Emacs around the inner
     frame (see below).  Its width is specified by the
     ‘internal-border-width’ frame parameter (*note Layout
     Parameters::).  Its color is specified by the background of the
     ‘internal-border’ face.

‘Inner Frame’
     The “inner frame” is the rectangle reserved for the frame’s
     windows.  It’s enclosed by the internal border which, however, is
     not part of the inner frame.  Its edges are called the “inner
     edges” of the frame.  The “inner width” and “inner height” specify
     the “inner size” of the rectangle.  The inner frame is sometimes
     also referred to as the “display area” of the frame.

     As a rule, the inner frame is subdivided into the frame’s root
     window (*note Windows and Frames::) and the frame’s minibuffer
     window (*note Minibuffer Windows::).  There are two notable
     exceptions to this rule: A “minibuffer-less frame” contains a root
     window only and does not contain a minibuffer window.  A
     “minibuffer-only frame” contains only a minibuffer window which
     also serves as that frame’s root window.  See *note Initial
     Parameters:: for how to create such frame configurations.

‘Text Area’
     The “text area” of a frame is a somewhat fictitious area that can
     be embedded in the native frame.  Its position is unspecified.  Its
     width can be obtained by removing from that of the native width the
     widths of the internal border, one vertical scroll bar, and one
     left and one right fringe if they are specified for this frame, see
     *note Layout Parameters::.  Its height can be obtained by removing
     from that of the native height the widths of the internal border
     and the heights of the frame’s internal menu and tool bars and one
     horizontal scroll bar if specified for this frame.

   The “absolute position” of a frame is given as a pair (X, Y) of
horizontal and vertical pixel offsets relative to an origin (0, 0) of
the frame’s display.  Correspondingly, the “absolute edges” of a frame
are given as pixel offsets from that origin.

   Note that with multiple monitors, the origin of the display does not
necessarily coincide with the top-left corner of the entire usable
display area of the terminal.  Hence the absolute position of a frame
can be negative in such an environment even when that frame is
completely visible.

   By convention, vertical offsets increase “downwards”.  This means
that the height of a frame is obtained by subtracting the offset of its
top edge from that of its bottom edge.  Horizontal offsets increase
“rightwards”, as expected, so a frame’s width is calculated by
subtracting the offset of its left edge from that of its right edge.

   For a frame on a graphical terminal the following function returns
the sizes of the areas described above:

 -- Function: frame-geometry &optional frame
     This function returns geometric attributes of FRAME.  The return
     value is an association list of the attributes listed below.  All
     coordinate, height and width values are integers counting pixels.
     Note that if FRAME has not been mapped yet, (*note Visibility of
     Frames::) some of the return values may only represent
     approximations of the actual values—those that can be seen after
     the frame has been mapped.

     ‘outer-position’
          A cons representing the absolute position of the outer FRAME,
          relative to the origin at position (0, 0) of FRAME’s display.

     ‘outer-size’
          A cons of the outer width and height of FRAME.

     ‘external-border-size’
          A cons of the horizontal and vertical width of FRAME’s
          external borders as supplied by the window manager.  If the
          window manager doesn’t supply these values, Emacs will try to
          guess them from the coordinates of the outer and inner frame.

     ‘outer-border-width’
          The width of the outer border of FRAME.  The value is
          meaningful for non-GTK+ X builds only.

     ‘title-bar-size’
          A cons of the width and height of the title bar of FRAME as
          supplied by the window manager or operating system.  If both
          of them are zero, the frame has no title bar.  If only the
          width is zero, Emacs was not able to retrieve the width
          information.

     ‘menu-bar-external’
          If non-‘nil’, this means the menu bar is external (not part of
          the native frame of FRAME).

     ‘menu-bar-size’
          A cons of the width and height of the menu bar of FRAME.

     ‘tool-bar-external’
          If non-‘nil’, this means the tool bar is external (not part of
          the native frame of FRAME).

     ‘tool-bar-position’
          This tells on which side the tool bar on FRAME is and can be
          one of ‘left’, ‘top’, ‘right’ or ‘bottom’.  The only toolkit
          that currently supports a value other than ‘top’ is GTK+.

     ‘tool-bar-size’
          A cons of the width and height of the tool bar of FRAME.

     ‘internal-border-width’
          The width of the internal border of FRAME.

   The following function can be used to retrieve the edges of the
outer, native and inner frame.

 -- Function: frame-edges &optional frame type
     This function returns the absolute edges of the outer, native or
     inner frame of FRAME.  FRAME must be a live frame and defaults to
     the selected one.  The returned list has the form
     ‘(LEFT TOP RIGHT BOTTOM)’ where all values are in pixels relative
     to the origin of FRAME’s display.  For terminal frames the values
     returned for LEFT and TOP are always zero.

     Optional argument TYPE specifies the type of the edges to return:
     ‘outer-edges’ means to return the outer edges of FRAME,
     ‘native-edges’ (or ‘nil’) means to return its native edges and
     ‘inner-edges’ means to return its inner edges.

     By convention, the pixels of the display at the values returned for
     LEFT and TOP are considered to be inside (part of) FRAME.  Hence,
     if LEFT and TOP are both zero, the pixel at the display’s origin is
     part of FRAME.  The pixels at BOTTOM and RIGHT, on the other hand,
     are considered to lie immediately outside FRAME.  This means that
     if you have, for example, two side-by-side frames positioned such
     that the right outer edge of the frame on the left equals the left
     outer edge of the frame on the right, the pixels at that edge show
     a part of the frame on the right.


File: elisp.info,  Node: Frame Font,  Next: Frame Position,  Prev: Frame Layout,  Up: Frame Geometry

29.3.2 Frame Font
-----------------

Each frame has a “default font” which specifies the default character
size for that frame.  This size is meant when retrieving or changing the
size of a frame in terms of columns or lines (*note Size Parameters::).
It is also used when resizing (*note Window Sizes::) or splitting (*note
Splitting Windows::) windows.

   The terms “line height” and “canonical character height” are
sometimes used instead of “default character height”.  Similarly, the
terms “column width” and “canonical character width” are used instead of
“default character width”.

 -- Function: frame-char-height &optional frame
 -- Function: frame-char-width &optional frame
     These functions return the default height and width of a character
     in FRAME, measured in pixels.  Together, these values establish the
     size of the default font on FRAME.  The values depend on the choice
     of font for FRAME, see *note Font and Color Parameters::.

   The default font can be also set directly with the following
function:

 -- Command: set-frame-font font &optional keep-size frames
     This sets the default font to FONT.  When called interactively, it
     prompts for the name of a font, and uses that font on the selected
     frame.  When called from Lisp, FONT should be a font name (a
     string), a font object, font entity, or a font spec.

     If the optional argument KEEP-SIZE is ‘nil’, this keeps the number
     of frame lines and columns fixed.  (If non-‘nil’, the option
     ‘frame-inhibit-implied-resize’ described in the next section will
     override this.)  If KEEP-SIZE is non-‘nil’ (or with a prefix
     argument), it tries to keep the size of the display area of the
     current frame fixed by adjusting the number of lines and columns.

     If the optional argument FRAMES is ‘nil’, this applies the font to
     the selected frame only.  If FRAMES is non-‘nil’, it should be a
     list of frames to act upon, or ‘t’ meaning all existing and all
     future graphical frames.


File: elisp.info,  Node: Frame Position,  Next: Frame Size,  Prev: Frame Font,  Up: Frame Geometry

29.3.3 Frame Position
---------------------

On graphical systems, the position of a normal top-level frame is
specified as the absolute position of its outer frame (*note Frame
Geometry::).  The position of a child frame (*note Child Frames::) is
specified via pixel offsets of its outer edges relative to the native
position of its parent frame.

   You can access or change the position of a frame using the frame
parameters ‘left’ and ‘top’ (*note Position Parameters::).  Here are two
additional functions for working with the positions of an existing,
visible frame.  For both functions, the argument FRAME must denote a
live frame and defaults to the selected frame.

 -- Function: frame-position &optional frame
     For a normal, non-child frame this function returns a cons of the
     pixel coordinates of its outer position (*note Frame Layout::) with
     respect to the origin ‘(0, 0)’ of its display.  For a child frame
     (*note Child Frames::) this function returns the pixel coordinates
     of its outer position with respect to an origin ‘(0, 0)’ at the
     native position of FRAME’s parent.

     Negative values never indicate an offset from the right or bottom
     edge of FRAME’s display or parent frame.  Rather, they mean that
     FRAME’s outer position is on the left and/or above the origin of
     its display or the native position of its parent frame.  This
     usually means that FRAME is only partially visible (or completely
     invisible).  However, on systems where the display’s origin does
     not coincide with its top-left corner, the frame may be visible on
     a secondary monitor.

     On a text terminal frame both values are zero.

 -- Function: set-frame-position frame x y
     This function sets the outer frame position of FRAME to (X, Y).
     The latter arguments specify pixels and normally count from the
     origin at the position (0, 0) of FRAME’s display.  For child
     frames, they count from the native position of FRAME’s parent
     frame.

     Negative parameter values position the right edge of the outer
     frame by -X pixels left from the right edge of the screen (or the
     parent frame’s native rectangle) and the bottom edge by -Y pixels
     up from the bottom edge of the screen (or the parent frame’s native
     rectangle).

     Note that negative values do not permit to align the right or
     bottom edge of FRAME exactly at the right or bottom edge of its
     display or parent frame.  Neither do they allow to specify a
     position that does not lie within the edges of the display or
     parent frame.  The frame parameters ‘left’ and ‘top’ (*note
     Position Parameters::) allow to do that, but may still fail to
     provide good results for the initial or a new frame.

     This function has no effect on text terminal frames.

 -- Variable: move-frame-functions
     This hook specifies the functions that are run when an Emacs frame
     is moved (assigned a new position) by the window-system or window
     manager.  The functions are run with one argument, the frame that
     moved.  For a child frame (*note Child Frames::), the functions are
     run only when the position of the frame changes in relation to that
     of its parent frame.


File: elisp.info,  Node: Frame Size,  Next: Implied Frame Resizing,  Prev: Frame Position,  Up: Frame Geometry

29.3.4 Frame Size
-----------------

The canonical way to specify the “size of a frame” from within Emacs is
by specifying its “text size”—a tuple of the width and height of the
frame’s text area (*note Frame Layout::).  It can be measured either in
pixels or in terms of the frame’s canonical character size (*note Frame
Font::).

   For frames with an internal menu or tool bar, the frame’s native
height cannot be told exactly before the frame has been actually drawn.
This means that in general you cannot use the native size to specify the
initial size of a frame.  As soon as you know the native size of a
visible frame, you can calculate its outer size (*note Frame Layout::)
by adding in the remaining components from the return value of
‘frame-geometry’.  For invisible frames or for frames that have yet to
be created, however, the outer size can only be estimated.  This also
means that calculating an exact initial position of a frame specified
via offsets from the right or bottom edge of the screen (*note Frame
Position::) is impossible.

   The text size of any frame can be set and retrieved with the help of
the ‘height’ and ‘width’ frame parameters (*note Size Parameters::).
The text size of the initial frame can be also set with the help of an
X-style geometry specification.  *Note Command Line Arguments for Emacs
Invocation: (emacs)Emacs Invocation.  Below we list some functions to
access and set the size of an existing, visible frame, by default the
selected one.

 -- Function: frame-height &optional frame
 -- Function: frame-width &optional frame
     These functions return the height and width of the text area of
     FRAME, measured in units of the default font height and width of
     FRAME (*note Frame Font::).  These functions are plain shorthands
     for writing ‘(frame-parameter frame 'height)’ and ‘(frame-parameter
     frame 'width)’.

     If the text area of FRAME measured in pixels is not a multiple of
     its default font size, the values returned by these functions are
     rounded down to the number of characters of the default font that
     fully fit into the text area.

   The functions following next return the pixel widths and heights of
the native, outer and inner frame and the text area (*note Frame
Layout::) of a given frame.  For a text terminal, the results are in
characters rather than pixels.

 -- Function: frame-outer-width &optional frame
 -- Function: frame-outer-height &optional frame
     These functions return the outer width and height of FRAME in
     pixels.

 -- Function: frame-native-height &optional frame
 -- Function: frame-native-width &optional frame
     These functions return the native width and height of FRAME in
     pixels.

 -- Function: frame-inner-width &optional frame
 -- Function: frame-inner-height &optional frame
     These functions return the inner width and height of FRAME in
     pixels.

 -- Function: frame-text-width &optional frame
 -- Function: frame-text-height &optional frame
     These functions return the width and height of the text area of
     FRAME in pixels.

   On window systems that support it, Emacs tries by default to make the
text size of a frame measured in pixels a multiple of the frame’s
character size.  This, however, usually means that a frame can be
resized only in character size increments when dragging its external
borders.  It also may break attempts to truly maximize the frame or
making it “fullheight” or “fullwidth” (*note Size Parameters::) leaving
some empty space below and/or on the right of the frame.  The following
option may help in that case.

 -- User Option: frame-resize-pixelwise
     If this option is ‘nil’ (the default), a frame’s text pixel size is
     usually rounded to a multiple of the current values of that frame’s
     ‘frame-char-height’ and ‘frame-char-width’ whenever the frame is
     resized.  If this is non-‘nil’, no rounding occurs, hence frame
     sizes can increase/decrease by one pixel.

     Setting this variable usually causes the next resize operation to
     pass the corresponding size hints to the window manager.  This
     means that this variable should be set only in a user’s initial
     file; applications should never bind it temporarily.

     The precise meaning of a value of ‘nil’ for this option depends on
     the toolkit used.  Dragging the external border with the mouse is
     done character-wise provided the window manager is willing to
     process the corresponding size hints.  Calling ‘set-frame-size’
     (see below) with arguments that do not specify the frame size as an
     integer multiple of its character size, however, may: be ignored,
     cause a rounding (GTK+), or be accepted (Lucid, Motif, MS-Windows).

     With some window managers you may have to set this to non-‘nil’ in
     order to make a frame appear truly maximized or full-screen.

 -- Function: set-frame-size frame width height &optional pixelwise
     This function sets the size of the text area of FRAME, measured in
     terms of the canonical height and width of a character on FRAME
     (*note Frame Font::).

     The optional argument PIXELWISE non-‘nil’ means to measure the new
     width and height in units of pixels instead.  Note that if
     ‘frame-resize-pixelwise’ is ‘nil’, some toolkits may refuse to
     truly honor the request if it does not increase/decrease the frame
     size to a multiple of its character size.

 -- Function: set-frame-height frame height &optional pretend pixelwise
     This function resizes the text area of FRAME to a height of HEIGHT
     lines.  The sizes of existing windows in FRAME are altered
     proportionally to fit.

     If PRETEND is non-‘nil’, then Emacs displays HEIGHT lines of output
     in FRAME, but does not change its value for the actual height of
     the frame.  This is only useful on text terminals.  Using a smaller
     height than the terminal actually implements may be useful to
     reproduce behavior observed on a smaller screen, or if the terminal
     malfunctions when using its whole screen.  Setting the frame height
     directly does not always work, because knowing the correct actual
     size may be necessary for correct cursor positioning on text
     terminals.

     The optional fourth argument PIXELWISE non-‘nil’ means that FRAME
     should be HEIGHT pixels high.  Note that if
     ‘frame-resize-pixelwise’ is ‘nil’, some window managers may refuse
     to truly honor the request if it does not increase/decrease the
     frame height to a multiple of its character height.

 -- Function: set-frame-width frame width &optional pretend pixelwise
     This function sets the width of the text area of FRAME, measured in
     characters.  The argument PRETEND has the same meaning as in
     ‘set-frame-height’.

     The optional fourth argument PIXELWISE non-‘nil’ means that FRAME
     should be WIDTH pixels wide.  Note that if ‘frame-resize-pixelwise’
     is ‘nil’, some window managers may refuse to fully honor the
     request if it does not increase/decrease the frame width to a
     multiple of its character width.

   None of these three functions will make a frame smaller than needed
to display all of its windows together with their scroll bars, fringes,
margins, dividers, mode and header lines.  This contrasts with requests
by the window manager triggered, for example, by dragging the external
border of a frame with the mouse.  Such requests are always honored by
clipping, if necessary, portions that cannot be displayed at the right,
bottom corner of the frame.  The parameters ‘min-width’ and ‘min-height’
(*note Size Parameters::) can be used to obtain a similar behavior when
changing the frame size from within Emacs.

   The abnormal hook ‘window-size-change-functions’ (*note Window
Hooks::) tracks all changes of the inner size of a frame including those
induced by request of the window-system or window manager.  To rule out
false positives that might occur when changing only the sizes of a
frame’s windows without actually changing the size of the inner frame,
use the following function.

 -- Function: frame-size-changed-p &optional frame
     This function returns non-‘nil’ when the inner width or height of
     FRAME has changed since ‘window-size-change-functions’ was run the
     last time for FRAME.  It always returns ‘nil’ immediately after
     running ‘window-size-change-functions’ for FRAME.


File: elisp.info,  Node: Implied Frame Resizing,  Prev: Frame Size,  Up: Frame Geometry

29.3.5 Implied Frame Resizing
-----------------------------

By default, Emacs tries to keep the number of lines and columns of a
frame’s text area unaltered when, for example, adding or removing the
menu bar, changing the default font or setting the width of the frame’s
scroll bars.  This means, however, that in such case Emacs must ask the
window manager to resize the outer frame in order to accommodate the
size change.  Note that wrapping a menu or tool bar usually does not
resize the frame’s outer size, hence this will alter the number of
displayed lines.

   Occasionally, such “implied frame resizing” may be unwanted, for
example, when the frame is maximized or made full-screen (where it’s
turned off by default).  In other cases you can disable implied resizing
with the following option:

 -- User Option: frame-inhibit-implied-resize
     If this option is ‘nil’, changing font, menu bar, tool bar,
     internal borders, fringes or scroll bars of a specific frame may
     implicitly resize the frame’s display area in order to preserve the
     number of columns or lines the frame displays.  If this option is
     non-‘nil’, no implied resizing is done.

     The value of this option can be also a list of frame parameters.
     In that case, implied resizing is inhibited when changing a
     parameter that appears in this list.  The frame parameters
     currently handled by this option are: ‘font’, ‘font-backend’,
     ‘internal-border-width’, ‘menu-bar-lines’ and ‘tool-bar-lines’.

     Changing any of the ‘scroll-bar-width’, ‘scroll-bar-height’,
     ‘vertical-scroll-bars’, ‘horizontal-scroll-bars’, ‘left-fringe’ and
     ‘right-fringe’ frame parameters is handled as if the frame
     contained just one live window.  This means, for example, that
     removing vertical scroll bars on a frame containing several side by
     side windows will shrink the outer frame width by the width of one
     scroll bar provided this option is ‘nil’ and keep it unchanged if
     this option is either ‘t’ or a list containing
     ‘vertical-scroll-bars’.

     The default value is ‘'(tool-bar-lines)’ for Lucid, Motif and
     MS-Windows (which means that adding/removing a tool bar there does
     not change the outer frame height), ‘nil’ on all other window
     systems including GTK+ (which means that changing any of the
     parameters listed above may change the size of the outer frame),
     and ‘t’ otherwise (which means the outer frame size never changes
     implicitly when there’s no window system support).

     Note that when a frame is not large enough to accommodate a change
     of any of the parameters listed above, Emacs may try to enlarge the
     frame even if this option is non-‘nil’.


File: elisp.info,  Node: Frame Parameters,  Next: Terminal Parameters,  Prev: Frame Geometry,  Up: Frames

29.4 Frame Parameters
=====================

A frame has many parameters that control its appearance and behavior.
Just what parameters a frame has depends on what display mechanism it
uses.

   Frame parameters exist mostly for the sake of graphical displays.
Most frame parameters have no effect when applied to a frame on a text
terminal; only the ‘height’, ‘width’, ‘name’, ‘title’, ‘menu-bar-lines’,
‘buffer-list’ and ‘buffer-predicate’ parameters do something special.
If the terminal supports colors, the parameters ‘foreground-color’,
‘background-color’, ‘background-mode’ and ‘display-type’ are also
meaningful.  If the terminal supports frame transparency, the parameter
‘alpha’ is also meaningful.

   By default, frame parameters are saved and restored by the desktop
library functions (*note Desktop Save Mode::) when the variable
‘desktop-restore-frames’ is non-‘nil’.  It’s the responsibility of
applications that their parameters are included in
‘frameset-persistent-filter-alist’ to avoid that they get meaningless or
even harmful values in restored sessions.

* Menu:

* Parameter Access::       How to change a frame’s parameters.
* Initial Parameters::     Specifying frame parameters when you make a frame.
* Window Frame Parameters:: List of frame parameters for window systems.
* Geometry::               Parsing geometry specifications.


File: elisp.info,  Node: Parameter Access,  Next: Initial Parameters,  Up: Frame Parameters

29.4.1 Access to Frame Parameters
---------------------------------

These functions let you read and change the parameter values of a frame.

 -- Function: frame-parameter frame parameter
     This function returns the value of the parameter PARAMETER (a
     symbol) of FRAME.  If FRAME is ‘nil’, it returns the selected
     frame’s parameter.  If FRAME has no setting for PARAMETER, this
     function returns ‘nil’.

 -- Function: frame-parameters &optional frame
     The function ‘frame-parameters’ returns an alist listing all the
     parameters of FRAME and their values.  If FRAME is ‘nil’ or
     omitted, this returns the selected frame’s parameters

 -- Function: modify-frame-parameters frame alist
     This function alters the frame FRAME based on the elements of
     ALIST.  Each element of ALIST has the form ‘(PARM . VALUE)’, where
     PARM is a symbol naming a parameter.  If you don’t mention a
     parameter in ALIST, its value doesn’t change.  If FRAME is ‘nil’,
     it defaults to the selected frame.

     Some parameters are only meaningful for frames on certain kinds of
     display (*note Frames::).  If ALIST includes parameters that are
     not meaningful for the FRAME’s display, this function will change
     its value in the frame’s parameter list, but will otherwise ignore
     it.

     When ALIST specifies more than one parameter whose value can affect
     the new size of FRAME, the final size of the frame may differ
     according to the toolkit used.  For example, specifying that a
     frame should from now on have a menu and/or tool bar instead of
     none and simultaneously specifying the new height of the frame will
     inevitably lead to a recalculation of the frame’s height.
     Conceptually, in such case, this function will try to have the
     explicit height specification prevail.  It cannot be excluded,
     however, that the addition (or removal) of the menu or tool bar,
     when eventually performed by the toolkit, will defeat this
     intention.

     Sometimes, binding ‘frame-inhibit-implied-resize’ (*note Implied
     Frame Resizing::) to a non-‘nil’ value around calls to this
     function may fix the problem sketched here.  Sometimes, however,
     exactly such binding may be hit by the problem.

 -- Function: set-frame-parameter frame parm value
     This function sets the frame parameter PARM to the specified VALUE.
     If FRAME is ‘nil’, it defaults to the selected frame.

 -- Function: modify-all-frames-parameters alist
     This function alters the frame parameters of all existing frames
     according to ALIST, then modifies ‘default-frame-alist’ (and, if
     necessary, ‘initial-frame-alist’) to apply the same parameter
     values to frames that will be created henceforth.


File: elisp.info,  Node: Initial Parameters,  Next: Window Frame Parameters,  Prev: Parameter Access,  Up: Frame Parameters

29.4.2 Initial Frame Parameters
-------------------------------

You can specify the parameters for the initial startup frame by setting
‘initial-frame-alist’ in your init file (*note Init File::).

 -- User Option: initial-frame-alist
     This variable’s value is an alist of parameter values used when
     creating the initial frame.  You can set this variable to specify
     the appearance of the initial frame without altering subsequent
     frames.  Each element has the form:

          (PARAMETER . VALUE)

     Emacs creates the initial frame before it reads your init file.
     After reading that file, Emacs checks ‘initial-frame-alist’, and
     applies the parameter settings in the altered value to the already
     created initial frame.

     If these settings affect the frame geometry and appearance, you’ll
     see the frame appear with the wrong ones and then change to the
     specified ones.  If that bothers you, you can specify the same
     geometry and appearance with X resources; those do take effect
     before the frame is created.  *Note X Resources: (emacs)X
     Resources.

     X resource settings typically apply to all frames.  If you want to
     specify some X resources solely for the sake of the initial frame,
     and you don’t want them to apply to subsequent frames, here’s how
     to achieve this.  Specify parameters in ‘default-frame-alist’ to
     override the X resources for subsequent frames; then, to prevent
     these from affecting the initial frame, specify the same parameters
     in ‘initial-frame-alist’ with values that match the X resources.

   If these parameters include ‘(minibuffer . nil)’, that indicates that
the initial frame should have no minibuffer.  In this case, Emacs
creates a separate “minibuffer-only frame” as well.

 -- User Option: minibuffer-frame-alist
     This variable’s value is an alist of parameter values used when
     creating an initial minibuffer-only frame (i.e., the
     minibuffer-only frame that Emacs creates if ‘initial-frame-alist’
     specifies a frame with no minibuffer).

 -- User Option: default-frame-alist
     This is an alist specifying default values of frame parameters for
     all Emacs frames—the first frame, and subsequent frames.  When
     using the X Window System, you can get the same results by means of
     X resources in many cases.

     Setting this variable does not affect existing frames.
     Furthermore, functions that display a buffer in a separate frame
     may override the default parameters by supplying their own
     parameters.

   If you invoke Emacs with command-line options that specify frame
appearance, those options take effect by adding elements to either
‘initial-frame-alist’ or ‘default-frame-alist’.  Options which affect
just the initial frame, such as ‘--geometry’ and ‘--maximized’, add to
‘initial-frame-alist’; the others add to ‘default-frame-alist’.  *note
Command Line Arguments for Emacs Invocation: (emacs)Emacs Invocation.


File: elisp.info,  Node: Window Frame Parameters,  Next: Geometry,  Prev: Initial Parameters,  Up: Frame Parameters

29.4.3 Window Frame Parameters
------------------------------

Just what parameters a frame has depends on what display mechanism it
uses.  This section describes the parameters that have special meanings
on some or all kinds of terminals.  Of these, ‘name’, ‘title’, ‘height’,
‘width’, ‘buffer-list’ and ‘buffer-predicate’ provide meaningful
information in terminal frames, and ‘tty-color-mode’ is meaningful only
for frames on text terminals.

* Menu:

* Basic Parameters::            Parameters that are fundamental.
* Position Parameters::         The position of the frame on the screen.
* Size Parameters::             Frame’s size.
* Layout Parameters::           Size of parts of the frame, and
                                  enabling or disabling some parts.
* Buffer Parameters::           Which buffers have been or should be shown.
* Frame Interaction Parameters::  Parameters for interacting with other
                                  frames.
* Mouse Dragging Parameters::   Parameters for resizing and moving
                                  frames with the mouse.
* Management Parameters::       Communicating with the window manager.
* Cursor Parameters::           Controlling the cursor appearance.
* Font and Color Parameters::   Fonts and colors for the frame text.


File: elisp.info,  Node: Basic Parameters,  Next: Position Parameters,  Up: Window Frame Parameters

29.4.3.1 Basic Parameters
.........................

These frame parameters give the most basic information about the frame.
‘title’ and ‘name’ are meaningful on all terminals.

‘display’
     The display on which to open this frame.  It should be a string of
     the form ‘HOST:DPY.SCREEN’, just like the ‘DISPLAY’ environment
     variable.  *Note Multiple Terminals::, for more details about
     display names.

‘display-type’
     This parameter describes the range of possible colors that can be
     used in this frame.  Its value is ‘color’, ‘grayscale’ or ‘mono’.

‘title’
     If a frame has a non-‘nil’ title, it appears in the window system’s
     title bar at the top of the frame, and also in the mode line of
     windows in that frame if ‘mode-line-frame-identification’ uses ‘%F’
     (*note %-Constructs::).  This is normally the case when Emacs is
     not using a window system, and can only display one frame at a
     time.  *Note Frame Titles::.

‘name’
     The name of the frame.  The frame name serves as a default for the
     frame title, if the ‘title’ parameter is unspecified or ‘nil’.  If
     you don’t specify a name, Emacs sets the frame name automatically
     (*note Frame Titles::).

     If you specify the frame name explicitly when you create the frame,
     the name is also used (instead of the name of the Emacs executable)
     when looking up X resources for the frame.

‘explicit-name’
     If the frame name was specified explicitly when the frame was
     created, this parameter will be that name.  If the frame wasn’t
     explicitly named, this parameter will be ‘nil’.


File: elisp.info,  Node: Position Parameters,  Next: Size Parameters,  Prev: Basic Parameters,  Up: Window Frame Parameters

29.4.3.2 Position Parameters
............................

Parameters describing the X- and Y-offsets of a frame are always
measured in pixels.  For a normal, non-child frame they specify the
frame’s outer position (*note Frame Geometry::) relative to its
display’s origin.  For a child frame (*note Child Frames::) they specify
the frame’s outer position relative to the native position of the
frame’s parent frame.  (Note that none of these parameters is meaningful
on TTY frames.)

‘left’
     The position, in pixels, of the left outer edge of the frame with
     respect to the left edge of the frame’s display or parent frame.
     It can be specified in one of the following ways.

     an integer
          A positive integer always relates the left edge of the frame
          to the left edge of its display or parent frame.  A negative
          integer relates the right frame edge to the right edge of the
          display or parent frame.

     ‘(+ POS)’
          This specifies the position of the left frame edge relative to
          the left edge of its display or parent frame.  The integer POS
          may be positive or negative; a negative value specifies a
          position outside the screen or parent frame or on a monitor
          other than the primary one (for multi-monitor displays).

     ‘(- POS)’
          This specifies the position of the right frame edge relative
          to the right edge of the display or parent frame.  The integer
          POS may be positive or negative; a negative value specifies a
          position outside the screen or parent frame or on a monitor
          other than the primary one (for multi-monitor displays).

     a floating-point value
          A floating-point value in the range 0.0 to 1.0 specifies the
          left edge’s offset via the “left position ratio” of the
          frame—the ratio of the left edge of its outer frame to the
          width of the frame’s workarea (*note Multiple Terminals::) or
          its parent’s native frame (*note Child Frames::) minus the
          width of the outer frame.  Thus, a left position ratio of 0.0
          flushes a frame to the left, a ratio of 0.5 centers it and a
          ratio of 1.0 flushes it to the right of its display or parent
          frame.  Similarly, the “top position ratio” of a frame is the
          ratio of the frame’s top position to the height of its
          workarea or parent frame minus the height of the frame.

          Emacs will try to keep the position ratios of a child frame
          unaltered if that frame has a non-‘nil’ ‘keep-ratio’ parameter
          (*note Frame Interaction Parameters::) and its parent frame is
          resized.

          Since the outer size of a frame (*note Frame Geometry::) is
          usually unavailable before a frame has been made visible, it
          is generally not advisable to use floating-point values when
          creating decorated frames.  Floating-point values are more
          suited for ensuring that an (undecorated) child frame is
          positioned nicely within the area of its parent frame.

     Some window managers ignore program-specified positions.  If you
     want to be sure the position you specify is not ignored, specify a
     non-‘nil’ value for the ‘user-position’ parameter as in the
     following example:

          (modify-frame-parameters
            nil '((user-position . t) (left . (+ -4))))

     In general, it is not a good idea to position a frame relative to
     the right or bottom edge of its display.  Positioning the initial
     or a new frame is either not accurate (because the size of the
     outer frame is not yet fully known before the frame has been made
     visible) or will cause additional flicker (if the frame has to be
     repositioned after becoming visible).

     Note also, that positions specified relative to the right/bottom
     edge of a display, workarea or parent frame as well as
     floating-point offsets are stored internally as integer offsets
     relative to the left/top edge of the display, workarea or parent
     frame edge.  They are also returned as such by functions like
     ‘frame-parameters’ and restored as such by the desktop saving
     routines.

‘top’
     The screen position of the top (or bottom) edge, in pixels, with
     respect to the top (or bottom) edge of the display or parent frame.
     It works just like ‘left’, except vertically instead of
     horizontally.

‘icon-left’
     The screen position of the left edge of the frame’s icon, in
     pixels, counting from the left edge of the screen.  This takes
     effect when the frame is iconified, if the window manager supports
     this feature.  If you specify a value for this parameter, then you
     must also specify a value for ‘icon-top’ and vice versa.

‘icon-top’
     The screen position of the top edge of the frame’s icon, in pixels,
     counting from the top edge of the screen.  This takes effect when
     the frame is iconified, if the window manager supports this
     feature.

‘user-position’
     When you create a frame and specify its screen position with the
     ‘left’ and ‘top’ parameters, use this parameter to say whether the
     specified position was user-specified (explicitly requested in some
     way by a human user) or merely program-specified (chosen by a
     program).  A non-‘nil’ value says the position was user-specified.

     Window managers generally heed user-specified positions, and some
     heed program-specified positions too.  But many ignore
     program-specified positions, placing the window in a default
     fashion or letting the user place it with the mouse.  Some window
     managers, including ‘twm’, let the user specify whether to obey
     program-specified positions or ignore them.

     When you call ‘make-frame’, you should specify a non-‘nil’ value
     for this parameter if the values of the ‘left’ and ‘top’ parameters
     represent the user’s stated preference; otherwise, use ‘nil’.

‘z-group’
     This parameter specifies a relative position of the frame’s
     window-system window in the stacking (Z-) order of the frame’s
     display.

     If this is ‘above’, the frame’s window-system window is displayed
     above all other window-system windows that do not have the ‘above’
     property set.  If this is ‘nil’, the frame’s window is displayed
     below all windows that have the ‘above’ property set and above all
     windows that have the ‘below’ property set.  If this is ‘below’,
     the frame’s window is displayed below all windows that do not have
     the ‘below’ property set.

     To position the frame above or below a specific other frame use the
     function ‘frame-restack’ (*note Raising and Lowering::).


File: elisp.info,  Node: Size Parameters,  Next: Layout Parameters,  Prev: Position Parameters,  Up: Window Frame Parameters

29.4.3.3 Size Parameters
........................

Frame parameters usually specify frame sizes in character units.  On
graphical displays, the ‘default’ face determines the actual pixel sizes
of these character units (*note Face Attributes::).

‘width’
     This parameter specifies the width of the frame.  It can be
     specified as in the following ways:

     an integer
          A positive integer specifies the width of the frame’s text
          area (*note Frame Geometry::) in characters.

     a cons cell
          If this is a cons cell with the symbol ‘text-pixels’ in its
          CAR, the CDR of that cell specifies the width of the frame’s
          text area in pixels.

     a floating-point value
          A floating-point number between 0.0 and 1.0 can be used to
          specify the width of a frame via its “width ratio”—the ratio
          of its outer width (*note Frame Geometry::) to the width of
          the frame’s workarea (*note Multiple Terminals::) or its
          parent frame’s (*note Child Frames::) native frame.  Thus, a
          value of 0.5 makes the frame occupy half of the width of its
          workarea or parent frame, a value of 1.0 the full width.
          Similarly, the “height ratio” of a frame is the ratio of its
          outer height to the height of its workarea or its parent’s
          native frame.

          Emacs will try to keep the width and height ratio of a child
          frame unaltered if that frame has a non-‘nil’ ‘keep-ratio’
          parameter (*note Frame Interaction Parameters::) and its
          parent frame is resized.

          Since the outer size of a frame is usually unavailable before
          a frame has been made visible, it is generally not advisable
          to use floating-point values when creating decorated frames.
          Floating-point values are more suited to ensure that a child
          frame always fits within the area of its parent frame as, for
          example, when customizing ‘display-buffer-alist’ (*note
          Choosing Window::) via ‘display-buffer-in-child-frame’.

     Regardless of how this parameter was specified, functions reporting
     the value of this parameter like ‘frame-parameters’ always report
     the width of the frame’s text area in characters as an integer
     rounded, if necessary, to a multiple of the frame’s default
     character width.  That value is also used by the desktop saving
     routines.

‘height’
     This parameter specifies the height of the frame.  It works just
     like ‘width’, except vertically instead of horizontally.

‘user-size’
     This does for the size parameters ‘height’ and ‘width’ what the
     ‘user-position’ parameter (*note user-position: Position
     Parameters.) does for the position parameters ‘top’ and ‘left’.

‘min-width’
     This parameter specifies the minimum native width (*note Frame
     Geometry::) of the frame, in characters.  Normally, the functions
     that establish a frame’s initial width or resize a frame
     horizontally make sure that all the frame’s windows, vertical
     scroll bars, fringes, margins and vertical dividers can be
     displayed.  This parameter, if non-‘nil’ allows to make a frame
     narrower than that with the consequence that any components that do
     not fit will be clipped by the window manager.

‘min-height’
     This parameter specifies the minimum native height (*note Frame
     Geometry::) of the frame, in characters.  Normally, the functions
     that establish a frame’s initial size or resize a frame make sure
     that all the frame’s windows, horizontal scroll bars and dividers,
     mode and header lines, the echo area and the internal menu and tool
     bar can be displayed.  This parameter, if non-‘nil’ allows to make
     a frame smaller than that with the consequence that any components
     that do not fit will be clipped by the window manager.

‘fullscreen’
     This parameter specifies whether to maximize the frame’s width,
     height or both.  Its value can be ‘fullwidth’, ‘fullheight’,
     ‘fullboth’, or ‘maximized’.  A “fullwidth” frame is as wide as
     possible, a “fullheight” frame is as tall as possible, and a
     “fullboth” frame is both as wide and as tall as possible.  A
     “maximized” frame is like a “fullboth” frame, except that it
     usually keeps its title bar and the buttons for resizing and
     closing the frame.  Also, maximized frames typically avoid hiding
     any task bar or panels displayed on the desktop.  A “fullboth”
     frame, on the other hand, usually omits the title bar and occupies
     the entire available screen space.

     Full-height and full-width frames are more similar to maximized
     frames in this regard.  However, these typically display an
     external border which might be absent with maximized frames.  Hence
     the heights of maximized and full-height frames and the widths of
     maximized and full-width frames often differ by a few pixels.

     With some window managers you may have to customize the variable
     ‘frame-resize-pixelwise’ (*note Frame Size::) in order to make a
     frame truly appear maximized or full-screen.  Moreover, some window
     managers might not support smooth transition between the various
     full-screen or maximization states.  Customizing the variable
     ‘x-frame-normalize-before-maximize’ can help to overcome that.

     Full-screen on macOS hides both the tool-bar and the menu-bar,
     however both will be displayed if the mouse pointer is moved to the
     top of the screen.

‘fullscreen-restore’
     This parameter specifies the desired fullscreen state of the frame
     after invoking the ‘toggle-frame-fullscreen’ command (*note
     (emacs)Frame Commands::) in the “fullboth” state.  Normally this
     parameter is installed automatically by that command when toggling
     the state to fullboth.  If, however, you start Emacs in the
     “fullboth” state, you have to specify the desired behavior in your
     initial file as, for example

          (setq default-frame-alist
              '((fullscreen . fullboth)
                (fullscreen-restore . fullheight)))

     This will give a new frame full height after typing in it <F11> for
     the first time.

‘fit-frame-to-buffer-margins’
     This parameter allows to override the value of the option
     ‘fit-frame-to-buffer-margins’ when fitting this frame to the buffer
     of its root window with ‘fit-frame-to-buffer’ (*note Resizing
     Windows::).

‘fit-frame-to-buffer-sizes’
     This parameter allows to override the value of the option
     ‘fit-frame-to-buffer-sizes’ when fitting this frame to the buffer
     of its root window with ‘fit-frame-to-buffer’ (*note Resizing
     Windows::).


File: elisp.info,  Node: Layout Parameters,  Next: Buffer Parameters,  Prev: Size Parameters,  Up: Window Frame Parameters

29.4.3.4 Layout Parameters
..........................

These frame parameters enable or disable various parts of the frame, or
control their sizes.

‘border-width’
     The width in pixels of the frame’s outer border (*note Frame
     Geometry::).

‘internal-border-width’
     The width in pixels of the frame’s internal border (*note Frame
     Geometry::).

‘vertical-scroll-bars’
     Whether the frame has scroll bars (*note Scroll Bars::) for
     vertical scrolling, and which side of the frame they should be on.
     The possible values are ‘left’, ‘right’, and ‘nil’ for no scroll
     bars.

‘horizontal-scroll-bars’
     Whether the frame has scroll bars for horizontal scrolling (‘t’ and
     ‘bottom’ mean yes, ‘nil’ means no).

‘scroll-bar-width’
     The width of vertical scroll bars, in pixels, or ‘nil’ meaning to
     use the default width.

‘scroll-bar-height’
     The height of horizontal scroll bars, in pixels, or ‘nil’ meaning
     to use the default height.

‘left-fringe’
‘right-fringe’
     The default width of the left and right fringes of windows in this
     frame (*note Fringes::).  If either of these is zero, that
     effectively removes the corresponding fringe.

     When you use ‘frame-parameter’ to query the value of either of
     these two frame parameters, the return value is always an integer.
     When using ‘set-frame-parameter’, passing a ‘nil’ value imposes an
     actual default value of 8 pixels.

‘right-divider-width’
     The width (thickness) reserved for the right divider (*note Window
     Dividers::) of any window on the frame, in pixels.  A value of zero
     means to not draw right dividers.

‘bottom-divider-width’
     The width (thickness) reserved for the bottom divider (*note Window
     Dividers::) of any window on the frame, in pixels.  A value of zero
     means to not draw bottom dividers.

‘menu-bar-lines’
     The number of lines to allocate at the top of the frame for a menu
     bar (*note Menu Bar::).  The default is one if Menu Bar mode is
     enabled and zero otherwise.  *Note (emacs)Menu Bars::.  For an
     external menu bar (*note Frame Layout::), this value remains
     unchanged even when the menu bar wraps to two or more lines.  In
     that case, the ‘menu-bar-size’ value returned by ‘frame-geometry’
     (*note Frame Geometry::) allows to derive whether the menu bar
     actually occupies one or more lines.

‘tool-bar-lines’
     The number of lines to use for the tool bar (*note Tool Bar::).
     The default is one if Tool Bar mode is enabled and zero otherwise.
     *Note (emacs)Tool Bars::.  This value may change whenever the tool
     bar wraps (*note Frame Layout::).

‘tool-bar-position’
     The position of the tool bar when Emacs was built with GTK+.  Its
     value can be one of ‘top’, ‘bottom’ ‘left’, ‘right’.  The default
     is ‘top’.

‘line-spacing’
     Additional space to leave below each text line, in pixels (a
     positive integer).  *Note Line Height::, for more information.

‘no-special-glyphs’
     If this is non-‘nil’, it suppresses the display of any truncation
     and continuation glyphs (*note Truncation::) for all buffers
     displayed by this frame.  This is useful to eliminate such glyphs
     when fitting a frame to its buffer via ‘fit-frame-to-buffer’ (*note
     Resizing Windows::).


File: elisp.info,  Node: Buffer Parameters,  Next: Frame Interaction Parameters,  Prev: Layout Parameters,  Up: Window Frame Parameters

29.4.3.5 Buffer Parameters
..........................

These frame parameters, meaningful on all kinds of terminals, deal with
which buffers have been, or should, be displayed in the frame.

‘minibuffer’
     Whether this frame has its own minibuffer.  The value ‘t’ means
     yes, ‘nil’ means no, ‘only’ means this frame is just a minibuffer.
     If the value is a minibuffer window (in some other frame), the
     frame uses that minibuffer.

     This parameter takes effect when the frame is created.  If
     specified as ‘nil’, Emacs will try to set it to the minibuffer
     window of ‘default-minibuffer-frame’ (*note Minibuffers and
     Frames::).  For an existing frame, this parameter can be used
     exclusively to specify another minibuffer window.  It is not
     allowed to change it from a minibuffer window to ‘t’ and
     vice-versa, or from ‘t’ to ‘nil’.  If the parameter specifies a
     minibuffer window already, setting it to ‘nil’ has no effect.

‘buffer-predicate’
     The buffer-predicate function for this frame.  The function
     ‘other-buffer’ uses this predicate (from the selected frame) to
     decide which buffers it should consider, if the predicate is not
     ‘nil’.  It calls the predicate with one argument, a buffer, once
     for each buffer; if the predicate returns a non-‘nil’ value, it
     considers that buffer.

‘buffer-list’
     A list of buffers that have been selected in this frame, ordered
     most-recently-selected first.

‘unsplittable’
     If non-‘nil’, this frame’s window is never split automatically.


File: elisp.info,  Node: Frame Interaction Parameters,  Next: Mouse Dragging Parameters,  Prev: Buffer Parameters,  Up: Window Frame Parameters

29.4.3.6 Frame Interaction Parameters
.....................................

These parameters supply forms of interactions between different frames.

‘parent-frame’
     If non-‘nil’, this means that this frame is a child frame (*note
     Child Frames::), and this parameter specifies its parent frame.  If
     ‘nil’, this means that this frame is a normal, top-level frame.

‘delete-before’
     If non-‘nil’, this parameter specifies another frame whose deletion
     will automatically trigger the deletion of this frame.  *Note
     Deleting Frames::.

‘mouse-wheel-frame’
     If non-‘nil’, this parameter specifies the frame whose windows will
     be scrolled whenever the mouse wheel is scrolled with the mouse
     pointer hovering over this frame, see *note (emacs)Mouse
     Commands::.

‘no-other-frame’
     If this is non-‘nil’, then this frame is not eligible as candidate
     for the functions ‘next-frame’, ‘previous-frame’ (*note Finding All
     Frames::) and ‘other-frame’, see *note (emacs)Frame Commands::.

‘auto-hide-function’
     When this parameter specifies a function, that function will be
     called instead of the function specified by the variable
     ‘frame-auto-hide-function’ when quitting the frame’s only window
     (*note Quitting Windows::) and there are other frames left.

‘minibuffer-exit’
     When this parameter is non-‘nil’, Emacs will by default make this
     frame invisible whenever the minibuffer (*note Minibuffers::) is
     exited.  Alternatively, it can specify the functions
     ‘iconify-frame’ and ‘delete-frame’.  This parameter is useful to
     make a child frame disappear automatically (similar to how Emacs
     deals with a window) when exiting the minibuffer.

‘keep-ratio’
     This parameter is currently meaningful for child frames (*note
     Child Frames::) only.  If it is non-‘nil’, then Emacs will try to
     keep the frame’s size (width and height) ratios (*note Size
     Parameters::) as well as its left and right position ratios (*note
     Position Parameters::) unaltered whenever its parent frame is
     resized.

     If the value of this parameter is ‘nil’, the frame’s position and
     size remain unaltered when the parent frame is resized, so the
     position and size ratios may change.  If the value of this
     parameter is ‘t’, Emacs will try to preserve the frame’s size and
     position ratios, hence the frame’s size and position relative to
     its parent frame may change.

     More individual control is possible by using a cons cell: In that
     case the frame’s width ratio is preserved if the CAR of the cell is
     either ‘t’ or ‘width-only’.  The height ratio is preserved if the
     CAR of the cell is either ‘t’ or ‘height-only’.  The left position
     ratio is preserved if the CDR of the cell is either ‘t’ or
     ‘left-only’.  The top position ratio is preserved if the CDR of the
     cell is either ‘t’ or ‘top-only’.


File: elisp.info,  Node: Mouse Dragging Parameters,  Next: Management Parameters,  Prev: Frame Interaction Parameters,  Up: Window Frame Parameters

29.4.3.7 Mouse Dragging Parameters
..................................

The parameters described below provide support for resizing a frame by
dragging its internal borders with the mouse.  They also allow moving a
frame with the mouse by dragging the header line of its topmost or the
mode line of its bottommost window.

   These parameters are mostly useful for child frames (*note Child
Frames::) that come without window manager decorations.  If necessary,
they can be used for undecorated top-level frames as well.

‘drag-internal-border’
     If non-‘nil’, the frame can be resized by dragging its internal
     borders, if present, with the mouse.

‘drag-with-header-line’
     If non-‘nil’, the frame can be moved with the mouse by dragging the
     header line of its topmost window.

‘drag-with-mode-line’
     If non-‘nil’, the frame can be moved with the mouse by dragging the
     mode line of its bottommost window.  Note that such a frame is not
     allowed to have its own minibuffer window.

‘snap-width’
     A frame that is moved with the mouse will “snap” at the border(s)
     of the display or its parent frame whenever it is dragged as near
     to such an edge as the number of pixels specified by this
     parameter.

‘top-visible’
     If this parameter is a number, the top edge of the frame never
     appears above the top edge of its display or parent frame.
     Moreover, as many pixels of the frame as specified by that number
     will remain visible when the frame is moved against any of the
     remaining edges of its display or parent frame.  Setting this
     parameter is useful to guard against dragging a child frame with a
     non-‘nil’ ‘drag-with-header-line’ parameter completely out of the
     area of its parent frame.

‘bottom-visible’
     If this parameter is a number, the bottom edge of the frame never
     appears below the bottom edge of its display or parent frame.
     Moreover, as many pixels of the frame as specified by that number
     will remain visible when the frame is moved against any of the
     remaining edges of its display or parent frame.  Setting this
     parameter is useful to guard against dragging a child frame with a
     non-‘nil’ ‘drag-with-mode-line’ parameter completely out of the
     area of its parent frame.


File: elisp.info,  Node: Management Parameters,  Next: Cursor Parameters,  Prev: Mouse Dragging Parameters,  Up: Window Frame Parameters

29.4.3.8 Window Management Parameters
.....................................

The following frame parameters control various aspects of the frame’s
interaction with the window manager or window system.  They have no
effect on text terminals.

‘visibility’
     The state of visibility of the frame.  There are three
     possibilities: ‘nil’ for invisible, ‘t’ for visible, and ‘icon’ for
     iconified.  *Note Visibility of Frames::.

‘auto-raise’
     If non-‘nil’, Emacs automatically raises the frame when it is
     selected.  Some window managers do not allow this.

‘auto-lower’
     If non-‘nil’, Emacs automatically lowers the frame when it is
     deselected.  Some window managers do not allow this.

‘icon-type’
     The type of icon to use for this frame.  If the value is a string,
     that specifies a file containing a bitmap to use; ‘nil’ specifies
     no icon (in which case the window manager decides what to show);
     any other non-‘nil’ value specifies the default Emacs icon.

‘icon-name’
     The name to use in the icon for this frame, when and if the icon
     appears.  If this is ‘nil’, the frame’s title is used.

‘window-id’
     The ID number which the graphical display uses for this frame.
     Emacs assigns this parameter when the frame is created; changing
     the parameter has no effect on the actual ID number.

‘outer-window-id’
     The ID number of the outermost window-system window in which the
     frame exists.  As with ‘window-id’, changing this parameter has no
     actual effect.

‘wait-for-wm’
     If non-‘nil’, tell Xt to wait for the window manager to confirm
     geometry changes.  Some window managers, including versions of
     Fvwm2 and KDE, fail to confirm, so Xt hangs.  Set this to ‘nil’ to
     prevent hanging with those window managers.

‘sticky’
     If non-‘nil’, the frame is visible on all virtual desktops on
     systems with virtual desktops.

‘inhibit-double-buffering’
     If non-‘nil’, the frame is drawn to the screen without double
     buffering.  Emacs normally attempts to use double buffering, where
     available, to reduce flicker.  Set this property if you experience
     display bugs or pine for that retro, flicker-y feeling.

‘skip-taskbar’
     If non-‘nil’, this tells the window manager to remove the frame’s
     icon from the taskbar associated with the frame’s display and
     inhibit switching to the frame’s window via the combination
     ‘Alt-<TAB>’.  On MS-Windows, iconifying such a frame will "roll in"
     its window-system window at the bottom of the desktop.  Some window
     managers may not honor this parameter.

‘no-focus-on-map’
     If non-‘nil’, this means that the frame does not want to receive
     input focus when it is mapped (*note Visibility of Frames::).  Some
     window managers may not honor this parameter.

‘no-accept-focus’
     If non-‘nil’, this means that the frame does not want to receive
     input focus via explicit mouse clicks or when moving the mouse into
     it either via ‘focus-follows-mouse’ (*note Input Focus::) or
     ‘mouse-autoselect-window’ (*note Mouse Window Auto-selection::).
     This may have the unwanted side-effect that a user cannot scroll a
     non-selected frame with the mouse.  Some window managers may not
     honor this parameter.

‘undecorated’
     If non-‘nil’, this frame’s window-system window is drawn without
     decorations, like the title, minimize/maximize boxes and external
     borders.  This usually means that the window cannot be dragged,
     resized, iconified, maximized or deleted with the mouse.  If ‘nil’,
     the frame’s window is usually drawn with all the elements listed
     above unless their display has been suspended via window manager
     settings.

     Under X, Emacs uses the Motif window manager hints to turn off
     decorations.  Some window managers may not honor these hints.

     NS builds consider the tool bar to be a decoration, and therefore
     hide it on an undecorated frame.

‘override-redirect’
     If non-‘nil’, this means that this is an “override redirect”
     frame—a frame not handled by window managers under X. Override
     redirect frames have no window manager decorations, can be
     positioned and resized only via Emacs’ positioning and resizing
     functions and are usually drawn on top of all other frames.
     Setting this parameter has no effect on MS-Windows.

‘ns-appearance’
     Only available on macOS, if set to ‘dark’ draw this frame’s
     window-system window using the “vibrant dark” theme, otherwise use
     the system default.  The “vibrant dark” theme can be used to set
     the toolbar and scrollbars to a dark appearance when using an Emacs
     theme with a dark background.

‘ns-transparent-titlebar’
     Only available on macOS, if non-‘nil’, set the titlebar and toolbar
     to be transparent.  This effectively sets the background color of
     both to match the Emacs background color.


File: elisp.info,  Node: Cursor Parameters,  Next: Font and Color Parameters,  Prev: Management Parameters,  Up: Window Frame Parameters

29.4.3.9 Cursor Parameters
..........................

This frame parameter controls the way the cursor looks.

‘cursor-type’
     How to display the cursor.  Legitimate values are:

     ‘box’
          Display a filled box.  (This is the default.)
     ‘hollow’
          Display a hollow box.
     ‘nil’
          Don’t display a cursor.
     ‘bar’
          Display a vertical bar between characters.
     ‘(bar . WIDTH)’
          Display a vertical bar WIDTH pixels wide between characters.
     ‘hbar’
          Display a horizontal bar.
     ‘(hbar . HEIGHT)’
          Display a horizontal bar HEIGHT pixels high.

   The ‘cursor-type’ frame parameter may be overridden by the variables
‘cursor-type’ and ‘cursor-in-non-selected-windows’:

 -- User Option: cursor-type
     This buffer-local variable controls how the cursor looks in a
     selected window showing the buffer.  If its value is ‘t’, that
     means to use the cursor specified by the ‘cursor-type’ frame
     parameter.  Otherwise, the value should be one of the cursor types
     listed above, and it overrides the ‘cursor-type’ frame parameter.

 -- User Option: cursor-in-non-selected-windows
     This buffer-local variable controls how the cursor looks in a
     window that is not selected.  It supports the same values as the
     ‘cursor-type’ frame parameter; also, ‘nil’ means don’t display a
     cursor in nonselected windows, and ‘t’ (the default) means use a
     standard modification of the usual cursor type (solid box becomes
     hollow box, and bar becomes a narrower bar).

 -- User Option: x-stretch-cursor
     This variable controls the width of the block cursor displayed on
     extra-wide glyphs such as a tab or a stretch of white space.  By
     default, the block cursor is only as wide as the font’s default
     character, and will not cover all of the width of the glyph under
     it if that glyph is extra-wide.  A non-‘nil’ value of this variable
     means draw the block cursor as wide as the glyph under it.  The
     default value is ‘nil’.

     This variable has no effect on text-mode frames, since the
     text-mode cursor is drawn by the terminal out of Emacs’s control.

 -- User Option: blink-cursor-alist
     This variable specifies how to blink the cursor.  Each element has
     the form ‘(ON-STATE . OFF-STATE)’.  Whenever the cursor type equals
     ON-STATE (comparing using ‘equal’), the corresponding OFF-STATE
     specifies what the cursor looks like when it blinks off.  Both
     ON-STATE and OFF-STATE should be suitable values for the
     ‘cursor-type’ frame parameter.

     There are various defaults for how to blink each type of cursor, if
     the type is not mentioned as an ON-STATE here.  Changes in this
     variable do not take effect immediately, only when you specify the
     ‘cursor-type’ frame parameter.


File: elisp.info,  Node: Font and Color Parameters,  Prev: Cursor Parameters,  Up: Window Frame Parameters

29.4.3.10 Font and Color Parameters
...................................

These frame parameters control the use of fonts and colors.

‘font-backend’
     A list of symbols, specifying the “font backends” to use for
     drawing fonts in the frame, in order of priority.  On X, there are
     currently two available font backends: ‘x’ (the X core font driver)
     and ‘xft’ (the Xft font driver).  On MS-Windows, there are
     currently two available font backends: ‘gdi’ and ‘uniscribe’ (*note
     (emacs)Windows Fonts::).  On other systems, there is only one
     available font backend, so it does not make sense to modify this
     frame parameter.

‘background-mode’
     This parameter is either ‘dark’ or ‘light’, according to whether
     the background color is a light one or a dark one.

‘tty-color-mode’
     This parameter overrides the terminal’s color support as given by
     the system’s terminal capabilities database in that this
     parameter’s value specifies the color mode to use on a text
     terminal.  The value can be either a symbol or a number.  A number
     specifies the number of colors to use (and, indirectly, what
     commands to issue to produce each color).  For example,
     ‘(tty-color-mode . 8)’ specifies use of the ANSI escape sequences
     for 8 standard text colors.  A value of −1 turns off color support.

     If the parameter’s value is a symbol, it specifies a number through
     the value of ‘tty-color-mode-alist’, and the associated number is
     used instead.

‘screen-gamma’
     If this is a number, Emacs performs gamma correction which adjusts
     the brightness of all colors.  The value should be the screen gamma
     of your display.

     Usual PC monitors have a screen gamma of 2.2, so color values in
     Emacs, and in X windows generally, are calibrated to display
     properly on a monitor with that gamma value.  If you specify 2.2
     for ‘screen-gamma’, that means no correction is needed.  Other
     values request correction, designed to make the corrected colors
     appear on your screen the way they would have appeared without
     correction on an ordinary monitor with a gamma value of 2.2.

     If your monitor displays colors too light, you should specify a
     ‘screen-gamma’ value smaller than 2.2.  This requests correction
     that makes colors darker.  A screen gamma value of 1.5 may give
     good results for LCD color displays.

‘alpha’
     This parameter specifies the opacity of the frame, on graphical
     displays that support variable opacity.  It should be an integer
     between 0 and 100, where 0 means completely transparent and 100
     means completely opaque.  It can also have a ‘nil’ value, which
     tells Emacs not to set the frame opacity (leaving it to the window
     manager).

     To prevent the frame from disappearing completely from view, the
     variable ‘frame-alpha-lower-limit’ defines a lower opacity limit.
     If the value of the frame parameter is less than the value of this
     variable, Emacs uses the latter.  By default,
     ‘frame-alpha-lower-limit’ is 20.

     The ‘alpha’ frame parameter can also be a cons cell ‘(ACTIVE .
     INACTIVE)’, where ACTIVE is the opacity of the frame when it is
     selected, and INACTIVE is the opacity when it is not selected.

     Some window systems do not support the ‘alpha’ parameter for child
     frames (*note Child Frames::).

   The following frame parameters are semi-obsolete in that they are
automatically equivalent to particular face attributes of particular
faces (*note (emacs)Standard Faces::):

‘font’
     The name of the font for displaying text in the frame.  This is a
     string, either a valid font name for your system or the name of an
     Emacs fontset (*note Fontsets::).  It is equivalent to the ‘font’
     attribute of the ‘default’ face.

‘foreground-color’
     The color to use for the image of a character.  It is equivalent to
     the ‘:foreground’ attribute of the ‘default’ face.

‘background-color’
     The color to use for the background of characters.  It is
     equivalent to the ‘:background’ attribute of the ‘default’ face.

‘mouse-color’
     The color for the mouse pointer.  It is equivalent to the
     ‘:background’ attribute of the ‘mouse’ face.

‘cursor-color’
     The color for the cursor that shows point.  It is equivalent to the
     ‘:background’ attribute of the ‘cursor’ face.

‘border-color’
     The color for the border of the frame.  It is equivalent to the
     ‘:background’ attribute of the ‘border’ face.

‘scroll-bar-foreground’
     If non-‘nil’, the color for the foreground of scroll bars.  It is
     equivalent to the ‘:foreground’ attribute of the ‘scroll-bar’ face.

‘scroll-bar-background’
     If non-‘nil’, the color for the background of scroll bars.  It is
     equivalent to the ‘:background’ attribute of the ‘scroll-bar’ face.


File: elisp.info,  Node: Geometry,  Prev: Window Frame Parameters,  Up: Frame Parameters

29.4.4 Geometry
---------------

Here’s how to examine the data in an X-style window geometry
specification:

 -- Function: x-parse-geometry geom
     The function ‘x-parse-geometry’ converts a standard X window
     geometry string to an alist that you can use as part of the
     argument to ‘make-frame’.

     The alist describes which parameters were specified in GEOM, and
     gives the values specified for them.  Each element looks like
     ‘(PARAMETER . VALUE)’.  The possible PARAMETER values are ‘left’,
     ‘top’, ‘width’, and ‘height’.

     For the size parameters, the value must be an integer.  The
     position parameter names ‘left’ and ‘top’ are not totally accurate,
     because some values indicate the position of the right or bottom
     edges instead.  The VALUE possibilities for the position parameters
     are: an integer, a list ‘(+ POS)’, or a list ‘(- POS)’; as
     previously described (*note Position Parameters::).

     Here is an example:

          (x-parse-geometry "35x70+0-0")
               ⇒ ((height . 70) (width . 35)
                   (top - 0) (left . 0))


File: elisp.info,  Node: Terminal Parameters,  Next: Frame Titles,  Prev: Frame Parameters,  Up: Frames

29.5 Terminal Parameters
========================

Each terminal has a list of associated parameters.  These “terminal
parameters” are mostly a convenient way of storage for terminal-local
variables, but some terminal parameters have a special meaning.

   This section describes functions to read and change the parameter
values of a terminal.  They all accept as their argument either a
terminal or a frame; the latter means use that frame’s terminal.  An
argument of ‘nil’ means the selected frame’s terminal.

 -- Function: terminal-parameters &optional terminal
     This function returns an alist listing all the parameters of
     TERMINAL and their values.

 -- Function: terminal-parameter terminal parameter
     This function returns the value of the parameter PARAMETER (a
     symbol) of TERMINAL.  If TERMINAL has no setting for PARAMETER,
     this function returns ‘nil’.

 -- Function: set-terminal-parameter terminal parameter value
     This function sets the parameter PARAMETER of TERMINAL to the
     specified VALUE, and returns the previous value of that parameter.

   Here’s a list of a few terminal parameters that have a special
meaning:

‘background-mode’
     The classification of the terminal’s background color, either
     ‘light’ or ‘dark’.
‘normal-erase-is-backspace’
     Value is either 1 or 0, depending on whether
     ‘normal-erase-is-backspace-mode’ is turned on or off on this
     terminal.  *Note (emacs)DEL Does Not Delete::.
‘terminal-initted’
     After the terminal is initialized, this is set to the
     terminal-specific initialization function.
‘tty-mode-set-strings’
     When present, a list of strings containing escape sequences that
     Emacs will output while configuring a tty for rendering.  Emacs
     emits these strings only when configuring a terminal: if you want
     to enable a mode on a terminal that is already active (for example,
     while in ‘tty-setup-hook’), explicitly output the necessary escape
     sequence using ‘send-string-to-terminal’ in addition to adding the
     sequence to ‘tty-mode-set-strings’.
‘tty-mode-reset-strings’
     When present, a list of strings that undo the effects of the
     strings in ‘tty-mode-set-strings’.  Emacs emits these strings when
     exiting, deleting a terminal, or suspending itself.


File: elisp.info,  Node: Frame Titles,  Next: Deleting Frames,  Prev: Terminal Parameters,  Up: Frames

29.6 Frame Titles
=================

Every frame has a ‘name’ parameter; this serves as the default for the
frame title which window systems typically display at the top of the
frame.  You can specify a name explicitly by setting the ‘name’ frame
property.

   Normally you don’t specify the name explicitly, and Emacs computes
the frame name automatically based on a template stored in the variable
‘frame-title-format’.  Emacs recomputes the name each time the frame is
redisplayed.

 -- Variable: frame-title-format
     This variable specifies how to compute a name for a frame when you
     have not explicitly specified one.  The variable’s value is
     actually a mode line construct, just like ‘mode-line-format’,
     except that the ‘%c’, ‘%C’, and ‘%l’ constructs are ignored.  *Note
     Mode Line Data::.

 -- Variable: icon-title-format
     This variable specifies how to compute the name for an iconified
     frame, when you have not explicitly specified the frame title.
     This title appears in the icon itself.

 -- Variable: multiple-frames
     This variable is set automatically by Emacs.  Its value is ‘t’ when
     there are two or more frames (not counting minibuffer-only frames
     or invisible frames).  The default value of ‘frame-title-format’
     uses ‘multiple-frames’ so as to put the buffer name in the frame
     title only when there is more than one frame.

     The value of this variable is not guaranteed to be accurate except
     while processing ‘frame-title-format’ or ‘icon-title-format’.


File: elisp.info,  Node: Deleting Frames,  Next: Finding All Frames,  Prev: Frame Titles,  Up: Frames

29.7 Deleting Frames
====================

A “live frame” is one that has not been deleted.  When a frame is
deleted, it is removed from its terminal display, although it may
continue to exist as a Lisp object until there are no more references to
it.

 -- Command: delete-frame &optional frame force
     This function deletes the frame FRAME.  The argument FRAME must
     specify a live frame (see below) and defaults to the selected
     frame.

     It first deletes any child frame of FRAME (*note Child Frames::)
     and any frame whose ‘delete-before’ frame parameter (*note Frame
     Interaction Parameters::) specifies FRAME.  All such deletions are
     performed recursively; so this step makes sure that no other frames
     with FRAME as their ancestor will exist.  Then, unless FRAME
     specifies a tooltip, this function runs the hook
     ‘delete-frame-functions’ (each function getting one argument,
     FRAME) before actually killing the frame.

     Note that a frame cannot be deleted as long as its minibuffer
     serves as surrogate minibuffer for another frame (*note Minibuffers
     and Frames::).  Normally, you cannot delete a frame if all other
     frames are invisible, but if FORCE is non-‘nil’, then you are
     allowed to do so.

 -- Function: frame-live-p frame
     This function returns non-‘nil’ if the frame FRAME has not been
     deleted.  The possible non-‘nil’ return values are like those of
     ‘framep’.  *Note Frames::.

   Some window managers provide a command to delete a window.  These
work by sending a special message to the program that operates the
window.  When Emacs gets one of these commands, it generates a
‘delete-frame’ event, whose normal definition is a command that calls
the function ‘delete-frame’.  *Note Misc Events::.

 -- Command: delete-other-frames &optional frame
     This command deletes all frames on FRAME’s terminal, except FRAME.
     If FRAME uses another frame’s minibuffer, that minibuffer frame is
     left untouched.  The argument FRAME must specify a live frame and
     defaults to the selected frame.  Internally, this command works by
     calling ‘delete-frame’ with FORCE ‘nil’ for all frames that shall
     be deleted.

     This function does not delete any of FRAME’s child frames (*note
     Child Frames::).  If FRAME is a child frame, it deletes FRAME’s
     siblings only.


File: elisp.info,  Node: Finding All Frames,  Next: Minibuffers and Frames,  Prev: Deleting Frames,  Up: Frames

29.8 Finding All Frames
=======================

 -- Function: frame-list
     This function returns a list of all the live frames, i.e., those
     that have not been deleted.  It is analogous to ‘buffer-list’ for
     buffers, and includes frames on all terminals.  The list that you
     get is newly created, so modifying the list doesn’t have any effect
     on the internals of Emacs.

 -- Function: visible-frame-list
     This function returns a list of just the currently visible frames.
     *Note Visibility of Frames::.  Frames on text terminals always
     count as visible, even though only the selected one is actually
     displayed.

 -- Function: frame-list-z-order &optional display
     This function returns a list of Emacs’ frames, in Z (stacking)
     order (*note Raising and Lowering::).  The optional argument
     DISPLAY specifies which display to poll.  DISPLAY should be either
     a frame or a display name (a string).  If omitted or ‘nil’, that
     stands for the selected frame’s display.  It returns ‘nil’ if
     DISPLAY contains no Emacs frame.

     Frames are listed from topmost (first) to bottommost (last).  As a
     special case, if DISPLAY is non-‘nil’ and specifies a live frame,
     it returns the child frames of that frame in Z (stacking) order.

     This function is not meaningful on text terminals.

 -- Function: next-frame &optional frame minibuf
     This function lets you cycle conveniently through all the frames on
     a specific terminal from an arbitrary starting point.  It returns
     the frame following FRAME, in the list of all live frames, on
     FRAME’s terminal.  The argument FRAME must specify a live frame and
     defaults to the selected frame.  It never returns a frame whose
     ‘no-other-frame’ parameter (*note Frame Interaction Parameters::)
     is non-‘nil’.

     The second argument, MINIBUF, says which frames to consider:

     ‘nil’
          Exclude minibuffer-only frames.
     ‘visible’
          Consider all visible frames.
     0
          Consider all visible or iconified frames.
     a window
          Consider only the frames using that particular window as their
          minibuffer.
     anything else
          Consider all frames.

 -- Function: previous-frame &optional frame minibuf
     Like ‘next-frame’, but cycles through all frames in the opposite
     direction.

   See also ‘next-window’ and ‘previous-window’, in *note Cyclic Window
Ordering::.


File: elisp.info,  Node: Minibuffers and Frames,  Next: Input Focus,  Prev: Finding All Frames,  Up: Frames

29.9 Minibuffers and Frames
===========================

Normally, each frame has its own minibuffer window at the bottom, which
is used whenever that frame is selected.  You can get that window with
the function ‘minibuffer-window’ (*note Minibuffer Windows::).

   However, you can also create a frame without a minibuffer.  Such a
frame must use the minibuffer window of some other frame.  That other
frame will serve as “surrogate minibuffer frame” for this frame and
cannot be deleted via ‘delete-frame’ (*note Deleting Frames::) as long
as this frame is live.

   When you create the frame, you can explicitly specify its minibuffer
window (in some other frame) with the ‘minibuffer’ frame parameter
(*note Buffer Parameters::).  If you don’t, then the minibuffer is found
in the frame which is the value of the variable
‘default-minibuffer-frame’.  Its value should be a frame that does have
a minibuffer.

   If you use a minibuffer-only frame, you might want that frame to
raise when you enter the minibuffer.  If so, set the variable
‘minibuffer-auto-raise’ to ‘t’.  *Note Raising and Lowering::.

 -- Variable: default-minibuffer-frame
     This variable specifies the frame to use for the minibuffer window,
     by default.  It does not affect existing frames.  It is always
     local to the current terminal and cannot be buffer-local.  *Note
     Multiple Terminals::.


File: elisp.info,  Node: Input Focus,  Next: Visibility of Frames,  Prev: Minibuffers and Frames,  Up: Frames

29.10 Input Focus
=================

At any time, one frame in Emacs is the “selected frame”.  The selected
window always resides on the selected frame.

   When Emacs displays its frames on several terminals (*note Multiple
Terminals::), each terminal has its own selected frame.  But only one of
these is _the_ selected frame: it’s the frame that belongs to the
terminal from which the most recent input came.  That is, when Emacs
runs a command that came from a certain terminal, the selected frame is
the one of that terminal.  Since Emacs runs only a single command at any
given time, it needs to consider only one selected frame at a time; this
frame is what we call “the selected frame” in this manual.  The display
on which the selected frame is shown is the “selected frame’s display”.

 -- Function: selected-frame
     This function returns the selected frame.

   Some window systems and window managers direct keyboard input to the
window object that the mouse is in; others require explicit clicks or
commands to “shift the focus” to various window objects.  Either way,
Emacs automatically keeps track of which frame has the focus.  To
explicitly switch to a different frame from a Lisp function, call
‘select-frame-set-input-focus’.

   Lisp programs can also switch frames temporarily by calling the
function ‘select-frame’.  This does not alter the window system’s
concept of focus; rather, it escapes from the window manager’s control
until that control is somehow reasserted.

   When using a text terminal, only one frame can be displayed at a time
on the terminal, so after a call to ‘select-frame’, the next redisplay
actually displays the newly selected frame.  This frame remains selected
until a subsequent call to ‘select-frame’.  Each frame on a text
terminal has a number which appears in the mode line before the buffer
name (*note Mode Line Variables::).

 -- Function: select-frame-set-input-focus frame &optional norecord
     This function selects FRAME, raises it (should it happen to be
     obscured by other frames) and tries to give it the X server’s
     focus.  On a text terminal, the next redisplay displays the new
     frame on the entire terminal screen.  The optional argument
     NORECORD has the same meaning as for ‘select-frame’ (see below).
     The return value of this function is not significant.

   Ideally, the function described next should focus a frame without
also raising it above other frames.  Unfortunately, many window-systems
or window managers may refuse to comply.

 -- Function: x-focus-frame frame &optional noactivate
     This function gives FRAME the focus of the X server without
     necessarily raising it.  FRAME ‘nil’ means use the selected frame.
     Under X, the optional argument NOACTIVATE, if non-‘nil’, means to
     avoid making FRAME’s window-system window the “active” window which
     should insist a bit more on avoiding to raise FRAME above other
     frames.

     On MS-Windows the NOACTIVATE argument has no effect.  However, if
     FRAME is a child frame (*note Child Frames::), this function
     usually focuses FRAME without raising it above other child frames.

     If there is no window system support, this function does nothing.

 -- Command: select-frame frame &optional norecord
     This function selects frame FRAME, temporarily disregarding the
     focus of the X server if any.  The selection of FRAME lasts until
     the next time the user does something to select a different frame,
     or until the next time this function is called.  (If you are using
     a window system, the previously selected frame may be restored as
     the selected frame after return to the command loop, because it
     still may have the window system’s input focus.)

     The specified FRAME becomes the selected frame, and its terminal
     becomes the selected terminal.  This function then calls
     ‘select-window’ as a subroutine, passing the window selected within
     FRAME as its first argument and NORECORD as its second argument
     (hence, if NORECORD is non-‘nil’, this avoids changing the order of
     recently selected windows and the buffer list).  *Note Selecting
     Windows::.

     This function returns FRAME, or ‘nil’ if FRAME has been deleted.

     In general, you should never use ‘select-frame’ in a way that could
     switch to a different terminal without switching back when you’re
     done.

   Emacs cooperates with the window system by arranging to select frames
as the server and window manager request.  It does so by generating a
special kind of input event, called a “focus” event, when appropriate.
The command loop handles a focus event by calling ‘handle-switch-frame’.
*Note Focus Events::.

 -- Command: handle-switch-frame frame
     This function handles a focus event by selecting frame FRAME.

     Focus events normally do their job by invoking this command.  Don’t
     call it for any other reason.

 -- Function: redirect-frame-focus frame &optional focus-frame
     This function redirects focus from FRAME to FOCUS-FRAME.  This
     means that FOCUS-FRAME will receive subsequent keystrokes and
     events intended for FRAME.  After such an event, the value of
     ‘last-event-frame’ will be FOCUS-FRAME.  Also, switch-frame events
     specifying FRAME will instead select FOCUS-FRAME.

     If FOCUS-FRAME is omitted or ‘nil’, that cancels any existing
     redirection for FRAME, which therefore once again receives its own
     events.

     One use of focus redirection is for frames that don’t have
     minibuffers.  These frames use minibuffers on other frames.
     Activating a minibuffer on another frame redirects focus to that
     frame.  This puts the focus on the minibuffer’s frame, where it
     belongs, even though the mouse remains in the frame that activated
     the minibuffer.

     Selecting a frame can also change focus redirections.  Selecting
     frame ‘bar’, when ‘foo’ had been selected, changes any redirections
     pointing to ‘foo’ so that they point to ‘bar’ instead.  This allows
     focus redirection to work properly when the user switches from one
     frame to another using ‘select-window’.

     This means that a frame whose focus is redirected to itself is
     treated differently from a frame whose focus is not redirected.
     ‘select-frame’ affects the former but not the latter.

     The redirection lasts until ‘redirect-frame-focus’ is called to
     change it.

 -- Variable: focus-in-hook
     This is a normal hook run when an Emacs frame gains input focus.
     The frame gaining focus is selected when this hook is run.

 -- Variable: focus-out-hook
     This is a normal hook run when an Emacs frame has lost input focus
     and no other Emacs frame has gained input focus instead.

 -- User Option: focus-follows-mouse
     This option informs Emacs whether and how the window manager
     transfers focus when you move the mouse pointer into a frame.  It
     can have three meaningful values:

     ‘nil’
          The default value ‘nil’ should be used when your window
          manager follows a “click-to-focus” policy where you have to
          click the mouse inside of a frame in order for that frame to
          gain focus.

     ‘t’
          The value ‘t’ should be used when your window manager has the
          focus automatically follow the position of the mouse pointer
          but a frame that gains focus is not raised automatically and
          may even remain occluded by other window-system windows.

     ‘auto-raise’
          The value ‘auto-raise’ should be used when your window manager
          has the focus automatically follow the position of the mouse
          pointer and a frame that gains focus is raised automatically.

     If this option is non-‘nil’, Emacs moves the mouse pointer to the
     frame selected by ‘select-frame-set-input-focus’.  That function is
     used by a number of commands like, for example, ‘other-frame’ and
     ‘pop-to-buffer’.

     The distinction between the values ‘t’ and ‘auto-raise’ is not
     needed for “normal” frames because the window manager usually takes
     care of raising them.  It is useful to automatically raise child
     frames via ‘mouse-autoselect-window’ (*note Mouse Window
     Auto-selection::).

     Note that this option does not distinguish “sloppy” focus (where
     the frame that previously had focus retains focus as long as the
     mouse pointer does not move into another window manager window)
     from “strict” focus (where a frame immediately loses focus when
     it’s left by the mouse pointer).  Neither does it recognize whether
     your window manager supports delayed focusing or auto-raising where
     you can explicitly specify the time until a new frame gets focus or
     is auto-raised.

     You can supply a “focus follows mouse” policy for individual Emacs
     windows by customizing the variable ‘mouse-autoselect-window’
     (*note Mouse Window Auto-selection::).


File: elisp.info,  Node: Visibility of Frames,  Next: Raising and Lowering,  Prev: Input Focus,  Up: Frames

29.11 Visibility of Frames
==========================

A frame on a graphical display may be “visible”, “invisible”, or
“iconified”.  If it is visible, its contents are displayed in the usual
manner.  If it is iconified, its contents are not displayed, but there
is a little icon somewhere to bring the frame back into view (some
window managers refer to this state as “minimized” rather than
“iconified”, but from Emacs’ point of view they are the same thing).  If
a frame is invisible, it is not displayed at all.

   The concept of visibility is strongly related to that of (un-)mapped
frames.  A frame (or, more precisely, its window-system window) is and
becomes “mapped” when it is displayed for the first time and whenever it
changes its state of visibility from ‘iconified’ or ‘invisible’ to
‘visible’.  Conversely, a frame is and becomes “unmapped” whenever it
changes its status from ‘visible’ to ‘iconified’ or ‘invisible’.

   Visibility is meaningless on text terminals, since only the selected
frame is actually displayed in any case.

 -- Function: frame-visible-p frame
     This function returns the visibility status of frame FRAME.  The
     value is ‘t’ if FRAME is visible, ‘nil’ if it is invisible, and
     ‘icon’ if it is iconified.

     On a text terminal, all frames are considered visible for the
     purposes of this function, even though only one frame is displayed.
     *Note Raising and Lowering::.

 -- Command: iconify-frame &optional frame
     This function iconifies frame FRAME.  If you omit FRAME, it
     iconifies the selected frame.  This usually makes all child frames
     of FRAME (and their descendants) invisible (*note Child Frames::).

 -- Command: make-frame-visible &optional frame
     This function makes frame FRAME visible.  If you omit FRAME, it
     makes the selected frame visible.  This does not raise the frame,
     but you can do that with ‘raise-frame’ if you wish (*note Raising
     and Lowering::).

     Making a frame visible usually makes all its child frames (and
     their descendants) visible as well (*note Child Frames::).

 -- Command: make-frame-invisible &optional frame force
     This function makes frame FRAME invisible.  If you omit FRAME, it
     makes the selected frame invisible.  Usually, this makes all child
     frames of FRAME (and their descendants) invisible too (*note Child
     Frames::).

     Unless FORCE is non-‘nil’, this function refuses to make FRAME
     invisible if all other frames are invisible.

   The visibility status of a frame is also available as a frame
parameter.  You can read or change it as such.  *Note Management
Parameters::.  The user can also iconify and deiconify frames with the
window manager.  This happens below the level at which Emacs can exert
any control, but Emacs does provide events that you can use to keep
track of such changes.  *Note Misc Events::.

 -- Function: x-double-buffered-p &optional frame
     This function returns non-‘nil’ if FRAME is currently being
     rendered with double buffering.  FRAME defaults to the selected
     frame.


File: elisp.info,  Node: Raising and Lowering,  Next: Frame Configurations,  Prev: Visibility of Frames,  Up: Frames

29.12 Raising, Lowering and Restacking Frames
=============================================

Most window systems use a desktop metaphor.  Part of this metaphor is
the idea that system-level windows (representing, e.g., Emacs frames)
are stacked in a notional third dimension perpendicular to the screen
surface.  The order induced by stacking is total and usually referred to
as stacking (or Z-) order.  Where the areas of two windows overlap, the
one higher up in that order will (partially) cover the one underneath.

   You can “raise” a frame to the top of that order or “lower” a frame
to its bottom by using the functions ‘raise-frame’ and ‘lower-frame’.
You can “restack” a frame directly above or below another frame using
the function ‘frame-restack’.

   Note that all functions described below will respect the adherence of
frames (and all other window-system windows) to their respective z-group
(*note Position Parameters::).  For example, you usually cannot lower a
frame below that of the desktop window and you cannot raise a frame
whose ‘z-group’ parameter is ‘nil’ above the window-system’s taskbar or
tooltip window.

 -- Command: raise-frame &optional frame
     This function raises frame FRAME (default, the selected frame)
     above all other frames belonging to the same or a lower z-group as
     FRAME.  If FRAME is invisible or iconified, this makes it visible.
     If FRAME is a child frame (*note Child Frames::), this raises FRAME
     above all other child frames of its parent.

 -- Command: lower-frame &optional frame
     This function lowers frame FRAME (default, the selected frame)
     below all other frames belonging to the same or a higher z-group as
     FRAME.  If FRAME is a child frame (*note Child Frames::), this
     lowers FRAME below all other child frames of its parent.

 -- Function: frame-restack frame1 frame2 &optional above
     This function restacks FRAME1 below FRAME2.  This implies that if
     both frames are visible and their display areas overlap, FRAME2
     will (partially) obscure FRAME1.  If the optional third argument
     ABOVE is non-‘nil’, this function restacks FRAME1 above FRAME2.
     This means that if both frames are visible and their display areas
     overlap, FRAME1 will (partially) obscure FRAME2.

     Technically, this function may be thought of as an atomic action
     performed in two steps: The first step removes FRAME1’s
     window-system window from the display.  The second step reinserts
     FRAME1’s window into the display below (above if ABOVE is true)
     that of FRAME2.  Hence the position of FRAME2 in its display’s Z
     (stacking) order relative to all other frames excluding FRAME1
     remains unaltered.

     Some window managers may refuse to restack windows.

   Note that the effect of restacking will only hold as long as neither
of the involved frames is iconified or made invisible.  You can use the
‘z-group’ (*note Position Parameters::) frame parameter to add a frame
to a group of frames permanently shown above or below other frames.  As
long as a frame belongs to one of these groups, restacking it will only
affect its relative stacking position within that group.  The effect of
restacking frames belonging to different z-groups is undefined.  You can
list frames in their current stacking order with the function
‘frame-list-z-order’ (*note Finding All Frames::).

 -- User Option: minibuffer-auto-raise
     If this is non-‘nil’, activation of the minibuffer raises the frame
     that the minibuffer window is in.

   On window systems, you can also enable auto-raising (on frame
selection) or auto-lowering (on frame deselection) using frame
parameters.  *Note Management Parameters::.

   The concept of raising and lowering frames also applies to text
terminal frames.  On each text terminal, only the top frame is displayed
at any one time.

 -- Function: tty-top-frame &optional terminal
     This function returns the top frame on TERMINAL.  TERMINAL should
     be a terminal object, a frame (meaning that frame’s terminal), or
     ‘nil’ (meaning the selected frame’s terminal).  If it does not
     refer to a text terminal, the return value is ‘nil’.


File: elisp.info,  Node: Frame Configurations,  Next: Child Frames,  Prev: Raising and Lowering,  Up: Frames

29.13 Frame Configurations
==========================

A “frame configuration” records the current arrangement of frames, all
their properties, and the window configuration of each one.  (*Note
Window Configurations::.)

 -- Function: current-frame-configuration
     This function returns a frame configuration list that describes the
     current arrangement of frames and their contents.

 -- Function: set-frame-configuration configuration &optional nodelete
     This function restores the state of frames described in
     CONFIGURATION.  However, this function does not restore deleted
     frames.

     Ordinarily, this function deletes all existing frames not listed in
     CONFIGURATION.  But if NODELETE is non-‘nil’, the unwanted frames
     are iconified instead.


File: elisp.info,  Node: Child Frames,  Next: Mouse Tracking,  Prev: Frame Configurations,  Up: Frames

29.14 Child Frames
==================

Child frames are objects halfway between windows (*note Windows::) and
“normal” frames.  Like windows, they are attached to an owning frame.
Unlike windows, they may overlap each other—changing the size or
position of one child frame does not change the size or position of any
of its sibling child frames.

   By design, operations to make or modify child frames are implemented
with the help of frame parameters (*note Frame Parameters::) without any
specialized functions or customizable variables.  Note that child frames
are meaningful on graphical terminals only.

   To create a new child frame or to convert a normal frame into a child
frame, set that frame’s ‘parent-frame’ parameter (*note Frame
Interaction Parameters::) to that of an already existing frame.  The
frame specified by that parameter will then be the frame’s parent frame
as long as the parameter is not changed or reset.  Technically, this
makes the child frame’s window-system window a child window of the
parent frame’s window-system window.

   The ‘parent-frame’ parameter can be changed at any time.  Setting it
to another frame “reparents” the child frame.  Setting it to another
child frame makes the frame a “nested” child frame.  Setting it to ‘nil’
restores the frame’s status as a top-level frame—a frame whose
window-system window is a child of its display’s root window.

   Since child frames can be arbitrarily nested, a frame can be both a
child and a parent frame.  Also, the relative roles of child and parent
frame may be reversed at any time (though it’s usually a good idea to
keep the size of a child frame sufficiently smaller than that of its
parent).  An error will be signaled for the attempt to make a frame an
ancestor of itself.

   Most window-systems clip a child frame at the native edges (*note
Frame Geometry::) of its parent frame—everything outside these edges is
usually invisible.  A child frame’s ‘left’ and ‘top’ parameters specify
a position relative to the top-left corner of its parent’s native frame.
When the parent frame is resized, this position remains conceptually
unaltered.

   NS builds do not clip child frames at the parent frame’s edges,
allowing them to be positioned so they do not obscure the parent frame
while still being visible themselves.

   Usually, moving a parent frame moves along all its child frames and
their descendants as well, keeping their relative positions unaltered.
Note that the hook ‘move-frame-functions’ (*note Frame Position::) is
run for a child frame only when the position of the child frame relative
to its parent frame changes.

   When a parent frame is resized, its child frames conceptually retain
their previous sizes and their positions relative to the left upper
corner of the parent.  This means that a child frame may become
(partially) invisible when its parent frame shrinks.  The parameter
‘keep-ratio’ (*note Frame Interaction Parameters::) can be used to
resize and reposition a child frame proportionally whenever its parent
frame is resized.  This may avoid obscuring parts of a frame when its
parent frame is shrunk.

   A visible child frame always appears on top of its parent frame thus
obscuring parts of it, except on NS builds where it may be positioned
beneath the parent.  This is comparable to the window-system window of a
top-level frame which also always appears on top of its parent
window—the desktop’s root window.  When a parent frame is iconified or
made invisible (*note Visibility of Frames::), its child frames are made
invisible.  When a parent frame is deiconified or made visible, its
child frames are made visible.  When a parent frame is about to be
deleted (*note Deleting Frames::), its child frames are recursively
deleted before it.

   Whether a child frame can have a menu or tool bar is window-system or
window manager dependent.  Most window-systems explicitly disallow menus
bars for child frames.  It seems advisable to disable both, menu and
tool bars, via the frame’s initial parameters settings.

   Usually, child frames do not exhibit window manager decorations like
a title bar or external borders (*note Frame Geometry::).  When the
child frame does not show a menu or tool bar, any other of the frame’s
borders (*note Layout Parameters::) can be used instead of the external
borders.

   In particular, under X (but not when building with GTK+), the frame’s
outer border can be used.  On MS-Windows, specifying a non-zero outer
border width will show a one-pixel wide external border.  Under all
window-systems, the internal border can be used.  In either case, it’s
advisable to disable a child frame’s window manager decorations with the
‘undecorated’ frame parameter (*note Management Parameters::).

   To resize or move an undecorated child frame with the mouse, special
frame parameters (*note Mouse Dragging Parameters::) have to be used.
The internal border of a child frame, if present, can be used to resize
the frame with the mouse, provided that frame has a non-‘nil’
‘drag-internal-border’ parameter.  If set, the ‘snap-width’ parameter
indicates the number of pixels where the frame “snaps” at the respective
edge or corner of its parent frame.

   There are two ways to drag an entire child frame with the mouse: The
‘drag-with-mode-line’ parameter, if non-‘nil’, allows to drag a frame
without minibuffer window (*note Minibuffer Windows::) via the mode line
area of its bottommost window.  The ‘drag-with-header-line’ parameter,
if non-‘nil’, allows to drag the frame via the header line area of its
topmost window.

   In order to give a child frame a draggable header or mode line, the
window parameters ‘mode-line-format’ and ‘header-line-format’ are handy
(*note Window Parameters::).  These allow to remove an unwanted mode
line (when ‘drag-with-header-line’ is chosen) and to remove
mouse-sensitive areas which might interfere with frame dragging.

   To avoid that dragging moves a frame completely out of its parent’s
native frame, something which might happen when the mouse cursor
overshoots and makes the frame difficult to retrieve once the mouse
button has been released, it is advisable to set the frame’s
‘top-visible’ or ‘bottom-visible’ parameter correspondingly.

   The ‘top-visible’ parameter specifies the number of pixels at the top
of the frame that always remain visible within the parent’s native frame
during dragging and should be set when specifying a non-‘nil’
‘drag-with-header-line’ parameter.  The ‘bottom-visible’ parameter
specifies the number of pixels at the bottom of the frame that always
remain visible within the parent’s native frame during dragging and
should be preferred when specifying a non-‘nil’ ‘drag-with-mode-line’
parameter.

   When a child frame is used for displaying a buffer via
‘display-buffer-in-child-frame’ (*note Display Action Functions::), the
frame’s ‘auto-hide-function’ parameter (*note Frame Interaction
Parameters::) can be set to a function, in order to appropriately deal
with the frame when the window displaying the buffer shall be quit.

   When a child frame is used during minibuffer interaction, for
example, to display completions in a separate window, the
‘minibuffer-exit’ parameter (*note Frame Interaction Parameters::) is
useful in order to deal with the frame when the minibuffer is exited.

   The behavior of child frames deviates from that of top-level frames
in a number of other ways as well.  Here we sketch a few of them:

   • The semantics of maximizing and iconifying child frames is highly
     window-system dependent.  As a rule, applications should never
     invoke these operations on child frames.  By default, invoking
     ‘iconify-frame’ on a child frame will try to iconify the top-level
     frame corresponding to that child frame instead.  To obtain a
     different behavior, users may customize the option
     ‘iconify-child-frame’ described below.

   • Raising, lowering and restacking child frames (*note Raising and
     Lowering::) or changing the ‘z-group’ (*note Position Parameters::)
     of a child frame changes only the stacking order of child frames
     with the same parent.

   • Many window-systems are not able to change the opacity (*note Font
     and Color Parameters::) of child frames.

   • Transferring focus from a child frame to an ancestor that is not
     its parent by clicking with the mouse in a visible part of that
     ancestor’s window may fail with some window-systems.  You may have
     to click into the direct parent’s window-system window first.

   • Window managers might not bother to extend their focus follows
     mouse policy to child frames.  Customizing
     ‘mouse-autoselect-window’ can help in this regard (*note Mouse
     Window Auto-selection::).

   • Dropping (*note Drag and Drop::) on child frames is not guaranteed
     to work on all window-systems.  Some will drop the object on the
     parent frame or on some ancestor instead.

   The following two functions can be useful when working with child and
parent frames:

 -- Function: frame-parent &optional frame
     This function returns the parent frame of FRAME.  The parent frame
     of FRAME is the Emacs frame whose window-system window is the
     parent window of FRAME’s window-system window.  If such a frame
     exists, FRAME is considered a child frame of that frame.

     This function returns ‘nil’ if FRAME has no parent frame.

 -- Function: frame-ancestor-p ancestor descendant
     This functions returns non-‘nil’ if ANCESTOR is an ancestor of
     DESCENDANT.  ANCESTOR is an ancestor of DESCENDANT when it is
     either DESCENDANT’s parent frame or it is an ancestor of
     DESCENDANT’s parent frame.  Both, ANCESTOR and DESCENDANT must
     specify live frames.

   Note also the function ‘window-largest-empty-rectangle’ (*note
Coordinates and Windows::) which can be used to inscribe a child frame
in the largest empty area of an existing window.  This can be useful to
avoid that a child frame obscures any text shown in that window.

   Customizing the following option can be useful to tweak the behavior
of ‘iconify-frame’ for child frames.

 -- User Option: iconify-child-frame
     This option tells Emacs how to proceed when it is asked to iconify
     a child frame.  If it is ‘nil’, ‘iconify-frame’ will do nothing
     when invoked on a child frame.  If it is ‘iconify-top-level’, Emacs
     will try to iconify the top-level frame that is the ancestor of
     this child frame instead.  If it is ‘make-invisible’, Emacs will
     try to make this child frame invisible instead of iconifying it.

     Any other value means to try iconifying the child frame.  Since
     such an attempt may not be honored by all window managers and can
     even lead to making the child frame unresponsive to user actions,
     the default is to iconify the top level frame instead.


File: elisp.info,  Node: Mouse Tracking,  Next: Mouse Position,  Prev: Child Frames,  Up: Frames

29.15 Mouse Tracking
====================

Sometimes it is useful to “track” the mouse, which means to display
something to indicate where the mouse is and move the indicator as the
mouse moves.  For efficient mouse tracking, you need a way to wait until
the mouse actually moves.

   The convenient way to track the mouse is to ask for events to
represent mouse motion.  Then you can wait for motion by waiting for an
event.  In addition, you can easily handle any other sorts of events
that may occur.  That is useful, because normally you don’t want to
track the mouse forever—only until some other event, such as the release
of a button.

 -- Special Form: track-mouse body...
     This special form executes BODY, with generation of mouse motion
     events enabled.  Typically, BODY would use ‘read-event’ to read the
     motion events and modify the display accordingly.  *Note Motion
     Events::, for the format of mouse motion events.

     The value of ‘track-mouse’ is that of the last form in BODY.  You
     should design BODY to return when it sees the up-event that
     indicates the release of the button, or whatever kind of event
     means it is time to stop tracking.

     The ‘track-mouse’ form causes Emacs to generate mouse motion events
     by binding the variable ‘track-mouse’ to a non-‘nil’ value.  If
     that variable has the special value ‘dragging’, it additionally
     instructs the display engine to refrain from changing the shape of
     the mouse pointer.  This is desirable in Lisp programs that require
     mouse dragging across large portions of Emacs display, which might
     otherwise cause the mouse pointer to change its shape according to
     the display portion it hovers on (*note Pointer Shape::).
     Therefore, Lisp programs that need the mouse pointer to retain its
     original shape during dragging should bind ‘track-mouse’ to the
     value ‘dragging’ at the beginning of their BODY.

   The usual purpose of tracking mouse motion is to indicate on the
screen the consequences of pushing or releasing a button at the current
position.

   In many cases, you can avoid the need to track the mouse by using the
‘mouse-face’ text property (*note Special Properties::).  That works at
a much lower level and runs more smoothly than Lisp-level mouse
tracking.


File: elisp.info,  Node: Mouse Position,  Next: Pop-Up Menus,  Prev: Mouse Tracking,  Up: Frames

29.16 Mouse Position
====================

The functions ‘mouse-position’ and ‘set-mouse-position’ give access to
the current position of the mouse.

 -- Function: mouse-position
     This function returns a description of the position of the mouse.
     The value looks like ‘(FRAME X . Y)’, where X and Y are integers
     giving the (possibly rounded) position in multiples of the default
     character size of FRAME (*note Frame Font::) relative to the native
     position of FRAME (*note Frame Geometry::).

 -- Variable: mouse-position-function
     If non-‘nil’, the value of this variable is a function for
     ‘mouse-position’ to call.  ‘mouse-position’ calls this function
     just before returning, with its normal return value as the sole
     argument, and it returns whatever this function returns to it.

     This abnormal hook exists for the benefit of packages like
     ‘xt-mouse.el’ that need to do mouse handling at the Lisp level.

 -- Function: set-mouse-position frame x y
     This function “warps the mouse” to position X, Y in frame FRAME.
     The arguments X and Y are integers, giving the position in
     multiples of the default character size of FRAME (*note Frame
     Font::) relative to the native position of FRAME (*note Frame
     Geometry::).

     The resulting mouse position is constrained to the native frame of
     FRAME.  If FRAME is not visible, this function does nothing.  The
     return value is not significant.

 -- Function: mouse-pixel-position
     This function is like ‘mouse-position’ except that it returns
     coordinates in units of pixels rather than units of characters.

 -- Function: set-mouse-pixel-position frame x y
     This function warps the mouse like ‘set-mouse-position’ except that
     X and Y are in units of pixels rather than units of characters.

     The resulting mouse position is not constrained to the native frame
     of FRAME.  If FRAME is not visible, this function does nothing.
     The return value is not significant.

   On a graphical terminal the following two functions allow the
absolute position of the mouse cursor to be retrieved and set.

 -- Function: mouse-absolute-pixel-position
     This function returns a cons cell (X .  Y) of the coordinates of
     the mouse cursor position in pixels, relative to a position (0, 0)
     of the selected frame’s display.

 -- Function: set-mouse-absolute-pixel-position x y
     This function moves the mouse cursor to the position (X, Y).  The
     coordinates X and Y are interpreted in pixels relative to a
     position (0, 0) of the selected frame’s display.

   The following function can tell whether the mouse cursor is currently
visible on a frame:

 -- Function: frame-pointer-visible-p &optional frame
     This predicate function returns non-‘nil’ if the mouse pointer
     displayed on FRAME is visible; otherwise it returns ‘nil’.  FRAME
     omitted or ‘nil’ means the selected frame.  This is useful when
     ‘make-pointer-invisible’ is set to ‘t’: it allows you to know if
     the pointer has been hidden.  *Note (emacs)Mouse Avoidance::.


File: elisp.info,  Node: Pop-Up Menus,  Next: Dialog Boxes,  Prev: Mouse Position,  Up: Frames

29.17 Pop-Up Menus
==================

A Lisp program can pop up a menu so that the user can choose an
alternative with the mouse.  On a text terminal, if the mouse is not
available, the user can choose an alternative using the keyboard motion
keys—‘C-n’, ‘C-p’, or up- and down-arrow keys.

 -- Function: x-popup-menu position menu
     This function displays a pop-up menu and returns an indication of
     what selection the user makes.

     The argument POSITION specifies where on the screen to put the top
     left corner of the menu.  It can be either a mouse button event
     (which says to put the menu where the user actuated the button) or
     a list of this form:

          ((XOFFSET YOFFSET) WINDOW)

     where XOFFSET and YOFFSET are coordinates, measured in pixels,
     counting from the top left corner of WINDOW.  WINDOW may be a
     window or a frame.

     If POSITION is ‘t’, it means to use the current mouse position (or
     the top-left corner of the frame if the mouse is not available on a
     text terminal).  If POSITION is ‘nil’, it means to precompute the
     key binding equivalents for the keymaps specified in MENU, without
     actually displaying or popping up the menu.

     The argument MENU says what to display in the menu.  It can be a
     keymap or a list of keymaps (*note Menu Keymaps::).  In this case,
     the return value is the list of events corresponding to the user’s
     choice.  This list has more than one element if the choice occurred
     in a submenu.  (Note that ‘x-popup-menu’ does not actually execute
     the command bound to that sequence of events.)  On text terminals
     and toolkits that support menu titles, the title is taken from the
     prompt string of MENU if MENU is a keymap, or from the prompt
     string of the first keymap in MENU if it is a list of keymaps
     (*note Defining Menus::).

     Alternatively, MENU can have the following form:

          (TITLE PANE1 PANE2...)

     where each pane is a list of form

          (TITLE ITEM1 ITEM2...)

     Each ITEM should be a cons cell, ‘(LINE . VALUE)’, where LINE is a
     string and VALUE is the value to return if that LINE is chosen.
     Unlike in a menu keymap, a ‘nil’ VALUE does not make the menu item
     non-selectable.  Alternatively, each ITEM can be a string rather
     than a cons cell; this makes a non-selectable menu item.

     If the user gets rid of the menu without making a valid choice, for
     instance by clicking the mouse away from a valid choice or by
     typing ‘C-g’, then this normally results in a quit and
     ‘x-popup-menu’ does not return.  But if POSITION is a mouse button
     event (indicating that the user invoked the menu with the mouse)
     then no quit occurs and ‘x-popup-menu’ returns ‘nil’.

   *Usage note:* Don’t use ‘x-popup-menu’ to display a menu if you could
do the job with a prefix key defined with a menu keymap.  If you use a
menu keymap to implement a menu, ‘C-h c’ and ‘C-h a’ can see the
individual items in that menu and provide help for them.  If instead you
implement the menu by defining a command that calls ‘x-popup-menu’, the
help facilities cannot know what happens inside that command, so they
cannot give any help for the menu’s items.

   The menu bar mechanism, which lets you switch between submenus by
moving the mouse, cannot look within the definition of a command to see
that it calls ‘x-popup-menu’.  Therefore, if you try to implement a
submenu using ‘x-popup-menu’, it cannot work with the menu bar in an
integrated fashion.  This is why all menu bar submenus are implemented
with menu keymaps within the parent menu, and never with ‘x-popup-menu’.
*Note Menu Bar::.

   If you want a menu bar submenu to have contents that vary, you should
still use a menu keymap to implement it.  To make the contents vary, add
a hook function to ‘menu-bar-update-hook’ to update the contents of the
menu keymap as necessary.


File: elisp.info,  Node: Dialog Boxes,  Next: Pointer Shape,  Prev: Pop-Up Menus,  Up: Frames

29.18 Dialog Boxes
==================

A dialog box is a variant of a pop-up menu—it looks a little different,
it always appears in the center of a frame, and it has just one level
and one or more buttons.  The main use of dialog boxes is for asking
questions that the user can answer with “yes”, “no”, and a few other
alternatives.  With a single button, they can also force the user to
acknowledge important information.  The functions ‘y-or-n-p’ and
‘yes-or-no-p’ use dialog boxes instead of the keyboard, when called from
commands invoked by mouse clicks.

 -- Function: x-popup-dialog position contents &optional header
     This function displays a pop-up dialog box and returns an
     indication of what selection the user makes.  The argument CONTENTS
     specifies the alternatives to offer; it has this format:

          (TITLE (STRING . VALUE)...)

     which looks like the list that specifies a single pane for
     ‘x-popup-menu’.

     The return value is VALUE from the chosen alternative.

     As for ‘x-popup-menu’, an element of the list may be just a string
     instead of a cons cell ‘(STRING . VALUE)’.  That makes a box that
     cannot be selected.

     If ‘nil’ appears in the list, it separates the left-hand items from
     the right-hand items; items that precede the ‘nil’ appear on the
     left, and items that follow the ‘nil’ appear on the right.  If you
     don’t include a ‘nil’ in the list, then approximately half the
     items appear on each side.

     Dialog boxes always appear in the center of a frame; the argument
     POSITION specifies which frame.  The possible values are as in
     ‘x-popup-menu’, but the precise coordinates or the individual
     window don’t matter; only the frame matters.

     If HEADER is non-‘nil’, the frame title for the box is
     ‘Information’, otherwise it is ‘Question’.  The former is used for
     ‘message-box’ (*note message-box::).  (On text terminals, the box
     title is not displayed.)

     In some configurations, Emacs cannot display a real dialog box; so
     instead it displays the same items in a pop-up menu in the center
     of the frame.

     If the user gets rid of the dialog box without making a valid
     choice, for instance using the window manager, then this produces a
     quit and ‘x-popup-dialog’ does not return.


File: elisp.info,  Node: Pointer Shape,  Next: Window System Selections,  Prev: Dialog Boxes,  Up: Frames

29.19 Pointer Shape
===================

You can specify the mouse pointer style for particular text or images
using the ‘pointer’ text property, and for images with the ‘:pointer’
and ‘:map’ image properties.  The values you can use in these properties
are ‘text’ (or ‘nil’), ‘arrow’, ‘hand’, ‘vdrag’, ‘hdrag’, ‘modeline’,
and ‘hourglass’.  ‘text’ stands for the usual mouse pointer style used
over text.

   Over void parts of the window (parts that do not correspond to any of
the buffer contents), the mouse pointer usually uses the ‘arrow’ style,
but you can specify a different style (one of those above) by setting
‘void-text-area-pointer’.

 -- User Option: void-text-area-pointer
     This variable specifies the mouse pointer style for void text
     areas.  These include the areas after the end of a line or below
     the last line in the buffer.  The default is to use the ‘arrow’
     (non-text) pointer style.

   When using X, you can specify what the ‘text’ pointer style really
looks like by setting the variable ‘x-pointer-shape’.

 -- Variable: x-pointer-shape
     This variable specifies the pointer shape to use ordinarily in the
     Emacs frame, for the ‘text’ pointer style.

 -- Variable: x-sensitive-text-pointer-shape
     This variable specifies the pointer shape to use when the mouse is
     over mouse-sensitive text.

   These variables affect newly created frames.  They do not normally
affect existing frames; however, if you set the mouse color of a frame,
that also installs the current value of those two variables.  *Note Font
and Color Parameters::.

   The values you can use, to specify either of these pointer shapes,
are defined in the file ‘lisp/term/x-win.el’.  Use ‘M-x apropos <RET>
x-pointer <RET>’ to see a list of them.


File: elisp.info,  Node: Window System Selections,  Next: Drag and Drop,  Prev: Pointer Shape,  Up: Frames

29.20 Window System Selections
==============================

In window systems, such as X, data can be transferred between different
applications by means of “selections”.  X defines an arbitrary number of
“selection types”, each of which can store its own data; however, only
three are commonly used: the “clipboard”, “primary selection”, and
“secondary selection”.  Other window systems support only the clipboard.
*Note Cut and Paste: (emacs)Cut and Paste, for Emacs commands that make
use of these selections.  This section documents the low-level functions
for reading and setting window-system selections.

 -- Command: gui-set-selection type data
     This function sets a window-system selection.  It takes two
     arguments: a selection type TYPE, and the value to assign to it,
     DATA.

     TYPE should be a symbol; it is usually one of ‘PRIMARY’,
     ‘SECONDARY’ or ‘CLIPBOARD’.  These are symbols with upper-case
     names, in accord with X Window System conventions.  If TYPE is
     ‘nil’, that stands for ‘PRIMARY’.

     If DATA is ‘nil’, it means to clear out the selection.  Otherwise,
     DATA may be a string, a symbol, an integer (or a cons of two
     integers or list of two integers), an overlay, or a cons of two
     markers pointing to the same buffer.  An overlay or a pair of
     markers stands for text in the overlay or between the markers.  The
     argument DATA may also be a vector of valid non-vector selection
     values.

     This function returns DATA.

 -- Function: gui-get-selection &optional type data-type
     This function accesses selections set up by Emacs or by other
     programs.  It takes two optional arguments, TYPE and DATA-TYPE.
     The default for TYPE, the selection type, is ‘PRIMARY’.

     The DATA-TYPE argument specifies the form of data conversion to
     use, to convert the raw data obtained from another program into
     Lisp data.  Meaningful values include ‘TEXT’, ‘STRING’,
     ‘UTF8_STRING’, ‘TARGETS’, ‘LENGTH’, ‘DELETE’, ‘FILE_NAME’,
     ‘CHARACTER_POSITION’, ‘NAME’, ‘LINE_NUMBER’, ‘COLUMN_NUMBER’,
     ‘OWNER_OS’, ‘HOST_NAME’, ‘USER’, ‘CLASS’, ‘ATOM’, and ‘INTEGER’.
     (These are symbols with upper-case names in accord with X
     conventions.)  The default for DATA-TYPE is ‘STRING’.  Window
     systems other than X usually support only a small subset of these
     types, in addition to ‘STRING’.

 -- User Option: selection-coding-system
     This variable specifies the coding system to use when reading and
     writing selections or the clipboard.  *Note Coding Systems::.  The
     default is ‘compound-text-with-extensions’, which converts to the
     text representation that X11 normally uses.

   When Emacs runs on MS-Windows, it does not implement X selections in
general, but it does support the clipboard.  ‘gui-get-selection’ and
‘gui-set-selection’ on MS-Windows support the text data type only; if
the clipboard holds other types of data, Emacs treats the clipboard as
empty.  The supported data type is ‘STRING’.

   For backward compatibility, there are obsolete aliases
‘x-get-selection’ and ‘x-set-selection’, which were the names of
‘gui-get-selection’ and ‘gui-set-selection’ before Emacs 25.1.


File: elisp.info,  Node: Drag and Drop,  Next: Color Names,  Prev: Window System Selections,  Up: Frames

29.21 Drag and Drop
===================

When a user drags something from another application over Emacs, that
other application expects Emacs to tell it if Emacs can handle the data
that is dragged.  The variable ‘x-dnd-test-function’ is used by Emacs to
determine what to reply.  The default value is
‘x-dnd-default-test-function’ which accepts drops if the type of the
data to be dropped is present in ‘x-dnd-known-types’.  You can customize
‘x-dnd-test-function’ and/or ‘x-dnd-known-types’ if you want Emacs to
accept or reject drops based on some other criteria.

   If you want to change the way Emacs handles drop of different types
or add a new type, customize ‘x-dnd-types-alist’.  This requires
detailed knowledge of what types other applications use for drag and
drop.

   When an URL is dropped on Emacs it may be a file, but it may also be
another URL type (ftp, http, etc.).  Emacs first checks
‘dnd-protocol-alist’ to determine what to do with the URL.  If there is
no match there and if ‘browse-url-browser-function’ is an alist, Emacs
looks for a match there.  If no match is found the text for the URL is
inserted.  If you want to alter Emacs behavior, you can customize these
variables.


File: elisp.info,  Node: Color Names,  Next: Text Terminal Colors,  Prev: Drag and Drop,  Up: Frames

29.22 Color Names
=================

A color name is text (usually in a string) that specifies a color.
Symbolic names such as ‘black’, ‘white’, ‘red’, etc., are allowed; use
‘M-x list-colors-display’ to see a list of defined names.  You can also
specify colors numerically in forms such as ‘#RGB’ and ‘RGB:R/G/B’,
where R specifies the red level, G specifies the green level, and B
specifies the blue level.  You can use either one, two, three, or four
hex digits for R; then you must use the same number of hex digits for
all G and B as well, making either 3, 6, 9 or 12 hex digits in all.
(See the documentation of the X Window System for more details about
numerical RGB specification of colors.)

   These functions provide a way to determine which color names are
valid, and what they look like.  In some cases, the value depends on the
“selected frame”, as described below; see *note Input Focus::, for the
meaning of the term “selected frame”.

   To read user input of color names with completion, use ‘read-color’
(*note read-color: High-Level Completion.).

 -- Function: color-defined-p color &optional frame
     This function reports whether a color name is meaningful.  It
     returns ‘t’ if so; otherwise, ‘nil’.  The argument FRAME says which
     frame’s display to ask about; if FRAME is omitted or ‘nil’, the
     selected frame is used.

     Note that this does not tell you whether the display you are using
     really supports that color.  When using X, you can ask for any
     defined color on any kind of display, and you will get some
     result—typically, the closest it can do.  To determine whether a
     frame can really display a certain color, use ‘color-supported-p’
     (see below).

     This function used to be called ‘x-color-defined-p’, and that name
     is still supported as an alias.

 -- Function: defined-colors &optional frame
     This function returns a list of the color names that are defined
     and supported on frame FRAME (default, the selected frame).  If
     FRAME does not support colors, the value is ‘nil’.

     This function used to be called ‘x-defined-colors’, and that name
     is still supported as an alias.

 -- Function: color-supported-p color &optional frame background-p
     This returns ‘t’ if FRAME can really display the color COLOR (or at
     least something close to it).  If FRAME is omitted or ‘nil’, the
     question applies to the selected frame.

     Some terminals support a different set of colors for foreground and
     background.  If BACKGROUND-P is non-‘nil’, that means you are
     asking whether COLOR can be used as a background; otherwise you are
     asking whether it can be used as a foreground.

     The argument COLOR must be a valid color name.

 -- Function: color-gray-p color &optional frame
     This returns ‘t’ if COLOR is a shade of gray, as defined on FRAME’s
     display.  If FRAME is omitted or ‘nil’, the question applies to the
     selected frame.  If COLOR is not a valid color name, this function
     returns ‘nil’.

 -- Function: color-values color &optional frame
     This function returns a value that describes what COLOR should
     ideally look like on FRAME.  If COLOR is defined, the value is a
     list of three integers, which give the amount of red, the amount of
     green, and the amount of blue.  Each integer ranges in principle
     from 0 to 65535, but some displays may not use the full range.
     This three-element list is called the “rgb values” of the color.

     If COLOR is not defined, the value is ‘nil’.

          (color-values "black")
               ⇒ (0 0 0)
          (color-values "white")
               ⇒ (65280 65280 65280)
          (color-values "red")
               ⇒ (65280 0 0)
          (color-values "pink")
               ⇒ (65280 49152 51968)
          (color-values "hungry")
               ⇒ nil

     The color values are returned for FRAME’s display.  If FRAME is
     omitted or ‘nil’, the information is returned for the selected
     frame’s display.  If the frame cannot display colors, the value is
     ‘nil’.

     This function used to be called ‘x-color-values’, and that name is
     still supported as an alias.


File: elisp.info,  Node: Text Terminal Colors,  Next: Resources,  Prev: Color Names,  Up: Frames

29.23 Text Terminal Colors
==========================

Text terminals usually support only a small number of colors, and the
computer uses small integers to select colors on the terminal.  This
means that the computer cannot reliably tell what the selected color
looks like; instead, you have to inform your application which small
integers correspond to which colors.  However, Emacs does know the
standard set of colors and will try to use them automatically.

   The functions described in this section control how terminal colors
are used by Emacs.

   Several of these functions use or return “rgb values”, described in
*note Color Names::.

   These functions accept a display (either a frame or the name of a
terminal) as an optional argument.  We hope in the future to make Emacs
support different colors on different text terminals; then this argument
will specify which terminal to operate on (the default being the
selected frame’s terminal; *note Input Focus::).  At present, though,
the FRAME argument has no effect.

 -- Function: tty-color-define name number &optional rgb frame
     This function associates the color name NAME with color number
     NUMBER on the terminal.

     The optional argument RGB, if specified, is an rgb value, a list of
     three numbers that specify what the color actually looks like.  If
     you do not specify RGB, then this color cannot be used by
     ‘tty-color-approximate’ to approximate other colors, because Emacs
     will not know what it looks like.

 -- Function: tty-color-clear &optional frame
     This function clears the table of defined colors for a text
     terminal.

 -- Function: tty-color-alist &optional frame
     This function returns an alist recording the known colors supported
     by a text terminal.

     Each element has the form ‘(NAME NUMBER . RGB)’ or ‘(NAME NUMBER)’.
     Here, NAME is the color name, NUMBER is the number used to specify
     it to the terminal.  If present, RGB is a list of three color
     values (for red, green, and blue) that says what the color actually
     looks like.

 -- Function: tty-color-approximate rgb &optional frame
     This function finds the closest color, among the known colors
     supported for DISPLAY, to that described by the rgb value RGB (a
     list of color values).  The return value is an element of
     ‘tty-color-alist’.

 -- Function: tty-color-translate color &optional frame
     This function finds the closest color to COLOR among the known
     colors supported for DISPLAY and returns its index (an integer).
     If the name COLOR is not defined, the value is ‘nil’.


File: elisp.info,  Node: Resources,  Next: Display Feature Testing,  Prev: Text Terminal Colors,  Up: Frames

29.24 X Resources
=================

This section describes some of the functions and variables for querying
and using X resources, or their equivalent on your operating system.
*Note X Resources: (emacs)X Resources, for more information about X
resources.

 -- Function: x-get-resource attribute class &optional component
          subclass
     The function ‘x-get-resource’ retrieves a resource value from the X
     Window defaults database.

     Resources are indexed by a combination of a “key” and a “class”.
     This function searches using a key of the form ‘INSTANCE.ATTRIBUTE’
     (where INSTANCE is the name under which Emacs was invoked), and
     using ‘Emacs.CLASS’ as the class.

     The optional arguments COMPONENT and SUBCLASS add to the key and
     the class, respectively.  You must specify both of them or neither.
     If you specify them, the key is ‘INSTANCE.COMPONENT.ATTRIBUTE’, and
     the class is ‘Emacs.CLASS.SUBCLASS’.

 -- Variable: x-resource-class
     This variable specifies the application name that ‘x-get-resource’
     should look up.  The default value is ‘"Emacs"’.  You can examine X
     resources for other application names by binding this variable to
     some other string, around a call to ‘x-get-resource’.

 -- Variable: x-resource-name
     This variable specifies the instance name that ‘x-get-resource’
     should look up.  The default value is the name Emacs was invoked
     with, or the value specified with the ‘-name’ or ‘-rn’ switches.

   To illustrate some of the above, suppose that you have the line:

     xterm.vt100.background: yellow

in your X resources file (whose name is usually ‘~/.Xdefaults’ or
‘~/.Xresources’).  Then:

     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "vt100.background" "VT100.Background"))
          ⇒ "yellow"
     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "background" "VT100" "vt100" "Background"))
          ⇒ "yellow"

 -- Variable: inhibit-x-resources
     If this variable is non-‘nil’, Emacs does not look up X resources,
     and X resources do not have any effect when creating new frames.


File: elisp.info,  Node: Display Feature Testing,  Prev: Resources,  Up: Frames

29.25 Display Feature Testing
=============================

The functions in this section describe the basic capabilities of a
particular display.  Lisp programs can use them to adapt their behavior
to what the display can do.  For example, a program that ordinarily uses
a popup menu could use the minibuffer if popup menus are not supported.

   The optional argument DISPLAY in these functions specifies which
display to ask the question about.  It can be a display name, a frame
(which designates the display that frame is on), or ‘nil’ (which refers
to the selected frame’s display, *note Input Focus::).

   *Note Color Names::, *note Text Terminal Colors::, for other
functions to obtain information about displays.

 -- Function: display-popup-menus-p &optional display
     This function returns ‘t’ if popup menus are supported on DISPLAY,
     ‘nil’ if not.  Support for popup menus requires that the mouse be
     available, since the menu is popped up by clicking the mouse on
     some portion of the Emacs display.

 -- Function: display-graphic-p &optional display
     This function returns ‘t’ if DISPLAY is a graphic display capable
     of displaying several frames and several different fonts at once.
     This is true for displays that use a window system such as X, and
     false for text terminals.

 -- Function: display-mouse-p &optional display
     This function returns ‘t’ if DISPLAY has a mouse available, ‘nil’
     if not.

 -- Function: display-color-p &optional display
     This function returns ‘t’ if the screen is a color screen.  It used
     to be called ‘x-display-color-p’, and that name is still supported
     as an alias.

 -- Function: display-grayscale-p &optional display
     This function returns ‘t’ if the screen can display shades of gray.
     (All color displays can do this.)

 -- Function: display-supports-face-attributes-p attributes &optional
          display
     This function returns non-‘nil’ if all the face attributes in
     ATTRIBUTES are supported (*note Face Attributes::).

     The definition of “supported” is somewhat heuristic, but basically
     means that a face containing all the attributes in ATTRIBUTES, when
     merged with the default face for display, can be represented in a
     way that’s

       1. different in appearance than the default face, and

       2. close in spirit to what the attributes specify, if not exact.

     Point (2) implies that a ‘:weight black’ attribute will be
     satisfied by any display that can display bold, as will
     ‘:foreground "yellow"’ as long as some yellowish color can be
     displayed, but ‘:slant italic’ will _not_ be satisfied by the tty
     display code’s automatic substitution of a dim face for italic.

 -- Function: display-selections-p &optional display
     This function returns ‘t’ if DISPLAY supports selections.  Windowed
     displays normally support selections, but they may also be
     supported in some other cases.

 -- Function: display-images-p &optional display
     This function returns ‘t’ if DISPLAY can display images.  Windowed
     displays ought in principle to handle images, but some systems lack
     the support for that.  On a display that does not support images,
     Emacs cannot display a tool bar.

 -- Function: display-screens &optional display
     This function returns the number of screens associated with the
     display.

 -- Function: display-pixel-height &optional display
     This function returns the height of the screen in pixels.  On a
     character terminal, it gives the height in characters.

     For graphical terminals, note that on multi-monitor setups this
     refers to the pixel height for all physical monitors associated
     with DISPLAY.  *Note Multiple Terminals::.

 -- Function: display-pixel-width &optional display
     This function returns the width of the screen in pixels.  On a
     character terminal, it gives the width in characters.

     For graphical terminals, note that on multi-monitor setups this
     refers to the pixel width for all physical monitors associated with
     DISPLAY.  *Note Multiple Terminals::.

 -- Function: display-mm-height &optional display
     This function returns the height of the screen in millimeters, or
     ‘nil’ if Emacs cannot get that information.

     For graphical terminals, note that on multi-monitor setups this
     refers to the height for all physical monitors associated with
     DISPLAY.  *Note Multiple Terminals::.

 -- Function: display-mm-width &optional display
     This function returns the width of the screen in millimeters, or
     ‘nil’ if Emacs cannot get that information.

     For graphical terminals, note that on multi-monitor setups this
     refers to the width for all physical monitors associated with
     DISPLAY.  *Note Multiple Terminals::.

 -- User Option: display-mm-dimensions-alist
     This variable allows the user to specify the dimensions of
     graphical displays returned by ‘display-mm-height’ and
     ‘display-mm-width’ in case the system provides incorrect values.

 -- Function: display-backing-store &optional display
     This function returns the backing store capability of the display.
     Backing store means recording the pixels of windows (and parts of
     windows) that are not exposed, so that when exposed they can be
     displayed very quickly.

     Values can be the symbols ‘always’, ‘when-mapped’, or ‘not-useful’.
     The function can also return ‘nil’ when the question is
     inapplicable to a certain kind of display.

 -- Function: display-save-under &optional display
     This function returns non-‘nil’ if the display supports the
     SaveUnder feature.  That feature is used by pop-up windows to save
     the pixels they obscure, so that they can pop down quickly.

 -- Function: display-planes &optional display
     This function returns the number of planes the display supports.
     This is typically the number of bits per pixel.  For a tty display,
     it is log to base two of the number of colors supported.

 -- Function: display-visual-class &optional display
     This function returns the visual class for the screen.  The value
     is one of the symbols ‘static-gray’ (a limited, unchangeable number
     of grays), ‘gray-scale’ (a full range of grays), ‘static-color’ (a
     limited, unchangeable number of colors), ‘pseudo-color’ (a limited
     number of colors), ‘true-color’ (a full range of colors), and
     ‘direct-color’ (a full range of colors).

 -- Function: display-color-cells &optional display
     This function returns the number of color cells the screen
     supports.

   These functions obtain additional information about the window system
in use where Emacs shows the specified DISPLAY.  (Their names begin with
‘x-’ for historical reasons.)

 -- Function: x-server-version &optional display
     This function returns the list of version numbers of the GUI window
     system running on DISPLAY, such as the X server on GNU and Unix
     systems.  The value is a list of three integers: the major and
     minor version numbers of the protocol, and the distributor-specific
     release number of the window system software itself.  On GNU and
     Unix systems, these are normally the version of the X protocol and
     the distributor-specific release number of the X server software.
     On MS-Windows, this is the version of the Windows OS.

 -- Function: x-server-vendor &optional display
     This function returns the vendor that provided the window system
     software (as a string).  On GNU and Unix systems this really means
     whoever distributes the X server.  On MS-Windows this is the vendor
     ID string of the Windows OS (Microsoft).

     When the developers of X labeled software distributors as
     “vendors”, they showed their false assumption that no system could
     ever be developed and distributed noncommercially.


File: elisp.info,  Node: Positions,  Next: Markers,  Prev: Frames,  Up: Top

30 Positions
************

A “position” is the index of a character in the text of a buffer.  More
precisely, a position identifies the place between two characters (or
before the first character, or after the last character), so we can
speak of the character before or after a given position.  However, we
often speak of the character “at” a position, meaning the character
after that position.

   Positions are usually represented as integers starting from 1, but
can also be represented as “markers”—special objects that relocate
automatically when text is inserted or deleted so they stay with the
surrounding characters.  Functions that expect an argument to be a
position (an integer), but accept a marker as a substitute, normally
ignore which buffer the marker points into; they convert the marker to
an integer, and use that integer, exactly as if you had passed the
integer as the argument, even if the marker points to the wrong buffer.
A marker that points nowhere cannot convert to an integer; using it
instead of an integer causes an error.  *Note Markers::.

   See also the field feature (*note Fields::), which provides functions
that are used by many cursor-motion commands.

* Menu:

* Point::         The special position where editing takes place.
* Motion::        Changing point.
* Excursions::    Temporary motion and buffer changes.
* Narrowing::     Restricting editing to a portion of the buffer.


File: elisp.info,  Node: Point,  Next: Motion,  Up: Positions

30.1 Point
==========

“Point” is a special buffer position used by many editing commands,
including the self-inserting typed characters and text insertion
functions.  Other commands move point through the text to allow editing
and insertion at different places.

   Like other positions, point designates a place between two characters
(or before the first character, or after the last character), rather
than a particular character.  Usually terminals display the cursor over
the character that immediately follows point; point is actually before
the character on which the cursor sits.

   The value of point is a number no less than 1, and no greater than
the buffer size plus 1.  If narrowing is in effect (*note Narrowing::),
then point is constrained to fall within the accessible portion of the
buffer (possibly at one end of it).

   Each buffer has its own value of point, which is independent of the
value of point in other buffers.  Each window also has a value of point,
which is independent of the value of point in other windows on the same
buffer.  This is why point can have different values in various windows
that display the same buffer.  When a buffer appears in only one window,
the buffer’s point and the window’s point normally have the same value,
so the distinction is rarely important.  *Note Window Point::, for more
details.

 -- Function: point
     This function returns the value of point in the current buffer, as
     an integer.

          (point)
               ⇒ 175

 -- Function: point-min
     This function returns the minimum accessible value of point in the
     current buffer.  This is normally 1, but if narrowing is in effect,
     it is the position of the start of the region that you narrowed to.
     (*Note Narrowing::.)

 -- Function: point-max
     This function returns the maximum accessible value of point in the
     current buffer.  This is ‘(1+ (buffer-size))’, unless narrowing is
     in effect, in which case it is the position of the end of the
     region that you narrowed to.  (*Note Narrowing::.)

 -- Function: buffer-end flag
     This function returns ‘(point-max)’ if FLAG is greater than 0,
     ‘(point-min)’ otherwise.  The argument FLAG must be a number.

 -- Function: buffer-size &optional buffer
     This function returns the total number of characters in the current
     buffer.  In the absence of any narrowing (*note Narrowing::),
     ‘point-max’ returns a value one larger than this.

     If you specify a buffer, BUFFER, then the value is the size of
     BUFFER.

          (buffer-size)
               ⇒ 35
          (point-max)
               ⇒ 36


File: elisp.info,  Node: Motion,  Next: Excursions,  Prev: Point,  Up: Positions

30.2 Motion
===========

Motion functions change the value of point, either relative to the
current value of point, relative to the beginning or end of the buffer,
or relative to the edges of the selected window.  *Note Point::.

* Menu:

* Character Motion::       Moving in terms of characters.
* Word Motion::            Moving in terms of words.
* Buffer End Motion::      Moving to the beginning or end of the buffer.
* Text Lines::             Moving in terms of lines of text.
* Screen Lines::           Moving in terms of lines as displayed.
* List Motion::            Moving by parsing lists and sexps.
* Skipping Characters::    Skipping characters belonging to a certain set.


File: elisp.info,  Node: Character Motion,  Next: Word Motion,  Up: Motion

30.2.1 Motion by Characters
---------------------------

These functions move point based on a count of characters.  ‘goto-char’
is the fundamental primitive; the other functions use that.

 -- Command: goto-char position
     This function sets point in the current buffer to the value
     POSITION.

     If narrowing is in effect, POSITION still counts from the beginning
     of the buffer, but point cannot go outside the accessible portion.
     If POSITION is out of range, ‘goto-char’ moves point to the
     beginning or the end of the accessible portion.

     When this function is called interactively, POSITION is the numeric
     prefix argument, if provided; otherwise it is read from the
     minibuffer.

     ‘goto-char’ returns POSITION.

 -- Command: forward-char &optional count
     This function moves point COUNT characters forward, towards the end
     of the buffer (or backward, towards the beginning of the buffer, if
     COUNT is negative).  If COUNT is ‘nil’, the default is 1.

     If this attempts to move past the beginning or end of the buffer
     (or the limits of the accessible portion, when narrowing is in
     effect), it signals an error with error symbol
     ‘beginning-of-buffer’ or ‘end-of-buffer’.

     In an interactive call, COUNT is the numeric prefix argument.

 -- Command: backward-char &optional count
     This is just like ‘forward-char’ except that it moves in the
     opposite direction.


File: elisp.info,  Node: Word Motion,  Next: Buffer End Motion,  Prev: Character Motion,  Up: Motion

30.2.2 Motion by Words
----------------------

The functions for parsing words described below use the syntax table and
‘char-script-table’ to decide whether a given character is part of a
word.  *Note Syntax Tables::, and see *note Character Properties::.

 -- Command: forward-word &optional count
     This function moves point forward COUNT words (or backward if COUNT
     is negative).  If COUNT is omitted or ‘nil’, it defaults to 1.  In
     an interactive call, COUNT is specified by the numeric prefix
     argument.

     “Moving one word” means moving until point crosses a
     word-constituent character, which indicates the beginning of a
     word, and then continue moving until the word ends.  By default,
     characters that begin and end words, known as “word boundaries”,
     are defined by the current buffer’s syntax table (*note Syntax
     Class Table::), but modes can override that by setting up a
     suitable ‘find-word-boundary-function-table’, described below.
     Characters that belong to different scripts (as defined by
     ‘char-script-table’), also define a word boundary (*note Character
     Properties::).  In any case, this function cannot move point past
     the boundary of the accessible portion of the buffer, or across a
     field boundary (*note Fields::).  The most common case of a field
     boundary is the end of the prompt in the minibuffer.

     If it is possible to move COUNT words, without being stopped
     prematurely by the buffer boundary or a field boundary, the value
     is ‘t’.  Otherwise, the return value is ‘nil’ and point stops at
     the buffer boundary or field boundary.

     If ‘inhibit-field-text-motion’ is non-‘nil’, this function ignores
     field boundaries.

 -- Command: backward-word &optional count
     This function is just like ‘forward-word’, except that it moves
     backward until encountering the front of a word, rather than
     forward.

 -- User Option: words-include-escapes
     This variable affects the behavior of ‘forward-word’ and
     ‘backward-word’, and everything that uses them.  If it is
     non-‘nil’, then characters in the escape and character-quote syntax
     classes count as part of words.  Otherwise, they do not.

 -- Variable: inhibit-field-text-motion
     If this variable is non-‘nil’, certain motion functions including
     ‘forward-word’, ‘forward-sentence’, and ‘forward-paragraph’ ignore
     field boundaries.

 -- Variable: find-word-boundary-function-table
     This variable affects the behavior of ‘forward-word’ and
     ‘backward-word’, and everything that uses them.  Its value is a
     char-table (*note Char-Tables::) of functions to search for word
     boundaries.  If a character has a non-‘nil’ entry in this table,
     then when a word starts or ends with that character, the
     corresponding function will be called with 2 arguments: POS and
     LIMIT.  The function should return the position of the other word
     boundary.  Specifically, if POS is smaller than LIMIT, then POS is
     at the beginning of a word, and the function should return the
     position after the last character of the word; otherwise, POS is at
     the last character of a word, and the function should return the
     position of that word’s first character.

 -- Function: forward-word-strictly &optional count
     This function is like ‘forward-word’, but it is not affected by
     ‘find-word-boundary-function-table’.  Lisp programs that should not
     change behavior when word movement is modified by modes which set
     that table, such as ‘subword-mode’, should use this function
     instead of ‘forward-word’.

 -- Function: backward-word-strictly &optional count
     This function is like ‘backward-word’, but it is not affected by
     ‘find-word-boundary-function-table’.  Like with
     ‘forward-word-strictly’, use this function instead of
     ‘backward-word’ when movement by words should only consider syntax
     tables.


File: elisp.info,  Node: Buffer End Motion,  Next: Text Lines,  Prev: Word Motion,  Up: Motion

30.2.3 Motion to an End of the Buffer
-------------------------------------

To move point to the beginning of the buffer, write:

     (goto-char (point-min))

Likewise, to move to the end of the buffer, use:

     (goto-char (point-max))

   Here are two commands that users use to do these things.  They are
documented here to warn you not to use them in Lisp programs, because
they set the mark and display messages in the echo area.

 -- Command: beginning-of-buffer &optional n
     This function moves point to the beginning of the buffer (or the
     limits of the accessible portion, when narrowing is in effect),
     setting the mark at the previous position (except in Transient Mark
     mode, if the mark is already active, it does not set the mark.)

     If N is non-‘nil’, then it puts point N tenths of the way from the
     beginning of the accessible portion of the buffer.  In an
     interactive call, N is the numeric prefix argument, if provided;
     otherwise N defaults to ‘nil’.

     *Warning:* Don’t use this function in Lisp programs!

 -- Command: end-of-buffer &optional n
     This function moves point to the end of the buffer (or the limits
     of the accessible portion, when narrowing is in effect), setting
     the mark at the previous position (except in Transient Mark mode
     when the mark is already active).  If N is non-‘nil’, then it puts
     point N tenths of the way from the end of the accessible portion of
     the buffer.

     In an interactive call, N is the numeric prefix argument, if
     provided; otherwise N defaults to ‘nil’.

     *Warning:* Don’t use this function in Lisp programs!


File: elisp.info,  Node: Text Lines,  Next: Screen Lines,  Prev: Buffer End Motion,  Up: Motion

30.2.4 Motion by Text Lines
---------------------------

Text lines are portions of the buffer delimited by newline characters,
which are regarded as part of the previous line.  The first text line
begins at the beginning of the buffer, and the last text line ends at
the end of the buffer whether or not the last character is a newline.
The division of the buffer into text lines is not affected by the width
of the window, by line continuation in display, or by how tabs and
control characters are displayed.

 -- Command: beginning-of-line &optional count
     This function moves point to the beginning of the current line.
     With an argument COUNT not ‘nil’ or 1, it moves forward COUNT−1
     lines and then to the beginning of the line.

     This function does not move point across a field boundary (*note
     Fields::) unless doing so would move beyond there to a different
     line; therefore, if COUNT is ‘nil’ or 1, and point starts at a
     field boundary, point does not move.  To ignore field boundaries,
     either bind ‘inhibit-field-text-motion’ to ‘t’, or use the
     ‘forward-line’ function instead.  For instance, ‘(forward-line 0)’
     does the same thing as ‘(beginning-of-line)’, except that it
     ignores field boundaries.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 -- Function: line-beginning-position &optional count
     Return the position that ‘(beginning-of-line COUNT)’ would move to.

 -- Command: end-of-line &optional count
     This function moves point to the end of the current line.  With an
     argument COUNT not ‘nil’ or 1, it moves forward COUNT−1 lines and
     then to the end of the line.

     This function does not move point across a field boundary (*note
     Fields::) unless doing so would move beyond there to a different
     line; therefore, if COUNT is ‘nil’ or 1, and point starts at a
     field boundary, point does not move.  To ignore field boundaries,
     bind ‘inhibit-field-text-motion’ to ‘t’.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 -- Function: line-end-position &optional count
     Return the position that ‘(end-of-line COUNT)’ would move to.

 -- Command: forward-line &optional count
     This function moves point forward COUNT lines, to the beginning of
     the line following that.  If COUNT is negative, it moves point
     −COUNT lines backward, to the beginning of a line preceding that.
     If COUNT is zero, it moves point to the beginning of the current
     line.  If COUNT is ‘nil’, that means 1.

     If ‘forward-line’ encounters the beginning or end of the buffer (or
     of the accessible portion) before finding that many lines, it sets
     point there.  No error is signaled.

     ‘forward-line’ returns the difference between COUNT and the number
     of lines actually moved.  If you attempt to move down five lines
     from the beginning of a buffer that has only three lines, point
     stops at the end of the last line, and the value will be 2.  As an
     explicit exception, if the last accessible line is non-empty, but
     has no newline (e.g., if the buffer ends without a newline), the
     function sets point to the end of that line, and the value returned
     by the function counts that line as one line successfully moved.

     In an interactive call, COUNT is the numeric prefix argument.

 -- Function: count-lines start end
     This function returns the number of lines between the positions
     START and END in the current buffer.  If START and END are equal,
     then it returns 0.  Otherwise it returns at least 1, even if START
     and END are on the same line.  This is because the text between
     them, considered in isolation, must contain at least one line
     unless it is empty.

 -- Command: count-words start end
     This function returns the number of words between the positions
     START and END in the current buffer.

     This function can also be called interactively.  In that case, it
     prints a message reporting the number of lines, words, and
     characters in the buffer, or in the region if the region is active.

 -- Function: line-number-at-pos &optional pos absolute
     This function returns the line number in the current buffer
     corresponding to the buffer position POS.  If POS is ‘nil’ or
     omitted, the current buffer position is used.  If ABSOLUTE is
     ‘nil’, the default, counting starts at ‘(point-min)’, so the value
     refers to the contents of the accessible portion of the
     (potentially narrowed) buffer.  If ABSOLUTE is non-‘nil’, ignore
     any narrowing and return the absolute line number.

   Also see the functions ‘bolp’ and ‘eolp’ in *note Near Point::.
These functions do not move point, but test whether it is already at the
beginning or end of a line.


File: elisp.info,  Node: Screen Lines,  Next: List Motion,  Prev: Text Lines,  Up: Motion

30.2.5 Motion by Screen Lines
-----------------------------

The line functions in the previous section count text lines, delimited
only by newline characters.  By contrast, these functions count screen
lines, which are defined by the way the text appears on the screen.  A
text line is a single screen line if it is short enough to fit the width
of the selected window, but otherwise it may occupy several screen
lines.

   In some cases, text lines are truncated on the screen rather than
continued onto additional screen lines.  In these cases,
‘vertical-motion’ moves point much like ‘forward-line’.  *Note
Truncation::.

   Because the width of a given string depends on the flags that control
the appearance of certain characters, ‘vertical-motion’ behaves
differently, for a given piece of text, depending on the buffer it is
in, and even on the selected window (because the width, the truncation
flag, and display table may vary between windows).  *Note Usual
Display::.

   These functions scan text to determine where screen lines break, and
thus take time proportional to the distance scanned.

 -- Function: vertical-motion count &optional window cur-col
     This function moves point to the start of the screen line COUNT
     screen lines down from the screen line containing point.  If COUNT
     is negative, it moves up instead.

     The COUNT argument can be a cons cell, ‘(COLS . LINES)’, instead of
     an integer.  Then the function moves by LINES screen lines, and
     puts point COLS columns from the visual start of that screen line.
     Note that COLS are counted from the _visual_ start of the line; if
     the window is scrolled horizontally (*note Horizontal Scrolling::),
     the column on which point will end is in addition to the number of
     columns by which the text is scrolled.

     The return value is the number of screen lines over which point was
     moved.  The value may be less in absolute value than COUNT if the
     beginning or end of the buffer was reached.

     The window WINDOW is used for obtaining parameters such as the
     width, the horizontal scrolling, and the display table.  But
     ‘vertical-motion’ always operates on the current buffer, even if
     WINDOW currently displays some other buffer.

     The optional argument CUR-COL specifies the current column when the
     function is called.  This is the window-relative horizontal
     coordinate of point, measured in units of font width of the frame’s
     default face.  Providing it speeds up the function, especially in
     very long lines, because the function doesn’t have to go back in
     the buffer in order to determine the current column.  Note that
     CUR-COL is also counted from the visual start of the line.

 -- Function: count-screen-lines &optional beg end count-final-newline
          window
     This function returns the number of screen lines in the text from
     BEG to END.  The number of screen lines may be different from the
     number of actual lines, due to line continuation, the display
     table, etc.  If BEG and END are ‘nil’ or omitted, they default to
     the beginning and end of the accessible portion of the buffer.

     If the region ends with a newline, that is ignored unless the
     optional third argument COUNT-FINAL-NEWLINE is non-‘nil’.

     The optional fourth argument WINDOW specifies the window for
     obtaining parameters such as width, horizontal scrolling, and so
     on.  The default is to use the selected window’s parameters.

     Like ‘vertical-motion’, ‘count-screen-lines’ always uses the
     current buffer, regardless of which buffer is displayed in WINDOW.
     This makes possible to use ‘count-screen-lines’ in any buffer,
     whether or not it is currently displayed in some window.

 -- Command: move-to-window-line count
     This function moves point with respect to the text currently
     displayed in the selected window.  It moves point to the beginning
     of the screen line COUNT screen lines from the top of the window;
     zero means the topmost line.  If COUNT is negative, that specifies
     a position −COUNT lines from the bottom (or the last line of the
     buffer, if the buffer ends above the specified screen position);
     thus, COUNT of −1 specifies the last fully visible screen line of
     the window.

     If COUNT is ‘nil’, then point moves to the beginning of the line in
     the middle of the window.  If the absolute value of COUNT is
     greater than the size of the window, then point moves to the place
     that would appear on that screen line if the window were tall
     enough.  This will probably cause the next redisplay to scroll to
     bring that location onto the screen.

     In an interactive call, COUNT is the numeric prefix argument.

     The value returned is the screen line number point has moved to,
     relative to the top line of the window.

 -- Function: move-to-window-group-line count
     This function is like ‘move-to-window-line’, except that when the
     selected window is a part of a group of windows (*note Window
     Group::), ‘move-to-window-group-line’ will move to a position with
     respect to the entire group, not just the single window.  This
     condition holds when the buffer local variable
     ‘move-to-window-group-line-function’ is set to a function.  In this
     case, ‘move-to-window-group-line’ calls the function with the
     argument COUNT, then returns its result.

 -- Function: compute-motion from frompos to topos width offsets window
     This function scans the current buffer, calculating screen
     positions.  It scans the buffer forward from position FROM,
     assuming that is at screen coordinates FROMPOS, to position TO or
     coordinates TOPOS, whichever comes first.  It returns the ending
     buffer position and screen coordinates.

     The coordinate arguments FROMPOS and TOPOS are cons cells of the
     form ‘(HPOS . VPOS)’.

     The argument WIDTH is the number of columns available to display
     text; this affects handling of continuation lines.  ‘nil’ means the
     actual number of usable text columns in the window, which is
     equivalent to the value returned by ‘(window-width window)’.

     The argument OFFSETS is either ‘nil’ or a cons cell of the form
     ‘(HSCROLL . TAB-OFFSET)’.  Here HSCROLL is the number of columns
     not being displayed at the left margin; most callers get this by
     calling ‘window-hscroll’.  Meanwhile, TAB-OFFSET is the offset
     between column numbers on the screen and column numbers in the
     buffer.  This can be nonzero in a continuation line, when the
     previous screen lines’ widths do not add up to a multiple of
     ‘tab-width’.  It is always zero in a non-continuation line.

     The window WINDOW serves only to specify which display table to
     use.  ‘compute-motion’ always operates on the current buffer,
     regardless of what buffer is displayed in WINDOW.

     The return value is a list of five elements:

          (POS HPOS VPOS PREVHPOS CONTIN)

     Here POS is the buffer position where the scan stopped, VPOS is the
     vertical screen position, and HPOS is the horizontal screen
     position.

     The result PREVHPOS is the horizontal position one character back
     from POS.  The result CONTIN is ‘t’ if the last line was continued
     after (or within) the previous character.

     For example, to find the buffer position of column COL of screen
     line LINE of a certain window, pass the window’s display start
     location as FROM and the window’s upper-left coordinates as
     FROMPOS.  Pass the buffer’s ‘(point-max)’ as TO, to limit the scan
     to the end of the accessible portion of the buffer, and pass LINE
     and COL as TOPOS.  Here’s a function that does this:

          (defun coordinates-of-position (col line)
            (car (compute-motion (window-start)
                                 '(0 . 0)
                                 (point-max)
                                 (cons col line)
                                 (window-width)
                                 (cons (window-hscroll) 0)
                                 (selected-window))))

     When you use ‘compute-motion’ for the minibuffer, you need to use
     ‘minibuffer-prompt-width’ to get the horizontal position of the
     beginning of the first screen line.  *Note Minibuffer Contents::.


File: elisp.info,  Node: List Motion,  Next: Skipping Characters,  Prev: Screen Lines,  Up: Motion

30.2.6 Moving over Balanced Expressions
---------------------------------------

Here are several functions concerned with balanced-parenthesis
expressions (also called “sexps” in connection with moving across them
in Emacs).  The syntax table controls how these functions interpret
various characters; see *note Syntax Tables::.  *Note Parsing
Expressions::, for lower-level primitives for scanning sexps or parts of
sexps.  For user-level commands, see *note Commands for Editing with
Parentheses: (emacs)Parentheses.

 -- Command: forward-list &optional arg
     This function moves forward across ARG (default 1) balanced groups
     of parentheses.  (Other syntactic entities such as words or paired
     string quotes are ignored.)

 -- Command: backward-list &optional arg
     This function moves backward across ARG (default 1) balanced groups
     of parentheses.  (Other syntactic entities such as words or paired
     string quotes are ignored.)

 -- Command: up-list &optional arg escape-strings no-syntax-crossing
     This function moves forward out of ARG (default 1) levels of
     parentheses.  A negative argument means move backward but still to
     a less deep spot.  If ESCAPE-STRINGS is non-‘nil’ (as it is
     interactively), move out of enclosing strings as well.  If
     NO-SYNTAX-CROSSING is non-‘nil’ (as it is interactively), prefer to
     break out of any enclosing string instead of moving to the start of
     a list broken across multiple strings.  On error, location of point
     is unspecified.

 -- Command: backward-up-list &optional arg escape-strings
          no-syntax-crossing
     This function is just like ‘up-list’, but with a negated argument.

 -- Command: down-list &optional arg
     This function moves forward into ARG (default 1) levels of
     parentheses.  A negative argument means move backward but still go
     deeper in parentheses (−ARG levels).

 -- Command: forward-sexp &optional arg
     This function moves forward across ARG (default 1) balanced
     expressions.  Balanced expressions include both those delimited by
     parentheses and other kinds, such as words and string constants.
     *Note Parsing Expressions::.  For example,

          ---------- Buffer: foo ----------
          (concat★ "foo " (car x) y z)
          ---------- Buffer: foo ----------

          (forward-sexp 3)
               ⇒ nil

          ---------- Buffer: foo ----------
          (concat "foo " (car x) y★ z)
          ---------- Buffer: foo ----------

 -- Command: backward-sexp &optional arg
     This function moves backward across ARG (default 1) balanced
     expressions.

 -- Command: beginning-of-defun &optional arg
     This function moves back to the ARGth beginning of a defun.  If ARG
     is negative, this actually moves forward, but it still moves to the
     beginning of a defun, not to the end of one.  ARG defaults to 1.

 -- Command: end-of-defun &optional arg
     This function moves forward to the ARGth end of a defun.  If ARG is
     negative, this actually moves backward, but it still moves to the
     end of a defun, not to the beginning of one.  ARG defaults to 1.

 -- User Option: defun-prompt-regexp
     If non-‘nil’, this buffer-local variable holds a regular expression
     that specifies what text can appear before the open-parenthesis
     that starts a defun.  That is to say, a defun begins on a line that
     starts with a match for this regular expression, followed by a
     character with open-parenthesis syntax.

 -- User Option: open-paren-in-column-0-is-defun-start
     If this variable’s value is non-‘nil’, an open parenthesis in
     column 0 is considered to be the start of a defun.  If it is ‘nil’,
     an open parenthesis in column 0 has no special meaning.  The
     default is ‘t’.

 -- Variable: beginning-of-defun-function
     If non-‘nil’, this variable holds a function for finding the
     beginning of a defun.  The function ‘beginning-of-defun’ calls this
     function instead of using its normal method, passing it its
     optional argument.  If the argument is non-‘nil’, the function
     should move back by that many functions, like ‘beginning-of-defun’
     does.

 -- Variable: end-of-defun-function
     If non-‘nil’, this variable holds a function for finding the end of
     a defun.  The function ‘end-of-defun’ calls this function instead
     of using its normal method.


File: elisp.info,  Node: Skipping Characters,  Prev: List Motion,  Up: Motion

30.2.7 Skipping Characters
--------------------------

The following two functions move point over a specified set of
characters.  For example, they are often used to skip whitespace.  For
related functions, see *note Motion and Syntax::.

   These functions convert the set string to multibyte if the buffer is
multibyte, and they convert it to unibyte if the buffer is unibyte, as
the search functions do (*note Searching and Matching::).

 -- Function: skip-chars-forward character-set &optional limit
     This function moves point in the current buffer forward, skipping
     over a given set of characters.  It examines the character
     following point, then advances point if the character matches
     CHARACTER-SET.  This continues until it reaches a character that
     does not match.  The function returns the number of characters
     moved over.

     The argument CHARACTER-SET is a string, like the inside of a
     ‘[...]’ in a regular expression except that ‘]’ does not terminate
     it, and ‘\’ quotes ‘^’, ‘-’ or ‘\’.  Thus, ‘"a-zA-Z"’ skips over
     all letters, stopping before the first nonletter, and ‘"^a-zA-Z"’
     skips nonletters stopping before the first letter.  See *Note
     Regular Expressions::.  Character classes can also be used, e.g.,
     ‘"[:alnum:]"’.  See *note Char Classes::.

     If LIMIT is supplied (it must be a number or a marker), it
     specifies the maximum position in the buffer that point can be
     skipped to.  Point will stop at or before LIMIT.

     In the following example, point is initially located directly
     before the ‘T’.  After the form is evaluated, point is located at
     the end of that line (between the ‘t’ of ‘hat’ and the newline).
     The function skips all letters and spaces, but not newlines.

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (skip-chars-forward "a-zA-Z ")
               ⇒ 18

          ---------- Buffer: foo ----------
          I read "The cat in the hat★
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Function: skip-chars-backward character-set &optional limit
     This function moves point backward, skipping characters that match
     CHARACTER-SET, until LIMIT.  It is just like ‘skip-chars-forward’
     except for the direction of motion.

     The return value indicates the distance traveled.  It is an integer
     that is zero or less.


File: elisp.info,  Node: Excursions,  Next: Narrowing,  Prev: Motion,  Up: Positions

30.3 Excursions
===============

It is often useful to move point temporarily within a localized portion
of the program.  This is called an “excursion”, and it is done with the
‘save-excursion’ special form.  This construct remembers the initial
identity of the current buffer, and its value of point, and restores
them after the excursion completes.  It is the standard way to move
point within one part of a program and avoid affecting the rest of the
program, and is used thousands of times in the Lisp sources of Emacs.

   If you only need to save and restore the identity of the current
buffer, use ‘save-current-buffer’ or ‘with-current-buffer’ instead
(*note Current Buffer::).  If you need to save or restore window
configurations, see the forms described in *note Window Configurations::
and in *note Frame Configurations::.

 -- Special Form: save-excursion body...
     This special form saves the identity of the current buffer and the
     value of point in it, evaluates BODY, and finally restores the
     buffer and its saved value of point.  Both saved values are
     restored even in case of an abnormal exit via ‘throw’ or error
     (*note Nonlocal Exits::).

     The value returned by ‘save-excursion’ is the result of the last
     form in BODY, or ‘nil’ if no body forms were given.

   Because ‘save-excursion’ only saves point for the buffer that was
current at the start of the excursion, any changes made to point in
other buffers, during the excursion, will remain in effect afterward.
This frequently leads to unintended consequences, so the byte compiler
warns if you call ‘set-buffer’ during an excursion:

     Warning: Use ‘with-current-buffer’ rather than
              save-excursion+set-buffer

To avoid such problems, you should call ‘save-excursion’ only after
setting the desired current buffer, as in the following example:

     (defun append-string-to-buffer (string buffer)
       "Append STRING to the end of BUFFER."
       (with-current-buffer buffer
         (save-excursion
           (goto-char (point-max))
           (insert string))))

   Likewise, ‘save-excursion’ does not restore window-buffer
correspondences altered by functions such as ‘switch-to-buffer’.

   *Warning:* Ordinary insertion of text adjacent to the saved point
value relocates the saved value, just as it relocates all markers.  More
precisely, the saved value is a marker with insertion type ‘nil’.  *Note
Marker Insertion Types::.  Therefore, when the saved point value is
restored, it normally comes before the inserted text.

 -- Macro: save-mark-and-excursion body...
     This macro is like ‘save-excursion’, but also saves and restores
     the mark location and ‘mark-active’.  This macro does what
     ‘save-excursion’ did before Emacs 25.1.


File: elisp.info,  Node: Narrowing,  Prev: Excursions,  Up: Positions

30.4 Narrowing
==============

“Narrowing” means limiting the text addressable by Emacs editing
commands to a limited range of characters in a buffer.  The text that
remains addressable is called the “accessible portion” of the buffer.

   Narrowing is specified with two buffer positions, which become the
beginning and end of the accessible portion.  For most editing commands
and primitives, these positions replace the values of the beginning and
end of the buffer.  While narrowing is in effect, no text outside the
accessible portion is displayed, and point cannot move outside the
accessible portion.  Note that narrowing does not alter actual buffer
positions (*note Point::); it only determines which positions are
considered the accessible portion of the buffer.  Most functions refuse
to operate on text that is outside the accessible portion.

   Commands for saving buffers are unaffected by narrowing; they save
the entire buffer regardless of any narrowing.

   If you need to display in a single buffer several very different
types of text, consider using an alternative facility described in *note
Swapping Text::.

 -- Command: narrow-to-region start end
     This function sets the accessible portion of the current buffer to
     start at START and end at END.  Both arguments should be character
     positions.

     In an interactive call, START and END are set to the bounds of the
     current region (point and the mark, with the smallest first).

 -- Command: narrow-to-page &optional move-count
     This function sets the accessible portion of the current buffer to
     include just the current page.  An optional first argument
     MOVE-COUNT non-‘nil’ means to move forward or backward by
     MOVE-COUNT pages and then narrow to one page.  The variable
     ‘page-delimiter’ specifies where pages start and end (*note
     Standard Regexps::).

     In an interactive call, MOVE-COUNT is set to the numeric prefix
     argument.

 -- Command: widen
     This function cancels any narrowing in the current buffer, so that
     the entire contents are accessible.  This is called “widening”.  It
     is equivalent to the following expression:

          (narrow-to-region 1 (1+ (buffer-size)))

 -- Function: buffer-narrowed-p
     This function returns non-‘nil’ if the buffer is narrowed, and
     ‘nil’ otherwise.

 -- Special Form: save-restriction body...
     This special form saves the current bounds of the accessible
     portion, evaluates the BODY forms, and finally restores the saved
     bounds, thus restoring the same state of narrowing (or absence
     thereof) formerly in effect.  The state of narrowing is restored
     even in the event of an abnormal exit via ‘throw’ or error (*note
     Nonlocal Exits::).  Therefore, this construct is a clean way to
     narrow a buffer temporarily.

     The value returned by ‘save-restriction’ is that returned by the
     last form in BODY, or ‘nil’ if no body forms were given.

     *Caution:* it is easy to make a mistake when using the
     ‘save-restriction’ construct.  Read the entire description here
     before you try it.

     If BODY changes the current buffer, ‘save-restriction’ still
     restores the restrictions on the original buffer (the buffer whose
     restrictions it saved from), but it does not restore the identity
     of the current buffer.

     ‘save-restriction’ does _not_ restore point; use ‘save-excursion’
     for that.  If you use both ‘save-restriction’ and ‘save-excursion’
     together, ‘save-excursion’ should come first (on the outside).
     Otherwise, the old point value would be restored with temporary
     narrowing still in effect.  If the old point value were outside the
     limits of the temporary narrowing, this would fail to restore it
     accurately.

     Here is a simple example of correct use of ‘save-restriction’:

          ---------- Buffer: foo ----------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo★
          ---------- Buffer: foo ----------

          (save-excursion
            (save-restriction
              (goto-char 1)
              (forward-line 2)
              (narrow-to-region 1 (point))
              (goto-char (point-min))
              (replace-string "foo" "bar")))

          ---------- Buffer: foo ----------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo★
          ---------- Buffer: foo ----------


File: elisp.info,  Node: Markers,  Next: Text,  Prev: Positions,  Up: Top

31 Markers
**********

A “marker” is a Lisp object used to specify a position in a buffer
relative to the surrounding text.  A marker changes its offset from the
beginning of the buffer automatically whenever text is inserted or
deleted, so that it stays with the two characters on either side of it.

* Menu:

* Overview of Markers::      The components of a marker, and how it relocates.
* Predicates on Markers::    Testing whether an object is a marker.
* Creating Markers::         Making empty markers or markers at certain places.
* Information from Markers:: Finding the marker’s buffer or character position.
* Marker Insertion Types::   Two ways a marker can relocate when you
                               insert where it points.
* Moving Markers::           Moving the marker to a new buffer or position.
* The Mark::                 How the mark is implemented with a marker.
* The Region::               How to access the region.


File: elisp.info,  Node: Overview of Markers,  Next: Predicates on Markers,  Up: Markers

31.1 Overview of Markers
========================

A marker specifies a buffer and a position in that buffer.  A marker can
be used to represent a position in functions that require one, just as
an integer could be used.  In that case, the marker’s buffer is normally
ignored.  Of course, a marker used in this way usually points to a
position in the buffer that the function operates on, but that is
entirely the programmer’s responsibility.  *Note Positions::, for a
complete description of positions.

   A marker has three attributes: the marker position, the marker
buffer, and the insertion type.  The marker position is an integer that
is equivalent (at a given time) to the marker as a position in that
buffer.  But the marker’s position value can change during the life of
the marker, and often does.  Insertion and deletion of text in the
buffer relocate the marker.  The idea is that a marker positioned
between two characters remains between those two characters despite
insertion and deletion elsewhere in the buffer.  Relocation changes the
integer equivalent of the marker.

   Deleting text around a marker’s position leaves the marker between
the characters immediately before and after the deleted text.  Inserting
text at the position of a marker normally leaves the marker either in
front of or after the new text, depending on the marker’s “insertion
type” (*note Marker Insertion Types::)—unless the insertion is done with
‘insert-before-markers’ (*note Insertion::).

   Insertion and deletion in a buffer must check all the markers and
relocate them if necessary.  This slows processing in a buffer with a
large number of markers.  For this reason, it is a good idea to make a
marker point nowhere if you are sure you don’t need it any more.
Markers that can no longer be accessed are eventually removed (*note
Garbage Collection::).

   Because it is common to perform arithmetic operations on a marker
position, most of these operations (including ‘+’ and ‘-’) accept
markers as arguments.  In such cases, the marker stands for its current
position.

   Here are examples of creating markers, setting markers, and moving
point to markers:

     ;; Make a new marker that initially does not point anywhere:
     (setq m1 (make-marker))
          ⇒ #<marker in no buffer>

     ;; Set ‘m1’ to point between the 99th and 100th characters
     ;;   in the current buffer:
     (set-marker m1 100)
          ⇒ #<marker at 100 in markers.texi>

     ;; Now insert one character at the beginning of the buffer:
     (goto-char (point-min))
          ⇒ 1
     (insert "Q")
          ⇒ nil

     ;; ‘m1’ is updated appropriately.
     m1
          ⇒ #<marker at 101 in markers.texi>

     ;; Two markers that point to the same position
     ;;   are not ‘eq’, but they are ‘equal’.
     (setq m2 (copy-marker m1))
          ⇒ #<marker at 101 in markers.texi>
     (eq m1 m2)
          ⇒ nil
     (equal m1 m2)
          ⇒ t

     ;; When you are finished using a marker, make it point nowhere.
     (set-marker m1 nil)
          ⇒ #<marker in no buffer>


File: elisp.info,  Node: Predicates on Markers,  Next: Creating Markers,  Prev: Overview of Markers,  Up: Markers

31.2 Predicates on Markers
==========================

You can test an object to see whether it is a marker, or whether it is
either an integer or a marker.  The latter test is useful in connection
with the arithmetic functions that work with both markers and integers.

 -- Function: markerp object
     This function returns ‘t’ if OBJECT is a marker, ‘nil’ otherwise.
     Note that integers are not markers, even though many functions will
     accept either a marker or an integer.

 -- Function: integer-or-marker-p object
     This function returns ‘t’ if OBJECT is an integer or a marker,
     ‘nil’ otherwise.

 -- Function: number-or-marker-p object
     This function returns ‘t’ if OBJECT is a number (either integer or
     floating point) or a marker, ‘nil’ otherwise.


File: elisp.info,  Node: Creating Markers,  Next: Information from Markers,  Prev: Predicates on Markers,  Up: Markers

31.3 Functions that Create Markers
==================================

When you create a new marker, you can make it point nowhere, or point to
the present position of point, or to the beginning or end of the
accessible portion of the buffer, or to the same place as another given
marker.

   The next four functions all return markers with insertion type ‘nil’.
*Note Marker Insertion Types::.

 -- Function: make-marker
     This function returns a newly created marker that does not point
     anywhere.

          (make-marker)
               ⇒ #<marker in no buffer>

 -- Function: point-marker
     This function returns a new marker that points to the present
     position of point in the current buffer.  *Note Point::.  For an
     example, see ‘copy-marker’, below.

 -- Function: point-min-marker
     This function returns a new marker that points to the beginning of
     the accessible portion of the buffer.  This will be the beginning
     of the buffer unless narrowing is in effect.  *Note Narrowing::.

 -- Function: point-max-marker
     This function returns a new marker that points to the end of the
     accessible portion of the buffer.  This will be the end of the
     buffer unless narrowing is in effect.  *Note Narrowing::.

     Here are examples of this function and ‘point-min-marker’, shown in
     a buffer containing a version of the source file for the text of
     this chapter.

          (point-min-marker)
               ⇒ #<marker at 1 in markers.texi>
          (point-max-marker)
               ⇒ #<marker at 24080 in markers.texi>

          (narrow-to-region 100 200)
               ⇒ nil
          (point-min-marker)
               ⇒ #<marker at 100 in markers.texi>
          (point-max-marker)
               ⇒ #<marker at 200 in markers.texi>

 -- Function: copy-marker &optional marker-or-integer insertion-type
     If passed a marker as its argument, ‘copy-marker’ returns a new
     marker that points to the same place and the same buffer as does
     MARKER-OR-INTEGER.  If passed an integer as its argument,
     ‘copy-marker’ returns a new marker that points to position
     MARKER-OR-INTEGER in the current buffer.

     The new marker’s insertion type is specified by the argument
     INSERTION-TYPE.  *Note Marker Insertion Types::.

          (copy-marker 0)
               ⇒ #<marker at 1 in markers.texi>

          (copy-marker 90000)
               ⇒ #<marker at 24080 in markers.texi>

     An error is signaled if MARKER is neither a marker nor an integer.

   Two distinct markers are considered ‘equal’ (even though not ‘eq’) to
each other if they have the same position and buffer, or if they both
point nowhere.

     (setq p (point-marker))
          ⇒ #<marker at 2139 in markers.texi>

     (setq q (copy-marker p))
          ⇒ #<marker at 2139 in markers.texi>

     (eq p q)
          ⇒ nil

     (equal p q)
          ⇒ t


File: elisp.info,  Node: Information from Markers,  Next: Marker Insertion Types,  Prev: Creating Markers,  Up: Markers

31.4 Information from Markers
=============================

This section describes the functions for accessing the components of a
marker object.

 -- Function: marker-position marker
     This function returns the position that MARKER points to, or ‘nil’
     if it points nowhere.

 -- Function: marker-buffer marker
     This function returns the buffer that MARKER points into, or ‘nil’
     if it points nowhere.

          (setq m (make-marker))
               ⇒ #<marker in no buffer>
          (marker-position m)
               ⇒ nil
          (marker-buffer m)
               ⇒ nil

          (set-marker m 3770 (current-buffer))
               ⇒ #<marker at 3770 in markers.texi>
          (marker-buffer m)
               ⇒ #<buffer markers.texi>
          (marker-position m)
               ⇒ 3770


File: elisp.info,  Node: Marker Insertion Types,  Next: Moving Markers,  Prev: Information from Markers,  Up: Markers

31.5 Marker Insertion Types
===========================

When you insert text directly at the place where a marker points, there
are two possible ways to relocate that marker: it can point before the
inserted text, or point after it.  You can specify which one a given
marker should do by setting its “insertion type”.  Note that use of
‘insert-before-markers’ ignores markers’ insertion types, always
relocating a marker to point after the inserted text.

 -- Function: set-marker-insertion-type marker type
     This function sets the insertion type of marker MARKER to TYPE.  If
     TYPE is ‘t’, MARKER will advance when text is inserted at its
     position.  If TYPE is ‘nil’, MARKER does not advance when text is
     inserted there.

 -- Function: marker-insertion-type marker
     This function reports the current insertion type of MARKER.

   All functions that create markers without accepting an argument that
specifies the insertion type, create them with insertion type ‘nil’
(*note Creating Markers::).  Also, the mark has, by default, insertion
type ‘nil’.


File: elisp.info,  Node: Moving Markers,  Next: The Mark,  Prev: Marker Insertion Types,  Up: Markers

31.6 Moving Marker Positions
============================

This section describes how to change the position of an existing marker.
When you do this, be sure you know whether the marker is used outside of
your program, and, if so, what effects will result from moving
it—otherwise, confusing things may happen in other parts of Emacs.

 -- Function: set-marker marker position &optional buffer
     This function moves MARKER to POSITION in BUFFER.  If BUFFER is not
     provided, it defaults to the current buffer.

     If POSITION is ‘nil’ or a marker that points nowhere, then MARKER
     is set to point nowhere.

     The value returned is MARKER.

          (setq m (point-marker))
               ⇒ #<marker at 4714 in markers.texi>
          (set-marker m 55)
               ⇒ #<marker at 55 in markers.texi>
          (setq b (get-buffer "foo"))
               ⇒ #<buffer foo>
          (set-marker m 0 b)
               ⇒ #<marker at 1 in foo>

 -- Function: move-marker marker position &optional buffer
     This is another name for ‘set-marker’.


File: elisp.info,  Node: The Mark,  Next: The Region,  Prev: Moving Markers,  Up: Markers

31.7 The Mark
=============

Each buffer has a special marker, which is designated “the mark”.  When
a buffer is newly created, this marker exists but does not point
anywhere; this means that the mark doesn’t exist in that buffer yet.
Subsequent commands can set the mark.

   The mark specifies a position to bound a range of text for many
commands, such as ‘kill-region’ and ‘indent-rigidly’.  These commands
typically act on the text between point and the mark, which is called
the “region”.  If you are writing a command that operates on the region,
don’t examine the mark directly; instead, use ‘interactive’ with the ‘r’
specification.  This provides the values of point and the mark as
arguments to the command in an interactive call, but permits other Lisp
programs to specify arguments explicitly.  *Note Interactive Codes::.

   Some commands set the mark as a side-effect.  Commands should do this
only if it has a potential use to the user, and never for their own
internal purposes.  For example, the ‘replace-regexp’ command sets the
mark to the value of point before doing any replacements, because this
enables the user to move back there conveniently after the replace is
finished.

   Once the mark exists in a buffer, it normally never ceases to exist.
However, it may become “inactive”, if Transient Mark mode is enabled.
The buffer-local variable ‘mark-active’, if non-‘nil’, means that the
mark is active.  A command can call the function ‘deactivate-mark’ to
deactivate the mark directly, or it can request deactivation of the mark
upon return to the editor command loop by setting the variable
‘deactivate-mark’ to a non-‘nil’ value.

   If Transient Mark mode is enabled, certain editing commands that
normally apply to text near point, apply instead to the region when the
mark is active.  This is the main motivation for using Transient Mark
mode.  (Another is that this enables highlighting of the region when the
mark is active.  *Note Display::.)

   In addition to the mark, each buffer has a “mark ring” which is a
list of markers containing previous values of the mark.  When editing
commands change the mark, they should normally save the old value of the
mark on the mark ring.  The variable ‘mark-ring-max’ specifies the
maximum number of entries in the mark ring; once the list becomes this
long, adding a new element deletes the last element.

   There is also a separate global mark ring, but that is used only in a
few particular user-level commands, and is not relevant to Lisp
programming.  So we do not describe it here.

 -- Function: mark &optional force
     This function returns the current buffer’s mark position as an
     integer, or ‘nil’ if no mark has ever been set in this buffer.

     If Transient Mark mode is enabled, and ‘mark-even-if-inactive’ is
     ‘nil’, ‘mark’ signals an error if the mark is inactive.  However,
     if FORCE is non-‘nil’, then ‘mark’ disregards inactivity of the
     mark, and returns the mark position (or ‘nil’) anyway.

 -- Function: mark-marker
     This function returns the marker that represents the current
     buffer’s mark.  It is not a copy, it is the marker used internally.
     Therefore, changing this marker’s position will directly affect the
     buffer’s mark.  Don’t do that unless that is the effect you want.

          (setq m (mark-marker))
               ⇒ #<marker at 3420 in markers.texi>
          (set-marker m 100)
               ⇒ #<marker at 100 in markers.texi>
          (mark-marker)
               ⇒ #<marker at 100 in markers.texi>

     Like any marker, this marker can be set to point at any buffer you
     like.  If you make it point at any buffer other than the one of
     which it is the mark, it will yield perfectly consistent, but
     rather odd, results.  We recommend that you not do it!

 -- Function: set-mark position
     This function sets the mark to POSITION, and activates the mark.
     The old value of the mark is _not_ pushed onto the mark ring.

     *Please note:* Use this function only if you want the user to see
     that the mark has moved, and you want the previous mark position to
     be lost.  Normally, when a new mark is set, the old one should go
     on the ‘mark-ring’.  For this reason, most applications should use
     ‘push-mark’ and ‘pop-mark’, not ‘set-mark’.

     Novice Emacs Lisp programmers often try to use the mark for the
     wrong purposes.  The mark saves a location for the user’s
     convenience.  An editing command should not alter the mark unless
     altering the mark is part of the user-level functionality of the
     command.  (And, in that case, this effect should be documented.)
     To remember a location for internal use in the Lisp program, store
     it in a Lisp variable.  For example:

          (let ((beg (point)))
            (forward-line 1)
            (delete-region beg (point))).

 -- Function: push-mark &optional position nomsg activate
     This function sets the current buffer’s mark to POSITION, and
     pushes a copy of the previous mark onto ‘mark-ring’.  If POSITION
     is ‘nil’, then the value of point is used.

     The function ‘push-mark’ normally _does not_ activate the mark.  To
     do that, specify ‘t’ for the argument ACTIVATE.

     A ‘Mark set’ message is displayed unless NOMSG is non-‘nil’.

 -- Function: pop-mark
     This function pops off the top element of ‘mark-ring’ and makes
     that mark become the buffer’s actual mark.  This does not move
     point in the buffer, and it does nothing if ‘mark-ring’ is empty.
     It deactivates the mark.

 -- User Option: transient-mark-mode
     This variable, if non-‘nil’, enables Transient Mark mode.  In
     Transient Mark mode, every buffer-modifying primitive sets
     ‘deactivate-mark’.  As a consequence, most commands that modify the
     buffer also deactivate the mark.

     When Transient Mark mode is enabled and the mark is active, many
     commands that normally apply to the text near point instead apply
     to the region.  Such commands should use the function
     ‘use-region-p’ to test whether they should operate on the region.
     *Note The Region::.

     Lisp programs can set ‘transient-mark-mode’ to non-‘nil’, non-‘t’
     values to enable Transient Mark mode temporarily.  If the value is
     ‘lambda’, Transient Mark mode is automatically turned off after any
     action, such as buffer modification, that would normally deactivate
     the mark.  If the value is ‘(only . OLDVAL)’, then
     ‘transient-mark-mode’ is set to the value OLDVAL after any
     subsequent command that moves point and is not shift-translated
     (*note shift-translation: Key Sequence Input.), or after any other
     action that would normally deactivate the mark.

 -- User Option: mark-even-if-inactive
     If this is non-‘nil’, Lisp programs and the Emacs user can use the
     mark even when it is inactive.  This option affects the behavior of
     Transient Mark mode.  When the option is non-‘nil’, deactivation of
     the mark turns off region highlighting, but commands that use the
     mark behave as if the mark were still active.

 -- Variable: deactivate-mark
     If an editor command sets this variable non-‘nil’, then the editor
     command loop deactivates the mark after the command returns (if
     Transient Mark mode is enabled).  All the primitives that change
     the buffer set ‘deactivate-mark’, to deactivate the mark when the
     command is finished.  Setting this variable makes it buffer-local.

     To write Lisp code that modifies the buffer without causing
     deactivation of the mark at the end of the command, bind
     ‘deactivate-mark’ to ‘nil’ around the code that does the
     modification.  For example:

          (let (deactivate-mark)
            (insert " "))

 -- Function: deactivate-mark &optional force
     If Transient Mark mode is enabled or FORCE is non-‘nil’, this
     function deactivates the mark and runs the normal hook
     ‘deactivate-mark-hook’.  Otherwise, it does nothing.

 -- Variable: mark-active
     The mark is active when this variable is non-‘nil’.  This variable
     is always buffer-local in each buffer.  Do _not_ use the value of
     this variable to decide whether a command that normally operates on
     text near point should operate on the region instead.  Use the
     function ‘use-region-p’ for that (*note The Region::).

 -- Variable: activate-mark-hook
 -- Variable: deactivate-mark-hook
     These normal hooks are run, respectively, when the mark becomes
     active and when it becomes inactive.  The hook ‘activate-mark-hook’
     is also run at the end of the command loop if the mark is active
     and it is possible that the region may have changed.

 -- Function: handle-shift-selection
     This function implements the shift-selection behavior of
     point-motion commands.  *Note (emacs)Shift Selection::.  It is
     called automatically by the Emacs command loop whenever a command
     with a ‘^’ character in its ‘interactive’ spec is invoked, before
     the command itself is executed (*note ^: Interactive Codes.).

     If ‘shift-select-mode’ is non-‘nil’ and the current command was
     invoked via shift translation (*note shift-translation: Key
     Sequence Input.), this function sets the mark and temporarily
     activates the region, unless the region was already temporarily
     activated in this way.  Otherwise, if the region has been activated
     temporarily, it deactivates the mark and restores the variable
     ‘transient-mark-mode’ to its earlier value.

 -- Variable: mark-ring
     The value of this buffer-local variable is the list of saved former
     marks of the current buffer, most recent first.

          mark-ring
          ⇒ (#<marker at 11050 in markers.texi>
              #<marker at 10832 in markers.texi>
              ...)

 -- User Option: mark-ring-max
     The value of this variable is the maximum size of ‘mark-ring’.  If
     more marks than this are pushed onto the ‘mark-ring’, ‘push-mark’
     discards an old mark when it adds a new one.

   When Delete Selection mode (*note Delete Selection: (emacs)Using
Region.) is enabled, commands that operate on the active region (a.k.a.
“selection”) behave slightly differently.  This works by adding the
function ‘delete-selection-pre-hook’ to the ‘pre-command-hook’ (*note
Command Overview::).  That function calls ‘delete-selection-helper’ to
delete the selection as appropriate for the command.  If you want to
adapt a command to Delete Selection mode, put the ‘delete-selection’
property on the function’s symbol (*note Symbol Plists::); commands that
don’t have this property on their symbol won’t delete the selection.
This property can have one of several values to tailor the behavior to
what the command is supposed to do; see the doc strings of
‘delete-selection-pre-hook’ and ‘delete-selection-helper’ for the
details.


File: elisp.info,  Node: The Region,  Prev: The Mark,  Up: Markers

31.8 The Region
===============

The text between point and the mark is known as “the region”.  Various
functions operate on text delimited by point and the mark, but only
those functions specifically related to the region itself are described
here.

   The next two functions signal an error if the mark does not point
anywhere.  If Transient Mark mode is enabled and ‘mark-even-if-inactive’
is ‘nil’, they also signal an error if the mark is inactive.

 -- Function: region-beginning
     This function returns the position of the beginning of the region
     (as an integer).  This is the position of either point or the mark,
     whichever is smaller.

 -- Function: region-end
     This function returns the position of the end of the region (as an
     integer).  This is the position of either point or the mark,
     whichever is larger.

   Instead of using ‘region-beginning’ and ‘region-end’, a command
designed to operate on a region should normally use ‘interactive’ with
the ‘r’ specification to find the beginning and end of the region.  This
lets other Lisp programs specify the bounds explicitly as arguments.
*Note Interactive Codes::.

 -- Function: use-region-p
     This function returns ‘t’ if Transient Mark mode is enabled, the
     mark is active, and there is a valid region in the buffer.  This
     function is intended to be used by commands that operate on the
     region, instead of on text near point, when the mark is active.

     A region is valid if it has a non-zero size, or if the user option
     ‘use-empty-active-region’ is non-‘nil’ (by default, it is ‘nil’).
     The function ‘region-active-p’ is similar to ‘use-region-p’, but
     considers all regions as valid.  In most cases, you should not use
     ‘region-active-p’, since if the region is empty it is often more
     appropriate to operate on point.


File: elisp.info,  Node: Text,  Next: Non-ASCII Characters,  Prev: Markers,  Up: Top

32 Text
*******

This chapter describes the functions that deal with the text in a
buffer.  Most examine, insert, or delete text in the current buffer,
often operating at point or on text adjacent to point.  Many are
interactive.  All the functions that change the text provide for undoing
the changes (*note Undo::).

   Many text-related functions operate on a region of text defined by
two buffer positions passed in arguments named START and END.  These
arguments should be either markers (*note Markers::) or numeric
character positions (*note Positions::).  The order of these arguments
does not matter; it is all right for START to be the end of the region
and END the beginning.  For example, ‘(delete-region 1 10)’ and
‘(delete-region 10 1)’ are equivalent.  An ‘args-out-of-range’ error is
signaled if either START or END is outside the accessible portion of the
buffer.  In an interactive call, point and the mark are used for these
arguments.

   Throughout this chapter, “text” refers to the characters in the
buffer, together with their properties (when relevant).  Keep in mind
that point is always between two characters, and the cursor appears on
the character after point.

* Menu:

* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
                        How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Transposition::    Swapping two portions of a buffer.
* Replacing::        Replacing the text of one buffer with the text
                       of another buffer.
* Decompression::    Dealing with compressed data.
* Base 64::          Conversion to or from base 64 encoding.
* Checksum/Hash::    Computing cryptographic hashes.
* GnuTLS Cryptography:: Cryptographic algorithms imported from GnuTLS.
* Parsing HTML/XML:: Parsing HTML and XML.
* Atomic Changes::   Installing several buffer changes atomically.
* Change Hooks::     Supplying functions to be run when text is changed.


File: elisp.info,  Node: Near Point,  Next: Buffer Contents,  Up: Text

32.1 Examining Text Near Point
==============================

Many functions are provided to look at the characters around point.
Several simple functions are described here.  See also ‘looking-at’ in
*note Regexp Search::.

   In the following four functions, “beginning” or “end” of buffer
refers to the beginning or end of the accessible portion.

 -- Function: char-after &optional position
     This function returns the character in the current buffer at (i.e.,
     immediately after) position POSITION.  If POSITION is out of range
     for this purpose, either before the beginning of the buffer, or at
     or beyond the end, then the value is ‘nil’.  The default for
     POSITION is point.

     In the following example, assume that the first character in the
     buffer is ‘@’:

          (string (char-after 1))
               ⇒ "@"

 -- Function: char-before &optional position
     This function returns the character in the current buffer
     immediately before position POSITION.  If POSITION is out of range
     for this purpose, either at or before the beginning of the buffer,
     or beyond the end, then the value is ‘nil’.  The default for
     POSITION is point.

 -- Function: following-char
     This function returns the character following point in the current
     buffer.  This is similar to ‘(char-after (point))’.  However, if
     point is at the end of the buffer, then ‘following-char’ returns 0.

     Remember that point is always between characters, and the cursor
     normally appears over the character following point.  Therefore,
     the character returned by ‘following-char’ is the character the
     cursor is over.

     In this example, point is between the ‘a’ and the ‘c’.

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea★ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (string (preceding-char))
               ⇒ "a"
          (string (following-char))
               ⇒ "c"

 -- Function: preceding-char
     This function returns the character preceding point in the current
     buffer.  See above, under ‘following-char’, for an example.  If
     point is at the beginning of the buffer, ‘preceding-char’ returns
     0.

 -- Function: bobp
     This function returns ‘t’ if point is at the beginning of the
     buffer.  If narrowing is in effect, this means the beginning of the
     accessible portion of the text.  See also ‘point-min’ in *note
     Point::.

 -- Function: eobp
     This function returns ‘t’ if point is at the end of the buffer.  If
     narrowing is in effect, this means the end of accessible portion of
     the text.  See also ‘point-max’ in *Note Point::.

 -- Function: bolp
     This function returns ‘t’ if point is at the beginning of a line.
     *Note Text Lines::.  The beginning of the buffer (or of its
     accessible portion) always counts as the beginning of a line.

 -- Function: eolp
     This function returns ‘t’ if point is at the end of a line.  The
     end of the buffer (or of its accessible portion) is always
     considered the end of a line.


File: elisp.info,  Node: Buffer Contents,  Next: Comparing Text,  Prev: Near Point,  Up: Text

32.2 Examining Buffer Contents
==============================

This section describes functions that allow a Lisp program to convert
any portion of the text in the buffer into a string.

 -- Function: buffer-substring start end
     This function returns a string containing a copy of the text of the
     region defined by positions START and END in the current buffer.
     If the arguments are not positions in the accessible portion of the
     buffer, ‘buffer-substring’ signals an ‘args-out-of-range’ error.

     Here’s an example which assumes Font-Lock mode is not enabled:

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-substring 1 10)
               ⇒ "This is t"
          (buffer-substring (point-max) 10)
               ⇒ "he contents of buffer foo\n"

     If the text being copied has any text properties, these are copied
     into the string along with the characters they belong to.  *Note
     Text Properties::.  However, overlays (*note Overlays::) in the
     buffer and their properties are ignored, not copied.

     For example, if Font-Lock mode is enabled, you might get results
     like these:

          (buffer-substring 1 10)
               ⇒ #("This is t" 0 1 (fontified t) 1 9 (fontified t))

 -- Function: buffer-substring-no-properties start end
     This is like ‘buffer-substring’, except that it does not copy text
     properties, just the characters themselves.  *Note Text
     Properties::.

 -- Function: buffer-string
     This function returns the contents of the entire accessible portion
     of the current buffer, as a string.

   If you need to make sure the resulting string, when copied to a
different location, will not change its visual appearance due to
reordering of bidirectional text, use the
‘buffer-substring-with-bidi-context’ function (*note
buffer-substring-with-bidi-context: Bidirectional Display.).

 -- Function: filter-buffer-substring start end &optional delete
     This function filters the buffer text between START and END using a
     function specified by the variable
     ‘filter-buffer-substring-function’, and returns the result.

     The default filter function consults the obsolete wrapper hook
     ‘filter-buffer-substring-functions’ (see the documentation string
     of the macro ‘with-wrapper-hook’ for the details about this
     obsolete facility), and the obsolete variable
     ‘buffer-substring-filters’.  If both of these are ‘nil’, it returns
     the unaltered text from the buffer, i.e., what ‘buffer-substring’
     would return.

     If DELETE is non-‘nil’, the function deletes the text between START
     and END after copying it, like ‘delete-and-extract-region’.

     Lisp code should use this function instead of ‘buffer-substring’,
     ‘buffer-substring-no-properties’, or ‘delete-and-extract-region’
     when copying into user-accessible data structures such as the
     kill-ring, X clipboard, and registers.  Major and minor modes can
     modify ‘filter-buffer-substring-function’ to alter such text as it
     is copied out of the buffer.

 -- Variable: filter-buffer-substring-function
     The value of this variable is a function that
     ‘filter-buffer-substring’ will call to do the actual work.  The
     function receives three arguments, the same as those of
     ‘filter-buffer-substring’, which it should treat as per the
     documentation of that function.  It should return the filtered text
     (and optionally delete the source text).

The following two variables are obsoleted by
‘filter-buffer-substring-function’, but are still supported for backward
compatibility.

 -- Variable: filter-buffer-substring-functions
     This obsolete variable is a wrapper hook, whose members should be
     functions that accept four arguments: FUN, START, END, and DELETE.
     FUN is a function that takes three arguments (START, END, and
     DELETE), and returns a string.  In both cases, the START, END, and
     DELETE arguments are the same as those of
     ‘filter-buffer-substring’.

     The first hook function is passed a FUN that is equivalent to the
     default operation of ‘filter-buffer-substring’, i.e., it returns
     the buffer-substring between START and END (processed by any
     ‘buffer-substring-filters’) and optionally deletes the original
     text from the buffer.  In most cases, the hook function will call
     FUN once, and then do its own processing of the result.  The next
     hook function receives a FUN equivalent to this, and so on.  The
     actual return value is the result of all the hook functions acting
     in sequence.

 -- Variable: buffer-substring-filters
     The value of this obsolete variable should be a list of functions
     that accept a single string argument and return another string.
     The default ‘filter-buffer-substring’ function passes the buffer
     substring to the first function in this list, and the return value
     of each function is passed to the next function.  The return value
     of the last function is passed to
     ‘filter-buffer-substring-functions’.

 -- Function: current-word &optional strict really-word
     This function returns the symbol (or word) at or near point, as a
     string.  The return value includes no text properties.

     If the optional argument REALLY-WORD is non-‘nil’, it finds a word;
     otherwise, it finds a symbol (which includes both word characters
     and symbol constituent characters).

     If the optional argument STRICT is non-‘nil’, then point must be in
     or next to the symbol or word—if no symbol or word is there, the
     function returns ‘nil’.  Otherwise, a nearby symbol or word on the
     same line is acceptable.

 -- Function: thing-at-point thing &optional no-properties
     Return the THING around or next to point, as a string.

     The argument THING is a symbol which specifies a kind of syntactic
     entity.  Possibilities include ‘symbol’, ‘list’, ‘sexp’, ‘defun’,
     ‘filename’, ‘url’, ‘word’, ‘sentence’, ‘whitespace’, ‘line’,
     ‘page’, and others.

     When the optional argument NO-PROPERTIES is non-‘nil’, this
     function strips text properties from the return value.

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea★ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (thing-at-point 'word)
               ⇒ "Peace"
          (thing-at-point 'line)
               ⇒ "Gentlemen may cry ``Peace! Peace!,''\n"
          (thing-at-point 'whitespace)
               ⇒ nil


File: elisp.info,  Node: Comparing Text,  Next: Insertion,  Prev: Buffer Contents,  Up: Text

32.3 Comparing Text
===================

This function lets you compare portions of the text in a buffer, without
copying them into strings first.

 -- Function: compare-buffer-substrings buffer1 start1 end1 buffer2
          start2 end2
     This function lets you compare two substrings of the same buffer or
     two different buffers.  The first three arguments specify one
     substring, giving a buffer (or a buffer name) and two positions
     within the buffer.  The last three arguments specify the other
     substring in the same way.  You can use ‘nil’ for BUFFER1, BUFFER2,
     or both to stand for the current buffer.

     The value is negative if the first substring is less, positive if
     the first is greater, and zero if they are equal.  The absolute
     value of the result is one plus the index of the first differing
     characters within the substrings.

     This function ignores case when comparing characters if
     ‘case-fold-search’ is non-‘nil’.  It always ignores text
     properties.

     Suppose you have the text ‘foobarbar haha!rara!’ in the current
     buffer; then in this example the two substrings are ‘rbar ’ and
     ‘rara!’.  The value is 2 because the first substring is greater at
     the second character.

          (compare-buffer-substrings nil 6 11 nil 16 21)
               ⇒ 2


File: elisp.info,  Node: Insertion,  Next: Commands for Insertion,  Prev: Comparing Text,  Up: Text

32.4 Inserting Text
===================

“Insertion” means adding new text to a buffer.  The inserted text goes
at point—between the character before point and the character after
point.  Some insertion functions leave point before the inserted text,
while other functions leave it after.  We call the former insertion
“after point” and the latter insertion “before point”.

   Insertion moves markers located at positions after the insertion
point, so that they stay with the surrounding text (*note Markers::).
When a marker points at the place of insertion, insertion may or may not
relocate the marker, depending on the marker’s insertion type (*note
Marker Insertion Types::).  Certain special functions such as
‘insert-before-markers’ relocate all such markers to point after the
inserted text, regardless of the markers’ insertion type.

   Insertion functions signal an error if the current buffer is
read-only (*note Read Only Buffers::) or if they insert within read-only
text (*note Special Properties::).

   These functions copy text characters from strings and buffers along
with their properties.  The inserted characters have exactly the same
properties as the characters they were copied from.  By contrast,
characters specified as separate arguments, not part of a string or
buffer, inherit their text properties from the neighboring text.

   The insertion functions convert text from unibyte to multibyte in
order to insert in a multibyte buffer, and vice versa—if the text comes
from a string or from a buffer.  However, they do not convert unibyte
character codes 128 through 255 to multibyte characters, not even if the
current buffer is a multibyte buffer.  *Note Converting
Representations::.

 -- Function: insert &rest args
     This function inserts the strings and/or characters ARGS into the
     current buffer, at point, moving point forward.  In other words, it
     inserts the text before point.  An error is signaled unless all
     ARGS are either strings or characters.  The value is ‘nil’.

 -- Function: insert-before-markers &rest args
     This function inserts the strings and/or characters ARGS into the
     current buffer, at point, moving point forward.  An error is
     signaled unless all ARGS are either strings or characters.  The
     value is ‘nil’.

     This function is unlike the other insertion functions in that it
     relocates markers initially pointing at the insertion point, to
     point after the inserted text.  If an overlay begins at the
     insertion point, the inserted text falls outside the overlay; if a
     nonempty overlay ends at the insertion point, the inserted text
     falls inside that overlay.

 -- Command: insert-char character &optional count inherit
     This command inserts COUNT instances of CHARACTER into the current
     buffer before point.  The argument COUNT must be an integer, and
     CHARACTER must be a character.

     If called interactively, this command prompts for CHARACTER using
     its Unicode name or its code point.  *Note (emacs)Inserting Text::.

     This function does not convert unibyte character codes 128 through
     255 to multibyte characters, not even if the current buffer is a
     multibyte buffer.  *Note Converting Representations::.

     If INHERIT is non-‘nil’, the inserted characters inherit sticky
     text properties from the two characters before and after the
     insertion point.  *Note Sticky Properties::.

 -- Function: insert-buffer-substring from-buffer-or-name &optional
          start end
     This function inserts a portion of buffer FROM-BUFFER-OR-NAME into
     the current buffer before point.  The text inserted is the region
     between START (inclusive) and END (exclusive).  (These arguments
     default to the beginning and end of the accessible portion of that
     buffer.)  This function returns ‘nil’.

     In this example, the form is executed with buffer ‘bar’ as the
     current buffer.  We assume that buffer ‘bar’ is initially empty.

          ---------- Buffer: foo ----------
          We hold these truths to be self-evident, that all
          ---------- Buffer: foo ----------

          (insert-buffer-substring "foo" 1 20)
               ⇒ nil

          ---------- Buffer: bar ----------
          We hold these truth★
          ---------- Buffer: bar ----------

 -- Function: insert-buffer-substring-no-properties from-buffer-or-name
          &optional start end
     This is like ‘insert-buffer-substring’ except that it does not copy
     any text properties.

   *Note Sticky Properties::, for other insertion functions that inherit
text properties from the nearby text in addition to inserting it.
Whitespace inserted by indentation functions also inherits text
properties.


File: elisp.info,  Node: Commands for Insertion,  Next: Deletion,  Prev: Insertion,  Up: Text

32.5 User-Level Insertion Commands
==================================

This section describes higher-level commands for inserting text,
commands intended primarily for the user but useful also in Lisp
programs.

 -- Command: insert-buffer from-buffer-or-name
     This command inserts the entire accessible contents of
     FROM-BUFFER-OR-NAME (which must exist) into the current buffer
     after point.  It leaves the mark after the inserted text.  The
     value is ‘nil’.

 -- Command: self-insert-command count
     This command inserts the last character typed; it does so COUNT
     times, before point, and returns ‘nil’.  Most printing characters
     are bound to this command.  In routine use, ‘self-insert-command’
     is the most frequently called function in Emacs, but programs
     rarely use it except to install it on a keymap.

     In an interactive call, COUNT is the numeric prefix argument.

     Self-insertion translates the input character through
     ‘translation-table-for-input’.  *Note Translation of Characters::.

     This command calls ‘auto-fill-function’ whenever that is non-‘nil’
     and the character inserted is in the table ‘auto-fill-chars’ (*note
     Auto Filling::).

     This command performs abbrev expansion if Abbrev mode is enabled
     and the inserted character does not have word-constituent syntax.
     (*Note Abbrevs::, and *note Syntax Class Table::.)  It is also
     responsible for calling ‘blink-paren-function’ when the inserted
     character has close parenthesis syntax (*note Blinking::).

     The final thing this command does is to run the hook
     ‘post-self-insert-hook’.  You could use this to automatically
     reindent text as it is typed, for example.  If any function on this
     hook needs to act on the region (*note The Region::), it should
     make sure Delete Selection mode (*note Delete Selection:
     (emacs)Using Region.) doesn’t delete the region before
     ‘post-self-insert-hook’ functions are invoked.  The way to do so is
     to add a function that returns ‘nil’ to
     ‘self-insert-uses-region-functions’, a special hook that tells
     Delete Selection mode it should not delete the region.

     Do not try substituting your own definition of
     ‘self-insert-command’ for the standard one.  The editor command
     loop handles this function specially.

 -- Command: newline &optional number-of-newlines
     This command inserts newlines into the current buffer before point.
     If NUMBER-OF-NEWLINES is supplied, that many newline characters are
     inserted.

     This function calls ‘auto-fill-function’ if the current column
     number is greater than the value of ‘fill-column’ and
     NUMBER-OF-NEWLINES is ‘nil’.  Typically what ‘auto-fill-function’
     does is insert a newline; thus, the overall result in this case is
     to insert two newlines at different places: one at point, and
     another earlier in the line.  ‘newline’ does not auto-fill if
     NUMBER-OF-NEWLINES is non-‘nil’.

     This command indents to the left margin if that is not zero.  *Note
     Margins::.

     The value returned is ‘nil’.  In an interactive call, COUNT is the
     numeric prefix argument.

 -- Variable: overwrite-mode
     This variable controls whether overwrite mode is in effect.  The
     value should be ‘overwrite-mode-textual’, ‘overwrite-mode-binary’,
     or ‘nil’.  ‘overwrite-mode-textual’ specifies textual overwrite
     mode (treats newlines and tabs specially), and
     ‘overwrite-mode-binary’ specifies binary overwrite mode (treats
     newlines and tabs like any other characters).


File: elisp.info,  Node: Deletion,  Next: User-Level Deletion,  Prev: Commands for Insertion,  Up: Text

32.6 Deleting Text
==================

Deletion means removing part of the text in a buffer, without saving it
in the kill ring (*note The Kill Ring::).  Deleted text can’t be yanked,
but can be reinserted using the undo mechanism (*note Undo::).  Some
deletion functions do save text in the kill ring in some special cases.

   All of the deletion functions operate on the current buffer.

 -- Command: erase-buffer
     This function deletes the entire text of the current buffer (_not_
     just the accessible portion), leaving it empty.  If the buffer is
     read-only, it signals a ‘buffer-read-only’ error; if some of the
     text in it is read-only, it signals a ‘text-read-only’ error.
     Otherwise, it deletes the text without asking for any confirmation.
     It returns ‘nil’.

     Normally, deleting a large amount of text from a buffer inhibits
     further auto-saving of that buffer because it has shrunk.  However,
     ‘erase-buffer’ does not do this, the idea being that the future
     text is not really related to the former text, and its size should
     not be compared with that of the former text.

 -- Command: delete-region start end
     This command deletes the text between positions START and END in
     the current buffer, and returns ‘nil’.  If point was inside the
     deleted region, its value afterward is START.  Otherwise, point
     relocates with the surrounding text, as markers do.

 -- Function: delete-and-extract-region start end
     This function deletes the text between positions START and END in
     the current buffer, and returns a string containing the text just
     deleted.

     If point was inside the deleted region, its value afterward is
     START.  Otherwise, point relocates with the surrounding text, as
     markers do.

 -- Command: delete-char count &optional killp
     This command deletes COUNT characters directly after point, or
     before point if COUNT is negative.  If KILLP is non-‘nil’, then it
     saves the deleted characters in the kill ring.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but not
     saved in the kill ring.

     The value returned is always ‘nil’.

 -- Command: delete-backward-char count &optional killp
     This command deletes COUNT characters directly before point, or
     after point if COUNT is negative.  If KILLP is non-‘nil’, then it
     saves the deleted characters in the kill ring.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but not
     saved in the kill ring.

     The value returned is always ‘nil’.

 -- Command: backward-delete-char-untabify count &optional killp
     This command deletes COUNT characters backward, changing tabs into
     spaces.  When the next character to be deleted is a tab, it is
     first replaced with the proper number of spaces to preserve
     alignment and then one of those spaces is deleted instead of the
     tab.  If KILLP is non-‘nil’, then the command saves the deleted
     characters in the kill ring.

     Conversion of tabs to spaces happens only if COUNT is positive.  If
     it is negative, exactly −COUNT characters after point are deleted.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but not
     saved in the kill ring.

     The value returned is always ‘nil’.

 -- User Option: backward-delete-char-untabify-method
     This option specifies how ‘backward-delete-char-untabify’ should
     deal with whitespace.  Possible values include ‘untabify’, the
     default, meaning convert a tab to many spaces and delete one;
     ‘hungry’, meaning delete all tabs and spaces before point with one
     command; ‘all’ meaning delete all tabs, spaces and newlines before
     point, and ‘nil’, meaning do nothing special for whitespace
     characters.

