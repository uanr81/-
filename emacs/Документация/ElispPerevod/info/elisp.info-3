This is elisp.info, produced by makeinfo version 6.1 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp.info,  Node: Default Value,  Prev: Creating Buffer-Local,  Up: Buffer-Local Variables

12.11.3 The Default Value of a Buffer-Local Variable
----------------------------------------------------

The global value of a variable with buffer-local bindings is also called
the “default” value, because it is the value that is in effect whenever
neither the current buffer nor the selected frame has its own binding
for the variable.

   The functions ‘default-value’ and ‘setq-default’ access and change a
variable’s default value regardless of whether the current buffer has a
buffer-local binding.  For example, you could use ‘setq-default’ to
change the default setting of ‘paragraph-start’ for most buffers; and
this would work even when you are in a C or Lisp mode buffer that has a
buffer-local value for this variable.

   The special forms ‘defvar’ and ‘defconst’ also set the default value
(if they set the variable at all), rather than any buffer-local value.

 -- Function: default-value symbol
     This function returns SYMBOL’s default value.  This is the value
     that is seen in buffers and frames that do not have their own
     values for this variable.  If SYMBOL is not buffer-local, this is
     equivalent to ‘symbol-value’ (*note Accessing Variables::).

 -- Function: default-boundp symbol
     The function ‘default-boundp’ tells you whether SYMBOL’s default
     value is nonvoid.  If ‘(default-boundp 'foo)’ returns ‘nil’, then
     ‘(default-value 'foo)’ would get an error.

     ‘default-boundp’ is to ‘default-value’ as ‘boundp’ is to
     ‘symbol-value’.

 -- Special Form: setq-default [symbol form]...
     This special form gives each SYMBOL a new default value, which is
     the result of evaluating the corresponding FORM.  It does not
     evaluate SYMBOL, but does evaluate FORM.  The value of the
     ‘setq-default’ form is the value of the last FORM.

     If a SYMBOL is not buffer-local for the current buffer, and is not
     marked automatically buffer-local, ‘setq-default’ has the same
     effect as ‘setq’.  If SYMBOL is buffer-local for the current
     buffer, then this changes the value that other buffers will see (as
     long as they don’t have a buffer-local value), but not the value
     that the current buffer sees.

          ;; In buffer ‘foo’:
          (make-local-variable 'buffer-local)
               ⇒ buffer-local
          (setq buffer-local 'value-in-foo)
               ⇒ value-in-foo
          (setq-default buffer-local 'new-default)
               ⇒ new-default
          buffer-local
               ⇒ value-in-foo
          (default-value 'buffer-local)
               ⇒ new-default

          ;; In (the new) buffer ‘bar’:
          buffer-local
               ⇒ new-default
          (default-value 'buffer-local)
               ⇒ new-default
          (setq buffer-local 'another-default)
               ⇒ another-default
          (default-value 'buffer-local)
               ⇒ another-default

          ;; Back in buffer ‘foo’:
          buffer-local
               ⇒ value-in-foo
          (default-value 'buffer-local)
               ⇒ another-default

 -- Function: set-default symbol value
     This function is like ‘setq-default’, except that SYMBOL is an
     ordinary evaluated argument.

          (set-default (car '(a b c)) 23)
               ⇒ 23
          (default-value 'a)
               ⇒ 23

   A variable can be let-bound (*note Local Variables::) to a value.
This makes its global value shadowed by the binding; ‘default-value’
will then return the value from that binding, not the global value, and
‘set-default’ will be prevented from setting the global value (it will
change the let-bound value instead).  The following two functions allow
to reference the global value even if it’s shadowed by a let-binding.

 -- Function: default-toplevel-value symbol
     This function returns the “top-level” default value of SYMBOL,
     which is its value outside of any let-binding.

     (defvar variable 'global-value)
         ⇒ variable
     (let ((variable 'let-binding))
       (default-value 'variable))
         ⇒ let-binding
     (let ((variable 'let-binding))
       (default-toplevel-value 'variable))
         ⇒ global-value

 -- Function: set-default-toplevel-value symbol value
     This function sets the top-level default value of SYMBOL to the
     specified VALUE.  This comes in handy when you want to set the
     global value of SYMBOL regardless of whether your code runs in the
     context of SYMBOL’s let-binding.


File: elisp.info,  Node: File Local Variables,  Next: Directory Local Variables,  Prev: Buffer-Local Variables,  Up: Variables

12.12 File Local Variables
==========================

A file can specify local variable values; Emacs uses these to create
buffer-local bindings for those variables in the buffer visiting that
file.  *Note Local Variables in Files: (emacs)File Variables, for basic
information about file-local variables.  This section describes the
functions and variables that affect how file-local variables are
processed.

   If a file-local variable could specify an arbitrary function or Lisp
expression that would be called later, visiting a file could take over
your Emacs.  Emacs protects against this by automatically setting only
those file-local variables whose specified values are known to be safe.
Other file-local variables are set only if the user agrees.

   For additional safety, ‘read-circle’ is temporarily bound to ‘nil’
when Emacs reads file-local variables (*note Input Functions::).  This
prevents the Lisp reader from recognizing circular and shared Lisp
structures (*note Circular Objects::).

 -- User Option: enable-local-variables
     This variable controls whether to process file-local variables.
     The possible values are:

     ‘t’ (the default)
          Set the safe variables, and query (once) about any unsafe
          variables.
     ‘:safe’
          Set only the safe variables and do not query.
     ‘:all’
          Set all the variables and do not query.
     ‘nil’
          Don’t set any variables.
     anything else
          Query (once) about all the variables.

 -- Variable: inhibit-local-variables-regexps
     This is a list of regular expressions.  If a file has a name
     matching an element of this list, then it is not scanned for any
     form of file-local variable.  For examples of why you might want to
     use this, *note Auto Major Mode::.

 -- Function: hack-local-variables &optional handle-mode
     This function parses, and binds or evaluates as appropriate, any
     local variables specified by the contents of the current buffer.
     The variable ‘enable-local-variables’ has its effect here.
     However, this function does not look for the ‘mode:’ local variable
     in the ‘-*-’ line.  ‘set-auto-mode’ does that, also taking
     ‘enable-local-variables’ into account (*note Auto Major Mode::).

     This function works by walking the alist stored in
     ‘file-local-variables-alist’ and applying each local variable in
     turn.  It calls ‘before-hack-local-variables-hook’ and
     ‘hack-local-variables-hook’ before and after applying the
     variables, respectively.  It only calls the before-hook if the
     alist is non-‘nil’; it always calls the other hook.  This function
     ignores a ‘mode’ element if it specifies the same major mode as the
     buffer already has.

     If the optional argument HANDLE-MODE is ‘t’, then all this function
     does is return a symbol specifying the major mode, if the ‘-*-’
     line or the local variables list specifies one, and ‘nil’
     otherwise.  It does not set the mode or any other file-local
     variable.  If HANDLE-MODE has any value other than ‘nil’ or ‘t’,
     any settings of ‘mode’ in the ‘-*-’ line or the local variables
     list are ignored, and the other settings are applied.  If
     HANDLE-MODE is ‘nil’, all the file local variables are set.

 -- Variable: file-local-variables-alist
     This buffer-local variable holds the alist of file-local variable
     settings.  Each element of the alist is of the form
     ‘(VAR . VALUE)’, where VAR is a symbol of the local variable and
     VALUE is its value.  When Emacs visits a file, it first collects
     all the file-local variables into this alist, and then the
     ‘hack-local-variables’ function applies them one by one.

 -- Variable: before-hack-local-variables-hook
     Emacs calls this hook immediately before applying file-local
     variables stored in ‘file-local-variables-alist’.

 -- Variable: hack-local-variables-hook
     Emacs calls this hook immediately after it finishes applying
     file-local variables stored in ‘file-local-variables-alist’.

   You can specify safe values for a variable with a
‘safe-local-variable’ property.  The property has to be a function of
one argument; any value is safe if the function returns non-‘nil’ given
that value.  Many commonly-encountered file variables have
‘safe-local-variable’ properties; these include ‘fill-column’,
‘fill-prefix’, and ‘indent-tabs-mode’.  For boolean-valued variables
that are safe, use ‘booleanp’ as the property value.

   When defining a user option using ‘defcustom’, you can set its
‘safe-local-variable’ property by adding the arguments ‘:safe FUNCTION’
to ‘defcustom’ (*note Variable Definitions::).  However, a safety
predicate defined using ‘:safe’ will only be known once the package that
contains the ‘defcustom’ is loaded, which is often too late.  As an
alternative, you can use the autoload cookie (*note Autoload::) to
assign the option its safety predicate, like this:

     ;;;###autoload (put 'VAR 'safe-local-variable 'PRED)

The safe value definitions specified with ‘autoload’ are copied into the
package’s autoloads file (‘loaddefs.el’ for most packages bundled with
Emacs), and are known to Emacs since the beginning of a session.

 -- User Option: safe-local-variable-values
     This variable provides another way to mark some variable values as
     safe.  It is a list of cons cells ‘(VAR . VAL)’, where VAR is a
     variable name and VAL is a value which is safe for that variable.

     When Emacs asks the user whether or not to obey a set of file-local
     variable specifications, the user can choose to mark them as safe.
     Doing so adds those variable/value pairs to
     ‘safe-local-variable-values’, and saves it to the user’s custom
     file.

 -- Function: safe-local-variable-p sym val
     This function returns non-‘nil’ if it is safe to give SYM the value
     VAL, based on the above criteria.

   Some variables are considered “risky”.  If a variable is risky, it is
never entered automatically into ‘safe-local-variable-values’; Emacs
always queries before setting a risky variable, unless the user
explicitly allows a value by customizing ‘safe-local-variable-values’
directly.

   Any variable whose name has a non-‘nil’ ‘risky-local-variable’
property is considered risky.  When you define a user option using
‘defcustom’, you can set its ‘risky-local-variable’ property by adding
the arguments ‘:risky VALUE’ to ‘defcustom’ (*note Variable
Definitions::).  In addition, any variable whose name ends in any of
‘-command’, ‘-frame-alist’, ‘-function’, ‘-functions’, ‘-hook’,
‘-hooks’, ‘-form’, ‘-forms’, ‘-map’, ‘-map-alist’, ‘-mode-alist’,
‘-program’, or ‘-predicate’ is automatically considered risky.  The
variables ‘font-lock-keywords’, ‘font-lock-keywords’ followed by a
digit, and ‘font-lock-syntactic-keywords’ are also considered risky.

 -- Function: risky-local-variable-p sym
     This function returns non-‘nil’ if SYM is a risky variable, based
     on the above criteria.

 -- Variable: ignored-local-variables
     This variable holds a list of variables that should not be given
     local values by files.  Any value specified for one of these
     variables is completely ignored.

   The ‘Eval:’ “variable” is also a potential loophole, so Emacs
normally asks for confirmation before handling it.

 -- User Option: enable-local-eval
     This variable controls processing of ‘Eval:’ in ‘-*-’ lines or
     local variables lists in files being visited.  A value of ‘t’ means
     process them unconditionally; ‘nil’ means ignore them; anything
     else means ask the user what to do for each file.  The default
     value is ‘maybe’.

 -- User Option: safe-local-eval-forms
     This variable holds a list of expressions that are safe to evaluate
     when found in the ‘Eval:’ “variable” in a file local variables
     list.

   If the expression is a function call and the function has a
‘safe-local-eval-function’ property, the property value determines
whether the expression is safe to evaluate.  The property value can be a
predicate to call to test the expression, a list of such predicates
(it’s safe if any predicate succeeds), or ‘t’ (always safe provided the
arguments are constant).

   Text properties are also potential loopholes, since their values
could include functions to call.  So Emacs discards all text properties
from string values specified for file-local variables.


File: elisp.info,  Node: Directory Local Variables,  Next: Connection Local Variables,  Prev: File Local Variables,  Up: Variables

12.13 Directory Local Variables
===============================

A directory can specify local variable values common to all files in
that directory; Emacs uses these to create buffer-local bindings for
those variables in buffers visiting any file in that directory.  This is
useful when the files in the directory belong to some “project” and
therefore share the same local variables.

   There are two different methods for specifying directory local
variables: by putting them in a special file, or by defining a “project
class” for that directory.

 -- Constant: dir-locals-file
     This constant is the name of the file where Emacs expects to find
     the directory-local variables.  The name of the file is
     ‘.dir-locals.el’(1).  A file by that name in a directory causes
     Emacs to apply its settings to any file in that directory or any of
     its subdirectories (optionally, you can exclude subdirectories; see
     below).  If some of the subdirectories have their own
     ‘.dir-locals.el’ files, Emacs uses the settings from the deepest
     file it finds starting from the file’s directory and moving up the
     directory tree.  This constant is also used to derive the name of a
     second dir-locals file ‘.dir-locals-2.el’.  If this second
     dir-locals file is present, then that is loaded instead of
     ‘.dir-locals.el’.  This is useful when ‘.dir-locals.el’ is under
     version control in a shared repository and cannot be used for
     personal customizations.  The file specifies local variables as a
     specially formatted list; see *note Per-directory Local Variables:
     (emacs)Directory Variables, for more details.

 -- Function: hack-dir-local-variables
     This function reads the ‘.dir-locals.el’ file and stores the
     directory-local variables in ‘file-local-variables-alist’ that is
     local to the buffer visiting any file in the directory, without
     applying them.  It also stores the directory-local settings in
     ‘dir-locals-class-alist’, where it defines a special class for the
     directory in which ‘.dir-locals.el’ file was found.  This function
     works by calling ‘dir-locals-set-class-variables’ and
     ‘dir-locals-set-directory-class’, described below.

 -- Function: hack-dir-local-variables-non-file-buffer
     This function looks for directory-local variables, and immediately
     applies them in the current buffer.  It is intended to be called in
     the mode commands for non-file buffers, such as Dired buffers, to
     let them obey directory-local variable settings.  For non-file
     buffers, Emacs looks for directory-local variables in
     ‘default-directory’ and its parent directories.

 -- Function: dir-locals-set-class-variables class variables
     This function defines a set of variable settings for the named
     CLASS, which is a symbol.  You can later assign the class to one or
     more directories, and Emacs will apply those variable settings to
     all files in those directories.  The list in VARIABLES can be of
     one of the two forms: ‘(MAJOR-MODE . ALIST)’ or ‘(DIRECTORY .
     LIST)’.  With the first form, if the file’s buffer turns on a mode
     that is derived from MAJOR-MODE, then the all the variables in the
     associated ALIST are applied; ALIST should be of the form ‘(NAME .
     VALUE)’.  A special value ‘nil’ for MAJOR-MODE means the settings
     are applicable to any mode.  In ALIST, you can use a special NAME:
     ‘subdirs’.  If the associated value is ‘nil’, the alist is only
     applied to files in the relevant directory, not to those in any
     subdirectories.

     With the second form of VARIABLES, if DIRECTORY is the initial
     substring of the file’s directory, then LIST is applied recursively
     by following the above rules; LIST should be of one of the two
     forms accepted by this function in VARIABLES.

 -- Function: dir-locals-set-directory-class directory class &optional
          mtime
     This function assigns CLASS to all the files in ‘directory’ and its
     subdirectories.  Thereafter, all the variable settings specified
     for CLASS will be applied to any visited file in DIRECTORY and its
     children.  CLASS must have been already defined by
     ‘dir-locals-set-class-variables’.

     Emacs uses this function internally when it loads directory
     variables from a ‘.dir-locals.el’ file.  In that case, the optional
     argument MTIME holds the file modification time (as returned by
     ‘file-attributes’).  Emacs uses this time to check stored local
     variables are still valid.  If you are assigning a class directly,
     not via a file, this argument should be ‘nil’.

 -- Variable: dir-locals-class-alist
     This alist holds the class symbols and the associated variable
     settings.  It is updated by ‘dir-locals-set-class-variables’.

 -- Variable: dir-locals-directory-cache
     This alist holds directory names, their assigned class names, and
     modification times of the associated directory local variables file
     (if there is one).  The function ‘dir-locals-set-directory-class’
     updates this list.

 -- Variable: enable-dir-local-variables
     If ‘nil’, directory-local variables are ignored.  This variable may
     be useful for modes that want to ignore directory-locals while
     still respecting file-local variables (*note File Local
     Variables::).

   ---------- Footnotes ----------

   (1) The MS-DOS version of Emacs uses ‘_dir-locals.el’ instead, due to
limitations of the DOS filesystems.


File: elisp.info,  Node: Connection Local Variables,  Next: Variable Aliases,  Prev: Directory Local Variables,  Up: Variables

12.14 Connection Local Variables
================================

Connection-local variables provide a general mechanism for different
variable settings in buffers with a remote connection.  They are bound
and set depending on the remote connection a buffer is dedicated to.

 -- Function: connection-local-set-profile-variables profile variables
     This function defines a set of variable settings for the connection
     PROFILE, which is a symbol.  You can later assign the connection
     profile to one or more remote connections, and Emacs will apply
     those variable settings to all process buffers for those
     connections.  The list in VARIABLES is an alist of the form
     ‘(NAME . VALUE)’.  Example:

          (connection-local-set-profile-variables
            'remote-bash
            '((shell-file-name . "/bin/bash")
              (shell-command-switch . "-c")
              (shell-interactive-switch . "-i")
              (shell-login-switch . "-l")))

          (connection-local-set-profile-variables
            'remote-ksh
            '((shell-file-name . "/bin/ksh")
              (shell-command-switch . "-c")
              (shell-interactive-switch . "-i")
              (shell-login-switch . "-l")))

          (connection-local-set-profile-variables
            'remote-null-device
            '((null-device . "/dev/null")))

 -- Variable: connection-local-profile-alist
     This alist holds the connection profile symbols and the associated
     variable settings.  It is updated by
     ‘connection-local-set-profile-variables’.

 -- Function: connection-local-set-profiles criteria &rest profiles
     This function assigns PROFILES, which are symbols, to all remote
     connections identified by CRITERIA.  CRITERIA is a plist
     identifying a connection and the application using this connection.
     Property names might be ‘:application’, ‘:protocol’, ‘:user’ and
     ‘:machine’.  The property value of ‘:application’ is a symbol, all
     other property values are strings.  All properties are optional; if
     CRITERIA is ‘nil’, it always applies.  Example:

          (connection-local-set-profiles
            '(:application 'tramp :protocol "ssh" :machine "localhost")
            'remote-bash 'remote-null-device)

          (connection-local-set-profiles
            '(:application 'tramp :protocol "sudo"
              :user "root" :machine "localhost")
            'remote-ksh 'remote-null-device)

     If CRITERIA is ‘nil’, it applies for all remote connections.
     Therefore, the example above would be equivalent to

          (connection-local-set-profiles
            '(:application 'tramp :protocol "ssh" :machine "localhost")
            'remote-bash)

          (connection-local-set-profiles
            '(:application 'tramp :protocol "sudo"
              :user "root" :machine "localhost")
            'remote-ksh)

          (connection-local-set-profiles
            nil 'remote-null-device)

     Any connection profile of PROFILES must have been already defined
     by ‘connection-local-set-profile-variables’.

 -- Variable: connection-local-criteria-alist
     This alist contains connection criteria and their assigned profile
     names.  The function ‘connection-local-set-profiles’ updates this
     list.

 -- Function: hack-connection-local-variables criteria
     This function collects applicable connection-local variables
     associated with CRITERIA in ‘connection-local-variables-alist’,
     without applying them.  Example:

          (hack-connection-local-variables
            '(:application 'tramp :protocol "ssh" :machine "localhost"))

          connection-local-variables-alist
               ⇒ ((null-device . "/dev/null")
                  (shell-login-switch . "-l")
                  (shell-interactive-switch . "-i")
                  (shell-command-switch . "-c")
                  (shell-file-name . "/bin/bash"))

 -- Function: hack-connection-local-variables-apply criteria
     This function looks for connection-local variables according to
     CRITERIA, and immediately applies them in the current buffer.

 -- Macro: with-connection-local-profiles profiles &rest body
     All connection-local variables, which are specified by a connection
     profile in PROFILES, are applied.

     After that, BODY is executed, and the connection-local variables
     are unwound.  Example:

          (connection-local-set-profile-variables
            'remote-perl
            '((perl-command-name . "/usr/local/bin/perl")
              (perl-command-switch . "-e %s")))

          (with-connection-local-profiles '(remote-perl)
            do something useful)

 -- Variable: enable-connection-local-variables
     If ‘nil’, connection-local variables are ignored.  This variable
     shall be changed temporarily only in special modes.


File: elisp.info,  Node: Variable Aliases,  Next: Variables with Restricted Values,  Prev: Connection Local Variables,  Up: Variables

12.15 Variable Aliases
======================

It is sometimes useful to make two variables synonyms, so that both
variables always have the same value, and changing either one also
changes the other.  Whenever you change the name of a variable—either
because you realize its old name was not well chosen, or because its
meaning has partly changed—it can be useful to keep the old name as an
_alias_ of the new one for compatibility.  You can do this with
‘defvaralias’.

 -- Function: defvaralias new-alias base-variable &optional docstring
     This function defines the symbol NEW-ALIAS as a variable alias for
     symbol BASE-VARIABLE.  This means that retrieving the value of
     NEW-ALIAS returns the value of BASE-VARIABLE, and changing the
     value of NEW-ALIAS changes the value of BASE-VARIABLE.  The two
     aliased variable names always share the same value and the same
     bindings.

     If the DOCSTRING argument is non-‘nil’, it specifies the
     documentation for NEW-ALIAS; otherwise, the alias gets the same
     documentation as BASE-VARIABLE has, if any, unless BASE-VARIABLE is
     itself an alias, in which case NEW-ALIAS gets the documentation of
     the variable at the end of the chain of aliases.

     This function returns BASE-VARIABLE.

   Variable aliases are convenient for replacing an old name for a
variable with a new name.  ‘make-obsolete-variable’ declares that the
old name is obsolete and therefore that it may be removed at some stage
in the future.

 -- Function: make-obsolete-variable obsolete-name current-name when
          &optional access-type
     This function makes the byte compiler warn that the variable
     OBSOLETE-NAME is obsolete.  If CURRENT-NAME is a symbol, it is the
     variable’s new name; then the warning message says to use
     CURRENT-NAME instead of OBSOLETE-NAME.  If CURRENT-NAME is a
     string, this is the message and there is no replacement variable.
     WHEN should be a string indicating when the variable was first made
     obsolete (usually a version number string).

     The optional argument ACCESS-TYPE, if non-‘nil’, should specify the
     kind of access that will trigger obsolescence warnings; it can be
     either ‘get’ or ‘set’.

   You can make two variables synonyms and declare one obsolete at the
same time using the macro ‘define-obsolete-variable-alias’.

 -- Macro: define-obsolete-variable-alias obsolete-name current-name
          &optional when docstring
     This macro marks the variable OBSOLETE-NAME as obsolete and also
     makes it an alias for the variable CURRENT-NAME.  It is equivalent
     to the following:

          (defvaralias OBSOLETE-NAME CURRENT-NAME DOCSTRING)
          (make-obsolete-variable OBSOLETE-NAME CURRENT-NAME WHEN)

 -- Function: indirect-variable variable
     This function returns the variable at the end of the chain of
     aliases of VARIABLE.  If VARIABLE is not a symbol, or if VARIABLE
     is not defined as an alias, the function returns VARIABLE.

     This function signals a ‘cyclic-variable-indirection’ error if
     there is a loop in the chain of symbols.

     (defvaralias 'foo 'bar)
     (indirect-variable 'foo)
          ⇒ bar
     (indirect-variable 'bar)
          ⇒ bar
     (setq bar 2)
     bar
          ⇒ 2
     foo
          ⇒ 2
     (setq foo 0)
     bar
          ⇒ 0
     foo
          ⇒ 0


File: elisp.info,  Node: Variables with Restricted Values,  Next: Generalized Variables,  Prev: Variable Aliases,  Up: Variables

12.16 Variables with Restricted Values
======================================

Ordinary Lisp variables can be assigned any value that is a valid Lisp
object.  However, certain Lisp variables are not defined in Lisp, but in
C.  Most of these variables are defined in the C code using
‘DEFVAR_LISP’.  Like variables defined in Lisp, these can take on any
value.  However, some variables are defined using ‘DEFVAR_INT’ or
‘DEFVAR_BOOL’.  *Note Writing Emacs Primitives: Defining Lisp variables
in C, in particular the description of functions of the type
‘syms_of_FILENAME’, for a brief discussion of the C implementation.

   Variables of type ‘DEFVAR_BOOL’ can only take on the values ‘nil’ or
‘t’.  Attempting to assign them any other value will set them to ‘t’:

     (let ((display-hourglass 5))
       display-hourglass)
          ⇒ t

 -- Variable: byte-boolean-vars
     This variable holds a list of all variables of type ‘DEFVAR_BOOL’.

   Variables of type ‘DEFVAR_INT’ can take on only integer values.
Attempting to assign them any other value will result in an error:

     (setq undo-limit 1000.0)
     error→ Wrong type argument: integerp, 1000.0


File: elisp.info,  Node: Generalized Variables,  Prev: Variables with Restricted Values,  Up: Variables

12.17 Generalized Variables
===========================

A “generalized variable” or “place form” is one of the many places in
Lisp memory where values can be stored using the ‘setf’ macro (*note
Setting Generalized Variables::).  The simplest place form is a regular
Lisp variable.  But the CARs and CDRs of lists, elements of arrays,
properties of symbols, and many other locations are also places where
Lisp values get stored.

   Generalized variables are analogous to lvalues in the C language,
where ‘x = a[i]’ gets an element from an array and ‘a[i] = x’ stores an
element using the same notation.  Just as certain forms like ‘a[i]’ can
be lvalues in C, there is a set of forms that can be generalized
variables in Lisp.

* Menu:

* Setting Generalized Variables::   The ‘setf’ macro.
* Adding Generalized Variables::    Defining new ‘setf’ forms.


File: elisp.info,  Node: Setting Generalized Variables,  Next: Adding Generalized Variables,  Up: Generalized Variables

12.17.1 The ‘setf’ Macro
------------------------

The ‘setf’ macro is the most basic way to operate on generalized
variables.  The ‘setf’ form is like ‘setq’, except that it accepts
arbitrary place forms on the left side rather than just symbols.  For
example, ‘(setf (car a) b)’ sets the car of ‘a’ to ‘b’, doing the same
operation as ‘(setcar a b)’, but without you having to use two separate
functions for setting and accessing this type of place.

 -- Macro: setf [place form]...
     This macro evaluates FORM and stores it in PLACE, which must be a
     valid generalized variable form.  If there are several PLACE and
     FORM pairs, the assignments are done sequentially just as with
     ‘setq’.  ‘setf’ returns the value of the last FORM.

   The following Lisp forms are the forms in Emacs that will work as
generalized variables, and so may appear in the PLACE argument of
‘setf’:

   • A symbol.  In other words, ‘(setf x y)’ is exactly equivalent to
     ‘(setq x y)’, and ‘setq’ itself is strictly speaking redundant
     given that ‘setf’ exists.  Most programmers will continue to prefer
     ‘setq’ for setting simple variables, though, for stylistic and
     historical reasons.  The macro ‘(setf x y)’ actually expands to
     ‘(setq x y)’, so there is no performance penalty for using it in
     compiled code.

   • A call to any of the following standard Lisp functions:

          aref      cddr      symbol-function
          car       elt       symbol-plist
          caar      get       symbol-value
          cadr      gethash
          cdr       nth
          cdar      nthcdr

   • A call to any of the following Emacs-specific functions:

          alist-get                     process-get
          frame-parameter               process-sentinel
          terminal-parameter            window-buffer
          keymap-parent                 window-display-table
          match-data                    window-dedicated-p
          overlay-get                   window-hscroll
          overlay-start                 window-parameter
          overlay-end                   window-point
          process-buffer                window-start
          process-filter                default-value

‘setf’ signals an error if you pass a PLACE form that it does not know
how to handle.

   Note that for ‘nthcdr’, the list argument of the function must itself
be a valid PLACE form.  For example, ‘(setf (nthcdr 0 foo) 7)’ will set
‘foo’ itself to 7.

   The macros ‘push’ (*note List Variables::) and ‘pop’ (*note List
Elements::) can manipulate generalized variables, not just lists.  ‘(pop
PLACE)’ removes and returns the first element of the list stored in
PLACE.  It is analogous to ‘(prog1 (car PLACE) (setf PLACE (cdr
PLACE)))’, except that it takes care to evaluate all subforms only once.
‘(push X PLACE)’ inserts X at the front of the list stored in PLACE.  It
is analogous to ‘(setf PLACE (cons X PLACE))’, except for evaluation of
the subforms.  Note that ‘push’ and ‘pop’ on an ‘nthcdr’ place can be
used to insert or delete at any position in a list.

   The ‘cl-lib’ library defines various extensions for generalized
variables, including additional ‘setf’ places.  *Note (cl)Generalized
Variables::.


File: elisp.info,  Node: Adding Generalized Variables,  Prev: Setting Generalized Variables,  Up: Generalized Variables

12.17.2 Defining new ‘setf’ forms
---------------------------------

This section describes how to define new forms that ‘setf’ can operate
on.

 -- Macro: gv-define-simple-setter name setter &optional fix-return
     This macro enables you to easily define ‘setf’ methods for simple
     cases.  NAME is the name of a function, macro, or special form.
     You can use this macro whenever NAME has a directly corresponding
     SETTER function that updates it, e.g., ‘(gv-define-simple-setter
     car setcar)’.

     This macro translates a call of the form

          (setf (NAME ARGS...) VALUE)

     into
          (SETTER ARGS... VALUE)

     Such a ‘setf’ call is documented to return VALUE.  This is no
     problem with, e.g., ‘car’ and ‘setcar’, because ‘setcar’ returns
     the value that it set.  If your SETTER function does not return
     VALUE, use a non-‘nil’ value for the FIX-RETURN argument of
     ‘gv-define-simple-setter’.  This expands into something equivalent
     to
          (let ((temp VALUE))
            (SETTER ARGS... temp)
            temp)
     so ensuring that it returns the correct result.

 -- Macro: gv-define-setter name arglist &rest body
     This macro allows for more complex ‘setf’ expansions than the
     previous form.  You may need to use this form, for example, if
     there is no simple setter function to call, or if there is one but
     it requires different arguments to the place form.

     This macro expands the form ‘(setf (NAME ARGS...) VALUE)’ by first
     binding the ‘setf’ argument forms ‘(VALUE ARGS...)’ according to
     ARGLIST, and then executing BODY.  BODY should return a Lisp form
     that does the assignment, and finally returns the value that was
     set.  An example of using this macro is:

          (gv-define-setter caar (val x) `(setcar (car ,x) ,val))

   For more control over the expansion, see the macro
‘gv-define-expander’.  The macro ‘gv-letplace’ can be useful in defining
macros that perform similarly to ‘setf’; for example, the ‘incf’ macro
of Common Lisp.  Consult the source file ‘gv.el’ for more details.

     Common Lisp note: Common Lisp defines another way to specify the
     ‘setf’ behavior of a function, namely ‘setf’ functions, whose names
     are lists ‘(setf NAME)’ rather than symbols.  For example, ‘(defun
     (setf foo) ...)’ defines the function that is used when ‘setf’ is
     applied to ‘foo’.  Emacs does not support this.  It is a
     compile-time error to use ‘setf’ on a form that has not already had
     an appropriate expansion defined.  In Common Lisp, this is not an
     error since the function ‘(setf FUNC)’ might be defined later.


File: elisp.info,  Node: Functions,  Next: Macros,  Prev: Variables,  Up: Top

13 Functions
************

Программа на Лиспе состоит в основном из функций на Лиспе.  Эта глава
объясняет, что такое функции, как они принимают аргументы и как их
определять.

* Menu:

* What Is a Function::          Функции Lisp против примитивов; терминология.
* Lambda Expressions::          Как функции выражаются как объекты Lisp.
* Function Names::              Символ может служить именем функции.
* Defining Functions::          Лисп-выражения для определения функций.
* Calling Functions::           Как использовать существующую функцию.
* Mapping Functions::           Применение функции к каждому элементу списка и т.п.
* Anonymous Functions::         Лямбда-выражения - это функции без имен.
* Generic Functions::           Полиморфизм в стиле Emacs.
* Function Cells::              Доступ или определение функции определения символа.
* Closures::                    Функции, которые заключают в себе лексическую среду.
* Advising Functions::          Добавление к определению функции.
* Obsolete Functions::          Объявление функций устаревшими.
* Inline Functions::            Функции, которые компилятор будет расширять встроенными.
* Declare Form::                Добавление дополнительной информации о функции.
* Declaring Functions::         Сообщаем компилятору, что функция определена.
* Function Safety::             Определение, безопасна ли функция для вызова.
* Related Topics::              Перекрестные ссылки на конкретные примитивы Lisp, которые
                                имеют особое отношение к тому, как работают функции.


File: elisp.info,  Node: What Is a Function,  Next: Lambda Expressions,  Up: Functions

13.1 What Is a Function?
========================

В общем смысле функция - это правило для выполнения вычислений с
заданными входными значениями, называемыми “arguments”.  Результат
вычисления называется “value” или “return value” функции.  Вычисления
также могут иметь побочные эффекты, такие как длительные изменения
значений переменных или содержимого структур данных.

   На большинстве компьютерных языков у каждой функции есть имя.  Но в
Лиспе функция в самом строгом смысле не имеет имени: это объект, который
может быть связан с символом _optionally_, который служит именем
функции.  *Note Function Names::.  Когда функции присваивается имя, мы
обычно также называем этот символ как “function” (например, мы ссылаемся
на “the function ‘car’”).  В этом руководстве различие между именем
функции и самим объектом функции, как правило, не имеет значения, но мы
отметим, где это уместно.

   Некоторые функционально-подобные объекты, называемые “special forms”
и “macros”, также принимают аргументы для выполнения вычислений.
Однако, как объясняется ниже, они не считаются функциями в Emacs Lisp.

   Вот важные термины для функций и функционально-подобных объектов:

“lambda expression”
     Функция (в строгом смысле, то есть объект функции), которая
     написана на Лиспе.  Описаны в следующем разделе.  *Note Lambda
     Expressions::.

“primitive”
     Функция, которая вызывается из Lisp, но на самом деле написана в C.
     Примитивы также называются “built-in functions” или “subrs”.
     Примеры включают такие функции, как ‘car’ и ‘append’.  Кроме того,
     все специальные формы (см.  Ниже) также считаются примитивами.

     Обычно функция реализуется как примитив, потому что она является
     фундаментальной частью Lisp (например, ‘car’), или потому, что она
     обеспечивает низкоуровневый интерфейс для служб операционной
     системы, или потому что она должна работать быстро.  В отличие от
     функций, определенных в Lisp, примитивы могут быть изменены или
     добавлены только путем изменения исходных кодов C и перекомпиляции
     Emacs.  Смотрите *note Writing Emacs Primitives::.

“special form”
     Примитив, который похож на функцию, но не оценивает все свои
     аргументы обычным способом.  Он может оценивать только некоторые из
     аргументов или может оценивать их в необычном порядке или несколько
     раз.  Примеры включают в себя ‘if’, ‘and’, и ‘while’.  *Note
     Special Forms::.

“macro”
     Конструкция, определенная в Lisp, которая отличается от функции
     тем, что переводит выражение Lisp в другое выражение, которое
     должно оцениваться вместо исходного выражения.  Макросы позволяют
     программистам на Лиспе делать то, что могут делать специальные
     формы.  *Note Macros::.

“command”
     Объект, который может быть вызван через примитив ‘command-execute’,
     обычно из-за того, что пользователь вводит последовательность
     клавиш “bound” для этой команды.  *Note Interactive Call::.
     Команда обычно является функцией; если функция написана на Лиспе,
     она превращается в команду в форме ‘interactive’ в определении
     функции (*note Defining Commands::).  Команды, которые являются
     функциями, также могут вызываться из выражений Lisp, как и другие
     функции.

     Макросы клавиатуры (строки и векторы) также являются командами,
     даже если они не являются функциями.  *Note Keyboard Macros::.  Мы
     говорим, что символ является командой, если его функциональная
     ячейка содержит команду (*note Symbol Components::); такой “named
     command” может быть вызван с ‘M-x’.

“closure”
     Функциональный объект, который очень похож на лямбда-выражение, за
     исключением того, что он также включает в себя среду привязки
     лексических переменных.  *Note Closures::.

“byte-code function”
     Функция, которая была скомпилирована байтовым компилятором.  *Note
     Byte-Code Type::.

“autoload object”
     Заполнитель для реальной функции.  Если вызывается объект
     автозагрузки, Emacs загружает файл, содержащий определение реальной
     функции, а затем вызывает настоящую функцию.  *Note Autoload::.

   Вы можете использовать функцию ‘functionp’, чтобы проверить, является
ли объект функцией:

 -- Function: functionp object
     Эта функция возвращает ‘t’, если OBJECT - это функция любого типа,
     т.е.  она может быть передана в ‘funcall’.  Обратите внимание, что
     ‘functionp’ возвращает ‘t’ для символов, которые являются именами
     функций, и возвращает ‘nil’ для специальных форм.

   Также можно узнать, сколько аргументов ожидает произвольная функция:

 -- Function: func-arity function
     Эта функция предоставляет информацию о списке аргументов указанного
     FUNCTION.  Возвращаемое значение является cons-ячейкой вида
     ‘(MIN. MAX)’, где MIN - минимальное количество аргументов, а MAX -
     либо максимальное количество аргументов, либо символ ‘many’ для
     функций с аргументами ‘&rest’, либо символ ‘unevalled’, если
     FUNCTION является особой формой.

     Обратите внимание, что эта функция может возвращать неточные
     результаты в некоторых ситуациях, например:

        − Функции, определенные с помощью ‘apply-partially’ (*note
          apply-partially: Calling Functions.).

        − Функции, которые рекомендуется использовать ‘advice-add’
          (*note Advising Named Functions::).

        − Функции, которые определяют список аргументов динамически, как
          часть их кода.

В отличие от ‘functionp’, следующие три функции _not_ рассматривают
символ как определение своей функции.

 -- Function: subrp object
     Эта функция возвращает ‘t’, если OBJECT является встроенной
     функцией (i.e., a Lisp primitive).

          (subrp 'message)            ; ‘message’ это символ,
               ⇒ nil                 ;   не объект subr.
          (subrp (symbol-function 'message))
               ⇒ t

 -- Function: byte-code-function-p object
     Эта функция возвращает ‘t’, если OBJECT является функцией
     байт-кода.  Например:

          (byte-code-function-p (symbol-function 'next-line))
               ⇒ t

 -- Function: subr-arity subr
     Это работает как ‘func-arity’, но только для встроенных функций и
     без косвенного обращения символа.  Это сигнализирует об ошибке для
     не встроенных функций.  Мы рекомендуем использовать ‘func-arity’
     вместо этого.


File: elisp.info,  Node: Lambda Expressions,  Next: Function Names,  Prev: What Is a Function,  Up: Functions

13.2 Lambda Expressions
=======================

Лямбда-выражение - это функциональный объект, написанный на Лиспе.  Вот
пример:

     (lambda (x)
       "Вернуть гиперболический косинус X."
       (* 0.5 (+ (exp x) (exp (- x)))))

В Emacs Lisp такой список является допустимым выражением, которое
оценивает функциональный объект.

   Лямбда-выражение само по себе не имеет имени; это “anonymous
function”.  Хотя лямбда-выражения можно использовать таким образом
(*note Anonymous Functions::), они чаще ассоциируются с символами для
создания “named functions” (*note Function Names::).  Прежде чем
углубляться в эти детали, в следующих подразделах описываются компоненты
лямбда-выражения и их действия.

* Menu:

* Lambda Components::           Части лямбда-выражения.
* Simple Lambda::               Простой пример.
* Argument List::               Подробности и особенности списков аргументов.
* Function Documentation::      Как поместить документацию в функцию.


File: elisp.info,  Node: Lambda Components,  Next: Simple Lambda,  Up: Lambda Expressions

13.2.1 Components of a Lambda Expression
----------------------------------------

Лямбда-выражение представляет собой список, который выглядит следующим
образом:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

   Первым элементом лямбда-выражения всегда является символ ‘lambda’.
Это указывает на то, что список представляет функцию.  Функции, которые
определены ‘lambda’, заключаются в том, что другие списки,
предназначенные для других целей, не будут случайно интерпретироваться в
качестве функций.

   Второй элемент - это список символов — имена переменных аргументов.
Это называется “lambda list”.  Когда вызывается функция Lisp, значения
аргументов сопоставляются с переменными в лямбда-списке, которым
присваиваются локальные привязки с указанными значениями.  *Note Local
Variables::.

   Строка документации - это строковый объект Lisp, помещенный в
определение функции для описания функции справочных средств Emacs.
*Note Function Documentation::.

   Интерактивная декларация представляет собой список вида ‘(interactive
CODE-STRING)’.  Это объявляет, как предоставить аргументы, если функция
используется в интерактивном режиме.  Функции с этим объявлением
называются “commands”; они могут быть вызваны с использованием ‘M-x’ или
привязаны к ключу.  Функции, не предназначенные для такого вызова, не
должны иметь интерактивных объявлений.  *Note Defining Commands::, о
том, как написать интерактивную декларацию.

   Остальные элементы - это “body” функции: код на Лиспе для выполнения
работы функции (или, как сказал бы программист на Лиспе, “ список форм
Лисп для оценки ”).  Значение, возвращаемое функцией, является
значением, возвращаемым последним элементом тела.


File: elisp.info,  Node: Simple Lambda,  Next: Argument List,  Prev: Lambda Components,  Up: Lambda Expressions

13.2.2 A Simple Lambda Expression Example
-----------------------------------------

Рассмотрим следующий пример:

     (lambda (a b c) (+ a b c))

Мы можем вызвать эту функцию, передав ее в ‘funcall’, например так:

     (funcall (lambda (a b c) (+ a b c))
              1 2 3)

Этот вызов оценивает тело лямбда-выражения с переменной ‘a’, связанной с
1, ‘b’, связанной с 2, и ‘c’, связанной с 3.  Оценка тела добавляет эти
три числа, производя результат 6; следовательно, этот вызов функции
возвращает значение 6.

   Обратите внимание, что аргументы могут быть результатами других
вызовов функций, как в этом примере:

     (funcall (lambda (a b c) (+ a b c))
              1 (* 2 3) (- 5 4))

Это оценивает аргументы ‘1’, ‘(* 2 3)’ и ‘(- 5 4)’ слева направо.  Затем
он применяет лямбда-выражение к значениям аргументов 1, 6 и 1, чтобы
получить значение 8.

   Как показывают эти примеры, вы можете использовать форму с
лямбда-выражением в качестве CAR для создания локальных переменных и
присвоения им значений.  В старые времена Лиспа этот метод был
единственным способом связать и инициализировать локальные переменные.
Но в настоящее время для этой цели понятнее использовать специальную
форму ‘let’ (*note Local Variables::).  Лямбда-выражения в основном
используются как анонимные функции для передачи в качестве аргументов
другим функциям (*note Anonymous Functions::) или хранятся как
определения символьных функций для создания именованных функций (*note
Function Names::).


File: elisp.info,  Node: Argument List,  Next: Function Documentation,  Prev: Simple Lambda,  Up: Lambda Expressions

13.2.3 Other Features of Argument Lists
---------------------------------------

Наша простая для примера функция, ‘(lambda (a b c) (+ a b c))’, задает
три переменные аргумента, поэтому она должна вызываться с тремя
аргументами: если вы попытаетесь вызвать ее только с двумя аргументами
или четырьмя аргументами, вы получите ошибку ‘wrong-number-of-arguments’
(*note Errors::).

   Часто удобно написать функцию, которая позволяет опустить
определенные аргументы.  Например, функция ‘substring’ принимает три
аргумента - строку, начальный индекс и конечный индекс - но третий
аргумент по умолчанию равен LENGTH строки, если вы его опускаете.
Некоторым функциям также удобно принимать неопределенное количество
аргументов, как это делают функции ‘list’ и ‘+’.

   Чтобы указать необязательные аргументы, которые могут быть опущены
при вызове функции, просто включите ключевое слово ‘&optional’ перед
необязательными аргументами.  Чтобы указать список из нуля или более
дополнительных аргументов, включите ключевое слово ‘&rest’ перед одним
последним аргументом.

   Таким образом, полный синтаксис для списка аргументов выглядит
следующим образом:

     (REQUIRED-VARS...
      [&optional OPTIONAL-VARS...]
      [&rest REST-VAR])

Квадратные скобки указывают, что предложения ‘&optional’ и ‘&rest’ и
переменные, которые следуют за ними, являются необязательными.

   Для вызова функции требуется один фактический аргумент для каждого из
REQUIRED-VARS.  Могут быть реальные аргументы для нуля или более
OPTIONAL-VARS, и не может быть никаких реальных аргументов, кроме тех
случаев, когда в лямбда-списке используется ‘&rest’.  В этом случае
может быть любое количество дополнительных фактических аргументов.

   Если фактические аргументы для необязательных и остальных переменных
опущены, то по умолчанию они всегда равны ‘nil’.  Функция не может
различить явный аргумент ‘nil’ и опущенный аргумент.  Тем не менее, тело
функции может считать ‘nil’ сокращением для некоторого другого значимого
значения.  Это то, что делает ‘substring’; ‘nil’ в качестве третьего
аргумента для ‘substring’ означает использование длины предоставленной
строки.

     Common Lisp note: Common Lisp позволяет функции указывать, какое
     значение по умолчанию использовать, когда опциональный аргумент
     опущен; Emacs Lisp всегда использует ‘nil’.  Emacs Lisp не
     поддерживает переменные ‘supplied-p’, которые сообщают вам, был ли
     аргумент передан явно.

   Например, список аргументов, который выглядит так:

     (a b &optional c d &rest e)

связывает ‘a’ и ‘b’ с первыми двумя фактическими аргументами, которые
необходимы.  Если предоставлен еще один или два аргумента, ‘c’ и ‘d’
связаны с ними соответственно; любые аргументы после первых четырех
собираются в список, и ‘e’ привязывается к этому списку.  Если есть
только два аргумента, ‘c’ будет ‘nil’; если два или три аргумента, ‘d’ -
это ‘nil’; если четыре аргумента или меньше, ‘e’ будет ‘nil’.

   Невозможно иметь обязательные аргументы после необязательных - это не
имеет смысла.  Чтобы понять, почему это так, предположим, что ‘c’ в
примере был необязательным, а ‘d’ - обязательным.  Предположим, даны три
фактических аргумента; для какой переменной будет третий аргумент?
Будет ли он использоваться для C или для D?  Можно поспорить за обе
возможности.  Точно так же не имеет смысла иметь больше аргументов
(обязательных или необязательных) после аргумента ‘&rest’.

   Вот несколько примеров списков аргументов и правильных вызовов:

     (funcall (lambda (n) (1+ n))        ; Один требуется:
              1)                         ; требует ровно одного аргумента.
          ⇒ 2
     (funcall (lambda (n &optional n1)   ; Один обязательный и один необязательный:
                (if n1 (+ n n1) (1+ n))) ; 1 или 2 аргумента.
              1 2)
          ⇒ 3
     (funcall (lambda (n &rest ns)       ; Один требуется и один отдых:
                (+ n (apply '+ ns)))     ; 1 или больше аргументов.
              1 2 3 4 5)
          ⇒ 15


File: elisp.info,  Node: Function Documentation,  Prev: Argument List,  Up: Lambda Expressions

13.2.4 Documentation Strings of Functions
-----------------------------------------

Лямбда-выражение может необязательно иметь “documentation string” сразу
после лямбда-списка.  Эта строка не влияет на выполнение функции; это
своего рода комментарий, но систематизированный комментарий, который на
самом деле появляется в мире Lisp и может быть использован средствами
помощи Emacs.  *Note Documentation::, для того, как получить доступ к
строке документации.

   Рекомендуется предоставлять строки документации для всех функций в
вашей программе, даже для тех, которые вызываются только из вашей
программы.  Строки документации похожи на комментарии, за исключением
того, что они легче доступны.

   Первая строка строки документации должна стоять отдельно, потому что
‘apropos’ отображает только эту первую строку.  Он должен состоять из
одного или двух полных предложений, которые суммируют назначение
функции.

   Начало строки документации обычно имеет отступ в исходном файле, но
поскольку эти пробелы идут перед начальной двойной кавычкой, они не
являются частью строки.  Некоторые люди практикуют делать отступы для
любых дополнительных строк строки, чтобы текст располагался в исходном
коде программы.  _That is a mistake._  Отступ следующих строк находится
внутри строки; то, что выглядит хорошо в исходном коде, будет выглядеть
ужасно при отображении командами справки.

   Вы можете задаться вопросом, как строка документации может быть
необязательной, поскольку за ней следуют обязательные компоненты функции
(тело).  Так как вычисление строки возвращает эту строку без каких-либо
побочных эффектов, это не имеет никакого эффекта, если она не является
последней формой в теле.  Таким образом, на практике нет никакой
путаницы между первой формой тела и строкой документации; если
единственной формой тела является строка, то она служит и как
возвращаемое значение, и как документация.

   Последняя строка строки документации может указывать соглашения о
вызовах, отличные от фактических аргументов функции.  Напишите текст
так:

     \(fn ARGLIST)

после пустой строки, в начале строки, без новой строки после нее внутри
строки документации.  (The ‘\’ используется, чтобы избежать путаницы в
командах движения Emacs.)  Указанное таким образом соглашение о вызовах
появляется в справочных сообщениях вместо тех, которые получены из
фактических аргументов функции.

   Эта функция особенно полезна для определений макросов, поскольку
аргументы, записанные в определении макросов, часто не соответствуют
тому, как пользователи думают о частях вызова макроса.

   Не используйте эту функцию, если вы хотите отказаться от соглашения о
вызовах и отдать предпочтение тому, который вы рекламируете в
приведенной выше спецификации.  Вместо этого используйте объявление
‘advertised-calling-convention’ (*note Declare Form::) или
‘set-advertised-calling-convention’ (*note Obsolete Functions::), потому
что эти два заставят байтовый компилятор выдавать предупреждающее
сообщение, когда он компилирует программы на Лиспе, которые используют
устаревшее соглашение о вызовах.


File: elisp.info,  Node: Function Names,  Next: Defining Functions,  Prev: Lambda Expressions,  Up: Functions

13.3 Naming a Function
======================

Символ может служить именем функции.  Это происходит, когда “function
cell” (*note Symbol Components::) символа содержит функциональный объект
(например, лямбда-выражение).  Тогда сам символ становится
действительной, вызываемой функцией, эквивалентной функциональному
объекту в его функциональной ячейке.

   Содержимое ячейки функции также называется “function definition”
символа.  Процедура использования определения функции символа вместо
символа называется “symbol function indirection”; см.  *note Function
Indirection::.  Если вы не дали символу определение функции, его ячейка
функции называется “void”, и ее нельзя использовать в качестве функции.

   На практике почти все функции имеют имена и называются их именами.
Вы можете создать именованную функцию Lisp, определив лямбда-выражение и
поместив его в ячейку функции (*note Function Cells::).  Однако чаще
используется специальная форма ‘defun’, описанная в следующем разделе.
*Note Defining Functions::.

   Мы даем имена функций, потому что к ним удобно обращаться по их
именам в выражениях Lisp.  Кроме того, именованная функция Lisp может
легко ссылаться на себя - она ​​может быть рекурсивной.  Кроме того, на
примитивы можно ссылаться только в текстовом виде по их именам,
поскольку примитивные функциональные объекты (*note Primitive Function
Type::) не имеют синтаксиса чтения.

   Функция не должна иметь уникального имени.  Данный функциональный
объект _usually_ появляется в ячейке функции только одного символа, но
это всего лишь соглашение.  Его легко хранить в нескольких символах,
используя ‘fset’; тогда каждый из символов является допустимым именем
для той же функции.

   Обратите внимание, что символ, используемый в качестве имени функции,
также может использоваться как переменная; эти два использования символа
независимы и не конфликтуют.  (Это не так на некоторых диалектах Лиспа,
таких как Scheme.)

   По соглашению, если символ функции состоит из двух имен, разделенных
‘--’, функция предназначена для внутреннего использования, а первая
часть именует файл, определяющий функцию.  Например, функция с именем
‘vc-git--rev-parse’ является внутренней функцией, определенной в
‘vc-git.el’.  Функции внутреннего использования, написанные на C, имеют
имена, оканчивающиеся на ‘-internal’, например, ‘bury-buffer-internal’.
Код Emacs, представленный до 2018 года, может следовать другим
соглашениям об именах внутреннего использования, которые постепенно
прекращаются.


File: elisp.info,  Node: Defining Functions,  Next: Calling Functions,  Prev: Function Names,  Up: Functions

13.4 Defining Functions
=======================

Обычно мы даем имя функции при ее первом создании.  Это называется
“defining a function”, и это делается с помощью макроса ‘defun’.

 -- Macro: defun name args [doc] [declare] [interactive] body...
     ‘defun’ - это обычный способ определения новых функций Lisp.  Он
     определяет символ NAME как функцию со списком аргументов ARGS и
     формами тела, заданными BODY.  Ни NAME, ни ARGS не следует
     заключать в кавычки.

     DOC, если присутствует, должен быть строкой, определяющей строку
     документации функции (*note Function Documentation::).  DECLARE,
     если имеется, должен быть формой ‘declare’, определяющей метаданные
     функции (*note Declare Form::).  INTERACTIVE, если он присутствует,
     должен быть формой ‘interactive’, определяющей, как функция должна
     вызываться в интерактивном режиме (*note Interactive Call::).

     Возвращаемое значение ‘defun’ не определено.

     вот несколько примеров:

          (defun foo () 5)
          (foo)
               ⇒ 5

          (defun bar (a &optional b &rest c)
              (list a b c))
          (bar 1 2 3 4 5)
               ⇒ (1 2 (3 4 5))
          (bar 1)
               ⇒ (1 nil nil)
          (bar)
          error→ Wrong number of arguments.

          (defun capitalize-backwards ()
            "Upcase последняя буква слова в точке."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))

     Будьте осторожны, чтобы не переопределить существующие функции
     непреднамеренно.  ‘defun’ переопределяет даже примитивные функции,
     такие как ‘car’, без каких-либо колебаний или уведомлений.  Emacs
     не мешает вам сделать это, потому что переопределение функции
     иногда выполняется намеренно, и нет никакого способа отличить
     преднамеренное переопределение от непреднамеренного
     переопределения.

 -- Function: defalias name definition &optional doc
     Эта функция определяет символ NAME как функцию с определением
     DEFINITION (которая может быть любой допустимой лисповской
     функцией).  Её возвращаемое значение - _undefined_.

     Если DOC не является ‘nil’, он становится функциональной
     документацией NAME.  В противном случае используется любая
     документация, предоставленная DEFINITION.

     Внутренне, ‘defalias’ обычно использует ‘fset’, чтобы установить
     определение.  Однако, если NAME имеет свойство
     ‘defalias-fset-function’, соответствующее значение используется как
     функция для вызова вместо ‘fset’.

     Правильное место для использования ‘defalias’ - это место, где
     определяется конкретное имя функции, особенно когда это имя явно
     появляется в загружаемом исходном файле.  Это потому, что
     ‘defalias’ записывает, какой файл определил функцию, так же, как
     ‘defun’ (*note Unloading::).

     Напротив, в программах, которые манипулируют определениями функций
     для других целей, лучше использовать ‘fset’, который не ведет такие
     записи.  *Note Function Cells::.

   Вы не можете создать новую примитивную функцию с помощью ‘defun’ или
‘defalias’, но вы можете использовать их для изменения определения
функции любого символа, даже такого, как ‘car’ или ‘x-popup-menu’, чье
обычное определение является примитивом.  Однако это рискованно:
например, почти невозможно переопределить ‘car’, не сломав полностью
Lisp.  Переопределение скрытой функции, такой как ‘x-popup-menu’, менее
опасно, но все равно может работать не так, как вы ожидаете.  Если к
примитиву поступают вызовы из кода C, они напрямую вызывают определение
C примитива, поэтому изменение определения символа на них не повлияет.

   Смотрите также ‘defsubst’, который определяет функцию, подобную
‘defun’, и указывает компилятору Lisp выполнить встроенное расширение
над ней.  *Note Inline Functions::.

   Кроме того, вы можете определить функцию, предоставив код, который
будет встроен в нее как макрос компилятора.  Следующие макросы делают
это возможным.

 -- Macro: define-inline name args [doc] [declare] body...
     Определите функцию NAME, предоставив код, который выполняет ее
     вставку, как макрос компилятора.  Функция примет список аргументов
     ARGS и будет иметь указанный BODY.

     Если присутствует, DOC должен быть строкой документации функции
     (*note Function Documentation::); DECLARE, если он присутствует,
     должен иметь форму ‘declare’ (*note Declare Form::), определяющую
     метаданные функции.

   Функции, определенные через ‘define-inline’, имеют несколько
преимуществ по отношению к макросам, определенным ‘defsubst’ или
‘defmacro’:

   − Они могут быть переданы в ‘mapcar’ (*note Mapping Functions::).

   − Они более эффективны.

   − Их можно использовать как “place forms” для хранения значений
     (*note Generalized Variables::).

   − Они ведут себя более предсказуемо, чем ‘cl-defsubst’ (*note
     (cl)Argument Lists::).

   Как и ‘defmacro’, функция, встроенная в ‘define-inline’, наследует
правила области видимости, динамические или лексические, от сайта
вызова.  *Note Variable Scoping::.

   Следующие макросы должны использоваться в теле функции, определенной
‘define-inline’.

 -- Macro: inline-quote expression
     Цитировать EXPRESSION для ‘define-inline’.  Это похоже на обратную
     цитату (*note Backquote::), но цитирует код и принимает только ‘,’,
     а не ‘,@’.

 -- Macro: inline-letevals (bindings...) body...
     Это похоже на ‘let’ (*note Local Variables::): он устанавливает
     локальные переменные, как указано в BINDINGS, а затем оценивает
     BODY с учетом этих привязок.  Каждый элемент BINDINGS должен быть
     либо символом, либо списком вида ‘(VAR EXPR)’; Результатом является
     оценка EXPR и привязка VAR к результату.  Хвост BINDINGS может быть
     либо ‘nil’, либо символом, который должен содержать список
     аргументов, в этом случае каждый аргумент оценивается, и символ
     связывается с результирующим списком.

 -- Macro: inline-const-p expression
     Вернуть non-‘nil’, если значение EXPRESSION уже известно.

 -- Macro: inline-const-val expression
     Вернуть значение EXPRESSION.

 -- Macro: inline-error format &rest args
     Подайте ошибку, форматируя ARGS в соответствии с FORMAT.

   Вот пример использования ‘define-inline’:

     (define-inline myaccessor (obj)
       (inline-letevals (obj)
         (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))

Это эквивалентно

     (defsubst myaccessor (obj)
       (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))


File: elisp.info,  Node: Calling Functions,  Next: Mapping Functions,  Prev: Defining Functions,  Up: Functions

13.5 Calling Functions
======================

Определение функций - это только полдела.  Функции ничего не делают,
пока вы не обнаружите их, то есть не скажете им запускаться.  Вызов
функции также известен как “invocation”.

   Наиболее распространенным способом вызова функции является оценка
списка.  Например, при оценке списка ‘(concat "a" "b")’ вызывается
функция ‘concat’ с аргументами ‘"a"’ и ‘"b"’.  *Note Evaluation::, для
описания оценки.

   Когда вы пишете список в виде выражения в вашей программе, вы
указываете, какую функцию вызывать и сколько аргументов для ее
предоставления в тексте программы.  Обычно это именно то, что вы хотите.
Иногда вам нужно вычислить во время выполнения, какую функцию вызывать.
Для этого используйте функцию ‘funcall’.  Когда вам также нужно
определить во время выполнения, сколько аргументов нужно передать,
используйте ‘apply’.

 -- Function: funcall function &rest arguments
     ‘funcall’ вызывает FUNCTION с помощью ARGUMENTS и возвращает все,
     что возвращает FUNCTION.

     Поскольку ‘funcall’ является функцией, все ее аргументы, включая
     FUNCTION, оцениваются до вызова ‘funcall’.  Это означает, что вы
     можете использовать любое выражение для получения вызываемой
     функции.  Это также означает, что ‘funcall’ не видит выражения,
     которые вы пишете для ARGUMENTS, а только их значения.  Эти
     значения _not_ оцениваются во второй раз в процессе вызова
     FUNCTION; операция ‘funcall’ похожа на обычную процедуру вызова
     функции, после того как ее аргументы уже оценены.

     Аргумент FUNCTION должен быть либо функцией Лиспа, либо примитивной
     функцией.  Специальные формы и макросы не допускаются, потому что
     они имеют смысл только при наличии выражений аргументов без оценки.
     ‘funcall’ не может предоставить их, потому что, как мы видели выше,
     он никогда не знает их в первую очередь.

     Если вам нужно использовать ‘funcall’ для вызова команды и
     заставить ее вести себя так, как будто она вызывается в
     интерактивном режиме, используйте ‘funcall-interactively’ (*note
     Interactive Call::).

          (setq f 'list)
               ⇒ list
          (funcall f 'x 'y 'z)
               ⇒ (x y z)
          (funcall f 'x 'y '(z))
               ⇒ (x y (z))
          (funcall 'and t nil)
          error→ Invalid function: #<subr and>

     Сравните эти примеры с примерами ‘apply’.

 -- Function: apply function &rest arguments
     ‘apply’ вызывает FUNCTION с ARGUMENTS, точно так же, как ‘funcall’,
     но с одним отличием: последний из ARGUMENTS - это список объектов,
     которые передаются в FUNCTION как отдельные аргументы, а не как
     один список.  Мы говорим, что ‘apply’ “spreads” этот список, так
     что каждый отдельный элемент становится аргументом.

     ‘apply’ возвращает результат вызова FUNCTION.  Как и в случае с
     ‘funcall’, FUNCTION должен быть либо функцией Lisp, либо
     примитивной функцией; специальные формы и макросы не имеют смысла в
     ‘apply’.

          (setq f 'list)
               ⇒ list
          (apply f 'x 'y 'z)
          error→ Wrong type argument: listp, z
          (apply '+ 1 2 '(3 4))
               ⇒ 10
          (apply '+ '(1 2 3 4))
               ⇒ 10

          (apply 'append '((a b c) nil (x y z) nil))
               ⇒ (a b c x y z)

     Для интересного примера использования ‘apply’, см.  *note
     Definition of mapcar::.

   Иногда полезно зафиксировать некоторые аргументы функции при
определенных значениях и оставить остальные аргументы, когда функция на
самом деле вызывается.  Акт фиксации некоторых аргументов функции
называется “partial application” из function(1).  Результатом является
новая функция, которая принимает остальные аргументы и вызывает исходную
функцию со всеми объединенными аргументами.

   Вот как сделать частичное применение в Emacs Lisp:

 -- Function: apply-partially func &rest args
     Эта функция возвращает новую функцию, которая при вызове будет
     вызывать FUNC со списком аргументов, составленным из ARGS, и
     дополнительными аргументами, указанными во время вызова.  Если FUNC
     принимает аргументы N, то вызов ‘apply-partially’ с аргументами
     ‘M < N’ создаст новую функцию аргументов ‘N - M’.

     Вот как мы можем определить встроенную функцию ‘1+’, если она не
     существует, используя ‘apply-partially’ и ‘+’, другую встроенную
     функцию:

          (defalias '1+ (apply-partially '+ 1)
            "Увеличение аргумента на единицу.")
          (1+ 10)
               ⇒ 11

   Обычно функции Lisp принимают функции в качестве аргументов или
находят их в структурах данных (особенно в переменных хуков и списках
свойств) и вызывают их, используя ‘funcall’ или ‘apply’.  Функции,
которые принимают аргументы функции, часто называются “functionals”.

   Иногда, когда вы вызываете функционал, полезно предоставить функцию
no-op в качестве аргумента.  Вот два разных типа неоперативной функции:

 -- Function: identity arg
     Эта функция возвращает ARG и не имеет побочных эффектов.

 -- Function: ignore &rest args
     Эта функция игнорирует любые аргументы и возвращает ‘nil’.

   Некоторые функции являются видимыми для пользователя “commands”,
которые можно вызывать в интерактивном режиме (обычно с помощью
последовательности клавиш).  Можно вызвать такую ​​команду точно так же,
как если бы она была вызвана в интерактивном режиме, используя функцию
‘call-interactively’.  *Note Interactive Call::.

   ---------- Footnotes ----------

   (1) Это связано, но отличается от “currying”, который преобразует
функцию, которая принимает несколько аргументов таким образом, что она
может быть вызвана как цепочка функций, каждая из которых имеет один
аргумент.


File: elisp.info,  Node: Mapping Functions,  Next: Anonymous Functions,  Prev: Calling Functions,  Up: Functions

13.6 Mapping Functions
======================

“mapping function” применяет данную функцию (специальную форму или
макрос _not_) к каждому элементу списка или другой коллекции.  Emacs
Lisp имеет несколько таких функций; в этом разделе описываются ‘mapcar’,
‘mapc’, ‘mapconcat’ и ‘mapcan’, какая карта над списком.  *Note
Definition of mapatoms::, для функции ‘mapatoms’, отображающей символы в
obarray.  *Note Definition of maphash::, для функции ‘maphash’, которая
отображает связи ключ/значение в хеш-таблице.

   Эти функции отображения не допускают использование таблиц символов,
поскольку таблица символов представляет собой разреженный массив,
номинальный диапазон индексов которого очень велик.  Чтобы отобразить
таблицу символов так, чтобы она правильно соотносилась с ее разреженной
природой, используйте функцию ‘map-char-table’ (*note Char-Tables::).

 -- Function: mapcar function sequence
     ‘mapcar’ применяет FUNCTION к каждому элементу SEQUENCE по очереди
     и возвращает список результатов.

     Аргумент SEQUENCE может быть любой последовательностью, кроме
     таблицы символов; то есть список, вектор, bool-вектор или строка.
     Результатом всегда является список.  Длина результата равна длине
     SEQUENCE.  Например:

          (mapcar 'car '((a b) (c d) (e f)))
               ⇒ (a c e)
          (mapcar '1+ [1 2 3])
               ⇒ (2 3 4)
          (mapcar 'string "abc")
               ⇒ ("a" "b" "c")

          ;; Call each function in ‘my-hooks’.
          (mapcar 'funcall my-hooks)

          (defun mapcar* (function &rest args)
            "Примените FUNCTION к последующим автомобилям всех ARGS.
            Вернуть список результатов."
            ;; Если список не исчерпан,
            (if (not (memq nil args))
                ;; apply function to CARs.
                (cons (apply function (mapcar 'car args))
                      (apply 'mapcar* function
                             ;; рекурсия для остальных элементов.
                             (mapcar 'cdr args)))))

          (mapcar* 'cons '(a b c) '(1 2 3 4))
               ⇒ ((a . 1) (b . 2) (c . 3))

 -- Function: mapcan function sequence
     Эта функция применяет FUNCTION к каждому элементу SEQUENCE, как и
     ‘mapcar’, но вместо сбора результатов в список она возвращает один
     список со всеми элементами результатов (которые должны быть
     списками), изменяя результаты (используя ‘nconc’; *note
     Rearrangement::).  Как и в случае с ‘mapcar’, SEQUENCE может быть
     любого типа, кроме таблицы символов.

          ;; Сравните это:
          (mapcar 'list '(a b c d))
               ⇒ ((a) (b) (c) (d))
          ;; with this:
          (mapcan 'list '(a b c d))
               ⇒ (a b c d)

 -- Function: mapc function sequence
     ‘mapc’ похож на ‘mapcar’ за исключением того, что FUNCTION
     используется только для побочных эффектов - возвращаемые значения
     игнорируются, а не собираются в список.  ‘mapc’ всегда возвращает
     SEQUENCE.

 -- Function: mapconcat function sequence separator
     ‘mapconcat’ применяет FUNCTION к каждому элементу SEQUENCE;
     результаты, которые должны быть последовательностями символов
     (строки, векторы или списки), объединяются в возвращаемое значение
     одной строки.  Между каждой парой последовательностей результатов
     ‘mapconcat’ вставляет символы из SEPARATOR, которые также должны
     быть строкой, вектором или списком символов.  *Note Sequences
     Arrays Vectors::.

     Аргумент FUNCTION должен быть функцией, которая может принимать
     один аргумент и возвращать последовательность символов: строку,
     вектор или список.  Аргумент SEQUENCE может быть любой
     последовательностью, кроме таблицы символов; то есть список,
     вектор, bool-вектор или строка.

          (mapconcat 'symbol-name
                     '(Кот в мешке)
                     " ")
               ⇒ "Кот в мешке"

          (mapconcat (function (lambda (x) (format "%c" (1+ x))))
                     "HAL-8000"
                     "")
               ⇒ "IBM.9111"


File: elisp.info,  Node: Anonymous Functions,  Next: Generic Functions,  Prev: Mapping Functions,  Up: Functions

13.7 Anonymous Functions
========================

Хотя функции обычно определяются с помощью ‘defun’ и именования
одновременно, иногда удобно использовать явное лямбда-выражение —
“anonymous function”.  Анонимные функции действуют везде, где есть имена
функций.  Они часто назначаются как значения переменных или как
аргументы функций; например, вы можете передать его в качестве аргумента
FUNCTION в ‘mapcar’, который применяет эту функцию к каждому элементу
списка (*note Mapping Functions::).  *Note describe-symbols example::,
для реалистичного примера этого.

   При определении лямбда-выражения, которое будет использоваться в
качестве анонимной функции, вы в принципе можете использовать любой
метод для построения списка.  Но обычно вы должны использовать макрос
‘lambda’, или специальную форму ‘function’, или синтаксис чтения ‘#'’:

 -- Macro: lambda args [doc] [interactive] body...
     Этот макрос возвращает анонимную функцию со списком аргументов
     ARGS, строкой документации DOC (если есть), интерактивной
     спецификацией INTERACTIVE (если есть) и формами тела,
     предоставленными BODY.

     По сути, этот макрос заставляет формы ‘lambda’ самостоятельно
     заключать в кавычки: вычисление формы, у которой CAR равен
     ‘lambda’, дает саму форму:

          (lambda (x) (* x x))
               ⇒ (lambda (x) (* x x))

     Форма ‘lambda’ имеет еще один эффект: она сообщает оценщику Emacs и
     байт-компилятору, что ее аргумент является функцией, используя
     ‘function’ в качестве подпрограммы (см.  Ниже).

 -- Special Form: function function-object
     Эта специальная форма возвращает FUNCTION-OBJECT без ее оценки.  В
     этом она похожа на ‘quote’ (*note Quoting::).  Но в отличие от
     ‘quote’, она также служит примечанием для оценщика Emacs и
     байтового компилятора, что FUNCTION-OBJECT предназначена для
     использования в качестве функции.  Предполагая, что FUNCTION-OBJECT
     является допустимым лямбда-выражением, это имеет два эффекта:

        • Когда код компилируется байтом, FUNCTION-OBJECT компилируется
          в объект функции байт-кода (*note Byte Compilation::).

        • Когда лексическое связывание включено, FUNCTION-OBJECT
          преобразуется в замыкание.  *Note Closures::.

   Синтаксис чтения ‘#'’ является сокращением для использования
‘function’.  Следующие формы все эквивалентны:

     (lambda (x) (* x x))
     (function (lambda (x) (* x x)))
     #'(lambda (x) (* x x))

   В следующем примере мы определяем функцию ‘change-property’, которая
принимает функцию в качестве третьего аргумента, за которой следует
функция ‘double-property’, которая использует ‘change-property’,
передавая ей анонимную функцию:

     (defun change-property (symbol prop function)
       (let ((value (get symbol prop)))
         (put symbol prop (funcall function value))))

     (defun double-property (symbol prop)
       (change-property symbol prop (lambda (x) (* 2 x))))

Обратите внимание, что мы не цитируем форму ‘lambda’.

   Если вы скомпилируете приведенный выше код, анонимная функция также
скомпилируется.  Этого бы не произошло, если бы, скажем, вы создали
анонимную функцию, заключив ее в список:

     (defun double-property (symbol prop)
       (change-property symbol prop '(lambda (x) (* 2 x))))

В этом случае анонимная функция сохраняется как лямбда-выражение в
скомпилированном коде.  Байт-компилятор не может предположить, что этот
список является функцией, даже если он выглядит так, поскольку он не
знает, что ‘change-property’ намеревается использовать его как функцию.


File: elisp.info,  Node: Generic Functions,  Next: Function Cells,  Prev: Anonymous Functions,  Up: Functions

13.8 Generic Functions
======================

Функции, определенные с использованием ‘defun’, имеют жестко заданный
набор предположений о типах и ожидаемых значениях их аргументов.
Например, функция, которая была разработана для обработки значений
своего аргумента, которые являются либо числами, либо списками чисел,
потерпит неудачу или сообщит об ошибке, если вызывается со значением
любого другого типа, например вектором или строкой.  Это происходит
потому, что реализация функции не подготовлена ​​для работы с типами,
отличными от тех, которые были приняты во время проектирования.

   Напротив, объектно-ориентированные программы используют “polymorphic
functions”: набор специализированных функций с одинаковым именем, каждая
из которых была написана для определенного набора типов аргументов.
Какая из функций фактически вызывается, определяется во время выполнения
на основе типов фактических аргументов.

   Emacs обеспечивает поддержку полиморфизма.  Как и в других средах
Lisp, в частности Common Lisp и его Common Lisp Object System (CLOS),
эта поддержка основана на “generic functions”.  Общие функции Emacs
тесно связаны с CLOS, включая использование похожих имен, поэтому, если
у вас есть опыт работы с CLOS, остальная часть этого раздела будет
звучать очень знакомо.

   Универсальная функция задает абстрактную операцию, определяя ее имя и
список аргументов, но (обычно) не реализуя.  Фактическая реализация для
нескольких определенных классов аргументов обеспечивается “methods”,
который должен быть определен отдельно.  Каждый метод, который реализует
обобщенную функцию, имеет то же имя, что и обобщенная функция, но
определение метода указывает, какие аргументы он может обработать с
помощью “specializing” аргументов, определенных обобщенной функцией.
Эти “argument specializers” могут быть более или менее конкретными;
например, тип ‘string’ более специфичен, чем более общий тип, такой как
‘sequence’.

   Обратите внимание, что в отличие от основанных на сообщениях
ОО-языков, таких как C++ и Simula, методы, которые реализуют
универсальные функции, не принадлежат классу, они принадлежат
универсальной функции, которую они реализуют.

   Когда вызывается универсальная функция, она выбирает применимые
методы, сравнивая фактические аргументы, передаваемые вызывающей
стороной, со специализированными аргументами каждого метода.  Метод
применим, если фактические аргументы вызова совместимы со
специализаторами метода.  Если применимо более одного метода, они
объединяются с использованием определенных правил, описанных ниже, и
затем комбинация обрабатывает вызов.

 -- Macro: cl-defgeneric name arguments [documentation]
          [options-and-methods...] &rest body
     Этот макрос определяет обобщенную функцию с указанными NAME и
     ARGUMENTS.  Если присутствует BODY, он обеспечивает реализацию по
     умолчанию.  Если присутствует DOCUMENTATION (так должно быть
     всегда), он указывает строку документации для универсальной функции
     в форме ‘(:documentation DOCSTRING)’.  Необязательный
     OPTIONS-AND-METHODS может иметь одну из следующих форм:

     ‘(declare DECLARATIONS)’
          Форма объявления, как описано в *note Declare Form::.
     ‘(:argument-precedence-order &rest ARGS)’
          Эта форма влияет на порядок сортировки для объединения
          применимых методов.  Обычно, когда два метода сравниваются во
          время объединения, аргументы метода проверяются слева направо,
          и первый метод, специализатор аргумента которого является
          более конкретным, предшествует другому.  Порядок, определенный
          этой формой, переопределяет это, и аргументы рассматриваются в
          соответствии с их порядком в этой форме, а не слева направо.
     ‘(:method [QUALIFIERS...] args &rest body)’
          Эта форма определяет метод как ‘cl-defmethod’.

 -- Macro: cl-defmethod name [qualifier] arguments &rest [docstring]
          body
     Этот макрос определяет конкретную реализацию для универсальной
     функции, называемой NAME.  Код реализации задается BODY.  Если
     присутствует, DOCSTRING - это строка документации для метода.
     Список ARGUMENTS, который должен быть одинаковым во всех методах,
     реализующих универсальную функцию, и должен соответствовать списку
     аргументов этой функции, предоставляет специализаторы аргументов в
     форме ‘(ARG SPEC)’, где ARG - это имя аргумента, указанное в вызове
     ‘cl-defgeneric’, и SPEC - это одна из следующих форм специализаций:

     ‘TYPE’
          Этот специализатор требует, чтобы аргумент имел заданный TYPE,
          один из типов из иерархии типов, описанной ниже.
     ‘(eql OBJECT)’
          Этот специализатор требует, чтобы аргумент был ‘eql’ для
          данного OBJECT.
     ‘(head OBJECT)’
          Аргумент должен быть cons-ячейкой, у которой ‘car’ от ‘eql’ до
          OBJECT.
     ‘STRUCT-TYPE’
          Аргумент должен быть экземпляром класса с именем STRUCT-TYPE,
          определенного с помощью ‘cl-defstruct’ (*note
          (cl)Structures::), или одного из его дочерних классов.

     Альтернативно, специализированный аргумент может иметь форму
     ‘&context (EXPR SPEC)’, и в этом случае значение EXPR должно быть
     совместимо со специализатором, предоставленным SPEC; SPEC может
     быть любой из форм, описанных выше.  Другими словами, эта форма
     специалиста использует значение EXPR вместо аргументов для решения,
     применим ли метод.  Например, ‘&context (overwrite-mode (eql t))’
     сделает метод совместимым только при включенном ‘overwrite-mode’.

     Специалист по типу, ‘(ARG TYPE)’, может указать один из “system
     types” в следующем списке.  Когда указан родительский тип,
     аргумент, тип которого является любым из его более конкретных
     дочерних типов, а также внуков, внуков и т.д., Также будет
     совместимым.

     ‘integer’
          Родительский тип: ‘number’.
     ‘number’
     ‘null’
          Родительский тип: ‘symbol’
     ‘symbol’
     ‘string’
          Родительский тип: ‘array’.
     ‘array’
          Родительский тип: ‘sequence’.
     ‘cons’
          Родительский тип: ‘list’.
     ‘list’
          Родительский тип: ‘sequence’.
     ‘marker’
     ‘overlay’
     ‘float’
          Родительский тип: ‘number’.
     ‘window-configuration’
     ‘process’
     ‘window’
     ‘subr’
     ‘compiled-function’
     ‘buffer’
     ‘char-table’
          Родительский тип: ‘array’.
     ‘bool-vector’
          Родительский тип: ‘array’.
     ‘vector’
          Родительский тип: ‘array’.
     ‘frame’
     ‘hash-table’
     ‘font-spec’
     ‘font-entity’
     ‘font-object’

     Необязательный QUALIFIER позволяет комбинировать несколько
     применимых методов.  Если он отсутствует, определенный метод
     является методом “primary”, отвечающим за обеспечение первичной
     реализации универсальной функции для специализированных аргументов.
     Вы также можете определить “auxiliary methods”, используя одно из
     следующих значений как QUALIFIER:

     ‘:before’
          Этот вспомогательный метод будет выполняться до основного
          метода.  Точнее, все методы ‘:before’ будут выполняться до
          основного, в наиболее специфичном первом порядке.
     ‘:after’
          Этот вспомогательный метод будет выполняться после основного
          метода.  Точнее, все такие методы будут выполняться после
          основного, в наиболее определенном последнем порядке.
     ‘:around’
          Этот вспомогательный метод запускает _instead_ основного
          метода.  Наиболее специфический из таких методов будет запущен
          перед любым другим методом.  Такие методы обычно используют
          ‘cl-call-next-method’, описанный ниже, для вызова других
          вспомогательных или первичных методов.
     ‘:extra STRING’
          Это позволяет вам добавлять больше методов, отличающихся
          STRING, для тех же самых специализаторов и классификаторов.

   Каждый раз, когда вызывается универсальная функция, она создает
“effective method”, который будет обрабатывать этот вызов путем
объединения применимых методов, определенных для функции.  Процесс
поиска применимых методов и создания эффективного метода называется
“dispatch”.  Применимыми методами являются те, все из которых
специализируются, совместимы с фактическими аргументами вызова.
Поскольку все аргументы должны быть совместимы со специализаторами, все
они определяют, применим ли метод.  Методы, которые явно специализируют
более одного аргумента, называются “multiple-dispatch methods”.

   Применяемые методы сортируются в порядке их объединения.  Метод, у
которого самый левый специализатор аргументов является самым конкретным,
будет первым в порядке.  (Указание ‘:argument-precedence-order’ как
части ‘cl-defmethod’ переопределяет это, как описано выше.)  Если тело
метода вызывает ‘cl-call-next-method’, будет запущен следующий наиболее
специфичный метод.  Если существуют применимые методы ‘:around’,
наиболее специфичные из них будут выполняться первыми; он должен вызвать
‘cl-call-next-method’ для запуска любого из менее специфичных методов
‘:around’.  Затем методы ‘:before’ выполняются в порядке их
специфичности, за которым следует основной метод, и, наконец, методы
‘:after’ в обратном порядке их специфичности.

 -- Function: cl-call-next-method &rest args
     При вызове из лексического тела основного или вспомогательного
     метода ‘:around’ вызовите следующий применимый метод для той же
     универсальной функции.  Обычно он вызывается без аргументов, что
     означает вызов следующего применимого метода с теми же аргументами,
     что и вызывающий метод.  В противном случае, вместо этого
     используются указанные аргументы.

 -- Function: cl-next-method-p
     Эта функция, когда вызывается из лексического тела основного или
     вспомогательного метода ‘:around’, возвращает не-‘nil’, если есть
     следующий метод для вызова.


File: elisp.info,  Node: Function Cells,  Next: Closures,  Prev: Generic Functions,  Up: Functions

13.9 Accessing Function Cell Contents
=====================================

“function definition” символа - это объект, хранящийся в функциональной
ячейке символа.  Описанные здесь функции осуществляют доступ,
тестирование и установку функциональной ячейки символов.

   Смотрите также функцию ‘indirect-function’.  *Note Definition of
indirect-function::.

 -- Function: symbol-function symbol
     Это возвращает объект в ячейке функции SYMBOL.  Он не проверяет,
     является ли возвращенный объект допустимой функцией.

     Если ячейка функции пуста, возвращаемое значение - ‘nil’.  Чтобы
     отличить ячейку функции, которая является пустой, и ячейкой,
     установленной на ‘nil’, используйте ‘fboundp’ (см.  Ниже).

          (defun bar (n) (+ n 2))
          (symbol-function 'bar)
               ⇒ (lambda (n) (+ n 2))
          (fset 'baz 'bar)
               ⇒ bar
          (symbol-function 'baz)
               ⇒ bar

   Если вы никогда не давали символу никакого определения функции, мы
говорим, что ячейка функции этого символа - “void”.  Другими словами, в
ячейке функции нет объекта Лисп.  Если вы попытаетесь вызвать символ как
функцию, Emacs сообщит об ошибке ‘void-function’.

   Обратите внимание, что void - это не то же самое, что ‘nil’ или
символ ‘void’.  Символы ‘nil’ и ‘void’ являются объектами Lisp и могут
быть сохранены в ячейке функции так же, как и любой другой объект (и они
могут быть действительными функциями, если вы определяете их по очереди
с помощью ‘defun’).  Ячейка пустой функции не содержит никаких объектов.

   Вы можете проверить пустотность определения функции символа с помощью
‘fboundp’.  После того, как вы дали символу определение функции, вы
можете снова сделать его недействительным, используя ‘fmakunbound’.

 -- Function: fboundp symbol
     Эта функция возвращает ‘t’, если символ имеет объект в своей ячейке
     функции, в противном случае ‘nil’.  Он не проверяет, является ли
     объект допустимой функцией.

 -- Function: fmakunbound symbol
     Эта функция делает ячейку функции SYMBOL’s недействительной,
     поэтому последующая попытка доступа к этой ячейке вызовет ошибку
     ‘void-function’.  Возвращает SYMBOL.  (См.  Также ‘makunbound’, в
     *note Void Variables::.)

          (defun foo (x) x)
          (foo 1)
               ⇒1
          (fmakunbound 'foo)
               ⇒ foo
          (foo 1)
          error→ Symbol's function definition is void: foo

 -- Function: fset symbol definition
     Эта функция хранит DEFINITION в ячейке функции SYMBOL.  Результат -
     DEFINITION.  Обычно ОПРЕДЕЛЕНИЕ должно быть функцией или именем
     функции, но это не проверяется.  Аргумент SYMBOL - это обычный
     оцененный аргумент.

     Основное использование этой функции в качестве подпрограммы -
     конструкции, которые определяют или изменяют функции, такие как
     ‘defun’ или ‘advice-add’ (*note Advising Functions::).  Вы также
     можете использовать его, чтобы дать символу определение функции,
     которое не является функцией, например, макрос клавиатуры (*note
     Keyboard Macros::):

          ;; Определить именованный макрос клавиатуры.
          (fset 'kill-two-lines "\^u2\^k")
               ⇒ "\^u2\^k"

     Если вы хотите использовать ‘fset’ для создания альтернативного
     имени для функции, рассмотрите возможность использования
     ‘defalias’.  *Note Definition of defalias::.


File: elisp.info,  Node: Closures,  Next: Advising Functions,  Prev: Function Cells,  Up: Functions

13.10 Closures
==============

Как объяснено в *note Variable Scoping::, Emacs может по желанию
включить лексическое связывание переменных.  Когда лексическое
связывание включено, любая именованная функция, которую вы создаете
(например, с помощью ‘defun’), а также любая анонимная функция, которую
вы создаете с помощью макроса ‘lambda’ или специальной формы ‘function’
или синтаксиса ‘#'’ (*note Anonymous Functions::), автоматически
преобразуется в “closure” ,

   Замыкание - это функция, которая также содержит запись лексической
среды, которая существовала, когда функция была определена.  Когда она
вызывается, любые ссылки на лексические переменные в его определении
используют сохраненную лексическую среду.  Во всех других отношениях
замыкания ведут себя подобно обычным функциям; в частности, они могут
вызываться так же, как и обычные функции.

   *Note Lexical Binding::, для примера использования замыкание.

   В настоящее время объект замыкания Emacs Lisp представлен списком с
символом ‘closure’ в качестве первого элемента, списком, представляющим
лексическую среду как второй элемент, а списком аргументов и телом
являются оставшиеся элементы:

     ;; лексическое связывание включено.
     (lambda (x) (* x x))
          ⇒ (closure (t) (x) (* x x))

Однако тот факт, что внутренняя структура замыкания открыта для
остального мира Lisp, считается внутренней деталью реализации.  По этой
причине мы не рекомендуем непосредственно проверять или изменять
структуру замыкающих объектов.


File: elisp.info,  Node: Advising Functions,  Next: Obsolete Functions,  Prev: Closures,  Up: Functions

13.11 Advising Emacs Lisp Functions
===================================

Когда вам нужно изменить функцию, определенную в другой библиотеке, или
когда вам нужно изменить хук, такой как ‘FOO-function’, фильтр процесса
или, в основном, любую переменную или поле объекта, которое содержит
значение функции, вы можете использовать соответствующую
функцию-установщик, такую ​​как ‘fset’ или ‘defun’ для именованных
функций, ‘setq’ для переменных хука или ‘set-process-filter’ для
фильтров процесса, но они часто слишком тупые, полностью отбрасывая
предыдущее значение.

   Функция “advice” позволяет добавить к существующему определению
функции, используя “advising the function”.  Это более чистый метод, чем
переопределение всей функции.

   Система рекомендаций Emacs предоставляет для этого два набора
примитивов: базовый набор для значений функций, хранящихся в переменных
и полях объектов (с соответствующими примитивами ‘add-function’ и
‘remove-function’), и другой набор, наслоенный поверх него для
именованных функций (с основными примитивами, являющимися ‘advice-add’ и
‘advice-remove’).

   Например, чтобы отследить вызовы к фильтру процесса процесса PROC, вы
можете использовать:

     (defun my-tracing-function (proc string)
       (message "Proc %S received %S" proc string))

     (add-function :before (process-filter PROC) #'my-tracing-function)

   Это приведет к тому, что выходные данные процесса будут переданы в
‘my-tracing-function’ перед передачей в исходный фильтр процесса.
‘my-tracing-function’ получает те же аргументы, что и исходная функция.
Когда вы закончите с этим, вы можете вернуться к неизведанному поведению
с помощью:

     (remove-function (process-filter PROC) #'my-tracing-function)

   Точно так же, если вы хотите отследить выполнение функции с именем
‘display-buffer’, вы можете использовать:

     (defun his-tracing-function (orig-fun &rest args)
       (message "display-buffer called with args %S" args)
       (let ((res (apply orig-fun args)))
         (message "display-buffer returned %S" res)
         res))

     (advice-add 'display-buffer :around #'his-tracing-function)

   Здесь ‘his-tracing-function’ вызывается вместо исходной функции и
получает исходную функцию (в дополнение к аргументам этой функции) в
качестве аргумента, поэтому он может вызывать ее, если и когда это
необходимо.  Когда вы устали видеть этот вывод, вы можете вернуться к
неотслеживаемому поведению с помощью:

     (advice-remove 'display-buffer #'his-tracing-function)

   Аргументы ‘:before’ и ‘:around’, использованные в приведенных выше
примерах, определяют, как составляются две функции, поскольку существует
много разных способов сделать это.  Добавленная функция также называется
частью _advice_.

* Menu:

* Core Advising Primitives::    Примитивы манипулируют советами.
* Advising Named Functions::    Консультирование именованных функций.
* Advice combinators::          Способы составить совет.
* Porting old advice::          Адаптация кода с использованием старого defadvice.


File: elisp.info,  Node: Core Advising Primitives,  Next: Advising Named Functions,  Up: Advising Functions

13.11.1 Primitives to manipulate advices
----------------------------------------

 -- Macro: add-function where place function &optional props
     Этот макрос - удобный способ добавить совет FUNCTION к функции,
     хранящейся в PLACE (*note Generalized Variables::).

     WHERE определяет, как FUNCTION составляется с существующей
     функцией, например, должен ли FUNCTION вызываться до или после
     исходной функции.  *Note Advice combinators::, для списка доступных
     способов составить две функции.

     При изменении переменной (имя которой обычно заканчивается на
     ‘-function’), вы можете выбрать, будет ли FUNCTION использоваться
     глобально или только в текущем буфере: если PLACE является просто
     символом, то FUNCTION добавляется к глобальному значению PLACE.
     Если PLACE имеет вид ‘(local SYMBOL)’, где SYMBOL - это выражение,
     которое возвращает имя переменной, то FUNCTION будет добавлен
     только в текущий буфер.  Наконец, если вы хотите изменить
     лексическую переменную, вам придется использовать ‘(var VARIABLE)’.

     Каждая функция, добавленная с помощью ‘add-function’, может
     сопровождаться списком ассоциаций свойств PROPS.  В настоящее время
     только два из этих свойств имеют особое значение:

     ‘name’
          Это дает название рекомендации, которую ‘remove-function’
          может использовать для определения, какую функцию удалить.
          Обычно используется, когда FUNCTION является анонимной
          функцией.

     ‘depth’
          Здесь указывается, как заказать совет, если есть несколько
          советов.  По умолчанию глубина равна 0.  Глубина 100
          указывает, что этот совет должен быть как можно глубже, тогда
          как глубина −100 указывает, что он должен оставаться как самый
          внешний фрагмент.  Когда два совета указывают одинаковую
          глубину, последний добавленный будет самым внешним.

          Для рекомендации ‘:before’ быть самым внешним означает, что
          этот совет будет выполняться первым, а не любым другим
          советом, в то время как самый внутренний означает, что он
          будет выполняться непосредственно перед исходной функцией, при
          этом никакой другой совет не будет выполняться между собой и
          исходной функцией.  Аналогично, для рекомендации ‘:after’
          самый внутренний означает, что он будет выполняться сразу
          после исходной функции, без других промежуточных рекомендаций,
          в то время как самый внешний означает, что он будет выполнен в
          конце после всех других рекомендаций.  Внутренний совет
          ‘:override’ будет переопределять только исходную функцию, и
          другие советы будут применяться к нему, тогда как самый
          внешний совет ‘:override’ будет переопределять не только
          исходную функцию, но и все другие рекомендации, примененные к
          ней.

     Если FUNCTION не является интерактивным, тогда объединенная функция
     наследует интерактивную спецификацию, если таковая имеется,
     исходной функции.  Иначе, объединенная функция будет интерактивной
     и будет использовать интерактивную спецификацию FUNCTION.
     Единственное исключение: если интерактивная спецификация FUNCTION
     является функцией (а не выражением или строкой), то интерактивной
     спецификацией объединенной функции будет вызов этой функции с
     единственным аргументом интерактивной спецификации исходной
     функции.  Чтобы интерпретировать спецификацию, полученную в
     качестве аргумента, используйте ‘advice-eval-interactive-spec’.

     Примечание: интерактивная спецификация FUNCTION будет применяться к
     объединенной функции и, следовательно, должна подчиняться
     соглашению о вызовах объединенной функции, а не FUNCTION.  Во
     многих случаях это не имеет значения, поскольку они идентичны, но
     это имеет значение для ‘:around’, ‘:filter-args’ и ‘filter-return’,
     где FUNCTION.

 -- Macro: remove-function place function
     Этот макрос удаляет FUNCTION из функции, хранящейся в PLACE.  Это
     работает, только если FUNCTION был добавлен к PLACE с помощью
     ‘add-function’.

     FUNCTION сравнивается с функциями, добавленными в PLACE с
     использованием ‘equal’, чтобы попытаться заставить его работать
     также с лямбда-выражениями.  Кроме того, он сравнивается также со
     свойством ‘name’ функций, добавленных в PLACE, что может быть более
     надежным, чем сравнение лямбда-выражений с использованием ‘equal’.

 -- Function: advice-function-member-p advice function-def
     Вернуть non-‘nil’, если ADVICE уже находится в FUNCTION-DEF.  Как и
     в случае с ‘remove-function’ выше, вместо ADVICE, являющейся
     фактической функцией, он также может быть ‘name’ из совета.

 -- Function: advice-function-mapc f function-def
     Вызовите функцию F для каждого совета, который был добавлен в
     FUNCTION-DEF.  F вызывается с двумя аргументами: функцией совета и
     ее свойствами.

 -- Function: advice-eval-interactive-spec spec
     Оцените интерактивный SPEC так же, как интерактивный вызов функции
     с такой спецификацией, и затем верните соответствующий список
     аргументов, который был построен.  Например,
     ‘(advice-eval-interactive-spec "r\nP")’ вернет список из трех
     элементов, содержащий границы региона и текущий префиксный
     аргумент.


File: elisp.info,  Node: Advising Named Functions,  Next: Advice combinators,  Prev: Core Advising Primitives,  Up: Advising Functions

13.11.2 Advising Named Functions
--------------------------------

Обычное использование консультирование - для именованных функций и
макросов.  Вы можете просто использовать ‘add-function’ как в:

     (add-function :around (symbol-function 'FUN) #'his-tracing-function)

   Но вы должны использовать для этого ‘advice-add’ и ‘advice-remove’.
Этот отдельный набор функций для управления консультациями, применяемым
к именованным функциям, предлагает следующие дополнительные функции по
сравнению с ‘add-function’: они знают, как обращаться с макросами и
автоматически загружаемыми функциями, они позволяют ‘describe-function’
сохранять исходную строку документации, а также документировать
добавленные консультации, и они позволяют вам добавлять и удалять
крнсультации еще до того, как функция будет определена.

   ‘advice-add’ может быть полезен для изменения поведения существующих
вызовов существующей функции без необходимости переопределения всей
функции.  Тем не менее, это может быть источником ошибок, поскольку
существующие вызывающие функции могут принимать старое поведение и
работать некорректно, когда поведение изменяется консультированием.
Консультирование может также вызвать путаницу при отладке, если человек,
выполняющий отладку, не замечает или не помнит, что функция была
изменена консультированием.

   По этим причинам, консультирование должено быть зарезервировано для
случаев, когда вы не можете изменить поведение функции любым другим
способом.  Если возможно сделать то же самое с помощью крючка, это
предпочтительнее (*note Hooks::).  Если вы просто хотите изменить
действие определенного ключа, лучше написать новую команду и
переназначить привязки клавиш старой команды к новой (*note Remapping
Commands::).  В частности, собственные исходные файлы Emacs не должны
содержать консультирований по функциям в Emacs.  (В настоящее время есть
несколько исключений из этого соглашения, но мы стремимся исправить их.)

   Специальные формы (*note Special Forms::) не могут быть
консультированы, однако макросы могут быть так же, как функции.
Конечно, это не повлияет на код, который уже был развернут макросом,
поэтому перед развертыванием макроса необходимо убедиться, что
консультирование установлено.

   Можно посоветовать примитив (*note What Is a Function::), но обычно
_not_ должен делать это по двум причинам.  Во-первых, некоторые
примитивы используются механизмом консультирования, и консультацмм по
ним могут вызвать бесконечную рекурсию.  Во-вторых, многие примитивы
вызываются непосредственно из C, и такие вызовы игнорируют
консультирование; следовательно, каждый оказывается в запутанной
ситуации, когда некоторые вызовы (происходящие из кода Lisp) подчиняются
консультации, а другие вызовы (из кода C) - нет.

 -- Macro: define-advice symbol (where lambda-list &optional name depth)
          &rest body
     Этот макрос определяет консультирование и добавляет её в функцию с
     именем SYMBOL.  Консультирование - анонимная функция, если NAME -
     это ‘nil’ или функция с именем ‘symbol@name’.  Смотрите
     ‘advice-add’ для объяснения других аргументов.

 -- Function: advice-add symbol where function &optional props
     Добавьте совет FUNCTION в именованную функцию SYMBOL.  WHERE и
     PROPS имеют то же значение, что и для ‘add-function’ (*note Core
     Advising Primitives::).

 -- Function: advice-remove symbol function
     Удалите совет FUNCTION из названной функции SYMBOL.  FUNCTION также
     может быть советом ‘name’.

 -- Function: advice-member-p function symbol
     Вернуть non-‘nil’, если консультирование FUNCTION уже находится в
     именованной функции SYMBOL.  FUNCTION также может быть
     консультированием ‘name’.

 -- Function: advice-mapc function symbol
     Вызывайте FUNCTION для каждой консультации, которая была добавлена
     к именованой функции SYMBOL.  FUNCTION вызывается с двумя
     аргументами: функцией консультирования и ее свойствами.


File: elisp.info,  Node: Advice combinators,  Next: Porting old advice,  Prev: Advising Named Functions,  Up: Advising Functions

13.11.3 Ways to compose advice
------------------------------

Вот различные возможные значения для аргумента WHERE для ‘add-function’
и ‘advice-add’, указывающие, как следует составлять консультирование
FUNCTION и исходную функцию.

‘:before’
     Вызовите FUNCTION перед старой функцией.  Обе функции получают
     одинаковые аргументы, а возвращаемое значение композиции является
     возвращаемым значением старой функции.  Более конкретно, состав
     этих двух функций ведет себя так:
          (lambda (&rest r) (apply FUNCTION r) (apply OLDFUN r))
     ‘(add-function :before FUNVAR FUNCTION)’ сопоставим для
     однофункциональных крючков с ‘(add-hook 'HOOKVAR FUNCTION)’ для
     обычных крючков.

‘:after’
     Вызовите FUNCTION после старой функции.  Обе функции получают
     одинаковые аргументы, а возвращаемое значение композиции является
     возвращаемым значением старой функции.  Более конкретно, состав
     этих двух функций ведет себя так:
          (lambda (&rest r) (prog1 (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after FUNVAR FUNCTION)’ сопоставим для
     однофункциональных крюков с ‘(add-hook 'HOOKVAR FUNCTION 'append)’
     для обычных крюков.

‘:override’
     Это полностью заменяет старую функцию новой.  Старая функция,
     конечно, может быть восстановлена, если позже вы вызовете
     ‘remove-function’.

‘:around’
     Вызовите FUNCTION вместо старой функции, но предоставьте старую
     функцию в качестве дополнительного аргумента для FUNCTION.  Это
     самая гибкая композиция.  Например, он позволяет вам вызывать
     старую функцию с разными аргументами, или много раз, или внутри
     привязки let, или вы можете иногда делегировать работу старой
     функции, а иногда полностью ее переопределять.  Более конкретно,
     состав этих двух функций ведет себя так:
          (lambda (&rest r) (apply FUNCTION OLDFUN r))

‘:before-while’
     Вызовите FUNCTION перед старой функцией и не вызывайте старую
     функцию, если FUNCTION возвращает ‘nil’.  Обе функции получают
     одинаковые аргументы, а возвращаемое значение композиции является
     возвращаемым значением старой функции.  Более конкретно, состав
     этих двух функций ведет себя так:
          (lambda (&rest r) (and (apply FUNCTION r) (apply OLDFUN r)))
     ‘(add-function :before-while FUNVAR FUNCTION)’ сопоставим для
     однофункциональных крючков с ‘(add-hook 'HOOKVAR FUNCTION)’, когда
     HOOKVAR запускается через ‘run-hook-with-args-until-failure’.

‘:before-until’
     Вызывайте FUNCTION перед старой функцией и вызывайте старую функцию
     только в том случае, если FUNCTION возвращает ‘nil’.  Более
     конкретно, состав этих двух функций ведет себя так:
          (lambda (&rest r) (or (apply FUNCTION r) (apply OLDFUN r)))
     ‘(add-function :before-until FUNVAR FUNCTION)’ сопоставим для
     однофункциональных крючков с ‘(add-hook 'HOOKVAR FUNCTION)’, когда
     HOOKVAR запускается через ‘run-hook-with-args-until-success’.

‘:after-while’
     Вызывайте FUNCTION после старой функции и только если старая
     функция вернула не-‘nil’.  Обе функции получают одинаковые
     аргументы, а возвращаемое значение композиции является возвращаемым
     значением FUNCTION.  Более конкретно, состав этих двух функций
     ведет себя так:
          (lambda (&rest r) (and (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after-while FUNVAR FUNCTION)’ сопоставим для
     однофункциональных крючков с ‘(add-hook 'HOOKVAR FUNCTION
     'append)’, когда HOOKVAR запускается через
     ‘run-hook-with-args-until-failure’.

‘:after-until’
     Вызывайте FUNCTION после старой функции и только в том случае, если
     старая функция вернула ‘nil’.  Более конкретно, состав этих двух
     функций ведет себя так:
          (lambda (&rest r) (or  (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after-until FUNVAR FUNCTION)’ сопоставим для
     однофункциональных хуков с ‘(add-hook 'HOOKVAR FUNCTION 'append)’,
     когда HOOKVAR запускается через ‘run-hook-with-args-until-success’.

‘:filter-args’
     Сначала вызовите FUNCTION и используйте результат (который должен
     быть списком) в качестве новых аргументов для передачи старой
     функции.  Более конкретно, состав этих двух функций ведет себя так:
          (lambda (&rest r) (apply OLDFUN (funcall FUNCTION r)))

‘:filter-return’
     Сначала вызовите старую функцию и передайте результат в FUNCTION.
     Более конкретно, состав этих двух функций ведет себя так:
          (lambda (&rest r) (funcall FUNCTION (apply OLDFUN r)))


File: elisp.info,  Node: Porting old advice,  Prev: Advice combinators,  Up: Advising Functions

13.11.4 Adapting code using the old defadvice
---------------------------------------------

Во многих кодах используется старый механизм ‘defadvice’, который во
многом устарел благодаря новому ‘advice-add’, реализация и семантика
которого значительно проще.

   Старое консультирование, такое как:

     (defadvice previous-line (before next-line-at-end
                                      (&optional arg try-vscroll))
       "Вставьте пустую строку при движении вверх от верхней строки."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   можно было бы перевести в новом механизме консультирования в простую
функцию:

     (defun previous-line--next-line-at-end (&optional arg try-vscroll)
       "Вставьте пустую строку при движении вверх от верхней строки."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   Очевидно, что это на самом деле не изменяет ‘previous-line’.  Для
этого нужно старое консультирование:
     (ad-activate 'previous-line)
   в то время как новый механизм консультирования сработает:
     (advice-add 'previous-line :before #'previous-line--next-line-at-end)

   Обратите внимание, что ‘ad-activate’ имел глобальный эффект: он
активировал все консультации, включенные для указанной функции.  Если вы
хотите активировать или деактивировать только определенную часть, вам
нужно было _enable_ или _disable_ с помощью ‘ad-enable-advice’ и
‘ad-disable-advice’.  Новый механизм устраняет это различие.

   Обзор консультирования, такого как:

     (defadvice foo (around foo-around)
       "Игнорировать регистр в `foo'."
       (let ((case-fold-search t))
         ad-do-it))
     (ad-activate 'foo)

   может изменить на на:

     (defun foo--foo-around (orig-fun &rest args)
       "Игнорировать регистр в `foo'."
       (let ((case-fold-search t))
         (apply orig-fun args)))
     (advice-add 'foo :around #'foo--foo-around)

   Что касается _class_ консультированию, обратите внимание, что новое
‘:before’ не совсем эквивалентен старому ‘before’, потому что в старом
вы можете изменить аргументы функции (например, с помощью ‘ad-set-arg’),
и это повлияет на значения аргументов, видимые исходной функцией, тогда
как в новом ‘:before’ изменение аргумента с помощью ‘setq’ в
консультирования не влияет на аргументы, видимые в исходной функции.При
переносе консультирования ‘before’, в котором основывались на этом
поведении, вам нужно вместо этого превратить его в новое
консультирование ‘:around’ или ‘:filter-args’.

   Точно так же старое консультирование ‘after’ могло изменить
возвращаемое значение путем изменения ‘ad-return-value’, тогда как в
новом консультировании ‘:after’ не может, поэтому при портировании
такого старого консультирования ‘after’ вам нужно вместо этого
превратить его в новое ‘:around’ или ‘:filter-return’.


File: elisp.info,  Node: Obsolete Functions,  Next: Inline Functions,  Prev: Advising Functions,  Up: Functions

13.12 Declaring Functions Obsolete
==================================

Вы можете пометить именованную функцию как “obsolete”, что означает, что
она может быть удалена в будущем.  Это заставляет Emacs предупреждать,
что функция устарела всякий раз, когда она выполняет байт-компиляцию
кода, содержащего эту функцию, и всякий раз, когда она отображает
документацию для этой функции.  Во всех других отношениях устаревшая
функция ведет себя как любая другая функция.

   Самый простой способ пометить функцию как устаревшую - это поместить
форму ‘(declare (obsolete ...))’ в функцию ‘defun’ definition.  *Note
Declare Form::.  В качестве альтернативы вы можете использовать функцию
‘make-obsolete’, описанную ниже.

   Макрос (*note Macros::) также может быть помечен как устаревший с
помощью ‘make-obsolete’; это имеет тот же эффект, что и для функции.
Псевдоним для функции или макроса также может быть помечен как
устаревший; это делает сам псевдоним устаревшим, а не функцию или
макрос, к которому он разрешает.

 -- Function: make-obsolete obsolete-name current-name &optional when
     Эта функция помечает OBSOLETE-NAME как устаревшее.  OBSOLETE-NAME
     должен быть символом, называющим функцию или макрос, или
     псевдонимом для функции или макроса.

     Если CURRENT-NAME является символом, в предупреждающем сообщении
     указывается использовать CURRENT-NAME вместо OBSOLETE-NAME.
     CURRENT-NAME не должен быть псевдонимом для OBSOLETE-NAME; это
     может быть другая функция со схожей функциональностью.
     CURRENT-NAME также может быть строкой, которая служит
     предупреждением.  Сообщение должно начинаться со строчной буквы и
     заканчиваться точкой.  Это также может быть ‘nil’, в этом случае в
     предупреждающем сообщении не содержится никаких дополнительных
     подробностей.

     Если предоставлено, WHEN должен быть строкой, указывающей, когда
     функция была впервые сделана устаревшей - например, дата или номер
     выпуска.

 -- Macro: define-obsolete-function-alias obsolete-name current-name
          &optional when doc
     Этот вспомогательный макрос помечает функцию OBSOLETE-NAME как
     устаревшую, а также определяет ее как псевдоним для функции
     CURRENT-NAME.  Это эквивалентно следующему:

          (defalias OBSOLETE-NAME CURRENT-NAME DOC)
          (make-obsolete OBSOLETE-NAME CURRENT-NAME WHEN)

   Кроме того, вы можете пометить конкретное соглашение о вызовах для
функции как устаревшее:

 -- Function: set-advertised-calling-convention function signature when
     Эта функция указывает список аргументов SIGNATURE как правильный
     способ вызова FUNCTION.  Это заставляет байт-компилятор Emacs
     выдавать предупреждение всякий раз, когда он сталкивается с
     программой Emacs Lisp, которая вызывает FUNCTION любым другим
     способом (однако, он все еще позволит скомпилировать байты кода).
     WHEN должен быть строкой, указывающей, когда переменная была
     впервые сделана устаревшей (обычно строка номера версии).

     Например, в старых версиях Emacs функция ‘sit-for’ принимала три
     аргумента, например

            (sit-for seconds milliseconds nodisp)

     Однако вызов ‘sit-for’ таким способом считается устаревшим (*note
     Waiting::).  Старое соглашение о вызовах как это устарело:

          (set-advertised-calling-convention
            'sit-for '(seconds &optional nodisp) "22.1")


File: elisp.info,  Node: Inline Functions,  Next: Declare Form,  Prev: Obsolete Functions,  Up: Functions

13.13 Inline Functions
======================

“inline function” - это функция, которая работает так же, как обычная
функция, за исключением одной вещи: когда вы байт-компилируете вызов
функции (*note Byte Compilation::), определение функции расширяется до
вызывающей стороны.  Чтобы определить встроенную функцию, используйте
‘defsubst’ вместо ‘defun’.

 -- Macro: defsubst name args [doc] [declare] [interactive] body...
     Этот макрос определяет встроенную функцию.  Его синтаксис точно
     такой же, как ‘defun’ (*note Defining Functions::).

   Если встрамвать функцию часто, ее вызовы выполняются быстрее.  Но это
также имеет недостатки.  С одной стороны, это снижает гибкость; если вы
измените определение функции, уже встроенные вызовы по-прежнему будут
использовать старое определение, пока вы не перекомпилируете их.

   Еще один недостаток заключается в том, что выполнение большой
встроенной функции может увеличить размер скомпилированного кода как в
файлах, так и в памяти.  Поскольку преимущество быстрых встроенных
функций является максимальным для небольших функций, обычно не следует
делать большие встроенные функции.

   Кроме того, встроенные функции не ведут себя хорошо в отношении
отладки, трассировки и консультирования (*note Advising Functions::).
Поскольку простота отладки и гибкость переопределения функций являются
важными функциями Emacs, вы не должны делать функцию встроенной, даже
если она небольшая, если только ее скорость не очень важна, и вы
рассчитали время для проверки того, что использование ‘defun’
действительно имеет проблемы с производительностью.

   После того, как встроенная функция определена, ее встроенное
расширение может быть выполнено позже в том же файле, как макросы.

   Можно использовать ‘defmacro’ для определения макроса для расширения
в тот же код, который будет выполнять встроенная функция (*note
Macros::).  Но макрос может быть ограничен прямым использованием в
выражениях - макрос нельзя вызывать с помощью ‘apply’, ‘mapcar’ и так
далее.  Кроме того, требуется некоторая работа для преобразования
обычной функции в макрос.  Преобразовать его во встроенную функцию
легко; просто замените ‘defun’ на ‘defsubst’.  Поскольку каждый аргумент
встроенной функции вычисляется ровно один раз, вам не нужно беспокоиться
о том, сколько раз тело использует аргументы, как вы это делаете для
макросов.

   В качестве альтернативы ‘defsubst’ вы можете использовать
‘define-inline’ для определения функций через их исчерпывающий макрос
компилятора.  *Note define-inline: Defining Functions.


File: elisp.info,  Node: Declare Form,  Next: Declaring Functions,  Prev: Inline Functions,  Up: Functions

13.14 The ‘declare’ Form
========================

‘declare’ - это специальный макрос, который можно использовать для
добавления мета-свойств к функции или макросу: например, пометить его
как устаревший или присвоить его формам специальное соглашение об
отступах <TAB> в режиме Emacs Lisp.

 -- Macro: declare specs...
     Этот макрос игнорирует свои аргументы и оценивает его как ‘nil’;
     это не имеет никакого эффекта во время выполнения.  Однако, когда
     форма ‘declare’ встречается в аргументе DECLARE определения функции
     ‘defun’ или ‘defsubst’ (*note Defining Functions::) или определения
     макроса ‘defmacro’ (*note Defining Macros::), она добавляет
     свойства, указанные SPECS, в функцию или макрос.  Эта работа
     специально выполняется ‘defun’, ‘defsubst’ и ‘defmacro’.

     Каждый элемент в SPECS должен иметь форму ‘(PROPERTY ARGS...)’,
     которая не должна заключаться в кавычки.  Они имеют следующие
     эффекты:

     ‘(advertised-calling-convention SIGNATURE WHEN)’
          Это действует как вызов ‘set-advertised-calling-convention’
          (*note Obsolete Functions::); SIGNATURE определяет правильный
          список аргументов для вызова функции или макроса, а WHEN
          должен быть строкой, указывающей, когда старый список
          аргументов был впервые сделан устаревшим.

     ‘(debug EDEBUG-FORM-SPEC)’
          Это действительно только для макросов.  При переходе по
          макросу с помощью Edebug используйте EDEBUG-FORM-SPEC.  *Note
          Instrumenting Macro Calls::.

     ‘(doc-string N)’
          Это используется при определении функции или макроса, который
          сам будет использоваться для определения сущностей, таких как
          функции, макросы или переменные.  Это указывает на то, что
          аргумент N, если таковой имеется, должен рассматриваться как
          строка документации.

     ‘(indent INDENT-SPEC)’
          Отступы вызова этой функции или макроса в соответствии с
          INDENT-SPEC.  Обычно это используется для макросов, хотя
          работает и для функций.  *Note Indenting Macros::.

     ‘(interactive-only VALUE)’
          Установите для свойства ‘interactive-only’ функции значение
          VALUE.  *Note The interactive-only property::.

     ‘(obsolete CURRENT-NAME WHEN)’
          Пометьте функцию или макрос как устаревшую, аналогично вызову
          ‘make-obsolete’ (*note Obsolete Functions::).  CURRENT-NAME
          должен быть символом (в этом случае предупреждающее сообщение
          говорит об использовании вместо этого), строкой (определяющей
          предупреждающее сообщение) или ‘nil’ (в этом случае
          предупреждающее сообщение не дает дополнительных
          подробностей).  WHEN должен быть строкой, указывающей, когда
          функция или макрос были впервые сделаны устаревшими.

     ‘(compiler-macro EXPANDER)’
          Это может использоваться только для функций и указывает
          компилятору использовать EXPANDER в качестве функции
          оптимизации.  При встрече с вызовом функции вида ‘(FUNCTION
          ARGS...)’ макроэкспандер вызовет EXPANDER с этой формой, а
          также с ARGS..., и EXPANDER может либо вернуть новое выражение
          для использования вместо вызова функции, либо он может вернуть
          только Форма неизменна, чтобы указать, что вызов функции
          должен быть оставлен в покое.  EXPANDER может быть символом
          или формой ‘(lambda (ARG) BODY)’, и в этом случае ARG будет
          содержать исходное выражение вызова функции, а к (неоцененным)
          аргументам функции можно получить доступ с помощью формальных
          аргументов функции.

     ‘(gv-expander EXPANDER)’
          Объявите EXPANDER как функцию для обработки вызовов макроса
          (или функции) как обобщенной переменной, аналогично
          ‘gv-define-expander’.  EXPANDER может быть символом или иметь
          форму ‘(lambda (ARG) BODY)’, и в этом случае эта функция будет
          дополнительно иметь доступ к аргументам макроса (или функции).

     ‘(gv-setter SETTER)’
          Объявите SETTER как функцию для обработки вызовов макроса (или
          функции) как обобщенной переменной.  SETTER может быть
          символом, в этом случае он будет передан в
          ‘gv-define-simple-setter’, или он может иметь форму ‘(lambda
          (ARG) BODY)’, и в этом случае эта функция будет дополнительно
          иметь доступ к аргументам макроса (или функции), и она будет
          передана в ‘gv-define-setter’.


File: elisp.info,  Node: Declaring Functions,  Next: Function Safety,  Prev: Declare Form,  Up: Functions

13.15 Telling the Compiler that a Function is Defined
=====================================================

Байт-компиляция файла часто выдает предупреждения о функциях, о которых
не знает компилятор (*note Compiler Errors::).  Иногда это указывает на
реальную проблему, но обычно рассматриваемые функции определяются в
других файлах, которые будут загружены при запуске этого кода.
Например, байтовая компиляция ‘simple.el’ используется для
предупреждения:

     simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
         defined.

   Фактически, ‘shell-mode’ используется только в функции, которая
выполняет ‘(require 'shell)’ перед вызовом ‘shell-mode’, поэтому
‘shell-mode’ будет определен правильно во время выполнения.  Когда вы
знаете, что такое предупреждение не указывает на реальную проблему,
полезно подавить предупреждение.  Это делает новые предупреждения,
которые могут означать реальные проблемы, более заметными.  Вы делаете
это с помощью ‘declare-function’.

   Все, что вам нужно сделать, это добавить оператор ‘declare-function’
перед первым использованием рассматриваемой функции:

     (declare-function shell-mode "shell" ())

   Это говорит о том, что ‘shell-mode’ определен в ‘shell.el’ (‘.el’
можно опустить).  Компилятор считает само собой разумеющимся, что этот
файл действительно определяет функцию, и не проверяет.

   Необязательный третий аргумент определяет список аргументов
‘shell-mode’.  В этом случае он не принимает аргументов (‘nil’
отличается от не указания значения).  В других случаях это может быть
что-то вроде ‘(file &optional overwrite)’.  Вам не нужно указывать
список аргументов, но если вы это сделаете, байтовый компилятор может
проверить, что вызовы соответствуют объявлению.

 -- Macro: declare-function function file &optional arglist fileonly
     Скажите байтовому компилятору, что предполагается, что FUNCTION
     определен в файле FILE.  Необязательный третий аргумент ARGLIST -
     это либо ‘t’, то есть список аргументов не указан, либо список
     формальных параметров в том же стиле, что и ‘defun’.  Пропущенный
     ARGLIST по умолчанию - ‘t’, а не ‘nil’; это нетипичное поведение
     для пропущенных аргументов, и это означает, что для предоставления
     четвертого, но не третьего аргумента необходимо указать ‘t’ для
     заполнителя третьего аргумента вместо обычного ‘nil’.
     Необязательный четвертый аргумент FILEONLY non-‘nil’ означает
     проверку только того, что FILE существует, а не то, что он
     фактически определяет FUNCTION.

   Чтобы убедиться, что эти функции действительно объявлены там, где,
как говорит ‘declare-function’, они есть, используйте
‘check-declare-file’, чтобы проверить все вызовы ‘declare-function’ в
одном исходном файле, или используйте ‘check-declare-directory’, чтобы
проверить все файлы в определенной директории.

   Эти команды находят файл, который должен содержать определение
функции, используя ‘locate-library’; если это не находит файл, они
расширяют имя файла определения относительно каталога файла, который
содержит вызов ‘declare-function’.

   Вы также можете сказать, что функция является примитивом, указав имя
файла, оканчивающееся на ‘.c’ или ‘.m’.  Это полезно только тогда, когда
вы вызываете примитив, который определен только в определенных системах.
Большинство примитивов всегда определены, поэтому они никогда не будут
предупреждать вас.

   Иногда файл может дополнительно использовать функции из внешнего
пакета.  Если вы ставите префикс имени файла в операторе
‘declare-function’ с помощью ‘ext:’, то он будет проверен, если он
найден, в противном случае будет пропущен без ошибок.

   Есть некоторые определения функций, которые ‘check-declare’ не
понимает (например, ‘defstruct’ и некоторые другие макросы).  В таких
случаях вы можете передать не-‘nil’ аргумент FILEONLY в
‘declare-function’, что означает только проверку того, что файл
существует, а не то, что он фактически определяет функцию.  Обратите
внимание, что для этого без указания списка аргументов необходимо
установить для аргумента ARGLIST значение ‘t’ (поскольку ‘nil’ означает
пустой список аргументов, а не неопределенный).


File: elisp.info,  Node: Function Safety,  Next: Related Topics,  Prev: Declaring Functions,  Up: Functions

13.16 Determining whether a Function is Safe to Call
====================================================

Некоторые основные режимы, такие как SES, вызывают функции, которые
хранятся в пользовательских файлах.  (*note (ses)Top::, для получения
дополнительной информации об SES.)  Пользовательские файлы иногда имеют
плохие родословные - вы можете получить электронную таблицу от кого-то,
с кем вы только что познакомились, или вы можете получить ее по
электронной почте от кого-то, кого вы никогда не встречали.  Поэтому
рискованно вызывать функцию, исходный код которой хранится в
пользовательском файле, пока вы не определите, что она безопасна.

 -- Function: unsafep form &optional unsafep-vars
     Возвращает ‘nil’, если FORM является выражением Lisp “safe”, или
     возвращает список, в котором описано, почему это может быть
     небезопасно.  Аргумент UNSAFEP-VARS представляет собой список
     символов, которые, как известно, имеют временные привязки на данный
     момент; он в основном используется для внутренних рекурсивных
     вызовов.  Текущий буфер является неявным аргументом, который
     предоставляет список локальных привязок буфера.

   Быстро и просто, ‘unsafep’ делает очень легкий анализ и отклоняет
многие выражения Lisp, которые на самом деле безопасны.  Нет известных
случаев, когда ‘unsafep’ возвращает ‘nil’ для небезопасного выражения.
Однако безопасное выражение Lisp может возвращать строку со свойством
‘display’, содержащую ассоциированное выражение Lisp, которое будет
выполнено после вставки строки в буфер.  Это связанное выражение может
быть вирусом.  Чтобы быть в безопасности, вы должны удалить свойства из
всех строк, рассчитанных по коду пользователя, прежде чем вставлять их в
буферы.


File: elisp.info,  Node: Related Topics,  Prev: Function Safety,  Up: Functions

13.17 Other Topics Related to Functions
=======================================

Вот таблица нескольких функций, которые выполняют функции, связанные с
вызовом функций и определениями функций.  Они документированы в другом
месте, но мы даем перекрестные ссылки здесь.

‘apply’
     Смотри *note Calling Functions::.

‘autoload’
     Смотри *note Autoload::.

‘call-interactively’
     Смотри *note Interactive Call::.

‘called-interactively-p’
     Смотри *note Distinguish Interactive::.

‘commandp’
     Смотри *note Interactive Call::.

‘documentation’
     Смотри *note Accessing Documentation::.

‘eval’
     Смотри *note Eval::.

‘funcall’
     Смотри *note Calling Functions::.

‘function’
     Смотри *note Anonymous Functions::.

‘ignore’
     Смотри *note Calling Functions::.

‘indirect-function’
     Смотри *note Function Indirection::.

‘interactive’
     Смотри *note Using Interactive::.

‘interactive-p’
     Смотри *note Distinguish Interactive::.

‘mapatoms’
     Смотри *note Creating Symbols::.

‘mapcar’
     Смотри *note Mapping Functions::.

‘map-char-table’
     Смотри *note Char-Tables::.

‘mapconcat’
     Смотри *note Mapping Functions::.

‘undefined’
     Смотри *note Functions for Key Lookup::.


File: elisp.info,  Node: Macros,  Next: Customization,  Prev: Functions,  Up: Top

14 Macros
*********

“Macros” enable you to define new control constructs and other language
features.  A macro is defined much like a function, but instead of
telling how to compute a value, it tells how to compute another Lisp
expression which will in turn compute the value.  We call this
expression the “expansion” of the macro.

   Macros can do this because they operate on the unevaluated
expressions for the arguments, not on the argument values as functions
do.  They can therefore construct an expansion containing these argument
expressions or parts of them.

   If you are using a macro to do something an ordinary function could
do, just for the sake of speed, consider using an inline function
instead.  *Note Inline Functions::.

* Menu:

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Problems with Macros::    Don’t evaluate the macro arguments too many times.
                              Don’t hide the user’s variables.
* Indenting Macros::        Specifying how to indent macro calls.


File: elisp.info,  Node: Simple Macro,  Next: Expansion,  Up: Macros

14.1 A Simple Example of a Macro
================================

Suppose we would like to define a Lisp construct to increment a variable
value, much like the ‘++’ operator in C.  We would like to write ‘(inc
x)’ and have the effect of ‘(setq x (1+ x))’.  Here’s a macro definition
that does the job:

     (defmacro inc (var)
        (list 'setq var (list '1+ var)))

   When this is called with ‘(inc x)’, the argument VAR is the symbol
‘x’—_not_ the _value_ of ‘x’, as it would be in a function.  The body of
the macro uses this to construct the expansion, which is ‘(setq x (1+
x))’.  Once the macro definition returns this expansion, Lisp proceeds
to evaluate it, thus incrementing ‘x’.

 -- Function: macrop object
     This predicate tests whether its argument is a macro, and returns
     ‘t’ if so, ‘nil’ otherwise.


File: elisp.info,  Node: Expansion,  Next: Compiling Macros,  Prev: Simple Macro,  Up: Macros

14.2 Expansion of a Macro Call
==============================

A macro call looks just like a function call in that it is a list which
starts with the name of the macro.  The rest of the elements of the list
are the arguments of the macro.

   Evaluation of the macro call begins like evaluation of a function
call except for one crucial difference: the macro arguments are the
actual expressions appearing in the macro call.  They are not evaluated
before they are given to the macro definition.  By contrast, the
arguments of a function are results of evaluating the elements of the
function call list.

   Having obtained the arguments, Lisp invokes the macro definition just
as a function is invoked.  The argument variables of the macro are bound
to the argument values from the macro call, or to a list of them in the
case of a ‘&rest’ argument.  And the macro body executes and returns its
value just as a function body does.

   The second crucial difference between macros and functions is that
the value returned by the macro body is an alternate Lisp expression,
also known as the “expansion” of the macro.  The Lisp interpreter
proceeds to evaluate the expansion as soon as it comes back from the
macro.

   Since the expansion is evaluated in the normal manner, it may contain
calls to other macros.  It may even be a call to the same macro, though
this is unusual.

   Note that Emacs tries to expand macros when loading an uncompiled
Lisp file.  This is not always possible, but if it is, it speeds up
subsequent execution.  *Note How Programs Do Loading::.

   You can see the expansion of a given macro call by calling
‘macroexpand’.

 -- Function: macroexpand form &optional environment
     This function expands FORM, if it is a macro call.  If the result
     is another macro call, it is expanded in turn, until something
     which is not a macro call results.  That is the value returned by
     ‘macroexpand’.  If FORM is not a macro call to begin with, it is
     returned as given.

     Note that ‘macroexpand’ does not look at the subexpressions of FORM
     (although some macro definitions may do so).  Even if they are
     macro calls themselves, ‘macroexpand’ does not expand them.

     The function ‘macroexpand’ does not expand calls to inline
     functions.  Normally there is no need for that, since a call to an
     inline function is no harder to understand than a call to an
     ordinary function.

     If ENVIRONMENT is provided, it specifies an alist of macro
     definitions that shadow the currently defined macros.  Byte
     compilation uses this feature.

          (defmacro inc (var)
              (list 'setq var (list '1+ var)))

          (macroexpand '(inc r))
               ⇒ (setq r (1+ r))

          (defmacro inc2 (var1 var2)
              (list 'progn (list 'inc var1) (list 'inc var2)))

          (macroexpand '(inc2 r s))
               ⇒ (progn (inc r) (inc s))  ; ‘inc’ not expanded here.

 -- Function: macroexpand-all form &optional environment
     ‘macroexpand-all’ expands macros like ‘macroexpand’, but will look
     for and expand all macros in FORM, not just at the top-level.  If
     no macros are expanded, the return value is ‘eq’ to FORM.

     Repeating the example used for ‘macroexpand’ above with
     ‘macroexpand-all’, we see that ‘macroexpand-all’ _does_ expand the
     embedded calls to ‘inc’:

          (macroexpand-all '(inc2 r s))
               ⇒ (progn (setq r (1+ r)) (setq s (1+ s)))

 -- Function: macroexpand-1 form &optional environment
     This function expands macros like ‘macroexpand’, but it only
     performs one step of the expansion: if the result is another macro
     call, ‘macroexpand-1’ will not expand it.


File: elisp.info,  Node: Compiling Macros,  Next: Defining Macros,  Prev: Expansion,  Up: Macros

14.3 Macros and Byte Compilation
================================

You might ask why we take the trouble to compute an expansion for a
macro and then evaluate the expansion.  Why not have the macro body
produce the desired results directly?  The reason has to do with
compilation.

   When a macro call appears in a Lisp program being compiled, the Lisp
compiler calls the macro definition just as the interpreter would, and
receives an expansion.  But instead of evaluating this expansion, it
compiles the expansion as if it had appeared directly in the program.
As a result, the compiled code produces the value and side effects
intended for the macro, but executes at full compiled speed.  This would
not work if the macro body computed the value and side effects
itself—they would be computed at compile time, which is not useful.

   In order for compilation of macro calls to work, the macros must
already be defined in Lisp when the calls to them are compiled.  The
compiler has a special feature to help you do this: if a file being
compiled contains a ‘defmacro’ form, the macro is defined temporarily
for the rest of the compilation of that file.

   Byte-compiling a file also executes any ‘require’ calls at top-level
in the file, so you can ensure that necessary macro definitions are
available during compilation by requiring the files that define them
(*note Named Features::).  To avoid loading the macro definition files
when someone _runs_ the compiled program, write ‘eval-when-compile’
around the ‘require’ calls (*note Eval During Compile::).


File: elisp.info,  Node: Defining Macros,  Next: Problems with Macros,  Prev: Compiling Macros,  Up: Macros

14.4 Defining Macros
====================

A Lisp macro object is a list whose CAR is ‘macro’, and whose CDR is a
function.  Expansion of the macro works by applying the function (with
‘apply’) to the list of _unevaluated_ arguments from the macro call.

   It is possible to use an anonymous Lisp macro just like an anonymous
function, but this is never done, because it does not make sense to pass
an anonymous macro to functionals such as ‘mapcar’.  In practice, all
Lisp macros have names, and they are almost always defined with the
‘defmacro’ macro.

 -- Macro: defmacro name args [doc] [declare] body...
     ‘defmacro’ defines the symbol NAME (which should not be quoted) as
     a macro that looks like this:

          (macro lambda ARGS . BODY)

     (Note that the CDR of this list is a lambda expression.)  This
     macro object is stored in the function cell of NAME.  The meaning
     of ARGS is the same as in a function, and the keywords ‘&rest’ and
     ‘&optional’ may be used (*note Argument List::).  Neither NAME nor
     ARGS should be quoted.  The return value of ‘defmacro’ is
     undefined.

     DOC, if present, should be a string specifying the macro’s
     documentation string.  DECLARE, if present, should be a ‘declare’
     form specifying metadata for the macro (*note Declare Form::).
     Note that macros cannot have interactive declarations, since they
     cannot be called interactively.

   Macros often need to construct large list structures from a mixture
of constants and nonconstant parts.  To make this easier, use the ‘`’
syntax (*note Backquote::).  For example:

          (defmacro t-becomes-nil (variable)
            `(if (eq ,variable t)
                 (setq ,variable nil)))

          (t-becomes-nil foo)
               ≡ (if (eq foo t) (setq foo nil))


File: elisp.info,  Node: Problems with Macros,  Next: Indenting Macros,  Prev: Defining Macros,  Up: Macros

14.5 Common Problems Using Macros
=================================

Macro expansion can have counterintuitive consequences.  This section
describes some important consequences that can lead to trouble, and
rules to follow to avoid trouble.

* Menu:

* Wrong Time::             Do the work in the expansion, not in the macro.
* Argument Evaluation::    The expansion should evaluate each macro arg once.
* Surprising Local Vars::  Local variable bindings in the expansion
                              require special care.
* Eval During Expansion::  Don’t evaluate them; put them in the expansion.
* Repeated Expansion::     Avoid depending on how many times expansion is done.


File: elisp.info,  Node: Wrong Time,  Next: Argument Evaluation,  Up: Problems with Macros

14.5.1 Wrong Time
-----------------

The most common problem in writing macros is doing some of the real work
prematurely—while expanding the macro, rather than in the expansion
itself.  For instance, one real package had this macro definition:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           (set-buffer-multibyte arg)))

   With this erroneous macro definition, the program worked fine when
interpreted but failed when compiled.  This macro definition called
‘set-buffer-multibyte’ during compilation, which was wrong, and then did
nothing when the compiled package was run.  The definition that the
programmer really wanted was this:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           `(set-buffer-multibyte ,arg)))

This macro expands, if appropriate, into a call to
‘set-buffer-multibyte’ that will be executed when the compiled program
is actually run.


File: elisp.info,  Node: Argument Evaluation,  Next: Surprising Local Vars,  Prev: Wrong Time,  Up: Problems with Macros

14.5.2 Evaluating Macro Arguments Repeatedly
--------------------------------------------

When defining a macro you must pay attention to the number of times the
arguments will be evaluated when the expansion is executed.  The
following macro (used to facilitate iteration) illustrates the problem.
This macro allows us to write a for-loop construct.

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (list 'let (list (list var init))
             (cons 'while
                   (cons (list '<= var final)
                         (append body (list (list 'inc var)))))))

     (for i from 1 to 3 do
        (setq square (* i i))
        (princ (format "\n%d %d" i square)))
     ↦
     (let ((i 1))
       (while (<= i 3)
         (setq square (* i i))
         (princ (format "\n%d %d" i square))
         (inc i)))

          ⊣1       1
          ⊣2       4
          ⊣3       9
     ⇒ nil

The arguments ‘from’, ‘to’, and ‘do’ in this macro are syntactic sugar;
they are entirely ignored.  The idea is that you will write noise words
(such as ‘from’, ‘to’, and ‘do’) in those positions in the macro call.

   Here’s an equivalent definition simplified through use of backquote:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       `(let ((,var ,init))
          (while (<= ,var ,final)
            ,@body
            (inc ,var))))

   Both forms of this definition (with backquote and without) suffer
from the defect that FINAL is evaluated on every iteration.  If FINAL is
a constant, this is not a problem.  If it is a more complex form, say
‘(long-complex-calculation x)’, this can slow down the execution
significantly.  If FINAL has side effects, executing it more than once
is probably incorrect.

   A well-designed macro definition takes steps to avoid this problem by
producing an expansion that evaluates the argument expressions exactly
once unless repeated evaluation is part of the intended purpose of the
macro.  Here is a correct expansion for the ‘for’ macro:

     (let ((i 1)
           (max 3))
       (while (<= i max)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))

   Here is a macro definition that creates this expansion:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   Unfortunately, this fix introduces another problem, described in the
following section.


File: elisp.info,  Node: Surprising Local Vars,  Next: Eval During Expansion,  Prev: Argument Evaluation,  Up: Problems with Macros

14.5.3 Local Variables in Macro Expansions
------------------------------------------

In the previous section, the definition of ‘for’ was fixed as follows to
make the expansion evaluate the macro arguments the proper number of
times:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   The new definition of ‘for’ has a new problem: it introduces a local
variable named ‘max’ which the user does not expect.  This causes
trouble in examples such as the following:

     (let ((max 0))
       (for x from 0 to 10 do
         (let ((this (frob x)))
           (if (< max this)
               (setq max this)))))

The references to ‘max’ inside the body of the ‘for’, which are supposed
to refer to the user’s binding of ‘max’, really access the binding made
by ‘for’.

   The way to correct this is to use an uninterned symbol instead of
‘max’ (*note Creating Symbols::).  The uninterned symbol can be bound
and referred to just like any other symbol, but since it is created by
‘for’, we know that it cannot already appear in the user’s program.
Since it is not interned, there is no way the user can put it into the
program later.  It will never appear anywhere except where put by ‘for’.
Here is a definition of ‘for’ that works this way:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       (let ((tempvar (make-symbol "max")))
         `(let ((,var ,init)
                (,tempvar ,final))
            (while (<= ,var ,tempvar)
              ,@body
              (inc ,var)))))

This creates an uninterned symbol named ‘max’ and puts it in the
expansion instead of the usual interned symbol ‘max’ that appears in
expressions ordinarily.


File: elisp.info,  Node: Eval During Expansion,  Next: Repeated Expansion,  Prev: Surprising Local Vars,  Up: Problems with Macros

14.5.4 Evaluating Macro Arguments in Expansion
----------------------------------------------

Another problem can happen if the macro definition itself evaluates any
of the macro argument expressions, such as by calling ‘eval’ (*note
Eval::).  If the argument is supposed to refer to the user’s variables,
you may have trouble if the user happens to use a variable with the same
name as one of the macro arguments.  Inside the macro body, the macro
argument binding is the most local binding of this variable, so any
references inside the form being evaluated do refer to it.  Here is an
example:

     (defmacro foo (a)
       (list 'setq (eval a) t))
     (setq x 'b)
     (foo x) ↦ (setq b t)
          ⇒ t                  ; and ‘b’ has been set.
     ;; but
     (setq a 'c)
     (foo a) ↦ (setq a t)
          ⇒ t                  ; but this set ‘a’, not ‘c’.


   It makes a difference whether the user’s variable is named ‘a’ or
‘x’, because ‘a’ conflicts with the macro argument variable ‘a’.

   Another problem with calling ‘eval’ in a macro definition is that it
probably won’t do what you intend in a compiled program.  The byte
compiler runs macro definitions while compiling the program, when the
program’s own computations (which you might have wished to access with
‘eval’) don’t occur and its local variable bindings don’t exist.

   To avoid these problems, *don’t evaluate an argument expression while
computing the macro expansion*.  Instead, substitute the expression into
the macro expansion, so that its value will be computed as part of
executing the expansion.  This is how the other examples in this chapter
work.


File: elisp.info,  Node: Repeated Expansion,  Prev: Eval During Expansion,  Up: Problems with Macros

14.5.5 How Many Times is the Macro Expanded?
--------------------------------------------

Occasionally problems result from the fact that a macro call is expanded
each time it is evaluated in an interpreted function, but is expanded
only once (during compilation) for a compiled function.  If the macro
definition has side effects, they will work differently depending on how
many times the macro is expanded.

   Therefore, you should avoid side effects in computation of the macro
expansion, unless you really know what you are doing.

   One special kind of side effect can’t be avoided: constructing Lisp
objects.  Almost all macro expansions include constructed lists; that is
the whole point of most macros.  This is usually safe; there is just one
case where you must be careful: when the object you construct is part of
a quoted constant in the macro expansion.

   If the macro is expanded just once, in compilation, then the object
is constructed just once, during compilation.  But in interpreted
execution, the macro is expanded each time the macro call runs, and this
means a new object is constructed each time.

   In most clean Lisp code, this difference won’t matter.  It can matter
only if you perform side-effects on the objects constructed by the macro
definition.  Thus, to avoid trouble, *avoid side effects on objects
constructed by macro definitions*.  Here is an example of how such side
effects can get you into trouble:

     (defmacro empty-object ()
       (list 'quote (cons nil nil)))

     (defun initialize (condition)
       (let ((object (empty-object)))
         (if condition
             (setcar object condition))
         object))

If ‘initialize’ is interpreted, a new list ‘(nil)’ is constructed each
time ‘initialize’ is called.  Thus, no side effect survives between
calls.  If ‘initialize’ is compiled, then the macro ‘empty-object’ is
expanded during compilation, producing a single constant ‘(nil)’ that is
reused and altered each time ‘initialize’ is called.

   One way to avoid pathological cases like this is to think of
‘empty-object’ as a funny kind of constant, not as a memory allocation
construct.  You wouldn’t use ‘setcar’ on a constant such as ‘'(nil)’, so
naturally you won’t use it on ‘(empty-object)’ either.


File: elisp.info,  Node: Indenting Macros,  Prev: Problems with Macros,  Up: Macros

14.6 Indenting Macros
=====================

Within a macro definition, you can use the ‘declare’ form (*note
Defining Macros::) to specify how <TAB> should indent calls to the
macro.  An indentation specification is written like this:

     (declare (indent INDENT-SPEC))

This results in the ‘lisp-indent-function’ property being set on the
macro name.

Here are the possibilities for INDENT-SPEC:

‘nil’
     This is the same as no property—use the standard indentation
     pattern.
‘defun’
     Handle this function like a ‘def’ construct: treat the second line
     as the start of a “body”.
an integer, NUMBER
     The first NUMBER arguments of the function are “distinguished”
     arguments; the rest are considered the body of the expression.  A
     line in the expression is indented according to whether the first
     argument on it is distinguished or not.  If the argument is part of
     the body, the line is indented ‘lisp-body-indent’ more columns than
     the open-parenthesis starting the containing expression.  If the
     argument is distinguished and is either the first or second
     argument, it is indented _twice_ that many extra columns.  If the
     argument is distinguished and not the first or second argument, the
     line uses the standard pattern.
a symbol, SYMBOL
     SYMBOL should be a function name; that function is called to
     calculate the indentation of a line within this expression.  The
     function receives two arguments:

     POS
          The position at which the line being indented begins.
     STATE
          The value returned by ‘parse-partial-sexp’ (a Lisp primitive
          for indentation and nesting computation) when it parses up to
          the beginning of this line.

     It should return either a number, which is the number of columns of
     indentation for that line, or a list whose car is such a number.
     The difference between returning a number and returning a list is
     that a number says that all following lines at the same nesting
     level should be indented just like this one; a list says that
     following lines might call for different indentations.  This makes
     a difference when the indentation is being computed by ‘C-M-q’; if
     the value is a number, ‘C-M-q’ need not recalculate indentation for
     the following lines until the end of the list.


File: elisp.info,  Node: Customization,  Next: Loading,  Prev: Macros,  Up: Top

15 Customization Settings
*************************

Users of Emacs can customize variables and faces without writing Lisp
code, by using the Customize interface.  *Note (emacs)Easy
Customization::.  This chapter describes how to define “customization
items” that users can interact with through the Customize interface.

   Customization items include customizable variables, which are defined
with the ‘defcustom’ macro (*note Variable Definitions::); customizable
faces, which are defined with ‘defface’ (described separately in *note
Defining Faces::); and “customization groups”, defined with ‘defgroup’
(*note Group Definitions::), which act as containers for groups of
related customization items.

* Menu:

* Common Keywords::         Common keyword arguments for all kinds of
                             customization declarations.
* Group Definitions::       Writing customization group definitions.
* Variable Definitions::    Declaring user options.
* Customization Types::     Specifying the type of a user option.
* Applying Customizations:: Functions to apply customization settings.
* Custom Themes::           Writing Custom themes.


File: elisp.info,  Node: Common Keywords,  Next: Group Definitions,  Up: Customization

15.1 Common Item Keywords
=========================

The customization declarations that we will describe in the next few
sections—‘defcustom’, ‘defgroup’, etc.—all accept keyword arguments
(*note Constant Variables::) for specifying various information.  This
section describes keywords that apply to all types of customization
declarations.

   All of these keywords, except ‘:tag’, can be used more than once in a
given item.  Each use of the keyword has an independent effect.  The
keyword ‘:tag’ is an exception because any given item can only display
one name.

‘:tag LABEL’
     Use LABEL, a string, instead of the item’s name, to label the item
     in customization menus and buffers.  *Don’t use a tag which is
     substantially different from the item’s real name; that would cause
     confusion.*

‘:group GROUP’
     Put this customization item in group GROUP.  If this keyword is
     missing from a customization item, it’ll be placed in the same
     group that was last defined (in the current file).

     When you use ‘:group’ in a ‘defgroup’, it makes the new group a
     subgroup of GROUP.

     If you use this keyword more than once, you can put a single item
     into more than one group.  Displaying any of those groups will show
     this item.  Please don’t overdo this, since the result would be
     annoying.

‘:link LINK-DATA’
     Include an external link after the documentation string for this
     item.  This is a sentence containing a button that references some
     other documentation.

     There are several alternatives you can use for LINK-DATA:

     ‘(custom-manual INFO-NODE)’
          Link to an Info node; INFO-NODE is a string which specifies
          the node name, as in ‘"(emacs)Top"’.  The link appears as
          ‘[Manual]’ in the customization buffer and enters the built-in
          Info reader on INFO-NODE.

     ‘(info-link INFO-NODE)’
          Like ‘custom-manual’ except that the link appears in the
          customization buffer with the Info node name.

     ‘(url-link URL)’
          Link to a web page; URL is a string which specifies the URL.
          The link appears in the customization buffer as URL and
          invokes the WWW browser specified by
          ‘browse-url-browser-function’.

     ‘(emacs-commentary-link LIBRARY)’
          Link to the commentary section of a library; LIBRARY is a
          string which specifies the library name.  *Note Library
          Headers::.

     ‘(emacs-library-link LIBRARY)’
          Link to an Emacs Lisp library file; LIBRARY is a string which
          specifies the library name.

     ‘(file-link FILE)’
          Link to a file; FILE is a string which specifies the name of
          the file to visit with ‘find-file’ when the user invokes this
          link.

     ‘(function-link FUNCTION)’
          Link to the documentation of a function; FUNCTION is a string
          which specifies the name of the function to describe with
          ‘describe-function’ when the user invokes this link.

     ‘(variable-link VARIABLE)’
          Link to the documentation of a variable; VARIABLE is a string
          which specifies the name of the variable to describe with
          ‘describe-variable’ when the user invokes this link.

     ‘(custom-group-link GROUP)’
          Link to another customization group.  Invoking it creates a
          new customization buffer for GROUP.

     You can specify the text to use in the customization buffer by
     adding ‘:tag NAME’ after the first element of the LINK-DATA; for
     example, ‘(info-link :tag "foo" "(emacs)Top")’ makes a link to the
     Emacs manual which appears in the buffer as ‘foo’.

     You can use this keyword more than once, to add multiple links.

‘:load FILE’
     Load file FILE (a string) before displaying this customization item
     (*note Loading::).  Loading is done with ‘load’, and only if the
     file is not already loaded.

‘:require FEATURE’
     Execute ‘(require 'FEATURE)’ when your saved customizations set the
     value of this item.  FEATURE should be a symbol.

     The most common reason to use ‘:require’ is when a variable enables
     a feature such as a minor mode, and just setting the variable won’t
     have any effect unless the code which implements the mode is
     loaded.

‘:version VERSION’
     This keyword specifies that the item was first introduced in Emacs
     version VERSION, or that its default value was changed in that
     version.  The value VERSION must be a string.

‘:package-version '(PACKAGE . VERSION)’
     This keyword specifies that the item was first introduced in
     PACKAGE version VERSION, or that its meaning or default value was
     changed in that version.  This keyword takes priority over
     ‘:version’.

     PACKAGE should be the official name of the package, as a symbol
     (e.g., ‘MH-E’).  VERSION should be a string.  If the package
     PACKAGE is released as part of Emacs, PACKAGE and VERSION should
     appear in the value of ‘customize-package-emacs-version-alist’.

   Packages distributed as part of Emacs that use the ‘:package-version’
keyword must also update the ‘customize-package-emacs-version-alist’
variable.

 -- Variable: customize-package-emacs-version-alist
     This alist provides a mapping for the versions of Emacs that are
     associated with versions of a package listed in the
     ‘:package-version’ keyword.  Its elements are:

          (PACKAGE (PVERSION . EVERSION)...)

     For each PACKAGE, which is a symbol, there are one or more elements
     that contain a package version PVERSION with an associated Emacs
     version EVERSION.  These versions are strings.  For example, the
     MH-E package updates this alist with the following:

          (add-to-list 'customize-package-emacs-version-alist
                       '(MH-E ("6.0" . "22.1") ("6.1" . "22.1") ("7.0" . "22.1")
                              ("7.1" . "22.1") ("7.2" . "22.1") ("7.3" . "22.1")
                              ("7.4" . "22.1") ("8.0" . "22.1")))

     The value of PACKAGE needs to be unique and it needs to match the
     PACKAGE value appearing in the ‘:package-version’ keyword.  Since
     the user might see the value in an error message, a good choice is
     the official name of the package, such as MH-E or Gnus.


File: elisp.info,  Node: Group Definitions,  Next: Variable Definitions,  Prev: Common Keywords,  Up: Customization

15.2 Defining Customization Groups
==================================

Each Emacs Lisp package should have one main customization group which
contains all the options, faces and other groups in the package.  If the
package has a small number of options and faces, use just one group and
put everything in it.  When there are more than twenty or so options and
faces, then you should structure them into subgroups, and put the
subgroups under the package’s main customization group.  It is OK to put
some of the options and faces in the package’s main group alongside the
subgroups.

   The package’s main or only group should be a member of one or more of
the standard customization groups.  (To display the full list of them,
use ‘M-x customize’.)  Choose one or more of them (but not too many),
and add your group to each of them using the ‘:group’ keyword.

   The way to declare new customization groups is with ‘defgroup’.

 -- Macro: defgroup group members doc [keyword value]...
     Declare GROUP as a customization group containing MEMBERS.  Do not
     quote the symbol GROUP.  The argument DOC specifies the
     documentation string for the group.

     The argument MEMBERS is a list specifying an initial set of
     customization items to be members of the group.  However, most
     often MEMBERS is ‘nil’, and you specify the group’s members by
     using the ‘:group’ keyword when defining those members.

     If you want to specify group members through MEMBERS, each element
     should have the form ‘(NAME WIDGET)’.  Here NAME is a symbol, and
     WIDGET is a widget type for editing that symbol.  Useful widgets
     are ‘custom-variable’ for a variable, ‘custom-face’ for a face, and
     ‘custom-group’ for a group.

     When you introduce a new group into Emacs, use the ‘:version’
     keyword in the ‘defgroup’; then you need not use it for the
     individual members of the group.

     In addition to the common keywords (*note Common Keywords::), you
     can also use this keyword in ‘defgroup’:

     ‘:prefix PREFIX’
          If the name of an item in the group starts with PREFIX, and
          the customizable variable ‘custom-unlispify-remove-prefixes’
          is non-‘nil’, the item’s tag will omit PREFIX.  A group can
          have any number of prefixes.

     The variables and subgroups of a group are stored in the
     ‘custom-group’ property of the group’s symbol.  *Note Symbol
     Plists::.  The value of that property is a list of pairs whose
     ‘car’ is the variable or subgroup symbol and the ‘cdr’ is either
     ‘custom-variable’ or ‘custom-group’.

 -- User Option: custom-unlispify-remove-prefixes
     If this variable is non-‘nil’, the prefixes specified by a group’s
     ‘:prefix’ keyword are omitted from tag names, whenever the user
     customizes the group.

     The default value is ‘nil’, i.e., the prefix-discarding feature is
     disabled.  This is because discarding prefixes often leads to
     confusing names for options and faces.


File: elisp.info,  Node: Variable Definitions,  Next: Customization Types,  Prev: Group Definitions,  Up: Customization

15.3 Defining Customization Variables
=====================================

“Customizable variables”, also called “user options”, are global Lisp
variables whose values can be set through the Customize interface.
Unlike other global variables, which are defined with ‘defvar’ (*note
Defining Variables::), customizable variables are defined using the
‘defcustom’ macro.  In addition to calling ‘defvar’ as a subroutine,
‘defcustom’ states how the variable should be displayed in the Customize
interface, the values it is allowed to take, etc.

 -- Macro: defcustom option standard doc [keyword value]...
     This macro declares OPTION as a user option (i.e., a customizable
     variable).  You should not quote OPTION.

     The argument STANDARD is an expression that specifies the standard
     value for OPTION.  Evaluating the ‘defcustom’ form evaluates
     STANDARD, but does not necessarily bind the option to that value.
     If OPTION already has a default value, it is left unchanged.  If
     the user has already saved a customization for OPTION, the user’s
     customized value is installed as the default value.  Otherwise, the
     result of evaluating STANDARD is installed as the default value.

     Like ‘defvar’, this macro marks ‘option’ as a special variable,
     meaning that it should always be dynamically bound.  If OPTION is
     already lexically bound, that lexical binding remains in effect
     until the binding construct exits.  *Note Variable Scoping::.

     The expression STANDARD can be evaluated at various other times,
     too—whenever the customization facility needs to know OPTION’s
     standard value.  So be sure to use an expression which is harmless
     to evaluate at any time.

     The argument DOC specifies the documentation string for the
     variable.

     If a ‘defcustom’ does not specify any ‘:group’, the last group
     defined with ‘defgroup’ in the same file will be used.  This way,
     most ‘defcustom’ do not need an explicit ‘:group’.

     When you evaluate a ‘defcustom’ form with ‘C-M-x’ in Emacs Lisp
     mode (‘eval-defun’), a special feature of ‘eval-defun’ arranges to
     set the variable unconditionally, without testing whether its value
     is void.  (The same feature applies to ‘defvar’, *note Defining
     Variables::.)  Using ‘eval-defun’ on a defcustom that is already
     defined calls the ‘:set’ function (see below), if there is one.

     If you put a ‘defcustom’ in a pre-loaded Emacs Lisp file (*note
     Building Emacs::), the standard value installed at dump time might
     be incorrect, e.g., because another variable that it depends on has
     not been assigned the right value yet.  In that case, use
     ‘custom-reevaluate-setting’, described below, to re-evaluate the
     standard value after Emacs starts up.

   In addition to the keywords listed in *note Common Keywords::, this
macro accepts the following keywords:

‘:type TYPE’
     Use TYPE as the data type for this option.  It specifies which
     values are legitimate, and how to display the value (*note
     Customization Types::).  Every ‘defcustom’ should specify a value
     for this keyword.

‘:options VALUE-LIST’
     Specify the list of reasonable values for use in this option.  The
     user is not restricted to using only these values, but they are
     offered as convenient alternatives.

     This is meaningful only for certain types, currently including
     ‘hook’, ‘plist’ and ‘alist’.  See the definition of the individual
     types for a description of how to use ‘:options’.

‘:set SETFUNCTION’
     Specify SETFUNCTION as the way to change the value of this option
     when using the Customize interface.  The function SETFUNCTION
     should take two arguments, a symbol (the option name) and the new
     value, and should do whatever is necessary to update the value
     properly for this option (which may not mean simply setting the
     option as a Lisp variable); preferably, though, it should not
     modify its value argument destructively.  The default for
     SETFUNCTION is ‘set-default’.

     If you specify this keyword, the variable’s documentation string
     should describe how to do the same job in hand-written Lisp code.

‘:get GETFUNCTION’
     Specify GETFUNCTION as the way to extract the value of this option.
     The function GETFUNCTION should take one argument, a symbol, and
     should return whatever customize should use as the current value
     for that symbol (which need not be the symbol’s Lisp value).  The
     default is ‘default-value’.

     You have to really understand the workings of Custom to use ‘:get’
     correctly.  It is meant for values that are treated in Custom as
     variables but are not actually stored in Lisp variables.  It is
     almost surely a mistake to specify GETFUNCTION for a value that
     really is stored in a Lisp variable.

‘:initialize FUNCTION’
     FUNCTION should be a function used to initialize the variable when
     the ‘defcustom’ is evaluated.  It should take two arguments, the
     option name (a symbol) and the value.  Here are some predefined
     functions meant for use in this way:

     ‘custom-initialize-set’
          Use the variable’s ‘:set’ function to initialize the variable,
          but do not reinitialize it if it is already non-void.

     ‘custom-initialize-default’
          Like ‘custom-initialize-set’, but use the function
          ‘set-default’ to set the variable, instead of the variable’s
          ‘:set’ function.  This is the usual choice for a variable
          whose ‘:set’ function enables or disables a minor mode; with
          this choice, defining the variable will not call the minor
          mode function, but customizing the variable will do so.

     ‘custom-initialize-reset’
          Always use the ‘:set’ function to initialize the variable.  If
          the variable is already non-void, reset it by calling the
          ‘:set’ function using the current value (returned by the
          ‘:get’ method).  This is the default ‘:initialize’ function.

     ‘custom-initialize-changed’
          Use the ‘:set’ function to initialize the variable, if it is
          already set or has been customized; otherwise, just use
          ‘set-default’.

     ‘custom-initialize-safe-set’
     ‘custom-initialize-safe-default’
          These functions behave like ‘custom-initialize-set’
          (‘custom-initialize-default’, respectively), but catch errors.
          If an error occurs during initialization, they set the
          variable to ‘nil’ using ‘set-default’, and signal no error.

          These functions are meant for options defined in pre-loaded
          files, where the STANDARD expression may signal an error
          because some required variable or function is not yet defined.
          The value normally gets updated in ‘startup.el’, ignoring the
          value computed by ‘defcustom’.  After startup, if one unsets
          the value and reevaluates the ‘defcustom’, the STANDARD
          expression can be evaluated without error.

‘:risky VALUE’
     Set the variable’s ‘risky-local-variable’ property to VALUE (*note
     File Local Variables::).

‘:safe FUNCTION’
     Set the variable’s ‘safe-local-variable’ property to FUNCTION
     (*note File Local Variables::).

‘:set-after VARIABLES’
     When setting variables according to saved customizations, make sure
     to set the variables VARIABLES before this one; i.e., delay setting
     this variable until after those others have been handled.  Use
     ‘:set-after’ if setting this variable won’t work properly unless
     those other variables already have their intended values.

   It is useful to specify the ‘:require’ keyword for an option that
turns on a certain feature.  This causes Emacs to load the feature, if
it is not already loaded, whenever the option is set.  *Note Common
Keywords::.  Here is an example, from the library ‘saveplace.el’:

     (defcustom save-place nil
       "Non-nil means automatically save place in each file..."
       :type 'boolean
       :require 'saveplace
       :group 'save-place)

   If a customization item has a type such as ‘hook’ or ‘alist’, which
supports ‘:options’, you can add additional values to the list from
outside the ‘defcustom’ declaration by calling
‘custom-add-frequent-value’.  For example, if you define a function
‘my-lisp-mode-initialization’ intended to be called from
‘emacs-lisp-mode-hook’, you might want to add that to the list of
reasonable values for ‘emacs-lisp-mode-hook’, but not by editing its
definition.  You can do it thus:

     (custom-add-frequent-value 'emacs-lisp-mode-hook
        'my-lisp-mode-initialization)

 -- Function: custom-add-frequent-value symbol value
     For the customization option SYMBOL, add VALUE to the list of
     reasonable values.

     The precise effect of adding a value depends on the customization
     type of SYMBOL.

   Internally, ‘defcustom’ uses the symbol property ‘standard-value’ to
record the expression for the standard value, ‘saved-value’ to record
the value saved by the user with the customization buffer, and
‘customized-value’ to record the value set by the user with the
customization buffer, but not saved.  *Note Symbol Properties::.  These
properties are lists, the car of which is an expression that evaluates
to the value.

 -- Function: custom-reevaluate-setting symbol
     This function re-evaluates the standard value of SYMBOL, which
     should be a user option declared via ‘defcustom’.  If the variable
     was customized, this function re-evaluates the saved value instead.
     Then it sets the user option to that value (using the option’s
     ‘:set’ property if that is defined).

     This is useful for customizable options that are defined before
     their value could be computed correctly.  For example, during
     startup Emacs calls this function for some user options that were
     defined in pre-loaded Emacs Lisp files, but whose initial values
     depend on information available only at run-time.

 -- Function: custom-variable-p arg
     This function returns non-‘nil’ if ARG is a customizable variable.
     A customizable variable is either a variable that has a
     ‘standard-value’ or ‘custom-autoload’ property (usually meaning it
     was declared with ‘defcustom’), or an alias for another
     customizable variable.


File: elisp.info,  Node: Customization Types,  Next: Applying Customizations,  Prev: Variable Definitions,  Up: Customization

15.4 Customization Types
========================

When you define a user option with ‘defcustom’, you must specify its
“customization type”.  That is a Lisp object which describes (1) which
values are legitimate and (2) how to display the value in the
customization buffer for editing.

   You specify the customization type in ‘defcustom’ with the ‘:type’
keyword.  The argument of ‘:type’ is evaluated, but only once when the
‘defcustom’ is executed, so it isn’t useful for the value to vary.
Normally we use a quoted constant.  For example:

     (defcustom diff-command "diff"
       "The command to use to run diff."
       :type '(string)
       :group 'diff)

   In general, a customization type is a list whose first element is a
symbol, one of the customization type names defined in the following
sections.  After this symbol come a number of arguments, depending on
the symbol.  Between the type symbol and its arguments, you can
optionally write keyword-value pairs (*note Type Keywords::).

   Some type symbols do not use any arguments; those are called “simple
types”.  For a simple type, if you do not use any keyword-value pairs,
you can omit the parentheses around the type symbol.  For example just
‘string’ as a customization type is equivalent to ‘(string)’.

   All customization types are implemented as widgets; see *note
Introduction: (widget)Top, for details.

* Menu:

* Simple Types::            Simple customization types: sexp, integer, etc.
* Composite Types::         Build new types from other types or data.
* Splicing into Lists::     Splice elements into list with ‘:inline’.
* Type Keywords::           Keyword-argument pairs in a customization type.
* Defining New Types::      Give your type a name.


File: elisp.info,  Node: Simple Types,  Next: Composite Types,  Up: Customization Types

15.4.1 Simple Types
-------------------

This section describes all the simple customization types.  For several
of these customization types, the customization widget provides inline
completion with ‘C-M-i’ or ‘M-<TAB>’.

‘sexp’
     The value may be any Lisp object that can be printed and read back.
     You can use ‘sexp’ as a fall-back for any option, if you don’t want
     to take the time to work out a more specific type to use.

‘integer’
     The value must be an integer.

‘number’
     The value must be a number (floating point or integer).

‘float’
     The value must be floating point.

‘string’
     The value must be a string.  The customization buffer shows the
     string without delimiting ‘"’ characters or ‘\’ quotes.

‘regexp’
     Like ‘string’ except that the string must be a valid regular
     expression.

‘character’
     The value must be a character code.  A character code is actually
     an integer, but this type shows the value by inserting the
     character in the buffer, rather than by showing the number.

‘file’
     The value must be a file name.  The widget provides completion.

‘(file :must-match t)’
     The value must be a file name for an existing file.  The widget
     provides completion.

‘directory’
     The value must be a directory.  The widget provides completion.

‘hook’
     The value must be a list of functions.  This customization type is
     used for hook variables.  You can use the ‘:options’ keyword in a
     hook variable’s ‘defcustom’ to specify a list of functions
     recommended for use in the hook; *Note Variable Definitions::.

‘symbol’
     The value must be a symbol.  It appears in the customization buffer
     as the symbol name.  The widget provides completion.

‘function’
     The value must be either a lambda expression or a function name.
     The widget provides completion for function names.

‘variable’
     The value must be a variable name.  The widget provides completion.

‘face’
     The value must be a symbol which is a face name.  The widget
     provides completion.

‘boolean’
     The value is boolean—either ‘nil’ or ‘t’.  Note that by using
     ‘choice’ and ‘const’ together (see the next section), you can
     specify that the value must be ‘nil’ or ‘t’, but also specify the
     text to describe each value in a way that fits the specific meaning
     of the alternative.

‘key-sequence’
     The value is a key sequence.  The customization buffer shows the
     key sequence using the same syntax as the ‘kbd’ function.  *Note
     Key Sequences::.

‘coding-system’
     The value must be a coding-system name, and you can do completion
     with ‘M-<TAB>’.

‘color’
     The value must be a valid color name.  The widget provides
     completion for color names, as well as a sample and a button for
     selecting a color name from a list of color names shown in a
     ‘*Colors*’ buffer.


File: elisp.info,  Node: Composite Types,  Next: Splicing into Lists,  Prev: Simple Types,  Up: Customization Types

15.4.2 Composite Types
----------------------

When none of the simple types is appropriate, you can use composite
types, which build new types from other types or from specified data.
The specified types or data are called the “arguments” of the composite
type.  The composite type normally looks like this:

     (CONSTRUCTOR ARGUMENTS...)

but you can also add keyword-value pairs before the arguments, like
this:

     (CONSTRUCTOR {KEYWORD VALUE}... ARGUMENTS...)

   Here is a table of constructors and how to use them to write
composite types:

‘(cons CAR-TYPE CDR-TYPE)’
     The value must be a cons cell, its CAR must fit CAR-TYPE, and its
     CDR must fit CDR-TYPE.  For example, ‘(cons string symbol)’ is a
     customization type which matches values such as ‘("foo" . foo)’.

     In the customization buffer, the CAR and CDR are displayed and
     edited separately, each according to their specified type.

‘(list ELEMENT-TYPES...)’
     The value must be a list with exactly as many elements as the
     ELEMENT-TYPES given; and each element must fit the corresponding
     ELEMENT-TYPE.

     For example, ‘(list integer string function)’ describes a list of
     three elements; the first element must be an integer, the second a
     string, and the third a function.

     In the customization buffer, each element is displayed and edited
     separately, according to the type specified for it.

‘(group ELEMENT-TYPES...)’
     This works like ‘list’ except for the formatting of text in the
     Custom buffer.  ‘list’ labels each element value with its tag;
     ‘group’ does not.

‘(vector ELEMENT-TYPES...)’
     Like ‘list’ except that the value must be a vector instead of a
     list.  The elements work the same as in ‘list’.

‘(alist :key-type KEY-TYPE :value-type VALUE-TYPE)’
     The value must be a list of cons-cells, the CAR of each cell
     representing a key of customization type KEY-TYPE, and the CDR of
     the same cell representing a value of customization type
     VALUE-TYPE.  The user can add and delete key/value pairs, and edit
     both the key and the value of each pair.

     If omitted, KEY-TYPE and VALUE-TYPE default to ‘sexp’.

     The user can add any key matching the specified key type, but you
     can give some keys a preferential treatment by specifying them with
     the ‘:options’ (see *note Variable Definitions::).  The specified
     keys will always be shown in the customize buffer (together with a
     suitable value), with a checkbox to include or exclude or disable
     the key/value pair from the alist.  The user will not be able to
     edit the keys specified by the ‘:options’ keyword argument.

     The argument to the ‘:options’ keywords should be a list of
     specifications for reasonable keys in the alist.  Ordinarily, they
     are simply atoms, which stand for themselves.  For example:

          :options '("foo" "bar" "baz")

     specifies that there are three known keys, namely ‘"foo"’, ‘"bar"’
     and ‘"baz"’, which will always be shown first.

     You may want to restrict the value type for specific keys, for
     example, the value associated with the ‘"bar"’ key can only be an
     integer.  You can specify this by using a list instead of an atom
     in the list.  The first element will specify the key, like before,
     while the second element will specify the value type.  For example:

          :options '("foo" ("bar" integer) "baz")

     Finally, you may want to change how the key is presented.  By
     default, the key is simply shown as a ‘const’, since the user
     cannot change the special keys specified with the ‘:options’
     keyword.  However, you may want to use a more specialized type for
     presenting the key, like ‘function-item’ if you know it is a symbol
     with a function binding.  This is done by using a customization
     type specification instead of a symbol for the key.

          :options '("foo"
                     ((function-item some-function) integer)
                     "baz")

     Many alists use lists with two elements, instead of cons cells.
     For example,

          (defcustom list-alist
            '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE).")

     instead of

          (defcustom cons-alist
            '(("foo" . 1) ("bar" . 2) ("baz" . 3))
            "Each element is a cons-cell (KEY . VALUE).")

     Because of the way lists are implemented on top of cons cells, you
     can treat ‘list-alist’ in the example above as a cons cell alist,
     where the value type is a list with a single element containing the
     real value.

          (defcustom list-alist '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE)."
            :type '(alist :value-type (group integer)))

     The ‘group’ widget is used here instead of ‘list’ only because the
     formatting is better suited for the purpose.

     Similarly, you can have alists with more values associated with
     each key, using variations of this trick:

          (defcustom person-data '(("brian"  50 t)
                                   ("dorith" 55 nil)
                                   ("ken"    52 t))
            "Alist of basic info about people.
          Each element has the form (NAME AGE MALE-FLAG)."
            :type '(alist :value-type (group integer boolean)))

‘(plist :key-type KEY-TYPE :value-type VALUE-TYPE)’
     This customization type is similar to ‘alist’ (see above), except
     that (i) the information is stored as a property list, (*note
     Property Lists::), and (ii) KEY-TYPE, if omitted, defaults to
     ‘symbol’ rather than ‘sexp’.

‘(choice ALTERNATIVE-TYPES...)’
     The value must fit one of ALTERNATIVE-TYPES.  For example, ‘(choice
     integer string)’ allows either an integer or a string.

     In the customization buffer, the user selects an alternative using
     a menu, and can then edit the value in the usual way for that
     alternative.

     Normally the strings in this menu are determined automatically from
     the choices; however, you can specify different strings for the
     menu by including the ‘:tag’ keyword in the alternatives.  For
     example, if an integer stands for a number of spaces, while a
     string is text to use verbatim, you might write the customization
     type this way,

          (choice (integer :tag "Number of spaces")
                  (string :tag "Literal text"))

     so that the menu offers ‘Number of spaces’ and ‘Literal text’.

     In any alternative for which ‘nil’ is not a valid value, other than
     a ‘const’, you should specify a valid default for that alternative
     using the ‘:value’ keyword.  *Note Type Keywords::.

     If some values are covered by more than one of the alternatives,
     customize will choose the first alternative that the value fits.
     This means you should always list the most specific types first,
     and the most general last.  Here’s an example of proper usage:

          (choice (const :tag "Off" nil)
                  symbol (sexp :tag "Other"))

     This way, the special value ‘nil’ is not treated like other
     symbols, and symbols are not treated like other Lisp expressions.

‘(radio ELEMENT-TYPES...)’
     This is similar to ‘choice’, except that the choices are displayed
     using radio buttons rather than a menu.  This has the advantage of
     displaying documentation for the choices when applicable and so is
     often a good choice for a choice between constant functions
     (‘function-item’ customization types).

‘(const VALUE)’
     The value must be VALUE—nothing else is allowed.

     The main use of ‘const’ is inside of ‘choice’.  For example,
     ‘(choice integer (const nil))’ allows either an integer or ‘nil’.

     ‘:tag’ is often used with ‘const’, inside of ‘choice’.  For
     example,

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (const :tag "Ask" foo))

     describes a variable for which ‘t’ means yes, ‘nil’ means no, and
     ‘foo’ means “ask”.

‘(other VALUE)’
     This alternative can match any Lisp value, but if the user chooses
     this alternative, that selects the value VALUE.

     The main use of ‘other’ is as the last element of ‘choice’.  For
     example,

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (other :tag "Ask" foo))

     describes a variable for which ‘t’ means yes, ‘nil’ means no, and
     anything else means “ask”.  If the user chooses ‘Ask’ from the menu
     of alternatives, that specifies the value ‘foo’; but any other
     value (not ‘t’, ‘nil’ or ‘foo’) displays as ‘Ask’, just like ‘foo’.

‘(function-item FUNCTION)’
     Like ‘const’, but used for values which are functions.  This
     displays the documentation string as well as the function name.
     The documentation string is either the one you specify with ‘:doc’,
     or FUNCTION’s own documentation string.

‘(variable-item VARIABLE)’
     Like ‘const’, but used for values which are variable names.  This
     displays the documentation string as well as the variable name.
     The documentation string is either the one you specify with ‘:doc’,
     or VARIABLE’s own documentation string.

‘(set TYPES...)’
     The value must be a list, and each element of the list must match
     one of the TYPES specified.

     This appears in the customization buffer as a checklist, so that
     each of TYPES may have either one corresponding element or none.
     It is not possible to specify two different elements that match the
     same one of TYPES.  For example, ‘(set integer symbol)’ allows one
     integer and/or one symbol in the list; it does not allow multiple
     integers or multiple symbols.  As a result, it is rare to use
     nonspecific types such as ‘integer’ in a ‘set’.

     Most often, the TYPES in a ‘set’ are ‘const’ types, as shown here:

          (set (const :bold) (const :italic))

     Sometimes they describe possible elements in an alist:

          (set (cons :tag "Height" (const height) integer)
               (cons :tag "Width" (const width) integer))

     That lets the user specify a height value optionally and a width
     value optionally.

‘(repeat ELEMENT-TYPE)’
     The value must be a list and each element of the list must fit the
     type ELEMENT-TYPE.  This appears in the customization buffer as a
     list of elements, with ‘[INS]’ and ‘[DEL]’ buttons for adding more
     elements or removing elements.

‘(restricted-sexp :match-alternatives CRITERIA)’
     This is the most general composite type construct.  The value may
     be any Lisp object that satisfies one of CRITERIA.  CRITERIA should
     be a list, and each element should be one of these possibilities:

        • A predicate—that is, a function of one argument that has no
          side effects, and returns either ‘nil’ or non-‘nil’ according
          to the argument.  Using a predicate in the list says that
          objects for which the predicate returns non-‘nil’ are
          acceptable.

        • A quoted constant—that is, ‘'OBJECT’.  This sort of element in
          the list says that OBJECT itself is an acceptable value.

     For example,

          (restricted-sexp :match-alternatives
                           (integerp 't 'nil))

     allows integers, ‘t’ and ‘nil’ as legitimate values.

     The customization buffer shows all legitimate values using their
     read syntax, and the user edits them textually.

   Here is a table of the keywords you can use in keyword-value pairs in
a composite type:

‘:tag TAG’
     Use TAG as the name of this alternative, for user communication
     purposes.  This is useful for a type that appears inside of a
     ‘choice’.

‘:match-alternatives CRITERIA’
     Use CRITERIA to match possible values.  This is used only in
     ‘restricted-sexp’.

‘:args ARGUMENT-LIST’
     Use the elements of ARGUMENT-LIST as the arguments of the type
     construct.  For instance, ‘(const :args (foo))’ is equivalent to
     ‘(const foo)’.  You rarely need to write ‘:args’ explicitly,
     because normally the arguments are recognized automatically as
     whatever follows the last keyword-value pair.


File: elisp.info,  Node: Splicing into Lists,  Next: Type Keywords,  Prev: Composite Types,  Up: Customization Types

15.4.3 Splicing into Lists
--------------------------

The ‘:inline’ feature lets you splice a variable number of elements into
the middle of a ‘list’ or ‘vector’ customization type.  You use it by
adding ‘:inline t’ to a type specification which is contained in a
‘list’ or ‘vector’ specification.

   Normally, each entry in a ‘list’ or ‘vector’ type specification
describes a single element type.  But when an entry contains ‘:inline
t’, the value it matches is merged directly into the containing
sequence.  For example, if the entry matches a list with three elements,
those become three elements of the overall sequence.  This is analogous
to ‘,@’ in a backquote construct (*note Backquote::).

   For example, to specify a list whose first element must be ‘baz’ and
whose remaining arguments should be zero or more of ‘foo’ and ‘bar’, use
this customization type:

     (list (const baz) (set :inline t (const foo) (const bar)))

This matches values such as ‘(baz)’, ‘(baz foo)’, ‘(baz bar)’ and ‘(baz
foo bar)’.

   When the element-type is a ‘choice’, you use ‘:inline’ not in the
‘choice’ itself, but in (some of) the alternatives of the ‘choice’.  For
example, to match a list which must start with a file name, followed
either by the symbol ‘t’ or two strings, use this customization type:

     (list file
           (choice (const t)
                   (list :inline t string string)))

If the user chooses the first alternative in the choice, then the
overall list has two elements and the second element is ‘t’.  If the
user chooses the second alternative, then the overall list has three
elements and the second and third must be strings.


File: elisp.info,  Node: Type Keywords,  Next: Defining New Types,  Prev: Splicing into Lists,  Up: Customization Types

15.4.4 Type Keywords
--------------------

You can specify keyword-argument pairs in a customization type after the
type name symbol.  Here are the keywords you can use, and their
meanings:

‘:value DEFAULT’
     Provide a default value.

     If ‘nil’ is not a valid value for the alternative, then it is
     essential to specify a valid default with ‘:value’.

     If you use this for a type that appears as an alternative inside of
     ‘choice’; it specifies the default value to use, at first, if and
     when the user selects this alternative with the menu in the
     customization buffer.

     Of course, if the actual value of the option fits this alternative,
     it will appear showing the actual value, not DEFAULT.

‘:format FORMAT-STRING’
     This string will be inserted in the buffer to represent the value
     corresponding to the type.  The following ‘%’ escapes are available
     for use in FORMAT-STRING:

     ‘%[BUTTON%]’
          Display the text BUTTON marked as a button.  The ‘:action’
          attribute specifies what the button will do if the user
          invokes it; its value is a function which takes two
          arguments—the widget which the button appears in, and the
          event.

          There is no way to specify two different buttons with
          different actions.

     ‘%{SAMPLE%}’
          Show SAMPLE in a special face specified by ‘:sample-face’.

     ‘%v’
          Substitute the item’s value.  How the value is represented
          depends on the kind of item, and (for variables) on the
          customization type.

     ‘%d’
          Substitute the item’s documentation string.

     ‘%h’
          Like ‘%d’, but if the documentation string is more than one
          line, add a button to control whether to show all of it or
          just the first line.

     ‘%t’
          Substitute the tag here.  You specify the tag with the ‘:tag’
          keyword.

     ‘%%’
          Display a literal ‘%’.

‘:action ACTION’
     Perform ACTION if the user clicks on a button.

‘:button-face FACE’
     Use the face FACE (a face name or a list of face names) for button
     text displayed with ‘%[...%]’.

‘:button-prefix PREFIX’
‘:button-suffix SUFFIX’
     These specify the text to display before and after a button.  Each
     can be:

     ‘nil’
          No text is inserted.

     a string
          The string is inserted literally.

     a symbol
          The symbol’s value is used.

‘:tag TAG’
     Use TAG (a string) as the tag for the value (or part of the value)
     that corresponds to this type.

‘:doc DOC’
     Use DOC as the documentation string for this value (or part of the
     value) that corresponds to this type.  In order for this to work,
     you must specify a value for ‘:format’, and use ‘%d’ or ‘%h’ in
     that value.

     The usual reason to specify a documentation string for a type is to
     provide more information about the meanings of alternatives inside
     a ‘:choice’ type or the parts of some other composite type.

‘:help-echo MOTION-DOC’
     When you move to this item with ‘widget-forward’ or
     ‘widget-backward’, it will display the string MOTION-DOC in the
     echo area.  In addition, MOTION-DOC is used as the mouse
     ‘help-echo’ string and may actually be a function or form evaluated
     to yield a help string.  If it is a function, it is called with one
     argument, the widget.

‘:match FUNCTION’
     Specify how to decide whether a value matches the type.  The
     corresponding value, FUNCTION, should be a function that accepts
     two arguments, a widget and a value; it should return non-‘nil’ if
     the value is acceptable.

‘:validate FUNCTION’
     Specify a validation function for input.  FUNCTION takes a widget
     as an argument, and should return ‘nil’ if the widget’s current
     value is valid for the widget.  Otherwise, it should return the
     widget containing the invalid data, and set that widget’s ‘:error’
     property to a string explaining the error.


File: elisp.info,  Node: Defining New Types,  Prev: Type Keywords,  Up: Customization Types

15.4.5 Defining New Types
-------------------------

In the previous sections we have described how to construct elaborate
type specifications for ‘defcustom’.  In some cases you may want to give
such a type specification a name.  The obvious case is when you are
using the same type for many user options: rather than repeat the
specification for each option, you can give the type specification a
name, and use that name each ‘defcustom’.  The other case is when a user
option’s value is a recursive data structure.  To make it possible for a
datatype to refer to itself, it needs to have a name.

   Since custom types are implemented as widgets, the way to define a
new customize type is to define a new widget.  We are not going to
describe the widget interface here in details, see *note Introduction:
(widget)Top, for that.  Instead we are going to demonstrate the minimal
functionality needed for defining new customize types by a simple
example.

     (define-widget 'binary-tree-of-string 'lazy
       "A binary tree made of cons-cells and strings."
       :offset 4
       :tag "Node"
       :type '(choice (string :tag "Leaf" :value "")
                      (cons :tag "Interior"
                            :value ("" . "")
                            binary-tree-of-string
                            binary-tree-of-string)))

     (defcustom foo-bar ""
       "Sample variable holding a binary tree of strings."
       :type 'binary-tree-of-string)

   The function to define a new widget is called ‘define-widget’.  The
first argument is the symbol we want to make a new widget type.  The
second argument is a symbol representing an existing widget, the new
widget is going to be defined in terms of difference from the existing
widget.  For the purpose of defining new customization types, the ‘lazy’
widget is perfect, because it accepts a ‘:type’ keyword argument with
the same syntax as the keyword argument to ‘defcustom’ with the same
name.  The third argument is a documentation string for the new widget.
You will be able to see that string with the ‘M-x widget-browse <RET>
binary-tree-of-string <RET>’ command.

   After these mandatory arguments follow the keyword arguments.  The
most important is ‘:type’, which describes the data type we want to
match with this widget.  Here a ‘binary-tree-of-string’ is described as
being either a string, or a cons-cell whose car and cdr are themselves
both ‘binary-tree-of-string’.  Note the reference to the widget type we
are currently in the process of defining.  The ‘:tag’ attribute is a
string to name the widget in the user interface, and the ‘:offset’
argument is there to ensure that child nodes are indented four spaces
relative to the parent node, making the tree structure apparent in the
customization buffer.

   The ‘defcustom’ shows how the new widget can be used as an ordinary
customization type.

   The reason for the name ‘lazy’ is that the other composite widgets
convert their inferior widgets to internal form when the widget is
instantiated in a buffer.  This conversion is recursive, so the inferior
widgets will convert _their_ inferior widgets.  If the data structure is
itself recursive, this conversion is an infinite recursion.  The ‘lazy’
widget prevents the recursion: it convert its ‘:type’ argument only when
needed.


File: elisp.info,  Node: Applying Customizations,  Next: Custom Themes,  Prev: Customization Types,  Up: Customization

15.5 Applying Customizations
============================

The following functions are responsible for installing the user’s
customization settings for variables and faces, respectively.  When the
user invokes ‘Save for future sessions’ in the Customize interface, that
takes effect by writing a ‘custom-set-variables’ and/or a
‘custom-set-faces’ form into the custom file, to be evaluated the next
time Emacs starts.

 -- Function: custom-set-variables &rest args
     This function installs the variable customizations specified by
     ARGS.  Each argument in ARGS should have the form

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     VAR is a variable name (a symbol), and EXPRESSION is an expression
     which evaluates to the desired customized value.

     If the ‘defcustom’ form for VAR has been evaluated prior to this
     ‘custom-set-variables’ call, EXPRESSION is immediately evaluated,
     and the variable’s value is set to the result.  Otherwise,
     EXPRESSION is stored into the variable’s ‘saved-value’ property, to
     be evaluated when the relevant ‘defcustom’ is called (usually when
     the library defining that variable is loaded into Emacs).

     The NOW, REQUEST, and COMMENT entries are for internal use only,
     and may be omitted.  NOW, if non-‘nil’, means to set the variable’s
     value now, even if the variable’s ‘defcustom’ form has not been
     evaluated.  REQUEST is a list of features to be loaded immediately
     (*note Named Features::).  COMMENT is a string describing the
     customization.

 -- Function: custom-set-faces &rest args
     This function installs the face customizations specified by ARGS.
     Each argument in ARGS should have the form

          (FACE SPEC [NOW [COMMENT]])

     FACE is a face name (a symbol), and SPEC is the customized face
     specification for that face (*note Defining Faces::).

     The NOW and COMMENT entries are for internal use only, and may be
     omitted.  NOW, if non-‘nil’, means to install the face
     specification now, even if the ‘defface’ form has not been
     evaluated.  COMMENT is a string describing the customization.


File: elisp.info,  Node: Custom Themes,  Prev: Applying Customizations,  Up: Customization

15.6 Custom Themes
==================

“Custom themes” are collections of settings that can be enabled or
disabled as a unit.  *Note (emacs)Custom Themes::.  Each Custom theme is
defined by an Emacs Lisp source file, which should follow the
conventions described in this section.  (Instead of writing a Custom
theme by hand, you can also create one using a Customize-like interface;
*note (emacs)Creating Custom Themes::.)

   A Custom theme file should be named ‘FOO-theme.el’, where FOO is the
theme name.  The first Lisp form in the file should be a call to
‘deftheme’, and the last form should be a call to ‘provide-theme’.

 -- Macro: deftheme theme &optional doc
     This macro declares THEME (a symbol) as the name of a Custom theme.
     The optional argument DOC should be a string describing the theme;
     this is the description shown when the user invokes the
     ‘describe-theme’ command or types ‘?’ in the ‘*Custom Themes*’
     buffer.

     Two special theme names are disallowed (using them causes an
     error): ‘user’ is a dummy theme that stores the user’s direct
     customization settings, and ‘changed’ is a dummy theme that stores
     changes made outside of the Customize system.

 -- Macro: provide-theme theme
     This macro declares that the theme named THEME has been fully
     specified.

   In between ‘deftheme’ and ‘provide-theme’ are Lisp forms specifying
the theme settings: usually a call to ‘custom-theme-set-variables’
and/or a call to ‘custom-theme-set-faces’.

 -- Function: custom-theme-set-variables theme &rest args
     This function specifies the Custom theme THEME’s variable settings.
     THEME should be a symbol.  Each argument in ARGS should be a list
     of the form

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     where the list entries have the same meanings as in
     ‘custom-set-variables’.  *Note Applying Customizations::.

 -- Function: custom-theme-set-faces theme &rest args
     This function specifies the Custom theme THEME’s face settings.
     THEME should be a symbol.  Each argument in ARGS should be a list
     of the form

          (FACE SPEC [NOW [COMMENT]])

     where the list entries have the same meanings as in
     ‘custom-set-faces’.  *Note Applying Customizations::.

   In theory, a theme file can also contain other Lisp forms, which
would be evaluated when loading the theme, but that is bad form.  To
protect against loading themes containing malicious code, Emacs displays
the source file and asks for confirmation from the user before loading
any non-built-in theme for the first time.  As such, themes are not
ordinarily byte-compiled, and source files always take precedence when
Emacs is looking for a theme to load.

   The following functions are useful for programmatically enabling and
disabling themes:

 -- Function: custom-theme-p theme
     This function return a non-‘nil’ value if THEME (a symbol) is the
     name of a Custom theme (i.e., a Custom theme which has been loaded
     into Emacs, whether or not the theme is enabled).  Otherwise, it
     returns ‘nil’.

 -- Variable: custom-known-themes
     The value of this variable is a list of themes loaded into Emacs.
     Each theme is represented by a Lisp symbol (the theme name).  The
     default value of this variable is a list containing two dummy
     themes: ‘(user changed)’.  The ‘changed’ theme stores settings made
     before any Custom themes are applied (e.g., variables set outside
     of Customize).  The ‘user’ theme stores settings the user has
     customized and saved.  Any additional themes declared with the
     ‘deftheme’ macro are added to the front of this list.

 -- Command: load-theme theme &optional no-confirm no-enable
     This function loads the Custom theme named THEME from its source
     file, looking for the source file in the directories specified by
     the variable ‘custom-theme-load-path’.  *Note (emacs)Custom
     Themes::.  It also “enables” the theme (unless the optional
     argument NO-ENABLE is non-‘nil’), causing its variable and face
     settings to take effect.  It prompts the user for confirmation
     before loading the theme, unless the optional argument NO-CONFIRM
     is non-‘nil’.

 -- Command: enable-theme theme
     This function enables the Custom theme named THEME.  It signals an
     error if no such theme has been loaded.

 -- Command: disable-theme theme
     This function disables the Custom theme named THEME.  The theme
     remains loaded, so that a subsequent call to ‘enable-theme’ will
     re-enable it.


File: elisp.info,  Node: Loading,  Next: Byte Compilation,  Prev: Customization,  Up: Top

16 Loading
**********

Loading a file of Lisp code means bringing its contents into the Lisp
environment in the form of Lisp objects.  Emacs finds and opens the
file, reads the text, evaluates each form, and then closes the file.
Such a file is also called a “Lisp library”.

   The load functions evaluate all the expressions in a file just as the
‘eval-buffer’ function evaluates all the expressions in a buffer.  The
difference is that the load functions read and evaluate the text in the
file as found on disk, not the text in an Emacs buffer.

   The loaded file must contain Lisp expressions, either as source code
or as byte-compiled code.  Each form in the file is called a “top-level
form”.  There is no special format for the forms in a loadable file; any
form in a file may equally well be typed directly into a buffer and
evaluated there.  (Indeed, most code is tested this way.)  Most often,
the forms are function definitions and variable definitions.

   Emacs can also load compiled dynamic modules: shared libraries that
provide additional functionality for use in Emacs Lisp programs, just
like a package written in Emacs Lisp would.  When a dynamic module is
loaded, Emacs calls a specially-named initialization function which the
module needs to implement, and which exposes the additional functions
and variables to Emacs Lisp programs.

   For on-demand loading of external libraries which are known in
advance to be required by certain Emacs primitives, *note Dynamic
Libraries::.

* Menu:

* How Programs Do Loading:: The ‘load’ function and others.
* Load Suffixes::           Details about the suffixes that ‘load’ tries.
* Library Search::          Finding a library to load.
* Loading Non-ASCII::       Non-ASCII characters in Emacs Lisp files.
* Autoload::                Setting up a function to autoload.
* Repeated Loading::        Precautions about loading a file twice.
* Named Features::          Loading a library if it isn’t already loaded.
* Where Defined::           Finding which file defined a certain symbol.
* Unloading::               How to unload a library that was loaded.
* Hooks for Loading::       Providing code to be run when
                              particular libraries are loaded.
* Dynamic Modules::         Modules provide additional Lisp primitives.


File: elisp.info,  Node: How Programs Do Loading,  Next: Load Suffixes,  Up: Loading

16.1 How Programs Do Loading
============================

Emacs Lisp has several interfaces for loading.  For example, ‘autoload’
creates a placeholder object for a function defined in a file; trying to
call the autoloading function loads the file to get the function’s real
definition (*note Autoload::).  ‘require’ loads a file if it isn’t
already loaded (*note Named Features::).  Ultimately, all these
facilities call the ‘load’ function to do the work.

 -- Function: load filename &optional missing-ok nomessage nosuffix
          must-suffix
     This function finds and opens a file of Lisp code, evaluates all
     the forms in it, and closes the file.

     To find the file, ‘load’ first looks for a file named
     ‘FILENAME.elc’, that is, for a file whose name is FILENAME with the
     extension ‘.elc’ appended.  If such a file exists, it is loaded.
     If there is no file by that name, then ‘load’ looks for a file
     named ‘FILENAME.el’.  If that file exists, it is loaded.  If Emacs
     was compiled with support for dynamic modules (*note Dynamic
     Modules::), ‘load’ next looks for a file named ‘FILENAME.EXT’,
     where EXT is a system-dependent file-name extension of shared
     libraries.  Finally, if neither of those names is found, ‘load’
     looks for a file named FILENAME with nothing appended, and loads it
     if it exists.  (The ‘load’ function is not clever about looking at
     FILENAME.  In the perverse case of a file named ‘foo.el.el’,
     evaluation of ‘(load "foo.el")’ will indeed find it.)

     If Auto Compression mode is enabled, as it is by default, then if
     ‘load’ can not find a file, it searches for a compressed version of
     the file before trying other file names.  It decompresses and loads
     it if it exists.  It looks for compressed versions by appending
     each of the suffixes in ‘jka-compr-load-suffixes’ to the file name.
     The value of this variable must be a list of strings.  Its standard
     value is ‘(".gz")’.

     If the optional argument NOSUFFIX is non-‘nil’, then ‘load’ does
     not try the suffixes ‘.elc’ and ‘.el’.  In this case, you must
     specify the precise file name you want, except that, if Auto
     Compression mode is enabled, ‘load’ will still use
     ‘jka-compr-load-suffixes’ to find compressed versions.  By
     specifying the precise file name and using ‘t’ for NOSUFFIX, you
     can prevent file names like ‘foo.el.el’ from being tried.

     If the optional argument MUST-SUFFIX is non-‘nil’, then ‘load’
     insists that the file name used must end in either ‘.el’ or ‘.elc’
     (possibly extended with a compression suffix) or the shared-library
     extension, unless it contains an explicit directory name.

     If the option ‘load-prefer-newer’ is non-‘nil’, then when searching
     suffixes, ‘load’ selects whichever version of a file (‘.elc’,
     ‘.el’, etc.) has been modified most recently.

     If FILENAME is a relative file name, such as ‘foo’ or
     ‘baz/foo.bar’, ‘load’ searches for the file using the variable
     ‘load-path’.  It appends FILENAME to each of the directories listed
     in ‘load-path’, and loads the first file it finds whose name
     matches.  The current default directory is tried only if it is
     specified in ‘load-path’, where ‘nil’ stands for the default
     directory.  ‘load’ tries all three possible suffixes in the first
     directory in ‘load-path’, then all three suffixes in the second
     directory, and so on.  *Note Library Search::.

     Whatever the name under which the file is eventually found, and the
     directory where Emacs found it, Emacs sets the value of the
     variable ‘load-file-name’ to that file’s name.

     If you get a warning that ‘foo.elc’ is older than ‘foo.el’, it
     means you should consider recompiling ‘foo.el’.  *Note Byte
     Compilation::.

     When loading a source file (not compiled), ‘load’ performs
     character set translation just as Emacs would do when visiting the
     file.  *Note Coding Systems::.

     When loading an uncompiled file, Emacs tries to expand any macros
     that the file contains (*note Macros::).  We refer to this as
     “eager macro expansion”.  Doing this (rather than deferring the
     expansion until the relevant code runs) can significantly speed up
     the execution of uncompiled code.  Sometimes, this macro expansion
     cannot be done, owing to a cyclic dependency.  In the simplest
     example of this, the file you are loading refers to a macro defined
     in another file, and that file in turn requires the file you are
     loading.  This is generally harmless.  Emacs prints a warning
     (‘Eager macro-expansion skipped due to cycle...’) giving details of
     the problem, but it still loads the file, just leaving the macro
     unexpanded for now.  You may wish to restructure your code so that
     this does not happen.  Loading a compiled file does not cause
     macroexpansion, because this should already have happened during
     compilation.  *Note Compiling Macros::.

     Messages like ‘Loading foo...’ and ‘Loading foo...done’ appear in
     the echo area during loading unless NOMESSAGE is non-‘nil’.

     Any unhandled errors while loading a file terminate loading.  If
     the load was done for the sake of ‘autoload’, any function
     definitions made during the loading are undone.

     If ‘load’ can’t find the file to load, then normally it signals a
     ‘file-error’ (with ‘Cannot open load file FILENAME’).  But if
     MISSING-OK is non-‘nil’, then ‘load’ just returns ‘nil’.

     You can use the variable ‘load-read-function’ to specify a function
     for ‘load’ to use instead of ‘read’ for reading expressions.  See
     below.

     ‘load’ returns ‘t’ if the file loads successfully.

 -- Command: load-file filename
     This command loads the file FILENAME.  If FILENAME is a relative
     file name, then the current default directory is assumed.  This
     command does not use ‘load-path’, and does not append suffixes.
     However, it does look for compressed versions (if Auto Compression
     Mode is enabled).  Use this command if you wish to specify
     precisely the file name to load.

 -- Command: load-library library
     This command loads the library named LIBRARY.  It is equivalent to
     ‘load’, except for the way it reads its argument interactively.
     *Note (emacs)Lisp Libraries::.

 -- Variable: load-in-progress
     This variable is non-‘nil’ if Emacs is in the process of loading a
     file, and it is ‘nil’ otherwise.

 -- Variable: load-file-name
     When Emacs is in the process of loading a file, this variable’s
     value is the name of that file, as Emacs found it during the search
     described earlier in this section.

 -- Variable: load-read-function
     This variable specifies an alternate expression-reading function
     for ‘load’ and ‘eval-region’ to use instead of ‘read’.  The
     function should accept one argument, just as ‘read’ does.

     By default, this variable’s value is ‘read’.  *Note Input
     Functions::.

     Instead of using this variable, it is cleaner to use another, newer
     feature: to pass the function as the READ-FUNCTION argument to
     ‘eval-region’.  *Note Eval: Definition of eval-region.

   For information about how ‘load’ is used in building Emacs, see *note
Building Emacs::.


File: elisp.info,  Node: Load Suffixes,  Next: Library Search,  Prev: How Programs Do Loading,  Up: Loading

16.2 Load Suffixes
==================

We now describe some technical details about the exact suffixes that
‘load’ tries.

 -- Variable: load-suffixes
     This is a list of suffixes indicating (compiled or source) Emacs
     Lisp files.  It should not include the empty string.  ‘load’ uses
     these suffixes in order when it appends Lisp suffixes to the
     specified file name.  The standard value is ‘(".elc" ".el")’ which
     produces the behavior described in the previous section.

 -- Variable: load-file-rep-suffixes
     This is a list of suffixes that indicate representations of the
     same file.  This list should normally start with the empty string.
     When ‘load’ searches for a file it appends the suffixes in this
     list, in order, to the file name, before searching for another
     file.

     Enabling Auto Compression mode appends the suffixes in
     ‘jka-compr-load-suffixes’ to this list and disabling Auto
     Compression mode removes them again.  The standard value of
     ‘load-file-rep-suffixes’ if Auto Compression mode is disabled is
     ‘("")’.  Given that the standard value of ‘jka-compr-load-suffixes’
     is ‘(".gz")’, the standard value of ‘load-file-rep-suffixes’ if
     Auto Compression mode is enabled is ‘("" ".gz")’.

 -- Function: get-load-suffixes
     This function returns the list of all suffixes that ‘load’ should
     try, in order, when its MUST-SUFFIX argument is non-‘nil’.  This
     takes both ‘load-suffixes’ and ‘load-file-rep-suffixes’ into
     account.  If ‘load-suffixes’, ‘jka-compr-load-suffixes’ and
     ‘load-file-rep-suffixes’ all have their standard values, this
     function returns ‘(".elc" ".elc.gz" ".el" ".el.gz")’ if Auto
     Compression mode is enabled and ‘(".elc" ".el")’ if Auto
     Compression mode is disabled.

   To summarize, ‘load’ normally first tries the suffixes in the value
of ‘(get-load-suffixes)’ and then those in ‘load-file-rep-suffixes’.  If
NOSUFFIX is non-‘nil’, it skips the former group, and if MUST-SUFFIX is
non-‘nil’, it skips the latter group.

 -- User Option: load-prefer-newer
     If this option is non-‘nil’, then rather than stopping at the first
     suffix that exists, ‘load’ tests them all, and uses whichever file
     is the newest.


File: elisp.info,  Node: Library Search,  Next: Loading Non-ASCII,  Prev: Load Suffixes,  Up: Loading

16.3 Library Search
===================

When Emacs loads a Lisp library, it searches for the library in a list
of directories specified by the variable ‘load-path’.

 -- Variable: load-path
     The value of this variable is a list of directories to search when
     loading files with ‘load’.  Each element is a string (which must be
     a directory) or ‘nil’ (which stands for the current working
     directory).

   When Emacs starts up, it sets up the value of ‘load-path’ in several
steps.  First, it initializes ‘load-path’ using default locations set
when Emacs was compiled.  Normally, this is a directory something like

     "/usr/local/share/emacs/VERSION/lisp"

   (In this and the following examples, replace ‘/usr/local’ with the
installation prefix appropriate for your Emacs.)  These directories
contain the standard Lisp files that come with Emacs.  If Emacs cannot
find them, it will not start correctly.

   If you run Emacs from the directory where it was built—that is, an
executable that has not been formally installed—Emacs instead
initializes ‘load-path’ using the ‘lisp’ directory in the directory
containing the sources from which it was built.  If you built Emacs in a
separate directory from the sources, it also adds the lisp directories
from the build directory.  (In all cases, elements are represented as
absolute file names.)

   Unless you start Emacs with the ‘--no-site-lisp’ option, it then adds
two more ‘site-lisp’ directories to the front of ‘load-path’.  These are
intended for locally installed Lisp files, and are normally of the form:

     "/usr/local/share/emacs/VERSION/site-lisp"

and

     "/usr/local/share/emacs/site-lisp"

The first one is for locally installed files for a specific Emacs
version; the second is for locally installed files meant for use with
all installed Emacs versions.  (If Emacs is running uninstalled, it also
adds ‘site-lisp’ directories from the source and build directories, if
they exist.  Normally these directories do not contain ‘site-lisp’
directories.)

   If the environment variable ‘EMACSLOADPATH’ is set, it modifies the
above initialization procedure.  Emacs initializes ‘load-path’ based on
the value of the environment variable.

   The syntax of ‘EMACSLOADPATH’ is the same as used for ‘PATH’;
directories are separated by ‘:’ (or ‘;’, on some operating systems).
Here is an example of how to set ‘EMACSLOADPATH’ variable (from a
‘sh’-style shell):

     export EMACSLOADPATH=/home/foo/.emacs.d/lisp:

   An empty element in the value of the environment variable, whether
trailing (as in the above example), leading, or embedded, is replaced by
the default value of ‘load-path’ as determined by the standard
initialization procedure.  If there are no such empty elements, then
‘EMACSLOADPATH’ specifies the entire ‘load-path’.  You must include
either an empty element, or the explicit path to the directory
containing the standard Lisp files, else Emacs will not function.
(Another way to modify ‘load-path’ is to use the ‘-L’ command-line
option when starting Emacs; see below.)

   For each directory in ‘load-path’, Emacs then checks to see if it
contains a file ‘subdirs.el’, and if so, loads it.  The ‘subdirs.el’
file is created when Emacs is built/installed, and contains code that
causes Emacs to add any subdirectories of those directories to
‘load-path’.  Both immediate subdirectories and subdirectories multiple
levels down are added.  But it excludes subdirectories whose names do
not start with a letter or digit, and subdirectories named ‘RCS’ or
‘CVS’, and subdirectories containing a file named ‘.nosearch’.

   Next, Emacs adds any extra load directories that you specify using
the ‘-L’ command-line option (*note (emacs)Action Arguments::).  It also
adds the directories where optional packages are installed, if any
(*note Packaging Basics::).

   It is common to add code to one’s init file (*note Init File::) to
add one or more directories to ‘load-path’.  For example:

     (push "~/.emacs.d/lisp" load-path)

   Dumping Emacs uses a special value of ‘load-path’.  If you use a
‘site-load.el’ or ‘site-init.el’ file to customize the dumped Emacs
(*note Building Emacs::), any changes to ‘load-path’ that these files
make will be lost after dumping.

 -- Command: locate-library library &optional nosuffix path
          interactive-call
     This command finds the precise file name for library LIBRARY.  It
     searches for the library in the same way ‘load’ does, and the
     argument NOSUFFIX has the same meaning as in ‘load’: don’t add
     suffixes ‘.elc’ or ‘.el’ to the specified name LIBRARY.

     If the PATH is non-‘nil’, that list of directories is used instead
     of ‘load-path’.

     When ‘locate-library’ is called from a program, it returns the file
     name as a string.  When the user runs ‘locate-library’
     interactively, the argument INTERACTIVE-CALL is ‘t’, and this tells
     ‘locate-library’ to display the file name in the echo area.

 -- Command: list-load-path-shadows &optional stringp
     This command shows a list of “shadowed” Emacs Lisp files.  A
     shadowed file is one that will not normally be loaded, despite
     being in a directory on ‘load-path’, due to the existence of
     another similarly-named file in a directory earlier on ‘load-path’.

     For instance, suppose ‘load-path’ is set to

            ("/opt/emacs/site-lisp" "/usr/share/emacs/23.3/lisp")

     and that both these directories contain a file named ‘foo.el’.
     Then ‘(require 'foo)’ never loads the file in the second directory.
     Such a situation might indicate a problem in the way Emacs was
     installed.

     When called from Lisp, this function prints a message listing the
     shadowed files, instead of displaying them in a buffer.  If the
     optional argument ‘stringp’ is non-‘nil’, it instead returns the
     shadowed files as a string.


File: elisp.info,  Node: Loading Non-ASCII,  Next: Autoload,  Prev: Library Search,  Up: Loading

16.4 Loading Non-ASCII Characters
=================================

When Emacs Lisp programs contain string constants with non-ASCII
characters, these can be represented within Emacs either as unibyte
strings or as multibyte strings (*note Text Representations::).  Which
representation is used depends on how the file is read into Emacs.  If
it is read with decoding into multibyte representation, the text of the
Lisp program will be multibyte text, and its string constants will be
multibyte strings.  If a file containing Latin-1 characters (for
example) is read without decoding, the text of the program will be
unibyte text, and its string constants will be unibyte strings.  *Note
Coding Systems::.

   In most Emacs Lisp programs, the fact that non-ASCII strings are
multibyte strings should not be noticeable, since inserting them in
unibyte buffers converts them to unibyte automatically.  However, if
this does make a difference, you can force a particular Lisp file to be
interpreted as unibyte by writing ‘coding: raw-text’ in a local
variables section.  With that designator, the file will unconditionally
be interpreted as unibyte.  This can matter when making keybindings to
non-ASCII characters written as ‘?vLITERAL’.


File: elisp.info,  Node: Autoload,  Next: Repeated Loading,  Prev: Loading Non-ASCII,  Up: Loading

16.5 Autoload
=============

The “autoload” facility lets you register the existence of a function or
macro, but put off loading the file that defines it.  The first call to
the function automatically loads the proper library, in order to install
the real definition and other associated code, then runs the real
definition as if it had been loaded all along.  Autoloading can also be
triggered by looking up the documentation of the function or macro
(*note Documentation Basics::).

* Menu:

* When to Autoload::   When to Use Autoload.

   There are two ways to set up an autoloaded function: by calling
‘autoload’, and by writing a “magic” comment in the source before the
real definition.  ‘autoload’ is the low-level primitive for autoloading;
any Lisp program can call ‘autoload’ at any time.  Magic comments are
the most convenient way to make a function autoload, for packages
installed along with Emacs.  These comments do nothing on their own, but
they serve as a guide for the command ‘update-file-autoloads’, which
constructs calls to ‘autoload’ and arranges to execute them when Emacs
is built.

 -- Function: autoload function filename &optional docstring interactive
          type
     This function defines the function (or macro) named FUNCTION so as
     to load automatically from FILENAME.  The string FILENAME specifies
     the file to load to get the real definition of FUNCTION.

     If FILENAME does not contain either a directory name, or the suffix
     ‘.el’ or ‘.elc’, this function insists on adding one of these
     suffixes, and it will not load from a file whose name is just
     FILENAME with no added suffix.  (The variable ‘load-suffixes’
     specifies the exact required suffixes.)

     The argument DOCSTRING is the documentation string for the
     function.  Specifying the documentation string in the call to
     ‘autoload’ makes it possible to look at the documentation without
     loading the function’s real definition.  Normally, this should be
     identical to the documentation string in the function definition
     itself.  If it isn’t, the function definition’s documentation
     string takes effect when it is loaded.

     If INTERACTIVE is non-‘nil’, that says FUNCTION can be called
     interactively.  This lets completion in ‘M-x’ work without loading
     FUNCTION’s real definition.  The complete interactive specification
     is not given here; it’s not needed unless the user actually calls
     FUNCTION, and when that happens, it’s time to load the real
     definition.

     You can autoload macros and keymaps as well as ordinary functions.
     Specify TYPE as ‘macro’ if FUNCTION is really a macro.  Specify
     TYPE as ‘keymap’ if FUNCTION is really a keymap.  Various parts of
     Emacs need to know this information without loading the real
     definition.

     An autoloaded keymap loads automatically during key lookup when a
     prefix key’s binding is the symbol FUNCTION.  Autoloading does not
     occur for other kinds of access to the keymap.  In particular, it
     does not happen when a Lisp program gets the keymap from the value
     of a variable and calls ‘define-key’; not even if the variable name
     is the same symbol FUNCTION.

     If FUNCTION already has a non-void function definition that is not
     an autoload object, this function does nothing and returns ‘nil’.
     Otherwise, it constructs an autoload object (*note Autoload
     Type::), and stores it as the function definition for FUNCTION.
     The autoload object has this form:

          (autoload FILENAME DOCSTRING INTERACTIVE TYPE)

     For example,

          (symbol-function 'run-prolog)
               ⇒ (autoload "prolog" 169681 t nil)

     In this case, ‘"prolog"’ is the name of the file to load, 169681
     refers to the documentation string in the ‘emacs/etc/DOC’ file
     (*note Documentation Basics::), ‘t’ means the function is
     interactive, and ‘nil’ that it is not a macro or a keymap.

 -- Function: autoloadp object
     This function returns non-‘nil’ if OBJECT is an autoload object.
     For example, to check if ‘run-prolog’ is defined as an autoloaded
     function, evaluate

          (autoloadp (symbol-function 'run-prolog))

   The autoloaded file usually contains other definitions and may
require or provide one or more features.  If the file is not completely
loaded (due to an error in the evaluation of its contents), any function
definitions or ‘provide’ calls that occurred during the load are undone.
This is to ensure that the next attempt to call any function autoloading
from this file will try again to load the file.  If not for this, then
some of the functions in the file might be defined by the aborted load,
but fail to work properly for the lack of certain subroutines not loaded
successfully because they come later in the file.

   If the autoloaded file fails to define the desired Lisp function or
macro, then an error is signaled with data ‘"Autoloading failed to
define function FUNCTION-NAME"’.

   A magic autoload comment (often called an “autoload cookie”) consists
of ‘;;;###autoload’, on a line by itself, just before the real
definition of the function in its autoloadable source file.  The command
‘M-x update-file-autoloads’ writes a corresponding ‘autoload’ call into
‘loaddefs.el’.  (The string that serves as the autoload cookie and the
name of the file generated by ‘update-file-autoloads’ can be changed
from the above defaults, see below.)  Building Emacs loads ‘loaddefs.el’
and thus calls ‘autoload’.  ‘M-x update-directory-autoloads’ is even
more powerful; it updates autoloads for all files in the current
directory.

   The same magic comment can copy any kind of form into ‘loaddefs.el’.
The form following the magic comment is copied verbatim, _except_ if it
is one of the forms which the autoload facility handles specially (e.g.,
by conversion into an ‘autoload’ call).  The forms which are not copied
verbatim are the following:

Definitions for function or function-like objects:
     ‘defun’ and ‘defmacro’; also ‘cl-defun’ and ‘cl-defmacro’ (*note
     (cl)Argument Lists::), and ‘define-overloadable-function’ (see the
     commentary in ‘mode-local.el’).

Definitions for major or minor modes:
     ‘define-minor-mode’, ‘define-globalized-minor-mode’,
     ‘define-generic-mode’, ‘define-derived-mode’,
     ‘easy-mmode-define-minor-mode’, ‘easy-mmode-define-global-mode’,
     ‘define-compilation-mode’, and ‘define-global-minor-mode’.

Other definition types:
     ‘defcustom’, ‘defgroup’, ‘defclass’ (*note EIEIO: (eieio)Top.), and
     ‘define-skeleton’ (*note Autotyping: (autotype)Top.).

   You can also use a magic comment to execute a form at build time
_without_ executing it when the file itself is loaded.  To do this,
write the form _on the same line_ as the magic comment.  Since it is in
a comment, it does nothing when you load the source file; but ‘M-x
update-file-autoloads’ copies it to ‘loaddefs.el’, where it is executed
while building Emacs.

   The following example shows how ‘doctor’ is prepared for autoloading
with a magic comment:

     ;;;###autoload
     (defun doctor ()
       "Switch to *doctor* buffer and start giving psychotherapy."
       (interactive)
       (switch-to-buffer "*doctor*")
       (doctor-mode))

Here’s what that produces in ‘loaddefs.el’:

     (autoload (quote doctor) "doctor" "\
     Switch to *doctor* buffer and start giving psychotherapy.

     \(fn)" t nil)

The backslash and newline immediately following the double-quote are a
convention used only in the preloaded uncompiled Lisp files such as
‘loaddefs.el’; they tell ‘make-docfile’ to put the documentation string
in the ‘etc/DOC’ file.  *Note Building Emacs::.  See also the commentary
in ‘lib-src/make-docfile.c’.  ‘(fn)’ in the usage part of the
documentation string is replaced with the function’s name when the
various help functions (*note Help Functions::) display it.

   If you write a function definition with an unusual macro that is not
one of the known and recognized function definition methods, use of an
ordinary magic autoload comment would copy the whole definition into
‘loaddefs.el’.  That is not desirable.  You can put the desired
‘autoload’ call into ‘loaddefs.el’ instead by writing this:

     ;;;###autoload (autoload 'foo "myfile")
     (mydefunmacro foo
       ...)

   You can use a non-default string as the autoload cookie and have the
corresponding autoload calls written into a file whose name is different
from the default ‘loaddefs.el’.  Emacs provides two variables to control
this:

 -- Variable: generate-autoload-cookie
     The value of this variable should be a string whose syntax is a
     Lisp comment.  ‘M-x update-file-autoloads’ copies the Lisp form
     that follows the cookie into the autoload file it generates.  The
     default value of this variable is ‘";;;###autoload"’.

 -- Variable: generated-autoload-file
     The value of this variable names an Emacs Lisp file where the
     autoload calls should go.  The default value is ‘loaddefs.el’, but
     you can override that, e.g., in the local variables section of a
     ‘.el’ file (*note File Local Variables::).  The autoload file is
     assumed to contain a trailer starting with a formfeed character.

   The following function may be used to explicitly load the library
specified by an autoload object:

 -- Function: autoload-do-load autoload &optional name macro-only
     This function performs the loading specified by AUTOLOAD, which
     should be an autoload object.  The optional argument NAME, if
     non-‘nil’, should be a symbol whose function value is AUTOLOAD; in
     that case, the return value of this function is the symbol’s new
     function value.  If the value of the optional argument MACRO-ONLY
     is ‘macro’, this function avoids loading a function, only a macro.

