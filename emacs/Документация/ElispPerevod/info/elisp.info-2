This is elisp.info, produced by makeinfo version 6.1 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp.info,  Node: Lists,  Next: Sequences Arrays Vectors,  Prev: Strings and Characters,  Up: Top

5 Lists
*******

A “list” represents a sequence of zero or more elements (which may be
any Lisp objects).  The important difference between lists and vectors
is that two or more lists can share part of their structure; in
addition, you can insert or delete elements in a list without copying
the whole list.

* Menu:

* Cons Cells::          How lists are made out of cons cells.
* List-related Predicates::        Is this object a list?  Comparing two lists.
* List Elements::       Extracting the pieces of a list.
* Building Lists::      Creating list structure.
* List Variables::      Modifying lists stored in variables.
* Modifying Lists::     Storing new pieces into an existing list.
* Sets And Lists::      A list can represent a finite mathematical set.
* Association Lists::   A list can represent a finite relation or mapping.
* Property Lists::      A list of paired elements.


File: elisp.info,  Node: Cons Cells,  Next: List-related Predicates,  Up: Lists

5.1 Lists and Cons Cells
========================

Lists in Lisp are not a primitive data type; they are built up from
“cons cells” (*note Cons Cell Type::).  A cons cell is a data object
that represents an ordered pair.  That is, it has two slots, and each
slot “holds”, or “refers to”, some Lisp object.  One slot is known as
the CAR, and the other is known as the CDR.  (These names are
traditional; see *note Cons Cell Type::.)  CDR is pronounced “could-er”.

   We say that “the CAR of this cons cell is” whatever object its CAR
slot currently holds, and likewise for the CDR.

   A list is a series of cons cells chained together, so that each cell
refers to the next one.  There is one cons cell for each element of the
list.  By convention, the CARs of the cons cells hold the elements of
the list, and the CDRs are used to chain the list (this asymmetry
between CAR and CDR is entirely a matter of convention; at the level of
cons cells, the CAR and CDR slots have similar properties).  Hence, the
CDR slot of each cons cell in a list refers to the following cons cell.

   Also by convention, the CDR of the last cons cell in a list is ‘nil’.
We call such a ‘nil’-terminated structure a “true list”.  In Emacs Lisp,
the symbol ‘nil’ is both a symbol and a list with no elements.  For
convenience, the symbol ‘nil’ is considered to have ‘nil’ as its CDR
(and also as its CAR).

   Hence, the CDR of a true list is always a true list.  The CDR of a
nonempty true list is a true list containing all the elements except the
first.

   If the CDR of a list’s last cons cell is some value other than ‘nil’,
we call the structure a “dotted list”, since its printed representation
would use dotted pair notation (*note Dotted Pair Notation::).  There is
one other possibility: some cons cell’s CDR could point to one of the
previous cons cells in the list.  We call that structure a “circular
list”.

   For some purposes, it does not matter whether a list is true,
circular or dotted.  If a program doesn’t look far enough down the list
to see the CDR of the final cons cell, it won’t care.  However, some
functions that operate on lists demand true lists and signal errors if
given a dotted list.  Most functions that try to find the end of a list
enter infinite loops if given a circular list.

   Because most cons cells are used as part of lists, we refer to any
structure made out of cons cells as a “list structure”.


File: elisp.info,  Node: List-related Predicates,  Next: List Elements,  Prev: Cons Cells,  Up: Lists

5.2 Predicates on Lists
=======================

The following predicates test whether a Lisp object is an atom, whether
it is a cons cell or is a list, or whether it is the distinguished
object ‘nil’.  (Many of these predicates can be defined in terms of the
others, but they are used so often that it is worth having them.)

 -- Function: consp object
     This function returns ‘t’ if OBJECT is a cons cell, ‘nil’
     otherwise.  ‘nil’ is not a cons cell, although it _is_ a list.

 -- Function: atom object
     This function returns ‘t’ if OBJECT is an atom, ‘nil’ otherwise.
     All objects except cons cells are atoms.  The symbol ‘nil’ is an
     atom and is also a list; it is the only Lisp object that is both.

          (atom OBJECT) ≡ (not (consp OBJECT))

 -- Function: listp object
     This function returns ‘t’ if OBJECT is a cons cell or ‘nil’.
     Otherwise, it returns ‘nil’.

          (listp '(1))
               ⇒ t
          (listp '())
               ⇒ t

 -- Function: nlistp object
     This function is the opposite of ‘listp’: it returns ‘t’ if OBJECT
     is not a list.  Otherwise, it returns ‘nil’.

          (listp OBJECT) ≡ (not (nlistp OBJECT))

 -- Function: null object
     This function returns ‘t’ if OBJECT is ‘nil’, and returns ‘nil’
     otherwise.  This function is identical to ‘not’, but as a matter of
     clarity we use ‘null’ when OBJECT is considered a list and ‘not’
     when it is considered a truth value (see ‘not’ in *note Combining
     Conditions::).

          (null '(1))
               ⇒ nil
          (null '())
               ⇒ t


File: elisp.info,  Node: List Elements,  Next: Building Lists,  Prev: List-related Predicates,  Up: Lists

5.3 Accessing Elements of Lists
===============================

 -- Function: car cons-cell
     This function returns the value referred to by the first slot of
     the cons cell CONS-CELL.  In other words, it returns the CAR of
     CONS-CELL.

     As a special case, if CONS-CELL is ‘nil’, this function returns
     ‘nil’.  Therefore, any list is a valid argument.  An error is
     signaled if the argument is not a cons cell or ‘nil’.

          (car '(a b c))
               ⇒ a
          (car '())
               ⇒ nil

 -- Function: cdr cons-cell
     This function returns the value referred to by the second slot of
     the cons cell CONS-CELL.  In other words, it returns the CDR of
     CONS-CELL.

     As a special case, if CONS-CELL is ‘nil’, this function returns
     ‘nil’; therefore, any list is a valid argument.  An error is
     signaled if the argument is not a cons cell or ‘nil’.

          (cdr '(a b c))
               ⇒ (b c)
          (cdr '())
               ⇒ nil

 -- Function: car-safe object
     This function lets you take the CAR of a cons cell while avoiding
     errors for other data types.  It returns the CAR of OBJECT if
     OBJECT is a cons cell, ‘nil’ otherwise.  This is in contrast to
     ‘car’, which signals an error if OBJECT is not a list.

          (car-safe OBJECT)
          ≡
          (let ((x OBJECT))
            (if (consp x)
                (car x)
              nil))

 -- Function: cdr-safe object
     This function lets you take the CDR of a cons cell while avoiding
     errors for other data types.  It returns the CDR of OBJECT if
     OBJECT is a cons cell, ‘nil’ otherwise.  This is in contrast to
     ‘cdr’, which signals an error if OBJECT is not a list.

          (cdr-safe OBJECT)
          ≡
          (let ((x OBJECT))
            (if (consp x)
                (cdr x)
              nil))

 -- Macro: pop listname
     This macro provides a convenient way to examine the CAR of a list,
     and take it off the list, all at once.  It operates on the list
     stored in LISTNAME.  It removes the first element from the list,
     saves the CDR into LISTNAME, then returns the removed element.

     In the simplest case, LISTNAME is an unquoted symbol naming a list;
     in that case, this macro is equivalent to
     ‘(prog1 (car listname) (setq listname (cdr listname)))’.

          x
               ⇒ (a b c)
          (pop x)
               ⇒ a
          x
               ⇒ (b c)

     More generally, LISTNAME can be a generalized variable.  In that
     case, this macro saves into LISTNAME using ‘setf’.  *Note
     Generalized Variables::.

     For the ‘push’ macro, which adds an element to a list, *Note List
     Variables::.

 -- Function: nth n list
     This function returns the Nth element of LIST.  Elements are
     numbered starting with zero, so the CAR of LIST is element number
     zero.  If the length of LIST is N or less, the value is ‘nil’.

          (nth 2 '(1 2 3 4))
               ⇒ 3
          (nth 10 '(1 2 3 4))
               ⇒ nil

          (nth n x) ≡ (car (nthcdr n x))

     The function ‘elt’ is similar, but applies to any kind of sequence.
     For historical reasons, it takes its arguments in the opposite
     order.  *Note Sequence Functions::.

 -- Function: nthcdr n list
     This function returns the Nth CDR of LIST.  In other words, it
     skips past the first N links of LIST and returns what follows.

     If N is zero, ‘nthcdr’ returns all of LIST.  If the length of LIST
     is N or less, ‘nthcdr’ returns ‘nil’.

          (nthcdr 1 '(1 2 3 4))
               ⇒ (2 3 4)
          (nthcdr 10 '(1 2 3 4))
               ⇒ nil
          (nthcdr 0 '(1 2 3 4))
               ⇒ (1 2 3 4)

 -- Function: last list &optional n
     This function returns the last link of LIST.  The ‘car’ of this
     link is the list’s last element.  If LIST is null, ‘nil’ is
     returned.  If N is non-‘nil’, the Nth-to-last link is returned
     instead, or the whole of LIST if N is bigger than LIST’s length.

 -- Function: safe-length list
     This function returns the length of LIST, with no risk of either an
     error or an infinite loop.  It generally returns the number of
     distinct cons cells in the list.  However, for circular lists, the
     value is just an upper bound; it is often too large.

     If LIST is not ‘nil’ or a cons cell, ‘safe-length’ returns 0.

   The most common way to compute the length of a list, when you are not
worried that it may be circular, is with ‘length’.  *Note Sequence
Functions::.

 -- Function: caar cons-cell
     This is the same as ‘(car (car CONS-CELL))’.

 -- Function: cadr cons-cell
     This is the same as ‘(car (cdr CONS-CELL))’ or ‘(nth 1 CONS-CELL)’.

 -- Function: cdar cons-cell
     This is the same as ‘(cdr (car CONS-CELL))’.

 -- Function: cddr cons-cell
     This is the same as ‘(cdr (cdr CONS-CELL))’ or ‘(nthcdr 2
     CONS-CELL)’.

   In addition to the above, 24 additional compositions of ‘car’ and
‘cdr’ are defined as ‘cXXXr’ and ‘cXXXXr’, where each ‘X’ is either ‘a’
or ‘d’.  ‘cadr’, ‘caddr’, and ‘cadddr’ pick out the second, third or
fourth elements of a list, respectively.  ‘cl-lib’ provides the same
under the names ‘cl-second’, ‘cl-third’, and ‘cl-fourth’.  *Note
(cl)List Functions::.

 -- Function: butlast x &optional n
     This function returns the list X with the last element, or the last
     N elements, removed.  If N is greater than zero it makes a copy of
     the list so as not to damage the original list.  In general,
     ‘(append (butlast X N) (last X N))’ will return a list equal to X.

 -- Function: nbutlast x &optional n
     This is a version of ‘butlast’ that works by destructively
     modifying the ‘cdr’ of the appropriate element, rather than making
     a copy of the list.


File: elisp.info,  Node: Building Lists,  Next: List Variables,  Prev: List Elements,  Up: Lists

5.4 Building Cons Cells and Lists
=================================

Many functions build lists, as lists reside at the very heart of Lisp.
‘cons’ is the fundamental list-building function; however, it is
interesting to note that ‘list’ is used more times in the source code
for Emacs than ‘cons’.

 -- Function: cons object1 object2
     This function is the most basic function for building new list
     structure.  It creates a new cons cell, making OBJECT1 the CAR, and
     OBJECT2 the CDR.  It then returns the new cons cell.  The arguments
     OBJECT1 and OBJECT2 may be any Lisp objects, but most often OBJECT2
     is a list.

          (cons 1 '(2))
               ⇒ (1 2)
          (cons 1 '())
               ⇒ (1)
          (cons 1 2)
               ⇒ (1 . 2)

     ‘cons’ is often used to add a single element to the front of a
     list.  This is called “consing the element onto the list”.  (1) For
     example:

          (setq list (cons newelt list))

     Note that there is no conflict between the variable named ‘list’
     used in this example and the function named ‘list’ described below;
     any symbol can serve both purposes.

 -- Function: list &rest objects
     This function creates a list with OBJECTS as its elements.  The
     resulting list is always ‘nil’-terminated.  If no OBJECTS are
     given, the empty list is returned.

          (list 1 2 3 4 5)
               ⇒ (1 2 3 4 5)
          (list 1 2 '(3 4 5) 'foo)
               ⇒ (1 2 (3 4 5) foo)
          (list)
               ⇒ nil

 -- Function: make-list length object
     This function creates a list of LENGTH elements, in which each
     element is OBJECT.  Compare ‘make-list’ with ‘make-string’ (*note
     Creating Strings::).

          (make-list 3 'pigs)
               ⇒ (pigs pigs pigs)
          (make-list 0 'pigs)
               ⇒ nil
          (setq l (make-list 3 '(a b)))
               ⇒ ((a b) (a b) (a b))
          (eq (car l) (cadr l))
               ⇒ t

 -- Function: append &rest sequences
     This function returns a list containing all the elements of
     SEQUENCES.  The SEQUENCES may be lists, vectors, bool-vectors, or
     strings, but the last one should usually be a list.  All arguments
     except the last one are copied, so none of the arguments is
     altered.  (See ‘nconc’ in *note Rearrangement::, for a way to join
     lists with no copying.)

     More generally, the final argument to ‘append’ may be any Lisp
     object.  The final argument is not copied or converted; it becomes
     the CDR of the last cons cell in the new list.  If the final
     argument is itself a list, then its elements become in effect
     elements of the result list.  If the final element is not a list,
     the result is a dotted list since its final CDR is not ‘nil’ as
     required in a true list.

   Here is an example of using ‘append’:

     (setq trees '(pine oak))
          ⇒ (pine oak)
     (setq more-trees (append '(maple birch) trees))
          ⇒ (maple birch pine oak)

     trees
          ⇒ (pine oak)
     more-trees
          ⇒ (maple birch pine oak)
     (eq trees (cdr (cdr more-trees)))
          ⇒ t

   You can see how ‘append’ works by looking at a box diagram.  The
variable ‘trees’ is set to the list ‘(pine oak)’ and then the variable
‘more-trees’ is set to the list ‘(maple birch pine oak)’.  However, the
variable ‘trees’ continues to refer to the original list:

     more-trees                trees
     |                           |
     |     --- ---      --- ---   -> --- ---      --- ---
      --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
           --- ---      --- ---      --- ---      --- ---
            |            |            |            |
            |            |            |            |
             --> maple    -->birch     --> pine     --> oak

   An empty sequence contributes nothing to the value returned by
‘append’.  As a consequence of this, a final ‘nil’ argument forces a
copy of the previous argument:

     trees
          ⇒ (pine oak)
     (setq wood (append trees nil))
          ⇒ (pine oak)
     wood
          ⇒ (pine oak)
     (eq wood trees)
          ⇒ nil

This once was the usual way to copy a list, before the function
‘copy-sequence’ was invented.  *Note Sequences Arrays Vectors::.

   Here we show the use of vectors and strings as arguments to ‘append’:

     (append [a b] "cd" nil)
          ⇒ (a b 99 100)

   With the help of ‘apply’ (*note Calling Functions::), we can append
all the lists in a list of lists:

     (apply 'append '((a b c) nil (x y z) nil))
          ⇒ (a b c x y z)

   If no SEQUENCES are given, ‘nil’ is returned:

     (append)
          ⇒ nil

   Here are some examples where the final argument is not a list:

     (append '(x y) 'z)
          ⇒ (x y . z)
     (append '(x y) [z])
          ⇒ (x y . [z])

The second example shows that when the final argument is a sequence but
not a list, the sequence’s elements do not become elements of the
resulting list.  Instead, the sequence becomes the final CDR, like any
other non-list final argument.

 -- Function: copy-tree tree &optional vecp
     This function returns a copy of the tree ‘tree’.  If TREE is a cons
     cell, this makes a new cons cell with the same CAR and CDR, then
     recursively copies the CAR and CDR in the same way.

     Normally, when TREE is anything other than a cons cell, ‘copy-tree’
     simply returns TREE.  However, if VECP is non-‘nil’, it copies
     vectors too (and operates recursively on their elements).

 -- Function: number-sequence from &optional to separation
     This returns a list of numbers starting with FROM and incrementing
     by SEPARATION, and ending at or just before TO.  SEPARATION can be
     positive or negative and defaults to 1.  If TO is ‘nil’ or
     numerically equal to FROM, the value is the one-element list
     ‘(FROM)’.  If TO is less than FROM with a positive SEPARATION, or
     greater than FROM with a negative SEPARATION, the value is ‘nil’
     because those arguments specify an empty sequence.

     If SEPARATION is 0 and TO is neither ‘nil’ nor numerically equal to
     FROM, ‘number-sequence’ signals an error, since those arguments
     specify an infinite sequence.

     All arguments are numbers.  Floating-point arguments can be tricky,
     because floating-point arithmetic is inexact.  For instance,
     depending on the machine, it may quite well happen that
     ‘(number-sequence 0.4 0.6 0.2)’ returns the one element list
     ‘(0.4)’, whereas ‘(number-sequence 0.4 0.8 0.2)’ returns a list
     with three elements.  The Nth element of the list is computed by
     the exact formula ‘(+ FROM (* N SEPARATION))’.  Thus, if one wants
     to make sure that TO is included in the list, one can pass an
     expression of this exact type for TO.  Alternatively, one can
     replace TO with a slightly larger value (or a slightly more
     negative value if SEPARATION is negative).

     Some examples:

          (number-sequence 4 9)
               ⇒ (4 5 6 7 8 9)
          (number-sequence 9 4 -1)
               ⇒ (9 8 7 6 5 4)
          (number-sequence 9 4 -2)
               ⇒ (9 7 5)
          (number-sequence 8)
               ⇒ (8)
          (number-sequence 8 5)
               ⇒ nil
          (number-sequence 5 8 -1)
               ⇒ nil
          (number-sequence 1.5 6 2)
               ⇒ (1.5 3.5 5.5)

   ---------- Footnotes ----------

   (1) There is no strictly equivalent way to add an element to the end
of a list.  You can use ‘(append LISTNAME (list NEWELT))’, which creates
a whole new list by copying LISTNAME and adding NEWELT to its end.  Or
you can use ‘(nconc LISTNAME (list NEWELT))’, which modifies LISTNAME by
following all the CDRs and then replacing the terminating ‘nil’.
Compare this to adding an element to the beginning of a list with
‘cons’, which neither copies nor modifies the list.


File: elisp.info,  Node: List Variables,  Next: Modifying Lists,  Prev: Building Lists,  Up: Lists

5.5 Modifying List Variables
============================

These functions, and one macro, provide convenient ways to modify a list
which is stored in a variable.

 -- Macro: push element listname
     This macro creates a new list whose CAR is ELEMENT and whose CDR is
     the list specified by LISTNAME, and saves that list in LISTNAME.
     In the simplest case, LISTNAME is an unquoted symbol naming a list,
     and this macro is equivalent to
     ‘(setq LISTNAME (cons ELEMENT LISTNAME))’.

          (setq l '(a b))
               ⇒ (a b)
          (push 'c l)
               ⇒ (c a b)
          l
               ⇒ (c a b)

     More generally, ‘listname’ can be a generalized variable.  In that
     case, this macro does the equivalent of
     ‘(setf LISTNAME (cons ELEMENT LISTNAME))’.  *Note Generalized
     Variables::.

     For the ‘pop’ macro, which removes the first element from a list,
     *Note List Elements::.

   Two functions modify lists that are the values of variables.

 -- Function: add-to-list symbol element &optional append compare-fn
     This function sets the variable SYMBOL by consing ELEMENT onto the
     old value, if ELEMENT is not already a member of that value.  It
     returns the resulting list, whether updated or not.  The value of
     SYMBOL had better be a list already before the call.  ‘add-to-list’
     uses COMPARE-FN to compare ELEMENT against existing list members;
     if COMPARE-FN is ‘nil’, it uses ‘equal’.

     Normally, if ELEMENT is added, it is added to the front of SYMBOL,
     but if the optional argument APPEND is non-‘nil’, it is added at
     the end.

     The argument SYMBOL is not implicitly quoted; ‘add-to-list’ is an
     ordinary function, like ‘set’ and unlike ‘setq’.  Quote the
     argument yourself if that is what you want.

   Here’s a scenario showing how to use ‘add-to-list’:

     (setq foo '(a b))
          ⇒ (a b)

     (add-to-list 'foo 'c)     ;; Add ‘c’.
          ⇒ (c a b)

     (add-to-list 'foo 'b)     ;; No effect.
          ⇒ (c a b)

     foo                       ;; ‘foo’ was changed.
          ⇒ (c a b)

   An equivalent expression for ‘(add-to-list 'VAR VALUE)’ is this:

     (or (member VALUE VAR)
         (setq VAR (cons VALUE VAR)))

 -- Function: add-to-ordered-list symbol element &optional order
     This function sets the variable SYMBOL by inserting ELEMENT into
     the old value, which must be a list, at the position specified by
     ORDER.  If ELEMENT is already a member of the list, its position in
     the list is adjusted according to ORDER.  Membership is tested
     using ‘eq’.  This function returns the resulting list, whether
     updated or not.

     The ORDER is typically a number (integer or float), and the
     elements of the list are sorted in non-decreasing numerical order.

     ORDER may also be omitted or ‘nil’.  Then the numeric order of
     ELEMENT stays unchanged if it already has one; otherwise, ELEMENT
     has no numeric order.  Elements without a numeric list order are
     placed at the end of the list, in no particular order.

     Any other value for ORDER removes the numeric order of ELEMENT if
     it already has one; otherwise, it is equivalent to ‘nil’.

     The argument SYMBOL is not implicitly quoted; ‘add-to-ordered-list’
     is an ordinary function, like ‘set’ and unlike ‘setq’.  Quote the
     argument yourself if necessary.

     The ordering information is stored in a hash table on SYMBOL’s
     ‘list-order’ property.

   Here’s a scenario showing how to use ‘add-to-ordered-list’:

     (setq foo '())
          ⇒ nil

     (add-to-ordered-list 'foo 'a 1)     ;; Add ‘a’.
          ⇒ (a)

     (add-to-ordered-list 'foo 'c 3)     ;; Add ‘c’.
          ⇒ (a c)

     (add-to-ordered-list 'foo 'b 2)     ;; Add ‘b’.
          ⇒ (a b c)

     (add-to-ordered-list 'foo 'b 4)     ;; Move ‘b’.
          ⇒ (a c b)

     (add-to-ordered-list 'foo 'd)       ;; Append ‘d’.
          ⇒ (a c b d)

     (add-to-ordered-list 'foo 'e)       ;; Add ‘e’.
          ⇒ (a c b e d)

     foo                       ;; ‘foo’ was changed.
          ⇒ (a c b e d)


File: elisp.info,  Node: Modifying Lists,  Next: Sets And Lists,  Prev: List Variables,  Up: Lists

5.6 Modifying Existing List Structure
=====================================

You can modify the CAR and CDR contents of a cons cell with the
primitives ‘setcar’ and ‘setcdr’.  These are destructive operations
because they change existing list structure.

     Common Lisp note: Common Lisp uses functions ‘rplaca’ and ‘rplacd’
     to alter list structure; they change structure the same way as
     ‘setcar’ and ‘setcdr’, but the Common Lisp functions return the
     cons cell while ‘setcar’ and ‘setcdr’ return the new CAR or CDR.

* Menu:

* Setcar::          Replacing an element in a list.
* Setcdr::          Replacing part of the list backbone.
                      This can be used to remove or add elements.
* Rearrangement::   Reordering the elements in a list; combining lists.


File: elisp.info,  Node: Setcar,  Next: Setcdr,  Up: Modifying Lists

5.6.1 Altering List Elements with ‘setcar’
------------------------------------------

Changing the CAR of a cons cell is done with ‘setcar’.  When used on a
list, ‘setcar’ replaces one element of a list with a different element.

 -- Function: setcar cons object
     This function stores OBJECT as the new CAR of CONS, replacing its
     previous CAR.  In other words, it changes the CAR slot of CONS to
     refer to OBJECT.  It returns the value OBJECT.  For example:

          (setq x '(1 2))
               ⇒ (1 2)
          (setcar x 4)
               ⇒ 4
          x
               ⇒ (4 2)

   When a cons cell is part of the shared structure of several lists,
storing a new CAR into the cons changes one element of each of these
lists.  Here is an example:

     ;; Create two lists that are partly shared.
     (setq x1 '(a b c))
          ⇒ (a b c)
     (setq x2 (cons 'z (cdr x1)))
          ⇒ (z b c)

     ;; Replace the CAR of a shared link.
     (setcar (cdr x1) 'foo)
          ⇒ foo
     x1                           ; Both lists are changed.
          ⇒ (a foo c)
     x2
          ⇒ (z foo c)

     ;; Replace the CAR of a link that is not shared.
     (setcar x1 'baz)
          ⇒ baz
     x1                           ; Only one list is changed.
          ⇒ (baz foo c)
     x2
          ⇒ (z foo c)

   Here is a graphical depiction of the shared structure of the two
lists in the variables ‘x1’ and ‘x2’, showing why replacing ‘b’ changes
them both:

             --- ---        --- ---      --- ---
     x1---> |   |   |----> |   |   |--> |   |   |--> nil
             --- ---        --- ---      --- ---
              |        -->   |            |
              |       |      |            |
               --> a  |       --> b        --> c
                      |
            --- ---   |
     x2--> |   |   |--
            --- ---
             |
             |
              --> z

   Here is an alternative form of box diagram, showing the same
relationship:

     x1:
      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   a   |   o------->|   b   |   o------->|   c   |  nil |
     |       |      |  -->|       |      |     |       |      |
      --------------  |    --------------       --------------
                      |
     x2:              |
      --------------  |
     | car   | cdr  | |
     |   z   |   o----
     |       |      |
      --------------


File: elisp.info,  Node: Setcdr,  Next: Rearrangement,  Prev: Setcar,  Up: Modifying Lists

5.6.2 Altering the CDR of a List
--------------------------------

The lowest-level primitive for modifying a CDR is ‘setcdr’:

 -- Function: setcdr cons object
     This function stores OBJECT as the new CDR of CONS, replacing its
     previous CDR.  In other words, it changes the CDR slot of CONS to
     refer to OBJECT.  It returns the value OBJECT.

   Here is an example of replacing the CDR of a list with a different
list.  All but the first element of the list are removed in favor of a
different sequence of elements.  The first element is unchanged, because
it resides in the CAR of the list, and is not reached via the CDR.

     (setq x '(1 2 3))
          ⇒ (1 2 3)
     (setcdr x '(4))
          ⇒ (4)
     x
          ⇒ (1 4)

   You can delete elements from the middle of a list by altering the
CDRs of the cons cells in the list.  For example, here we delete the
second element, ‘b’, from the list ‘(a b c)’, by changing the CDR of the
first cons cell:

     (setq x1 '(a b c))
          ⇒ (a b c)
     (setcdr x1 (cdr (cdr x1)))
          ⇒ (c)
     x1
          ⇒ (a c)

   Here is the result in box notation:

                        --------------------
                       |                    |
      --------------   |   --------------   |    --------------
     | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
     |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
     |       |      |     |       |      |      |       |      |
      --------------       --------------        --------------

The second cons cell, which previously held the element ‘b’, still
exists and its CAR is still ‘b’, but it no longer forms part of this
list.

   It is equally easy to insert a new element by changing CDRs:

     (setq x1 '(a b c))
          ⇒ (a b c)
     (setcdr x1 (cons 'd (cdr x1)))
          ⇒ (d b c)
     x1
          ⇒ (a d b c)

   Here is this result in box notation:

      --------------        -------------       -------------
     | car  | cdr   |      | car  | cdr  |     | car  | cdr  |
     |   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
     |      |   |   |  |   |      |      |     |      |      |
      --------- | --   |    -------------       -------------
                |      |
          -----         --------
         |                      |
         |    ---------------   |
         |   | car   | cdr   |  |
          -->|   d   |   o------
             |       |       |
              ---------------


File: elisp.info,  Node: Rearrangement,  Prev: Setcdr,  Up: Modifying Lists

5.6.3 Functions that Rearrange Lists
------------------------------------

Here are some functions that rearrange lists destructively by modifying
the CDRs of their component cons cells.  These functions are destructive
because they chew up the original lists passed to them as arguments,
relinking their cons cells to form a new list that is the returned
value.

   See ‘delq’, in *note Sets And Lists::, for another function that
modifies cons cells.

 -- Function: nconc &rest lists
     This function returns a list containing all the elements of LISTS.
     Unlike ‘append’ (*note Building Lists::), the LISTS are _not_
     copied.  Instead, the last CDR of each of the LISTS is changed to
     refer to the following list.  The last of the LISTS is not altered.
     For example:

          (setq x '(1 2 3))
               ⇒ (1 2 3)
          (nconc x '(4 5))
               ⇒ (1 2 3 4 5)
          x
               ⇒ (1 2 3 4 5)

     Since the last argument of ‘nconc’ is not itself modified, it is
     reasonable to use a constant list, such as ‘'(4 5)’, as in the
     above example.  For the same reason, the last argument need not be
     a list:

          (setq x '(1 2 3))
               ⇒ (1 2 3)
          (nconc x 'z)
               ⇒ (1 2 3 . z)
          x
               ⇒ (1 2 3 . z)

     However, the other arguments (all but the last) must be lists.

     A common pitfall is to use a quoted constant list as a non-last
     argument to ‘nconc’.  If you do this, your program will change each
     time you run it!  Here is what happens:

          (defun add-foo (x)            ; We want this function to add
            (nconc '(foo) x))           ;   ‘foo’ to the front of its arg.

          (symbol-function 'add-foo)
               ⇒ (lambda (x) (nconc (quote (foo)) x))

          (setq xx (add-foo '(1 2)))    ; It seems to work.
               ⇒ (foo 1 2)
          (setq xy (add-foo '(3 4)))    ; What happened?
               ⇒ (foo 1 2 3 4)
          (eq xx xy)
               ⇒ t

          (symbol-function 'add-foo)
               ⇒ (lambda (x) (nconc (quote (foo 1 2 3 4) x)))


File: elisp.info,  Node: Sets And Lists,  Next: Association Lists,  Prev: Modifying Lists,  Up: Lists

5.7 Using Lists as Sets
=======================

A list can represent an unordered mathematical set—simply consider a
value an element of a set if it appears in the list, and ignore the
order of the list.  To form the union of two sets, use ‘append’ (as long
as you don’t mind having duplicate elements).  You can remove ‘equal’
duplicates using ‘delete-dups’.  Other useful functions for sets include
‘memq’ and ‘delq’, and their ‘equal’ versions, ‘member’ and ‘delete’.

     Common Lisp note: Common Lisp has functions ‘union’ (which avoids
     duplicate elements) and ‘intersection’ for set operations.
     Although standard GNU Emacs Lisp does not have them, the ‘cl-lib’
     library provides versions.  *Note (cl)Lists as Sets::.

 -- Function: memq object list
     This function tests to see whether OBJECT is a member of LIST.  If
     it is, ‘memq’ returns a list starting with the first occurrence of
     OBJECT.  Otherwise, it returns ‘nil’.  The letter ‘q’ in ‘memq’
     says that it uses ‘eq’ to compare OBJECT against the elements of
     the list.  For example:

          (memq 'b '(a b c b a))
               ⇒ (b c b a)
          (memq '(2) '((1) (2)))    ; ‘(2)’ and ‘(2)’ are not ‘eq’.
               ⇒ nil

 -- Function: delq object list
     This function destructively removes all elements ‘eq’ to OBJECT
     from LIST, and returns the resulting list.  The letter ‘q’ in
     ‘delq’ says that it uses ‘eq’ to compare OBJECT against the
     elements of the list, like ‘memq’ and ‘remq’.

     Typically, when you invoke ‘delq’, you should use the return value
     by assigning it to the variable which held the original list.  The
     reason for this is explained below.

   The ‘delq’ function deletes elements from the front of the list by
simply advancing down the list, and returning a sublist that starts
after those elements.  For example:

     (delq 'a '(a b c)) ≡ (cdr '(a b c))

When an element to be deleted appears in the middle of the list,
removing it involves changing the CDRs (*note Setcdr::).

     (setq sample-list '(a b c (4)))
          ⇒ (a b c (4))
     (delq 'a sample-list)
          ⇒ (b c (4))
     sample-list
          ⇒ (a b c (4))
     (delq 'c sample-list)
          ⇒ (a b (4))
     sample-list
          ⇒ (a b (4))

   Note that ‘(delq 'c sample-list)’ modifies ‘sample-list’ to splice
out the third element, but ‘(delq 'a sample-list)’ does not splice
anything—it just returns a shorter list.  Don’t assume that a variable
which formerly held the argument LIST now has fewer elements, or that it
still holds the original list!  Instead, save the result of ‘delq’ and
use that.  Most often we store the result back into the variable that
held the original list:

     (setq flowers (delq 'rose flowers))

   In the following example, the ‘(4)’ that ‘delq’ attempts to match and
the ‘(4)’ in the ‘sample-list’ are not ‘eq’:

     (delq '(4) sample-list)
          ⇒ (a c (4))

   If you want to delete elements that are ‘equal’ to a given value, use
‘delete’ (see below).

 -- Function: remq object list
     This function returns a copy of LIST, with all elements removed
     which are ‘eq’ to OBJECT.  The letter ‘q’ in ‘remq’ says that it
     uses ‘eq’ to compare OBJECT against the elements of ‘list’.

          (setq sample-list '(a b c a b c))
               ⇒ (a b c a b c)
          (remq 'a sample-list)
               ⇒ (b c b c)
          sample-list
               ⇒ (a b c a b c)

 -- Function: memql object list
     The function ‘memql’ tests to see whether OBJECT is a member of
     LIST, comparing members with OBJECT using ‘eql’, so floating-point
     elements are compared by value.  If OBJECT is a member, ‘memql’
     returns a list starting with its first occurrence in LIST.
     Otherwise, it returns ‘nil’.

     Compare this with ‘memq’:

          (memql 1.2 '(1.1 1.2 1.3))  ; ‘1.2’ and ‘1.2’ are ‘eql’.
               ⇒ (1.2 1.3)
          (memq 1.2 '(1.1 1.2 1.3))  ; ‘1.2’ and ‘1.2’ are not ‘eq’.
               ⇒ nil

   The following three functions are like ‘memq’, ‘delq’ and ‘remq’, but
use ‘equal’ rather than ‘eq’ to compare elements.  *Note Equality
Predicates::.

 -- Function: member object list
     The function ‘member’ tests to see whether OBJECT is a member of
     LIST, comparing members with OBJECT using ‘equal’.  If OBJECT is a
     member, ‘member’ returns a list starting with its first occurrence
     in LIST.  Otherwise, it returns ‘nil’.

     Compare this with ‘memq’:

          (member '(2) '((1) (2)))  ; ‘(2)’ and ‘(2)’ are ‘equal’.
               ⇒ ((2))
          (memq '(2) '((1) (2)))    ; ‘(2)’ and ‘(2)’ are not ‘eq’.
               ⇒ nil
          ;; Two strings with the same contents are ‘equal’.
          (member "foo" '("foo" "bar"))
               ⇒ ("foo" "bar")

 -- Function: delete object sequence
     This function removes all elements ‘equal’ to OBJECT from SEQUENCE,
     and returns the resulting sequence.

     If SEQUENCE is a list, ‘delete’ is to ‘delq’ as ‘member’ is to
     ‘memq’: it uses ‘equal’ to compare elements with OBJECT, like
     ‘member’; when it finds an element that matches, it cuts the
     element out just as ‘delq’ would.  As with ‘delq’, you should
     typically use the return value by assigning it to the variable
     which held the original list.

     If ‘sequence’ is a vector or string, ‘delete’ returns a copy of
     ‘sequence’ with all elements ‘equal’ to ‘object’ removed.

     For example:

          (setq l '((2) (1) (2)))
          (delete '(2) l)
               ⇒ ((1))
          l
               ⇒ ((2) (1))
          ;; If you want to change ‘l’ reliably,
          ;; write ‘(setq l (delete '(2) l))’.
          (setq l '((2) (1) (2)))
          (delete '(1) l)
               ⇒ ((2) (2))
          l
               ⇒ ((2) (2))
          ;; In this case, it makes no difference whether you set ‘l’,
          ;; but you should do so for the sake of the other case.
          (delete '(2) [(2) (1) (2)])
               ⇒ [(1)]

 -- Function: remove object sequence
     This function is the non-destructive counterpart of ‘delete’.  It
     returns a copy of ‘sequence’, a list, vector, or string, with
     elements ‘equal’ to ‘object’ removed.  For example:

          (remove '(2) '((2) (1) (2)))
               ⇒ ((1))
          (remove '(2) [(2) (1) (2)])
               ⇒ [(1)]

     Common Lisp note: The functions ‘member’, ‘delete’ and ‘remove’ in
     GNU Emacs Lisp are derived from Maclisp, not Common Lisp.  The
     Common Lisp versions do not use ‘equal’ to compare elements.

 -- Function: member-ignore-case object list
     This function is like ‘member’, except that OBJECT should be a
     string and that it ignores differences in letter-case and text
     representation: upper-case and lower-case letters are treated as
     equal, and unibyte strings are converted to multibyte prior to
     comparison.

 -- Function: delete-dups list
     This function destructively removes all ‘equal’ duplicates from
     LIST, stores the result in LIST and returns it.  Of several ‘equal’
     occurrences of an element in LIST, ‘delete-dups’ keeps the first
     one.

   See also the function ‘add-to-list’, in *note List Variables::, for a
way to add an element to a list stored in a variable and used as a set.


File: elisp.info,  Node: Association Lists,  Next: Property Lists,  Prev: Sets And Lists,  Up: Lists

5.8 Association Lists
=====================

An “association list”, or “alist” for short, records a mapping from keys
to values.  It is a list of cons cells called “associations”: the CAR of
each cons cell is the “key”, and the CDR is the “associated value”.(1)

   Here is an example of an alist.  The key ‘pine’ is associated with
the value ‘cones’; the key ‘oak’ is associated with ‘acorns’; and the
key ‘maple’ is associated with ‘seeds’.

     ((pine . cones)
      (oak . acorns)
      (maple . seeds))

   Both the values and the keys in an alist may be any Lisp objects.
For example, in the following alist, the symbol ‘a’ is associated with
the number ‘1’, and the string ‘"b"’ is associated with the _list_ ‘(2
3)’, which is the CDR of the alist element:

     ((a . 1) ("b" 2 3))

   Sometimes it is better to design an alist to store the associated
value in the CAR of the CDR of the element.  Here is an example of such
an alist:

     ((rose red) (lily white) (buttercup yellow))

Here we regard ‘red’ as the value associated with ‘rose’.  One advantage
of this kind of alist is that you can store other related
information—even a list of other items—in the CDR of the CDR.  One
disadvantage is that you cannot use ‘rassq’ (see below) to find the
element containing a given value.  When neither of these considerations
is important, the choice is a matter of taste, as long as you are
consistent about it for any given alist.

   The same alist shown above could be regarded as having the associated
value in the CDR of the element; the value associated with ‘rose’ would
be the list ‘(red)’.

   Association lists are often used to record information that you might
otherwise keep on a stack, since new associations may be added easily to
the front of the list.  When searching an association list for an
association with a given key, the first one found is returned, if there
is more than one.

   In Emacs Lisp, it is _not_ an error if an element of an association
list is not a cons cell.  The alist search functions simply ignore such
elements.  Many other versions of Lisp signal errors in such cases.

   Note that property lists are similar to association lists in several
respects.  A property list behaves like an association list in which
each key can occur only once.  *Note Property Lists::, for a comparison
of property lists and association lists.

 -- Function: assoc key alist &optional testfn
     This function returns the first association for KEY in ALIST,
     comparing KEY against the alist elements using TESTFN if it is
     non-‘nil’ and ‘equal’ otherwise (*note Equality Predicates::).  It
     returns ‘nil’ if no association in ALIST has a CAR equal to KEY.
     For example:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
          (assoc 'oak trees)
               ⇒ (oak . acorns)
          (cdr (assoc 'oak trees))
               ⇒ acorns
          (assoc 'birch trees)
               ⇒ nil

     Here is another example, in which the keys and values are not
     symbols:

          (setq needles-per-cluster
                '((2 "Austrian Pine" "Red Pine")
                  (3 "Pitch Pine")
                  (5 "White Pine")))

          (cdr (assoc 3 needles-per-cluster))
               ⇒ ("Pitch Pine")
          (cdr (assoc 2 needles-per-cluster))
               ⇒ ("Austrian Pine" "Red Pine")

   The function ‘assoc-string’ is much like ‘assoc’ except that it
ignores certain differences between strings.  *Note Text Comparison::.

 -- Function: rassoc value alist
     This function returns the first association with value VALUE in
     ALIST.  It returns ‘nil’ if no association in ALIST has a CDR
     ‘equal’ to VALUE.

     ‘rassoc’ is like ‘assoc’ except that it compares the CDR of each
     ALIST association instead of the CAR.  You can think of this as
     reverse ‘assoc’, finding the key for a given value.

 -- Function: assq key alist
     This function is like ‘assoc’ in that it returns the first
     association for KEY in ALIST, but it makes the comparison using
     ‘eq’.  ‘assq’ returns ‘nil’ if no association in ALIST has a CAR
     ‘eq’ to KEY.  This function is used more often than ‘assoc’, since
     ‘eq’ is faster than ‘equal’ and most alists use symbols as keys.
     *Note Equality Predicates::.

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
          (assq 'pine trees)
               ⇒ (pine . cones)

     On the other hand, ‘assq’ is not usually useful in alists where the
     keys may not be symbols:

          (setq leaves
                '(("simple leaves" . oak)
                  ("compound leaves" . horsechestnut)))

          (assq "simple leaves" leaves)
               ⇒ nil
          (assoc "simple leaves" leaves)
               ⇒ ("simple leaves" . oak)

 -- Function: alist-get key alist &optional default remove testfn
     This function is similar to ‘assq’.  It finds the first association
     ‘(KEY . VALUE)’ by comparing KEY with ALIST elements, and, if
     found, returns the VALUE of that association.  If no association is
     found, the function returns DEFAULT.  Comparison of KEY against
     ALIST elements uses the function specified by TESTFN, defaulting to
     ‘eq’.

     This is a generalized variable (*note Generalized Variables::) that
     can be used to change a value with ‘setf’.  When using it to set a
     value, optional argument REMOVE non-‘nil’ means to remove KEY’s
     association from ALIST if the new value is ‘eql’ to DEFAULT.

 -- Function: rassq value alist
     This function returns the first association with value VALUE in
     ALIST.  It returns ‘nil’ if no association in ALIST has a CDR ‘eq’
     to VALUE.

     ‘rassq’ is like ‘assq’ except that it compares the CDR of each
     ALIST association instead of the CAR.  You can think of this as
     reverse ‘assq’, finding the key for a given value.

     For example:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

          (rassq 'acorns trees)
               ⇒ (oak . acorns)
          (rassq 'spores trees)
               ⇒ nil

     ‘rassq’ cannot search for a value stored in the CAR of the CDR of
     an element:

          (setq colors '((rose red) (lily white) (buttercup yellow)))

          (rassq 'white colors)
               ⇒ nil

     In this case, the CDR of the association ‘(lily white)’ is not the
     symbol ‘white’, but rather the list ‘(white)’.  This becomes
     clearer if the association is written in dotted pair notation:

          (lily white) ≡ (lily . (white))

 -- Function: assoc-default key alist &optional test default
     This function searches ALIST for a match for KEY.  For each element
     of ALIST, it compares the element (if it is an atom) or the
     element’s CAR (if it is a cons) against KEY, by calling TEST with
     two arguments: the element or its CAR, and KEY.  The arguments are
     passed in that order so that you can get useful results using
     ‘string-match’ with an alist that contains regular expressions
     (*note Regexp Search::).  If TEST is omitted or ‘nil’, ‘equal’ is
     used for comparison.

     If an alist element matches KEY by this criterion, then
     ‘assoc-default’ returns a value based on this element.  If the
     element is a cons, then the value is the element’s CDR.  Otherwise,
     the return value is DEFAULT.

     If no alist element matches KEY, ‘assoc-default’ returns ‘nil’.

 -- Function: copy-alist alist
     This function returns a two-level deep copy of ALIST: it creates a
     new copy of each association, so that you can alter the
     associations of the new alist without changing the old one.

          (setq needles-per-cluster
                '((2 . ("Austrian Pine" "Red Pine"))
                  (3 . ("Pitch Pine"))
                  (5 . ("White Pine"))))
          ⇒
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (setq copy (copy-alist needles-per-cluster))
          ⇒
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (eq needles-per-cluster copy)
               ⇒ nil
          (equal needles-per-cluster copy)
               ⇒ t
          (eq (car needles-per-cluster) (car copy))
               ⇒ nil
          (cdr (car (cdr needles-per-cluster)))
               ⇒ ("Pitch Pine")
          (eq (cdr (car (cdr needles-per-cluster)))
              (cdr (car (cdr copy))))
               ⇒ t

     This example shows how ‘copy-alist’ makes it possible to change the
     associations of one copy without affecting the other:

          (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
          (cdr (assq 3 needles-per-cluster))
               ⇒ ("Pitch Pine")

 -- Function: assq-delete-all key alist
     This function deletes from ALIST all the elements whose CAR is ‘eq’
     to KEY, much as if you used ‘delq’ to delete each such element one
     by one.  It returns the shortened alist, and often modifies the
     original list structure of ALIST.  For correct results, use the
     return value of ‘assq-delete-all’ rather than looking at the saved
     value of ALIST.

          (setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))
               ⇒ ((foo 1) (bar 2) (foo 3) (lose 4))
          (assq-delete-all 'foo alist)
               ⇒ ((bar 2) (lose 4))
          alist
               ⇒ ((foo 1) (bar 2) (lose 4))

 -- Function: rassq-delete-all value alist
     This function deletes from ALIST all the elements whose CDR is ‘eq’
     to VALUE.  It returns the shortened alist, and often modifies the
     original list structure of ALIST.  ‘rassq-delete-all’ is like
     ‘assq-delete-all’ except that it compares the CDR of each ALIST
     association instead of the CAR.

   ---------- Footnotes ----------

   (1) This usage of “key” is not related to the term “key sequence”; it
means a value used to look up an item in a table.  In this case, the
table is the alist, and the alist associations are the items.


File: elisp.info,  Node: Property Lists,  Prev: Association Lists,  Up: Lists

5.9 Property Lists
==================

A “property list” (“plist” for short) is a list of paired elements.
Each of the pairs associates a property name (usually a symbol) with a
property or value.  Here is an example of a property list:

     (pine cones numbers (1 2 3) color "blue")

This property list associates ‘pine’ with ‘cones’, ‘numbers’ with ‘(1 2
3)’, and ‘color’ with ‘"blue"’.  The property names and values can be
any Lisp objects, but the names are usually symbols (as they are in this
example).

   Property lists are used in several contexts.  For instance, the
function ‘put-text-property’ takes an argument which is a property list,
specifying text properties and associated values which are to be applied
to text in a string or buffer.  *Note Text Properties::.

   Another prominent use of property lists is for storing symbol
properties.  Every symbol possesses a list of properties, used to record
miscellaneous information about the symbol; these properties are stored
in the form of a property list.  *Note Symbol Properties::.

* Menu:

* Plists and Alists::           Comparison of the advantages of property
                                  lists and association lists.
* Plist Access::                Accessing property lists stored elsewhere.


File: elisp.info,  Node: Plists and Alists,  Next: Plist Access,  Up: Property Lists

5.9.1 Property Lists and Association Lists
------------------------------------------

Association lists (*note Association Lists::) are very similar to
property lists.  In contrast to association lists, the order of the
pairs in the property list is not significant, since the property names
must be distinct.

   Property lists are better than association lists for attaching
information to various Lisp function names or variables.  If your
program keeps all such information in one association list, it will
typically need to search that entire list each time it checks for an
association for a particular Lisp function name or variable, which could
be slow.  By contrast, if you keep the same information in the property
lists of the function names or variables themselves, each search will
scan only the length of one property list, which is usually short.  This
is why the documentation for a variable is recorded in a property named
‘variable-documentation’.  The byte compiler likewise uses properties to
record those functions needing special treatment.

   However, association lists have their own advantages.  Depending on
your application, it may be faster to add an association to the front of
an association list than to update a property.  All properties for a
symbol are stored in the same property list, so there is a possibility
of a conflict between different uses of a property name.  (For this
reason, it is a good idea to choose property names that are probably
unique, such as by beginning the property name with the program’s usual
name-prefix for variables and functions.)  An association list may be
used like a stack where associations are pushed on the front of the list
and later discarded; this is not possible with a property list.


File: elisp.info,  Node: Plist Access,  Prev: Plists and Alists,  Up: Property Lists

5.9.2 Property Lists Outside Symbols
------------------------------------

The following functions can be used to manipulate property lists.  They
all compare property names using ‘eq’.

 -- Function: plist-get plist property
     This returns the value of the PROPERTY property stored in the
     property list PLIST.  It accepts a malformed PLIST argument.  If
     PROPERTY is not found in the PLIST, it returns ‘nil’.  For example,

          (plist-get '(foo 4) 'foo)
               ⇒ 4
          (plist-get '(foo 4 bad) 'foo)
               ⇒ 4
          (plist-get '(foo 4 bad) 'bad)
               ⇒ nil
          (plist-get '(foo 4 bad) 'bar)
               ⇒ nil

 -- Function: plist-put plist property value
     This stores VALUE as the value of the PROPERTY property in the
     property list PLIST.  It may modify PLIST destructively, or it may
     construct a new list structure without altering the old.  The
     function returns the modified property list, so you can store that
     back in the place where you got PLIST.  For example,

          (setq my-plist '(bar t foo 4))
               ⇒ (bar t foo 4)
          (setq my-plist (plist-put my-plist 'foo 69))
               ⇒ (bar t foo 69)
          (setq my-plist (plist-put my-plist 'quux '(a)))
               ⇒ (bar t foo 69 quux (a))

 -- Function: lax-plist-get plist property
     Like ‘plist-get’ except that it compares properties using ‘equal’
     instead of ‘eq’.

 -- Function: lax-plist-put plist property value
     Like ‘plist-put’ except that it compares properties using ‘equal’
     instead of ‘eq’.

 -- Function: plist-member plist property
     This returns non-‘nil’ if PLIST contains the given PROPERTY.
     Unlike ‘plist-get’, this allows you to distinguish between a
     missing property and a property with the value ‘nil’.  The value is
     actually the tail of PLIST whose ‘car’ is PROPERTY.


File: elisp.info,  Node: Sequences Arrays Vectors,  Next: Records,  Prev: Lists,  Up: Top

6 Sequences, Arrays, and Vectors
********************************

The “sequence” type is the union of two other Lisp types: lists and
arrays.  In other words, any list is a sequence, and any array is a
sequence.  The common property that all sequences have is that each is
an ordered collection of elements.

   An “array” is a fixed-length object with a slot for each of its
elements.  All the elements are accessible in constant time.  The four
types of arrays are strings, vectors, char-tables and bool-vectors.

   A list is a sequence of elements, but it is not a single primitive
object; it is made of cons cells, one cell per element.  Finding the Nth
element requires looking through N cons cells, so elements farther from
the beginning of the list take longer to access.  But it is possible to
add elements to the list, or remove elements.

   The following diagram shows the relationship between these types:

               _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

* Menu:

* Sequence Functions::    Functions that accept any kind of sequence.
* Arrays::                Characteristics of arrays in Emacs Lisp.
* Array Functions::       Functions specifically for arrays.
* Vectors::               Special characteristics of Emacs Lisp vectors.
* Vector Functions::      Functions specifically for vectors.
* Char-Tables::           How to work with char-tables.
* Bool-Vectors::          How to work with bool-vectors.
* Rings::                 Managing a fixed-size ring of objects.


File: elisp.info,  Node: Sequence Functions,  Next: Arrays,  Up: Sequences Arrays Vectors

6.1 Sequences
=============

This section describes functions that accept any kind of sequence.

 -- Function: sequencep object
     This function returns ‘t’ if OBJECT is a list, vector, string,
     bool-vector, or char-table, ‘nil’ otherwise.

 -- Function: length sequence
     This function returns the number of elements in SEQUENCE.  If
     SEQUENCE is a dotted list, a ‘wrong-type-argument’ error is
     signaled.  Circular lists may cause an infinite loop.  For a
     char-table, the value returned is always one more than the maximum
     Emacs character code.

     *Note Definition of safe-length::, for the related function
     ‘safe-length’.

          (length '(1 2 3))
              ⇒ 3
          (length ())
              ⇒ 0
          (length "foobar")
              ⇒ 6
          (length [1 2 3])
              ⇒ 3
          (length (make-bool-vector 5 nil))
              ⇒ 5

See also ‘string-bytes’, in *note Text Representations::.

   If you need to compute the width of a string on display, you should
use ‘string-width’ (*note Size of Displayed Text::), not ‘length’, since
‘length’ only counts the number of characters, but does not account for
the display width of each character.

 -- Function: elt sequence index
     This function returns the element of SEQUENCE indexed by INDEX.
     Legitimate values of INDEX are integers ranging from 0 up to one
     less than the length of SEQUENCE.  If SEQUENCE is a list,
     out-of-range values behave as for ‘nth’.  *Note Definition of
     nth::.  Otherwise, out-of-range values trigger an
     ‘args-out-of-range’ error.

          (elt [1 2 3 4] 2)
               ⇒ 3
          (elt '(1 2 3 4) 2)
               ⇒ 3
          ;; We use ‘string’ to show clearly which character ‘elt’ returns.
          (string (elt "1234" 2))
               ⇒ "3"
          (elt [1 2 3 4] 4)
               error→ Args out of range: [1 2 3 4], 4
          (elt [1 2 3 4] -1)
               error→ Args out of range: [1 2 3 4], -1

     This function generalizes ‘aref’ (*note Array Functions::) and
     ‘nth’ (*note Definition of nth::).

 -- Function: copy-sequence seqr
     This function returns a copy of SEQR, which should be either a
     sequence or a record.  The copy is the same type of object as the
     original, and it has the same elements in the same order.  However,
     if SEQR is empty, like a string or a vector of zero length, the
     value returned by this function might not be a copy, but an empty
     object of the same type and identical to SEQR.

     Storing a new element into the copy does not affect the original
     SEQR, and vice versa.  However, the elements of the copy are not
     copies; they are identical (‘eq’) to the elements of the original.
     Therefore, changes made within these elements, as found via the
     copy, are also visible in the original.

     If the argument is a string with text properties, the property list
     in the copy is itself a copy, not shared with the original’s
     property list.  However, the actual values of the properties are
     shared.  *Note Text Properties::.

     This function does not work for dotted lists.  Trying to copy a
     circular list may cause an infinite loop.

     See also ‘append’ in *note Building Lists::, ‘concat’ in *note
     Creating Strings::, and ‘vconcat’ in *note Vector Functions::, for
     other ways to copy sequences.

          (setq bar '(1 2))
               ⇒ (1 2)
          (setq x (vector 'foo bar))
               ⇒ [foo (1 2)]
          (setq y (copy-sequence x))
               ⇒ [foo (1 2)]

          (eq x y)
               ⇒ nil
          (equal x y)
               ⇒ t
          (eq (elt x 1) (elt y 1))
               ⇒ t

          ;; Replacing an element of one sequence.
          (aset x 0 'quux)
          x ⇒ [quux (1 2)]
          y ⇒ [foo (1 2)]

          ;; Modifying the inside of a shared element.
          (setcar (aref x 1) 69)
          x ⇒ [quux (69 2)]
          y ⇒ [foo (69 2)]

 -- Function: reverse sequence
     This function creates a new sequence whose elements are the
     elements of SEQUENCE, but in reverse order.  The original argument
     SEQUENCE is _not_ altered.  Note that char-tables cannot be
     reversed.

          (setq x '(1 2 3 4))
               ⇒ (1 2 3 4)
          (reverse x)
               ⇒ (4 3 2 1)
          x
               ⇒ (1 2 3 4)
          (setq x [1 2 3 4])
               ⇒ [1 2 3 4]
          (reverse x)
               ⇒ [4 3 2 1]
          x
               ⇒ [1 2 3 4]
          (setq x "xyzzy")
               ⇒ "xyzzy"
          (reverse x)
               ⇒ "yzzyx"
          x
               ⇒ "xyzzy"

 -- Function: nreverse sequence
     This function reverses the order of the elements of SEQUENCE.
     Unlike ‘reverse’ the original SEQUENCE may be modified.

     For example:

          (setq x '(a b c))
               ⇒ (a b c)
          x
               ⇒ (a b c)
          (nreverse x)
               ⇒ (c b a)
          ;; The cons cell that was first is now last.
          x
               ⇒ (a)

     To avoid confusion, we usually store the result of ‘nreverse’ back
     in the same variable which held the original list:

          (setq x (nreverse x))

     Here is the ‘nreverse’ of our favorite example, ‘(a b c)’,
     presented graphically:

          Original list head:                       Reversed list:
           -------------        -------------        ------------
          | car  | cdr  |      | car  | cdr  |      | car | cdr  |
          |   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |
          |      |      |   |  |      |   |  |   |  |     |   |  |
           -------------    |   --------- | -    |   -------- | -
                            |             |      |            |
                             -------------        ------------

     For the vector, it is even simpler because you don’t need setq:

          (setq x [1 2 3 4])
               ⇒ [1 2 3 4]
          (nreverse x)
               ⇒ [4 3 2 1]
          x
               ⇒ [4 3 2 1]

     Note that unlike ‘reverse’, this function doesn’t work with
     strings.  Although you can alter string data by using ‘aset’, it is
     strongly encouraged to treat strings as immutable.

 -- Function: sort sequence predicate
     This function sorts SEQUENCE stably.  Note that this function
     doesn’t work for all sequences; it may be used only for lists and
     vectors.  If SEQUENCE is a list, it is modified destructively.
     This functions returns the sorted SEQUENCE and compares elements
     using PREDICATE.  A stable sort is one in which elements with equal
     sort keys maintain their relative order before and after the sort.
     Stability is important when successive sorts are used to order
     elements according to different criteria.

     The argument PREDICATE must be a function that accepts two
     arguments.  It is called with two elements of SEQUENCE.  To get an
     increasing order sort, the PREDICATE should return non-‘nil’ if the
     first element is “less” than the second, or ‘nil’ if not.

     The comparison function PREDICATE must give reliable results for
     any given pair of arguments, at least within a single call to
     ‘sort’.  It must be “antisymmetric”; that is, if A is less than B,
     B must not be less than A.  It must be “transitive”—that is, if A
     is less than B, and B is less than C, then A must be less than C.
     If you use a comparison function which does not meet these
     requirements, the result of ‘sort’ is unpredictable.

     The destructive aspect of ‘sort’ for lists is that it rearranges
     the cons cells forming SEQUENCE by changing CDRs.  A nondestructive
     sort function would create new cons cells to store the elements in
     their sorted order.  If you wish to make a sorted copy without
     destroying the original, copy it first with ‘copy-sequence’ and
     then sort.

     Sorting does not change the CARs of the cons cells in SEQUENCE; the
     cons cell that originally contained the element ‘a’ in SEQUENCE
     still has ‘a’ in its CAR after sorting, but it now appears in a
     different position in the list due to the change of CDRs.  For
     example:

          (setq nums '(1 3 2 6 5 4 0))
               ⇒ (1 3 2 6 5 4 0)
          (sort nums '<)
               ⇒ (0 1 2 3 4 5 6)
          nums
               ⇒ (1 2 3 4 5 6)

     *Warning*: Note that the list in ‘nums’ no longer contains 0; this
     is the same cons cell that it was before, but it is no longer the
     first one in the list.  Don’t assume a variable that formerly held
     the argument now holds the entire sorted list!  Instead, save the
     result of ‘sort’ and use that.  Most often we store the result back
     into the variable that held the original list:

          (setq nums (sort nums '<))

     For the better understanding of what stable sort is, consider the
     following vector example.  After sorting, all items whose ‘car’ is
     8 are grouped at the beginning of ‘vector’, but their relative
     order is preserved.  All items whose ‘car’ is 9 are grouped at the
     end of ‘vector’, but their relative order is also preserved:

          (setq
            vector
            (vector '(8 . "xxx") '(9 . "aaa") '(8 . "bbb") '(9 . "zzz")
                    '(9 . "ppp") '(8 . "ttt") '(8 . "eee") '(9 . "fff")))
               ⇒ [(8 . "xxx") (9 . "aaa") (8 . "bbb") (9 . "zzz")
                   (9 . "ppp") (8 . "ttt") (8 . "eee") (9 . "fff")]
          (sort vector (lambda (x y) (< (car x) (car y))))
               ⇒ [(8 . "xxx") (8 . "bbb") (8 . "ttt") (8 . "eee")
                   (9 . "aaa") (9 . "zzz") (9 . "ppp") (9 . "fff")]

     *Note Sorting::, for more functions that perform sorting.  See
     ‘documentation’ in *note Accessing Documentation::, for a useful
     example of ‘sort’.

   The ‘seq.el’ library provides the following additional sequence
manipulation macros and functions, prefixed with ‘seq-’.  To use them,
you must first load the ‘seq’ library.

   All functions defined in this library are free of side-effects; i.e.,
they do not modify any sequence (list, vector, or string) that you pass
as an argument.  Unless otherwise stated, the result is a sequence of
the same type as the input.  For those functions that take a predicate,
this should be a function of one argument.

   The ‘seq.el’ library can be extended to work with additional types of
sequential data-structures.  For that purpose, all functions are defined
using ‘cl-defgeneric’.  *Note Generic Functions::, for more details
about using ‘cl-defgeneric’ for adding extensions.

 -- Function: seq-elt sequence index
     This function returns the element of SEQUENCE at the specified
     INDEX, which is an integer whose valid value range is zero to one
     less than the length of SEQUENCE.  For out-of-range values on
     built-in sequence types, ‘seq-elt’ behaves like ‘elt’.  For the
     details, see *note Definition of elt::.

          (seq-elt [1 2 3 4] 2)
          ⇒ 3

     ‘seq-elt’ returns places settable using ‘setf’ (*note Setting
     Generalized Variables::).

          (setq vec [1 2 3 4])
          (setf (seq-elt vec 2) 5)
          vec
          ⇒ [1 2 5 4]

 -- Function: seq-length sequence
     This function returns the number of elements in SEQUENCE.  For
     built-in sequence types, ‘seq-length’ behaves like ‘length’.  *Note
     Definition of length::.

 -- Function: seqp sequence
     This function returns non-‘nil’ if SEQUENCE is a sequence (a list
     or array), or any additional type of sequence defined via ‘seq.el’
     generic functions.

          (seqp [1 2])
          ⇒ t
          (seqp 2)
          ⇒ nil

 -- Function: seq-drop sequence n
     This function returns all but the first N (an integer) elements of
     SEQUENCE.  If N is negative or zero, the result is SEQUENCE.

          (seq-drop [1 2 3 4 5 6] 3)
          ⇒ [4 5 6]
          (seq-drop "hello world" -4)
          ⇒ "hello world"

 -- Function: seq-take sequence n
     This function returns the first N (an integer) elements of
     SEQUENCE.  If N is negative or zero, the result is ‘nil’.

          (seq-take '(1 2 3 4) 3)
          ⇒ (1 2 3)
          (seq-take [1 2 3 4] 0)
          ⇒ []

 -- Function: seq-take-while predicate sequence
     This function returns the members of SEQUENCE in order, stopping
     before the first one for which PREDICATE returns ‘nil’.

          (seq-take-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))
          ⇒ (1 2 3)
          (seq-take-while (lambda (elt) (> elt 0)) [-1 4 6])
          ⇒ []

 -- Function: seq-drop-while predicate sequence
     This function returns the members of SEQUENCE in order, starting
     from the first one for which PREDICATE returns ‘nil’.

          (seq-drop-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))
          ⇒ (-1 -2)
          (seq-drop-while (lambda (elt) (< elt 0)) [1 4 6])
          ⇒ [1 4 6]

 -- Function: seq-do function sequence
     This function applies FUNCTION to each element of SEQUENCE in turn
     (presumably for side effects), and returns SEQUENCE.

 -- Function: seq-map function sequence
     This function returns the result of applying FUNCTION to each
     element of SEQUENCE.  The returned value is a list.

          (seq-map #'1+ '(2 4 6))
          ⇒ (3 5 7)
          (seq-map #'symbol-name [foo bar])
          ⇒ ("foo" "bar")

 -- Function: seq-map-indexed function sequence
     This function returns the result of applying FUNCTION to each
     element of SEQUENCE and its index within SEQ.  The returned value
     is a list.

          (seq-map-indexed (lambda (elt idx)
                             (list idx elt))
                           '(a b c))
          ⇒ ((0 a) (b 1) (c 2))

 -- Function: seq-mapn function &rest sequences
     This function returns the result of applying FUNCTION to each
     element of SEQUENCES.  The arity (*note sub-arity: What Is a
     Function.) of FUNCTION must match the number of sequences.  Mapping
     stops at the end of the shortest sequence, and the returned value
     is a list.

          (seq-mapn #'+ '(2 4 6) '(20 40 60))
          ⇒ (22 44 66)
          (seq-mapn #'concat '("moskito" "bite") ["bee" "sting"])
          ⇒ ("moskitobee" "bitesting")

 -- Function: seq-filter predicate sequence
     This function returns a list of all the elements in SEQUENCE for
     which PREDICATE returns non-‘nil’.

          (seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
          ⇒ (1 3 5)
          (seq-filter (lambda (elt) (> elt 0)) '(-1 -3 -5))
          ⇒ nil

 -- Function: seq-remove predicate sequence
     This function returns a list of all the elements in SEQUENCE for
     which PREDICATE returns ‘nil’.

          (seq-remove (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
          ⇒ (-1 -3)
          (seq-remove (lambda (elt) (< elt 0)) '(-1 -3 -5))
          ⇒ nil

 -- Function: seq-reduce function sequence initial-value
     This function returns the result of calling FUNCTION with
     INITIAL-VALUE and the first element of SEQUENCE, then calling
     FUNCTION with that result and the second element of SEQUENCE, then
     with that result and the third element of SEQUENCE, etc.  FUNCTION
     should be a function of two arguments.  If SEQUENCE is empty, this
     returns INITIAL-VALUE without calling FUNCTION.

          (seq-reduce #'+ [1 2 3 4] 0)
          ⇒ 10
          (seq-reduce #'+ '(1 2 3 4) 5)
          ⇒ 15
          (seq-reduce #'+ '() 3)
          ⇒ 3

 -- Function: seq-some predicate sequence
     This function returns the first non-‘nil’ value returned by
     applying PREDICATE to each element of SEQUENCE in turn.

          (seq-some #'numberp ["abc" 1 nil])
          ⇒ t
          (seq-some #'numberp ["abc" "def"])
          ⇒ nil
          (seq-some #'null ["abc" 1 nil])
          ⇒ t
          (seq-some #'1+ [2 4 6])
          ⇒ 3

 -- Function: seq-find predicate sequence &optional default
     This function returns the first element in SEQUENCE for which
     PREDICATE returns non-‘nil’.  If no element matches PREDICATE, the
     function returns DEFAULT.

     Note that this function has an ambiguity if the found element is
     identical to DEFAULT, as in that case it cannot be known whether an
     element was found or not.

          (seq-find #'numberp ["abc" 1 nil])
          ⇒ 1
          (seq-find #'numberp ["abc" "def"])
          ⇒ nil

 -- Function: seq-every-p predicate sequence
     This function returns non-‘nil’ if applying PREDICATE to every
     element of SEQUENCE returns non-‘nil’.

          (seq-every-p #'numberp [2 4 6])
          ⇒ t
          (seq-every-p #'numberp [2 4 "6"])
          ⇒ nil

 -- Function: seq-empty-p sequence
     This function returns non-‘nil’ if SEQUENCE is empty.

          (seq-empty-p "not empty")
          ⇒ nil
          (seq-empty-p "")
          ⇒ t

 -- Function: seq-count predicate sequence
     This function returns the number of elements in SEQUENCE for which
     PREDICATE returns non-‘nil’.

          (seq-count (lambda (elt) (> elt 0)) [-1 2 0 3 -2])
          ⇒ 2

 -- Function: seq-sort function sequence
     This function returns a copy of SEQUENCE that is sorted according
     to FUNCTION, a function of two arguments that returns non-‘nil’ if
     the first argument should sort before the second.

 -- Function: seq-sort-by function predicate sequence
     This function is similar to ‘seq-sort’, but the elements of
     SEQUENCE are transformed by applying FUNCTION on them before being
     sorted.  FUNCTION is a function of one argument.

          (seq-sort-by #'seq-length #'> ["a" "ab" "abc"])
          ⇒ ["abc" "ab" "a"]

 -- Function: seq-contains sequence elt &optional function
     This function returns the first element in SEQUENCE that is equal
     to ELT.  If the optional argument FUNCTION is non-‘nil’, it is a
     function of two arguments to use instead of the default ‘equal’.

          (seq-contains '(symbol1 symbol2) 'symbol1)
          ⇒ symbol1
          (seq-contains '(symbol1 symbol2) 'symbol3)
          ⇒ nil

 -- Function: seq-set-equal-p sequence1 sequence2 &optional testfn
     This function checks whether SEQUENCE1 and SEQUENCE2 contain the
     same elements, regardless of the order.  If the optional argument
     TESTFN is non-‘nil’, it is a function of two arguments to use
     instead of the default ‘equal’.

          (seq-set-equal-p '(a b c) '(c b a))
          ⇒ t
          (seq-set-equal-p '(a b c) '(c b))
          ⇒ nil
          (seq-set-equal-p '("a" "b" "c") '("c" "b" "a"))
          ⇒ t
          (seq-set-equal-p '("a" "b" "c") '("c" "b" "a") #'eq)
          ⇒ nil

 -- Function: seq-position sequence elt &optional function
     This function returns the index of the first element in SEQUENCE
     that is equal to ELT.  If the optional argument FUNCTION is
     non-‘nil’, it is a function of two arguments to use instead of the
     default ‘equal’.

          (seq-position '(a b c) 'b)
          ⇒ 1
          (seq-position '(a b c) 'd)
          ⇒ nil

 -- Function: seq-uniq sequence &optional function
     This function returns a list of the elements of SEQUENCE with
     duplicates removed.  If the optional argument FUNCTION is
     non-‘nil’, it is a function of two arguments to use instead of the
     default ‘equal’.

          (seq-uniq '(1 2 2 1 3))
          ⇒ (1 2 3)
          (seq-uniq '(1 2 2.0 1.0) #'=)
          ⇒ (1 2)

 -- Function: seq-subseq sequence start &optional end
     This function returns a subset of SEQUENCE from START to END, both
     integers (END defaults to the last element).  If START or END is
     negative, it counts from the end of SEQUENCE.

          (seq-subseq '(1 2 3 4 5) 1)
          ⇒ (2 3 4 5)
          (seq-subseq '[1 2 3 4 5] 1 3)
          ⇒ [2 3]
          (seq-subseq '[1 2 3 4 5] -3 -1)
          ⇒ [3 4]

 -- Function: seq-concatenate type &rest sequences
     This function returns a sequence of type TYPE made of the
     concatenation of SEQUENCES.  TYPE may be: ‘vector’, ‘list’ or
     ‘string’.

          (seq-concatenate 'list '(1 2) '(3 4) [5 6])
          ⇒ (1 2 3 4 5 6)
          (seq-concatenate 'string "Hello " "world")
          ⇒ "Hello world"

 -- Function: seq-mapcat function sequence &optional type
     This function returns the result of applying ‘seq-concatenate’ to
     the result of applying FUNCTION to each element of SEQUENCE.  The
     result is a sequence of type TYPE, or a list if TYPE is ‘nil’.

          (seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
          ⇒ (1 2 3 4 5 6)

 -- Function: seq-partition sequence n
     This function returns a list of the elements of SEQUENCE grouped
     into sub-sequences of length N.  The last sequence may contain less
     elements than N.  N must be an integer.  If N is a negative integer
     or 0, the return value is ‘nil’.

          (seq-partition '(0 1 2 3 4 5 6 7) 3)
          ⇒ ((0 1 2) (3 4 5) (6 7))

 -- Function: seq-intersection sequence1 sequence2 &optional function
     This function returns a list of the elements that appear both in
     SEQUENCE1 and SEQUENCE2.  If the optional argument FUNCTION is
     non-‘nil’, it is a function of two arguments to use to compare
     elements instead of the default ‘equal’.

          (seq-intersection [2 3 4 5] [1 3 5 6 7])
          ⇒ (3 5)

 -- Function: seq-difference sequence1 sequence2 &optional function
     This function returns a list of the elements that appear in
     SEQUENCE1 but not in SEQUENCE2.  If the optional argument FUNCTION
     is non-‘nil’, it is a function of two arguments to use to compare
     elements instead of the default ‘equal’.

          (seq-difference '(2 3 4 5) [1 3 5 6 7])
          ⇒ (2 4)

 -- Function: seq-group-by function sequence
     This function separates the elements of SEQUENCE into an alist
     whose keys are the result of applying FUNCTION to each element of
     SEQUENCE.  Keys are compared using ‘equal’.

          (seq-group-by #'integerp '(1 2.1 3 2 3.2))
          ⇒ ((t 1 3 2) (nil 2.1 3.2))
          (seq-group-by #'car '((a 1) (b 2) (a 3) (c 4)))
          ⇒ ((b (b 2)) (a (a 1) (a 3)) (c (c 4)))

 -- Function: seq-into sequence type
     This function converts the sequence SEQUENCE into a sequence of
     type TYPE.  TYPE can be one of the following symbols: ‘vector’,
     ‘string’ or ‘list’.

          (seq-into [1 2 3] 'list)
          ⇒ (1 2 3)
          (seq-into nil 'vector)
          ⇒ []
          (seq-into "hello" 'vector)
          ⇒ [104 101 108 108 111]

 -- Function: seq-min sequence
     This function returns the smallest element of SEQUENCE.  The
     elements of SEQUENCE must be numbers or markers (*note Markers::).

          (seq-min [3 1 2])
          ⇒ 1
          (seq-min "Hello")
          ⇒ 72

 -- Function: seq-max sequence
     This function returns the largest element of SEQUENCE.  The
     elements of SEQUENCE must be numbers or markers.

          (seq-max [1 3 2])
          ⇒ 3
          (seq-max "Hello")
          ⇒ 111

 -- Macro: seq-doseq (var sequence) body...
     This macro is like ‘dolist’ (*note dolist: Iteration.), except that
     SEQUENCE can be a list, vector or string.  This is primarily useful
     for side-effects.

 -- Macro: seq-let arguments sequence body...
     This macro binds the variables defined in ARGUMENTS to the elements
     of SEQUENCE.  ARGUMENTS can themselves include sequences, allowing
     for nested destructuring.

     The ARGUMENTS sequence can also include the ‘&rest’ marker followed
     by a variable name to be bound to the rest of ‘sequence’.

          (seq-let [first second] [1 2 3 4]
            (list first second))
          ⇒ (1 2)
          (seq-let (_ a _ b) '(1 2 3 4)
            (list a b))
          ⇒ (2 4)
          (seq-let [a [b [c]]] [1 [2 [3]]]
            (list a b c))
          ⇒ (1 2 3)
          (seq-let [a b &rest others] [1 2 3 4]
            others)
          ⇒ [3 4]

 -- Function: seq-random-elt sequence
     This function returns an element of SEQUENCE taken at random.

          (seq-random-elt [1 2 3 4])
          ⇒ 3
          (seq-random-elt [1 2 3 4])
          ⇒ 2
          (seq-random-elt [1 2 3 4])
          ⇒ 4
          (seq-random-elt [1 2 3 4])
          ⇒ 2
          (seq-random-elt [1 2 3 4])
          ⇒ 1

     If SEQUENCE is empty, this function signals an error.


File: elisp.info,  Node: Arrays,  Next: Array Functions,  Prev: Sequence Functions,  Up: Sequences Arrays Vectors

6.2 Arrays
==========

An “array” object has slots that hold a number of other Lisp objects,
called the elements of the array.  Any element of an array may be
accessed in constant time.  In contrast, the time to access an element
of a list is proportional to the position of that element in the list.

   Emacs defines four types of array, all one-dimensional: “strings”
(*note String Type::), “vectors” (*note Vector Type::), “bool-vectors”
(*note Bool-Vector Type::), and “char-tables” (*note Char-Table Type::).
Vectors and char-tables can hold elements of any type, but strings can
only hold characters, and bool-vectors can only hold ‘t’ and ‘nil’.

   All four kinds of array share these characteristics:

   • The first element of an array has index zero, the second element
     has index 1, and so on.  This is called “zero-origin” indexing.
     For example, an array of four elements has indices 0, 1, 2, and 3.

   • The length of the array is fixed once you create it; you cannot
     change the length of an existing array.

   • For purposes of evaluation, the array is a constant—i.e., it
     evaluates to itself.

   • The elements of an array may be referenced or changed with the
     functions ‘aref’ and ‘aset’, respectively (*note Array
     Functions::).

   When you create an array, other than a char-table, you must specify
its length.  You cannot specify the length of a char-table, because that
is determined by the range of character codes.

   In principle, if you want an array of text characters, you could use
either a string or a vector.  In practice, we always choose strings for
such applications, for four reasons:

   • They occupy one-fourth the space of a vector of the same elements.

   • Strings are printed in a way that shows the contents more clearly
     as text.

   • Strings can hold text properties.  *Note Text Properties::.

   • Many of the specialized editing and I/O facilities of Emacs accept
     only strings.  For example, you cannot insert a vector of
     characters into a buffer the way you can insert a string.  *Note
     Strings and Characters::.

   By contrast, for an array of keyboard input characters (such as a key
sequence), a vector may be necessary, because many keyboard input
characters are outside the range that will fit in a string.  *Note Key
Sequence Input::.


File: elisp.info,  Node: Array Functions,  Next: Vectors,  Prev: Arrays,  Up: Sequences Arrays Vectors

6.3 Functions that Operate on Arrays
====================================

In this section, we describe the functions that accept all types of
arrays.

 -- Function: arrayp object
     This function returns ‘t’ if OBJECT is an array (i.e., a vector, a
     string, a bool-vector or a char-table).

          (arrayp [a])
               ⇒ t
          (arrayp "asdf")
               ⇒ t
          (arrayp (syntax-table))    ;; A char-table.
               ⇒ t

 -- Function: aref arr index
     This function returns the INDEXth element of the array or record
     ARR.  The first element is at index zero.

          (setq primes [2 3 5 7 11 13])
               ⇒ [2 3 5 7 11 13]
          (aref primes 4)
               ⇒ 11
          (aref "abcdefg" 1)
               ⇒ 98           ; ‘b’ is ASCII code 98.

     See also the function ‘elt’, in *note Sequence Functions::.

 -- Function: aset array index object
     This function sets the INDEXth element of ARRAY to be OBJECT.  It
     returns OBJECT.

          (setq w [foo bar baz])
               ⇒ [foo bar baz]
          (aset w 0 'fu)
               ⇒ fu
          w
               ⇒ [fu bar baz]

          (setq x "asdfasfd")
               ⇒ "asdfasfd"
          (aset x 3 ?Z)
               ⇒ 90
          x
               ⇒ "asdZasfd"

     If ARRAY is a string and OBJECT is not a character, a
     ‘wrong-type-argument’ error results.  The function converts a
     unibyte string to multibyte if necessary to insert a character.

 -- Function: fillarray array object
     This function fills the array ARRAY with OBJECT, so that each
     element of ARRAY is OBJECT.  It returns ARRAY.

          (setq a [a b c d e f g])
               ⇒ [a b c d e f g]
          (fillarray a 0)
               ⇒ [0 0 0 0 0 0 0]
          a
               ⇒ [0 0 0 0 0 0 0]
          (setq s "When in the course")
               ⇒ "When in the course"
          (fillarray s ?-)
               ⇒ "------------------"

     If ARRAY is a string and OBJECT is not a character, a
     ‘wrong-type-argument’ error results.

   The general sequence functions ‘copy-sequence’ and ‘length’ are often
useful for objects known to be arrays.  *Note Sequence Functions::.


File: elisp.info,  Node: Vectors,  Next: Vector Functions,  Prev: Array Functions,  Up: Sequences Arrays Vectors

6.4 Vectors
===========

A “vector” is a general-purpose array whose elements can be any Lisp
objects.  (By contrast, the elements of a string can only be characters.
*Note Strings and Characters::.)  Vectors are used in Emacs for many
purposes: as key sequences (*note Key Sequences::), as symbol-lookup
tables (*note Creating Symbols::), as part of the representation of a
byte-compiled function (*note Byte Compilation::), and more.

   Like other arrays, vectors use zero-origin indexing: the first
element has index 0.

   Vectors are printed with square brackets surrounding the elements.
Thus, a vector whose elements are the symbols ‘a’, ‘b’ and ‘a’ is
printed as ‘[a b a]’.  You can write vectors in the same way in Lisp
input.

   A vector, like a string or a number, is considered a constant for
evaluation: the result of evaluating it is the same vector.  This does
not evaluate or even examine the elements of the vector.  *Note
Self-Evaluating Forms::.

   Here are examples illustrating these principles:

     (setq avector [1 two '(three) "four" [five]])
          ⇒ [1 two (quote (three)) "four" [five]]
     (eval avector)
          ⇒ [1 two (quote (three)) "four" [five]]
     (eq avector (eval avector))
          ⇒ t


File: elisp.info,  Node: Vector Functions,  Next: Char-Tables,  Prev: Vectors,  Up: Sequences Arrays Vectors

6.5 Functions for Vectors
=========================

Here are some functions that relate to vectors:

 -- Function: vectorp object
     This function returns ‘t’ if OBJECT is a vector.

          (vectorp [a])
               ⇒ t
          (vectorp "asdf")
               ⇒ nil

 -- Function: vector &rest objects
     This function creates and returns a vector whose elements are the
     arguments, OBJECTS.

          (vector 'foo 23 [bar baz] "rats")
               ⇒ [foo 23 [bar baz] "rats"]
          (vector)
               ⇒ []

 -- Function: make-vector length object
     This function returns a new vector consisting of LENGTH elements,
     each initialized to OBJECT.

          (setq sleepy (make-vector 9 'Z))
               ⇒ [Z Z Z Z Z Z Z Z Z]

 -- Function: vconcat &rest sequences
     This function returns a new vector containing all the elements of
     SEQUENCES.  The arguments SEQUENCES may be true lists, vectors,
     strings or bool-vectors.  If no SEQUENCES are given, the empty
     vector is returned.

     The value is either the empty vector, or is a newly constructed
     nonempty vector that is not ‘eq’ to any existing vector.

          (setq a (vconcat '(A B C) '(D E F)))
               ⇒ [A B C D E F]
          (eq a (vconcat a))
               ⇒ nil
          (vconcat)
               ⇒ []
          (vconcat [A B C] "aa" '(foo (6 7)))
               ⇒ [A B C 97 97 foo (6 7)]

     The ‘vconcat’ function also allows byte-code function objects as
     arguments.  This is a special feature to make it easy to access the
     entire contents of a byte-code function object.  *Note Byte-Code
     Objects::.

     For other concatenation functions, see ‘mapconcat’ in *note Mapping
     Functions::, ‘concat’ in *note Creating Strings::, and ‘append’ in
     *note Building Lists::.

   The ‘append’ function also provides a way to convert a vector into a
list with the same elements:

     (setq avector [1 two (quote (three)) "four" [five]])
          ⇒ [1 two (quote (three)) "four" [five]]
     (append avector nil)
          ⇒ (1 two (quote (three)) "four" [five])


File: elisp.info,  Node: Char-Tables,  Next: Bool-Vectors,  Prev: Vector Functions,  Up: Sequences Arrays Vectors

6.6 Char-Tables
===============

A char-table is much like a vector, except that it is indexed by
character codes.  Any valid character code, without modifiers, can be
used as an index in a char-table.  You can access a char-table’s
elements with ‘aref’ and ‘aset’, as with any array.  In addition, a
char-table can have “extra slots” to hold additional data not associated
with particular character codes.  Like vectors, char-tables are
constants when evaluated, and can hold elements of any type.

   Each char-table has a “subtype”, a symbol, which serves two purposes:

   • The subtype provides an easy way to tell what the char-table is
     for.  For instance, display tables are char-tables with
     ‘display-table’ as the subtype, and syntax tables are char-tables
     with ‘syntax-table’ as the subtype.  The subtype can be queried
     using the function ‘char-table-subtype’, described below.

   • The subtype controls the number of “extra slots” in the char-table.
     This number is specified by the subtype’s ‘char-table-extra-slots’
     symbol property (*note Symbol Properties::), whose value should be
     an integer between 0 and 10.  If the subtype has no such symbol
     property, the char-table has no extra slots.

   A char-table can have a “parent”, which is another char-table.  If it
does, then whenever the char-table specifies ‘nil’ for a particular
character C, it inherits the value specified in the parent.  In other
words, ‘(aref CHAR-TABLE C)’ returns the value from the parent of
CHAR-TABLE if CHAR-TABLE itself specifies ‘nil’.

   A char-table can also have a “default value”.  If so, then ‘(aref
CHAR-TABLE C)’ returns the default value whenever the char-table does
not specify any other non-‘nil’ value.

 -- Function: make-char-table subtype &optional init
     Return a newly-created char-table, with subtype SUBTYPE (a symbol).
     Each element is initialized to INIT, which defaults to ‘nil’.  You
     cannot alter the subtype of a char-table after the char-table is
     created.

     There is no argument to specify the length of the char-table,
     because all char-tables have room for any valid character code as
     an index.

     If SUBTYPE has the ‘char-table-extra-slots’ symbol property, that
     specifies the number of extra slots in the char-table.  This should
     be an integer between 0 and 10; otherwise, ‘make-char-table’ raises
     an error.  If SUBTYPE has no ‘char-table-extra-slots’ symbol
     property (*note Property Lists::), the char-table has no extra
     slots.

 -- Function: char-table-p object
     This function returns ‘t’ if OBJECT is a char-table, and ‘nil’
     otherwise.

 -- Function: char-table-subtype char-table
     This function returns the subtype symbol of CHAR-TABLE.

   There is no special function to access default values in a
char-table.  To do that, use ‘char-table-range’ (see below).

 -- Function: char-table-parent char-table
     This function returns the parent of CHAR-TABLE.  The parent is
     always either ‘nil’ or another char-table.

 -- Function: set-char-table-parent char-table new-parent
     This function sets the parent of CHAR-TABLE to NEW-PARENT.

 -- Function: char-table-extra-slot char-table n
     This function returns the contents of extra slot N (zero based) of
     CHAR-TABLE.  The number of extra slots in a char-table is
     determined by its subtype.

 -- Function: set-char-table-extra-slot char-table n value
     This function stores VALUE in extra slot N (zero based) of
     CHAR-TABLE.

   A char-table can specify an element value for a single character
code; it can also specify a value for an entire character set.

 -- Function: char-table-range char-table range
     This returns the value specified in CHAR-TABLE for a range of
     characters RANGE.  Here are the possibilities for RANGE:

     ‘nil’
          Refers to the default value.

     CHAR
          Refers to the element for character CHAR (supposing CHAR is a
          valid character code).

     ‘(FROM . TO)’
          A cons cell refers to all the characters in the inclusive
          range ‘[FROM..TO]’.

 -- Function: set-char-table-range char-table range value
     This function sets the value in CHAR-TABLE for a range of
     characters RANGE.  Here are the possibilities for RANGE:

     ‘nil’
          Refers to the default value.

     ‘t’
          Refers to the whole range of character codes.

     CHAR
          Refers to the element for character CHAR (supposing CHAR is a
          valid character code).

     ‘(FROM . TO)’
          A cons cell refers to all the characters in the inclusive
          range ‘[FROM..TO]’.

 -- Function: map-char-table function char-table
     This function calls its argument FUNCTION for each element of
     CHAR-TABLE that has a non-‘nil’ value.  The call to FUNCTION is
     with two arguments, a key and a value.  The key is a possible RANGE
     argument for ‘char-table-range’—either a valid character or a cons
     cell ‘(FROM . TO)’, specifying a range of characters that share the
     same value.  The value is what ‘(char-table-range CHAR-TABLE KEY)’
     returns.

     Overall, the key-value pairs passed to FUNCTION describe all the
     values stored in CHAR-TABLE.

     The return value is always ‘nil’; to make calls to ‘map-char-table’
     useful, FUNCTION should have side effects.  For example, here is
     how to examine the elements of the syntax table:

          (let (accumulator)
             (map-char-table
              #'(lambda (key value)
                  (setq accumulator
                        (cons (list
                               (if (consp key)
                                   (list (car key) (cdr key))
                                 key)
                               value)
                              accumulator)))
              (syntax-table))
             accumulator)
          ⇒
          (((2597602 4194303) (2)) ((2597523 2597601) (3))
           ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1))
           ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))


File: elisp.info,  Node: Bool-Vectors,  Next: Rings,  Prev: Char-Tables,  Up: Sequences Arrays Vectors

6.7 Bool-vectors
================

A bool-vector is much like a vector, except that it stores only the
values ‘t’ and ‘nil’.  If you try to store any non-‘nil’ value into an
element of the bool-vector, the effect is to store ‘t’ there.  As with
all arrays, bool-vector indices start from 0, and the length cannot be
changed once the bool-vector is created.  Bool-vectors are constants
when evaluated.

   Several functions work specifically with bool-vectors; aside from
that, you manipulate them with same functions used for other kinds of
arrays.

 -- Function: make-bool-vector length initial
     Return a new bool-vector of LENGTH elements, each one initialized
     to INITIAL.

 -- Function: bool-vector &rest objects
     This function creates and returns a bool-vector whose elements are
     the arguments, OBJECTS.

 -- Function: bool-vector-p object
     This returns ‘t’ if OBJECT is a bool-vector, and ‘nil’ otherwise.

   There are also some bool-vector set operation functions, described
below:

 -- Function: bool-vector-exclusive-or a b &optional c
     Return “bitwise exclusive or” of bool vectors A and B.  If optional
     argument C is given, the result of this operation is stored into C.
     All arguments should be bool vectors of the same length.

 -- Function: bool-vector-union a b &optional c
     Return “bitwise or” of bool vectors A and B.  If optional argument
     C is given, the result of this operation is stored into C.  All
     arguments should be bool vectors of the same length.

 -- Function: bool-vector-intersection a b &optional c
     Return “bitwise and” of bool vectors A and B.  If optional argument
     C is given, the result of this operation is stored into C.  All
     arguments should be bool vectors of the same length.

 -- Function: bool-vector-set-difference a b &optional c
     Return “set difference” of bool vectors A and B.  If optional
     argument C is given, the result of this operation is stored into C.
     All arguments should be bool vectors of the same length.

 -- Function: bool-vector-not a &optional b
     Return “set complement” of bool vector A.  If optional argument B
     is given, the result of this operation is stored into B.  All
     arguments should be bool vectors of the same length.

 -- Function: bool-vector-subsetp a b
     Return ‘t’ if every ‘t’ value in A is also ‘t’ in B, ‘nil’
     otherwise.  All arguments should be bool vectors of the same
     length.

 -- Function: bool-vector-count-consecutive a b i
     Return the number of consecutive elements in A equal B starting at
     I.  ‘a’ is a bool vector, B is ‘t’ or ‘nil’, and I is an index into
     ‘a’.

 -- Function: bool-vector-count-population a
     Return the number of elements that are ‘t’ in bool vector A.

   The printed form represents up to 8 boolean values as a single
character:

     (bool-vector t nil t nil)
          ⇒ #&4"^E"
     (bool-vector)
          ⇒ #&0""

   You can use ‘vconcat’ to print a bool-vector like other vectors:

     (vconcat (bool-vector nil t nil t))
          ⇒ [nil t nil t]

   Here is another example of creating, examining, and updating a
bool-vector:

     (setq bv (make-bool-vector 5 t))
          ⇒ #&5"^_"
     (aref bv 1)
          ⇒ t
     (aset bv 3 nil)
          ⇒ nil
     bv
          ⇒ #&5"^W"

These results make sense because the binary codes for control-_ and
control-W are 11111 and 10111, respectively.


File: elisp.info,  Node: Rings,  Prev: Bool-Vectors,  Up: Sequences Arrays Vectors

6.8 Managing a Fixed-Size Ring of Objects
=========================================

A “ring” is a fixed-size data structure that supports insertion,
deletion, rotation, and modulo-indexed reference and traversal.  An
efficient ring data structure is implemented by the ‘ring’ package.  It
provides the functions listed in this section.

   Note that several rings in Emacs, like the kill ring and the mark
ring, are actually implemented as simple lists, _not_ using the ‘ring’
package; thus the following functions won’t work on them.

 -- Function: make-ring size
     This returns a new ring capable of holding SIZE objects.  SIZE
     should be an integer.

 -- Function: ring-p object
     This returns ‘t’ if OBJECT is a ring, ‘nil’ otherwise.

 -- Function: ring-size ring
     This returns the maximum capacity of the RING.

 -- Function: ring-length ring
     This returns the number of objects that RING currently contains.
     The value will never exceed that returned by ‘ring-size’.

 -- Function: ring-elements ring
     This returns a list of the objects in RING, in order, newest first.

 -- Function: ring-copy ring
     This returns a new ring which is a copy of RING.  The new ring
     contains the same (‘eq’) objects as RING.

 -- Function: ring-empty-p ring
     This returns ‘t’ if RING is empty, ‘nil’ otherwise.

   The newest element in the ring always has index 0.  Higher indices
correspond to older elements.  Indices are computed modulo the ring
length.  Index −1 corresponds to the oldest element, −2 to the
next-oldest, and so forth.

 -- Function: ring-ref ring index
     This returns the object in RING found at index INDEX.  INDEX may be
     negative or greater than the ring length.  If RING is empty,
     ‘ring-ref’ signals an error.

 -- Function: ring-insert ring object
     This inserts OBJECT into RING, making it the newest element, and
     returns OBJECT.

     If the ring is full, insertion removes the oldest element to make
     room for the new element.

 -- Function: ring-remove ring &optional index
     Remove an object from RING, and return that object.  The argument
     INDEX specifies which item to remove; if it is ‘nil’, that means to
     remove the oldest item.  If RING is empty, ‘ring-remove’ signals an
     error.

 -- Function: ring-insert-at-beginning ring object
     This inserts OBJECT into RING, treating it as the oldest element.
     The return value is not significant.

     If the ring is full, this function removes the newest element to
     make room for the inserted element.

   If you are careful not to exceed the ring size, you can use the ring
as a first-in-first-out queue.  For example:

     (let ((fifo (make-ring 5)))
       (mapc (lambda (obj) (ring-insert fifo obj))
             '(0 one "two"))
       (list (ring-remove fifo) t
             (ring-remove fifo) t
             (ring-remove fifo)))
          ⇒ (0 t one t "two")


File: elisp.info,  Node: Records,  Next: Hash Tables,  Prev: Sequences Arrays Vectors,  Up: Top

7 Records
*********

The purpose of records is to allow programmers to create objects with
new types that are not built into Emacs.  They are used as the
underlying representation of ‘cl-defstruct’ and ‘defclass’ instances.

   Internally, a record object is much like a vector; its slots can be
accessed using ‘aref’ and it can be copied using ‘copy-sequence’.
However, the first slot is used to hold its type as returned by
‘type-of’.  Also, in the current implementation records can have at most
4096 slots, whereas vectors can be much larger.  Like arrays, records
use zero-origin indexing: the first slot has index 0.

   The type slot should be a symbol or a type descriptor.  If it’s a
type descriptor, the symbol naming its type will be returned; *note Type
Descriptors::.  Any other kind of object is returned as-is.

   The printed representation of records is ‘#s’ followed by a list
specifying the contents.  The first list element must be the record
type.  The following elements are the record slots.

   To avoid conflicts with other type names, Lisp programs that define
new types of records should normally use the naming conventions of the
package where these record types are introduced for the names of the
types.  Note that the names of the types which could possibly conflict
might not be known at the time the package defining a record type is
loaded; they could be loaded at some future point in time.

   A record is considered a constant for evaluation: the result of
evaluating it is the same record.  This does not evaluate or even
examine the slots.  *Note Self-Evaluating Forms::.

* Menu:

* Record Functions::        Functions for records.
* Backward Compatibility::  Compatibility for cl-defstruct.


File: elisp.info,  Node: Record Functions,  Next: Backward Compatibility,  Up: Records

7.1 Record Functions
====================

 -- Function: recordp object
     This function returns ‘t’ if OBJECT is a record.

          (recordp #s(a))
               ⇒ t

 -- Function: record type &rest objects
     This function creates and returns a record whose type is TYPE and
     remaining slots are the rest of the arguments, OBJECTS.

          (record 'foo 23 [bar baz] "rats")
               ⇒ #s(foo 23 [bar baz] "rats")

 -- Function: make-record type length object
     This function returns a new record with type TYPE and LENGTH more
     slots, each initialized to OBJECT.

          (setq sleepy (make-record 'foo 9 'Z))
               ⇒ #s(foo Z Z Z Z Z Z Z Z Z)


File: elisp.info,  Node: Backward Compatibility,  Prev: Record Functions,  Up: Records

7.2 Backward Compatibility
==========================

Code compiled with older versions of ‘cl-defstruct’ that doesn’t use
records may run into problems when used in a new Emacs.  To alleviate
this, Emacs detects when an old ‘cl-defstruct’ is used, and enables a
mode in which ‘type-of’ handles old struct objects as if they were
records.

 -- Function: cl-old-struct-compat-mode arg
     If ARG is positive, enable backward compatibility with old-style
     structs.


File: elisp.info,  Node: Hash Tables,  Next: Symbols,  Prev: Records,  Up: Top

8 Hash Tables
*************

A hash table is a very fast kind of lookup table, somewhat like an alist
(*note Association Lists::) in that it maps keys to corresponding
values.  It differs from an alist in these ways:

   • Lookup in a hash table is extremely fast for large tables—in fact,
     the time required is essentially _independent_ of how many elements
     are stored in the table.  For smaller tables (a few tens of
     elements) alists may still be faster because hash tables have a
     more-or-less constant overhead.

   • The correspondences in a hash table are in no particular order.

   • There is no way to share structure between two hash tables, the way
     two alists can share a common tail.

   Emacs Lisp provides a general-purpose hash table data type, along
with a series of functions for operating on them.  Hash tables have a
special printed representation, which consists of ‘#s’ followed by a
list specifying the hash table properties and contents.  *Note Creating
Hash::.  (Hash notation, the initial ‘#’ character used in the printed
representations of objects with no read representation, has nothing to
do with hash tables.  *Note Printed Representation::.)

   Obarrays are also a kind of hash table, but they are a different type
of object and are used only for recording interned symbols (*note
Creating Symbols::).

* Menu:

* Creating Hash::       Functions to create hash tables.
* Hash Access::         Reading and writing the hash table contents.
* Defining Hash::       Defining new comparison methods.
* Other Hash::          Miscellaneous.


File: elisp.info,  Node: Creating Hash,  Next: Hash Access,  Up: Hash Tables

8.1 Creating Hash Tables
========================

The principal function for creating a hash table is ‘make-hash-table’.

 -- Function: make-hash-table &rest keyword-args
     This function creates a new hash table according to the specified
     arguments.  The arguments should consist of alternating keywords
     (particular symbols recognized specially) and values corresponding
     to them.

     Several keywords make sense in ‘make-hash-table’, but the only two
     that you really need to know about are ‘:test’ and ‘:weakness’.

     ‘:test TEST’
          This specifies the method of key lookup for this hash table.
          The default is ‘eql’; ‘eq’ and ‘equal’ are other alternatives:

          ‘eql’
               Keys which are numbers are the same if they are ‘equal’,
               that is, if they are equal in value and either both are
               integers or both are floating point; otherwise, two
               distinct objects are never the same.

          ‘eq’
               Any two distinct Lisp objects are different as keys.

          ‘equal’
               Two Lisp objects are the same, as keys, if they are equal
               according to ‘equal’.

          You can use ‘define-hash-table-test’ (*note Defining Hash::)
          to define additional possibilities for TEST.

     ‘:weakness WEAK’
          The weakness of a hash table specifies whether the presence of
          a key or value in the hash table preserves it from garbage
          collection.

          The value, WEAK, must be one of ‘nil’, ‘key’, ‘value’,
          ‘key-or-value’, ‘key-and-value’, or ‘t’ which is an alias for
          ‘key-and-value’.  If WEAK is ‘key’ then the hash table does
          not prevent its keys from being collected as garbage (if they
          are not referenced anywhere else); if a particular key does
          get collected, the corresponding association is removed from
          the hash table.

          If WEAK is ‘value’, then the hash table does not prevent
          values from being collected as garbage (if they are not
          referenced anywhere else); if a particular value does get
          collected, the corresponding association is removed from the
          hash table.

          If WEAK is ‘key-and-value’ or ‘t’, both the key and the value
          must be live in order to preserve the association.  Thus, the
          hash table does not protect either keys or values from garbage
          collection; if either one is collected as garbage, that
          removes the association.

          If WEAK is ‘key-or-value’, either the key or the value can
          preserve the association.  Thus, associations are removed from
          the hash table when both their key and value would be
          collected as garbage (if not for references from weak hash
          tables).

          The default for WEAK is ‘nil’, so that all keys and values
          referenced in the hash table are preserved from garbage
          collection.

     ‘:size SIZE’
          This specifies a hint for how many associations you plan to
          store in the hash table.  If you know the approximate number,
          you can make things a little more efficient by specifying it
          this way.  If you specify too small a size, the hash table
          will grow automatically when necessary, but doing that takes
          some extra time.

          The default size is 65.

     ‘:rehash-size REHASH-SIZE’
          When you add an association to a hash table and the table is
          full, it grows automatically.  This value specifies how to
          make the hash table larger, at that time.

          If REHASH-SIZE is an integer, it should be positive, and the
          hash table grows by adding approximately that much to the
          nominal size.  If REHASH-SIZE is floating point, it had better
          be greater than 1, and the hash table grows by multiplying the
          old size by approximately that number.

          The default value is 1.5.

     ‘:rehash-threshold THRESHOLD’
          This specifies the criterion for when the hash table is full
          (so it should be made larger).  The value, THRESHOLD, should
          be a positive floating-point number, no greater than 1.  The
          hash table is full whenever the actual number of entries
          exceeds the nominal size multiplied by an approximation to
          this value.  The default for THRESHOLD is 0.8125.

   You can also create a new hash table using the printed representation
for hash tables.  The Lisp reader can read this printed representation,
provided each element in the specified hash table has a valid read
syntax (*note Printed Representation::).  For instance, the following
specifies a new hash table containing the keys ‘key1’ and ‘key2’ (both
symbols) associated with ‘val1’ (a symbol) and ‘300’ (a number)
respectively.

     #s(hash-table size 30 data (key1 val1 key2 300))

The printed representation for a hash table consists of ‘#s’ followed by
a list beginning with ‘hash-table’.  The rest of the list should consist
of zero or more property-value pairs specifying the hash table’s
properties and initial contents.  The properties and values are read
literally.  Valid property names are ‘size’, ‘test’, ‘weakness’,
‘rehash-size’, ‘rehash-threshold’, and ‘data’.  The ‘data’ property
should be a list of key-value pairs for the initial contents; the other
properties have the same meanings as the matching ‘make-hash-table’
keywords (‘:size’, ‘:test’, etc.), described above.

   Note that you cannot specify a hash table whose initial contents
include objects that have no read syntax, such as buffers and frames.
Such objects may be added to the hash table after it is created.


File: elisp.info,  Node: Hash Access,  Next: Defining Hash,  Prev: Creating Hash,  Up: Hash Tables

8.2 Hash Table Access
=====================

This section describes the functions for accessing and storing
associations in a hash table.  In general, any Lisp object can be used
as a hash key, unless the comparison method imposes limits.  Any Lisp
object can also be used as the value.

 -- Function: gethash key table &optional default
     This function looks up KEY in TABLE, and returns its associated
     VALUE—or DEFAULT, if KEY has no association in TABLE.

 -- Function: puthash key value table
     This function enters an association for KEY in TABLE, with value
     VALUE.  If KEY already has an association in TABLE, VALUE replaces
     the old associated value.

 -- Function: remhash key table
     This function removes the association for KEY from TABLE, if there
     is one.  If KEY has no association, ‘remhash’ does nothing.

     Common Lisp note: In Common Lisp, ‘remhash’ returns non-‘nil’ if it
     actually removed an association and ‘nil’ otherwise.  In Emacs
     Lisp, ‘remhash’ always returns ‘nil’.

 -- Function: clrhash table
     This function removes all the associations from hash table TABLE,
     so that it becomes empty.  This is also called “clearing” the hash
     table.

     Common Lisp note: In Common Lisp, ‘clrhash’ returns the empty
     TABLE.  In Emacs Lisp, it returns ‘nil’.

 -- Function: maphash function table
     This function calls FUNCTION once for each of the associations in
     TABLE.  The function FUNCTION should accept two arguments—a KEY
     listed in TABLE, and its associated VALUE.  ‘maphash’ returns
     ‘nil’.


File: elisp.info,  Node: Defining Hash,  Next: Other Hash,  Prev: Hash Access,  Up: Hash Tables

8.3 Defining Hash Comparisons
=============================

You can define new methods of key lookup by means of
‘define-hash-table-test’.  In order to use this feature, you need to
understand how hash tables work, and what a “hash code” means.

   You can think of a hash table conceptually as a large array of many
slots, each capable of holding one association.  To look up a key,
‘gethash’ first computes an integer, the hash code, from the key.  It
reduces this integer modulo the length of the array, to produce an index
in the array.  Then it looks in that slot, and if necessary in other
nearby slots, to see if it has found the key being sought.

   Thus, to define a new method of key lookup, you need to specify both
a function to compute the hash code from a key, and a function to
compare two keys directly.

 -- Function: define-hash-table-test name test-fn hash-fn
     This function defines a new hash table test, named NAME.

     After defining NAME in this way, you can use it as the TEST
     argument in ‘make-hash-table’.  When you do that, the hash table
     will use TEST-FN to compare key values, and HASH-FN to compute a
     hash code from a key value.

     The function TEST-FN should accept two arguments, two keys, and
     return non-‘nil’ if they are considered the same.

     The function HASH-FN should accept one argument, a key, and return
     an integer that is the hash code of that key.  For good results,
     the function should use the whole range of integers for hash codes,
     including negative integers.

     The specified functions are stored in the property list of NAME
     under the property ‘hash-table-test’; the property value’s form is
     ‘(TEST-FN HASH-FN)’.

 -- Function: sxhash-equal obj
     This function returns a hash code for Lisp object OBJ.  This is an
     integer which reflects the contents of OBJ and the other Lisp
     objects it points to.

     If two objects OBJ1 and OBJ2 are ‘equal’, then ‘(sxhash-equal
     OBJ1)’ and ‘(sxhash-equal OBJ2)’ are the same integer.

     If the two objects are not ‘equal’, the values returned by
     ‘sxhash-equal’ are usually different, but not always; once in a
     rare while, by luck, you will encounter two distinct-looking
     objects that give the same result from ‘sxhash-equal’.

     Common Lisp note: In Common Lisp a similar function is called
     ‘sxhash’.  Emacs provides this name as a compatibility alias for
     ‘sxhash-equal’.

 -- Function: sxhash-eq obj
     This function returns a hash code for Lisp object OBJ.  Its result
     reflects identity of OBJ, but not its contents.

     If two objects OBJ1 and OBJ2 are ‘eq’, then ‘(sxhash-eq OBJ1)’ and
     ‘(sxhash-eq OBJ2)’ are the same integer.

 -- Function: sxhash-eql obj
     This function returns a hash code for Lisp object OBJ suitable for
     ‘eql’ comparison.  I.e.  it reflects identity of OBJ except for the
     case where the object is a float number, in which case hash code is
     generated for the value.

     If two objects OBJ1 and OBJ2 are ‘eql’, then ‘(sxhash-eql OBJ1)’
     and ‘(sxhash-eql OBJ2)’ are the same integer.

   This example creates a hash table whose keys are strings that are
compared case-insensitively.

     (defun case-fold-string= (a b)
       (eq t (compare-strings a nil nil b nil nil t)))
     (defun case-fold-string-hash (a)
       (sxhash-equal (upcase a)))

     (define-hash-table-test 'case-fold
       'case-fold-string= 'case-fold-string-hash)

     (make-hash-table :test 'case-fold)

   Here is how you could define a hash table test equivalent to the
predefined test value ‘equal’.  The keys can be any Lisp object, and
equal-looking objects are considered the same key.

     (define-hash-table-test 'contents-hash 'equal 'sxhash-equal)

     (make-hash-table :test 'contents-hash)


File: elisp.info,  Node: Other Hash,  Prev: Defining Hash,  Up: Hash Tables

8.4 Other Hash Table Functions
==============================

Here are some other functions for working with hash tables.

 -- Function: hash-table-p table
     This returns non-‘nil’ if TABLE is a hash table object.

 -- Function: copy-hash-table table
     This function creates and returns a copy of TABLE.  Only the table
     itself is copied—the keys and values are shared.

 -- Function: hash-table-count table
     This function returns the actual number of entries in TABLE.

 -- Function: hash-table-test table
     This returns the TEST value that was given when TABLE was created,
     to specify how to hash and compare keys.  See ‘make-hash-table’
     (*note Creating Hash::).

 -- Function: hash-table-weakness table
     This function returns the WEAK value that was specified for hash
     table TABLE.

 -- Function: hash-table-rehash-size table
     This returns the rehash size of TABLE.

 -- Function: hash-table-rehash-threshold table
     This returns the rehash threshold of TABLE.

 -- Function: hash-table-size table
     This returns the current nominal size of TABLE.


File: elisp.info,  Node: Symbols,  Next: Evaluation,  Prev: Hash Tables,  Up: Top

9 Symbols
*********

A “symbol” is an object with a unique name.  This chapter describes
symbols, their components, their property lists, and how they are
created and interned.  Separate chapters describe the use of symbols as
variables and as function names; see *note Variables::, and *note
Functions::.  For the precise read syntax for symbols, see *note Symbol
Type::.

   You can test whether an arbitrary Lisp object is a symbol with
‘symbolp’:

 -- Function: symbolp object
     This function returns ‘t’ if OBJECT is a symbol, ‘nil’ otherwise.

* Menu:

* Symbol Components::        Symbols have names, values, function definitions
                               and property lists.
* Definitions::              A definition says how a symbol will be used.
* Creating Symbols::         How symbols are kept unique.
* Symbol Properties::        Each symbol has a property list
                               for recording miscellaneous information.


File: elisp.info,  Node: Symbol Components,  Next: Definitions,  Up: Symbols

9.1 Symbol Components
=====================

Each symbol has four components (or “cells”), each of which references
another object:

Print name
     The symbol’s name.

Value
     The symbol’s current value as a variable.

Function
     The symbol’s function definition.  It can also hold a symbol, a
     keymap, or a keyboard macro.

Property list
     The symbol’s property list.

The print name cell always holds a string, and cannot be changed.  Each
of the other three cells can be set to any Lisp object.

   The print name cell holds the string that is the name of a symbol.
Since symbols are represented textually by their names, it is important
not to have two symbols with the same name.  The Lisp reader ensures
this: every time it reads a symbol, it looks for an existing symbol with
the specified name before it creates a new one.  To get a symbol’s name,
use the function ‘symbol-name’ (*note Creating Symbols::).

   The value cell holds a symbol’s value as a variable, which is what
you get if the symbol itself is evaluated as a Lisp expression.  *Note
Variables::, for details about how values are set and retrieved,
including complications such as “local bindings” and “scoping rules”.
Most symbols can have any Lisp object as a value, but certain special
symbols have values that cannot be changed; these include ‘nil’ and ‘t’,
and any symbol whose name starts with ‘:’ (those are called “keywords”).
*Note Constant Variables::.

   The function cell holds a symbol’s function definition.  Often, we
refer to “the function ‘foo’” when we really mean the function stored in
the function cell of ‘foo’; we make the distinction explicit only when
necessary.  Typically, the function cell is used to hold a function
(*note Functions::) or a macro (*note Macros::).  However, it can also
be used to hold a symbol (*note Function Indirection::), keyboard macro
(*note Keyboard Macros::), keymap (*note Keymaps::), or autoload object
(*note Autoloading::).  To get the contents of a symbol’s function cell,
use the function ‘symbol-function’ (*note Function Cells::).

   The property list cell normally should hold a correctly formatted
property list.  To get a symbol’s property list, use the function
‘symbol-plist’.  *Note Symbol Properties::.

   The function cell or the value cell may be “void”, which means that
the cell does not reference any object.  (This is not the same thing as
holding the symbol ‘void’, nor the same as holding the symbol ‘nil’.)
Examining a function or value cell that is void results in an error,
such as ‘Symbol's value as variable is void’.

   Because each symbol has separate value and function cells, variables
names and function names do not conflict.  For example, the symbol
‘buffer-file-name’ has a value (the name of the file being visited in
the current buffer) as well as a function definition (a primitive
function that returns the name of the file):

     buffer-file-name
          ⇒ "/gnu/elisp/symbols.texi"
     (symbol-function 'buffer-file-name)
          ⇒ #<subr buffer-file-name>


File: elisp.info,  Node: Definitions,  Next: Creating Symbols,  Prev: Symbol Components,  Up: Symbols

9.2 Defining Symbols
====================

A “definition” is a special kind of Lisp expression that announces your
intention to use a symbol in a particular way.  It typically specifies a
value or meaning for the symbol for one kind of use, plus documentation
for its meaning when used in this way.  Thus, when you define a symbol
as a variable, you can supply an initial value for the variable, plus
documentation for the variable.

   ‘defvar’ and ‘defconst’ are special forms that define a symbol as a
“global variable”—a variable that can be accessed at any point in a Lisp
program.  *Note Variables::, for details about variables.  To define a
customizable variable, use the ‘defcustom’ macro, which also calls
‘defvar’ as a subroutine (*note Customization::).

   In principle, you can assign a variable value to any symbol with
‘setq’, whether not it has first been defined as a variable.  However,
you ought to write a variable definition for each global variable that
you want to use; otherwise, your Lisp program may not act correctly if
it is evaluated with lexical scoping enabled (*note Variable Scoping::).

   ‘defun’ defines a symbol as a function, creating a lambda expression
and storing it in the function cell of the symbol.  This lambda
expression thus becomes the function definition of the symbol.  (The
term “function definition”, meaning the contents of the function cell,
is derived from the idea that ‘defun’ gives the symbol its definition as
a function.)  ‘defsubst’ and ‘defalias’ are two other ways of defining a
function.  *Note Functions::.

   ‘defmacro’ defines a symbol as a macro.  It creates a macro object
and stores it in the function cell of the symbol.  Note that a given
symbol can be a macro or a function, but not both at once, because both
macro and function definitions are kept in the function cell, and that
cell can hold only one Lisp object at any given time.  *Note Macros::.

   As previously noted, Emacs Lisp allows the same symbol to be defined
both as a variable (e.g., with ‘defvar’) and as a function or macro
(e.g., with ‘defun’).  Such definitions do not conflict.

   These definitions also act as guides for programming tools.  For
example, the ‘C-h f’ and ‘C-h v’ commands create help buffers containing
links to the relevant variable, function, or macro definitions.  *Note
(emacs)Name Help::.


File: elisp.info,  Node: Creating Symbols,  Next: Symbol Properties,  Prev: Definitions,  Up: Symbols

9.3 Creating and Interning Symbols
==================================

To understand how symbols are created in GNU Emacs Lisp, you must know
how Lisp reads them.  Lisp must ensure that it finds the same symbol
every time it reads the same set of characters.  Failure to do so would
cause complete confusion.

   When the Lisp reader encounters a symbol, it reads all the characters
of the name.  Then it hashes those characters to find an index in a
table called an “obarray”.  Hashing is an efficient method of looking
something up.  For example, instead of searching a telephone book cover
to cover when looking up Jan Jones, you start with the J’s and go from
there.  That is a simple version of hashing.  Each element of the
obarray is a “bucket” which holds all the symbols with a given hash
code; to look for a given name, it is sufficient to look through all the
symbols in the bucket for that name’s hash code.  (The same idea is used
for general Emacs hash tables, but they are a different data type; see
*note Hash Tables::.)

   If a symbol with the desired name is found, the reader uses that
symbol.  If the obarray does not contain a symbol with that name, the
reader makes a new symbol and adds it to the obarray.  Finding or adding
a symbol with a certain name is called “interning” it, and the symbol is
then called an “interned symbol”.

   Interning ensures that each obarray has just one symbol with any
particular name.  Other like-named symbols may exist, but not in the
same obarray.  Thus, the reader gets the same symbols for the same
names, as long as you keep reading with the same obarray.

   Interning usually happens automatically in the reader, but sometimes
other programs need to do it.  For example, after the ‘M-x’ command
obtains the command name as a string using the minibuffer, it then
interns the string, to get the interned symbol with that name.

   No obarray contains all symbols; in fact, some symbols are not in any
obarray.  They are called “uninterned symbols”.  An uninterned symbol
has the same four cells as other symbols; however, the only way to gain
access to it is by finding it in some other object or as the value of a
variable.

   Creating an uninterned symbol is useful in generating Lisp code,
because an uninterned symbol used as a variable in the code you generate
cannot clash with any variables used in other Lisp programs.

   In Emacs Lisp, an obarray is actually a vector.  Each element of the
vector is a bucket; its value is either an interned symbol whose name
hashes to that bucket, or 0 if the bucket is empty.  Each interned
symbol has an internal link (invisible to the user) to the next symbol
in the bucket.  Because these links are invisible, there is no way to
find all the symbols in an obarray except using ‘mapatoms’ (below).  The
order of symbols in a bucket is not significant.

   In an empty obarray, every element is 0, so you can create an obarray
with ‘(make-vector LENGTH 0)’.  *This is the only valid way to create an
obarray.*  Prime numbers as lengths tend to result in good hashing;
lengths one less than a power of two are also good.

   *Do not try to put symbols in an obarray yourself.*  This does not
work—only ‘intern’ can enter a symbol in an obarray properly.

     Common Lisp note: Unlike Common Lisp, Emacs Lisp does not provide
     for interning a single symbol in several obarrays.

   Most of the functions below take a name and sometimes an obarray as
arguments.  A ‘wrong-type-argument’ error is signaled if the name is not
a string, or if the obarray is not a vector.

 -- Function: symbol-name symbol
     This function returns the string that is SYMBOL’s name.  For
     example:

          (symbol-name 'foo)
               ⇒ "foo"

     *Warning:* Changing the string by substituting characters does
     change the name of the symbol, but fails to update the obarray, so
     don’t do it!

 -- Function: make-symbol name
     This function returns a newly-allocated, uninterned symbol whose
     name is NAME (which must be a string).  Its value and function
     definition are void, and its property list is ‘nil’.  In the
     example below, the value of ‘sym’ is not ‘eq’ to ‘foo’ because it
     is a distinct uninterned symbol whose name is also ‘foo’.

          (setq sym (make-symbol "foo"))
               ⇒ foo
          (eq sym 'foo)
               ⇒ nil

 -- Function: gensym &optional prefix
     This function returns a symbol using ‘make-symbol’, whose name is
     made by appending ‘gensym-counter’ to PREFIX.  The prefix defaults
     to ‘"g"’.

 -- Function: intern name &optional obarray
     This function returns the interned symbol whose name is NAME.  If
     there is no such symbol in the obarray OBARRAY, ‘intern’ creates a
     new one, adds it to the obarray, and returns it.  If OBARRAY is
     omitted, the value of the global variable ‘obarray’ is used.

          (setq sym (intern "foo"))
               ⇒ foo
          (eq sym 'foo)
               ⇒ t

          (setq sym1 (intern "foo" other-obarray))
               ⇒ foo
          (eq sym1 'foo)
               ⇒ nil

     Common Lisp note: In Common Lisp, you can intern an existing symbol
     in an obarray.  In Emacs Lisp, you cannot do this, because the
     argument to ‘intern’ must be a string, not a symbol.

 -- Function: intern-soft name &optional obarray
     This function returns the symbol in OBARRAY whose name is NAME, or
     ‘nil’ if OBARRAY has no symbol with that name.  Therefore, you can
     use ‘intern-soft’ to test whether a symbol with a given name is
     already interned.  If OBARRAY is omitted, the value of the global
     variable ‘obarray’ is used.

     The argument NAME may also be a symbol; in that case, the function
     returns NAME if NAME is interned in the specified obarray, and
     otherwise ‘nil’.

          (intern-soft "frazzle")        ; No such symbol exists.
               ⇒ nil
          (make-symbol "frazzle")        ; Create an uninterned one.
               ⇒ frazzle
          (intern-soft "frazzle")        ; That one cannot be found.
               ⇒ nil
          (setq sym (intern "frazzle"))  ; Create an interned one.
               ⇒ frazzle
          (intern-soft "frazzle")        ; That one can be found!
               ⇒ frazzle
          (eq sym 'frazzle)              ; And it is the same one.
               ⇒ t

 -- Variable: obarray
     This variable is the standard obarray for use by ‘intern’ and
     ‘read’.

 -- Function: mapatoms function &optional obarray
     This function calls FUNCTION once with each symbol in the obarray
     OBARRAY.  Then it returns ‘nil’.  If OBARRAY is omitted, it
     defaults to the value of ‘obarray’, the standard obarray for
     ordinary symbols.

          (setq count 0)
               ⇒ 0
          (defun count-syms (s)
            (setq count (1+ count)))
               ⇒ count-syms
          (mapatoms 'count-syms)
               ⇒ nil
          count
               ⇒ 1871

     See ‘documentation’ in *note Accessing Documentation::, for another
     example using ‘mapatoms’.

 -- Function: unintern symbol obarray
     This function deletes SYMBOL from the obarray OBARRAY.  If ‘symbol’
     is not actually in the obarray, ‘unintern’ does nothing.  If
     OBARRAY is ‘nil’, the current obarray is used.

     If you provide a string instead of a symbol as SYMBOL, it stands
     for a symbol name.  Then ‘unintern’ deletes the symbol (if any) in
     the obarray which has that name.  If there is no such symbol,
     ‘unintern’ does nothing.

     If ‘unintern’ does delete a symbol, it returns ‘t’.  Otherwise it
     returns ‘nil’.


File: elisp.info,  Node: Symbol Properties,  Prev: Creating Symbols,  Up: Symbols

9.4 Symbol Properties
=====================

A symbol may possess any number of “symbol properties”, which can be
used to record miscellaneous information about the symbol.  For example,
when a symbol has a ‘risky-local-variable’ property with a non-‘nil’
value, that means the variable which the symbol names is a risky
file-local variable (*note File Local Variables::).

   Each symbol’s properties and property values are stored in the
symbol’s property list cell (*note Symbol Components::), in the form of
a property list (*note Property Lists::).

* Menu:

* Symbol Plists::        Accessing symbol properties.
* Standard Properties::  Standard meanings of symbol properties.


File: elisp.info,  Node: Symbol Plists,  Next: Standard Properties,  Up: Symbol Properties

9.4.1 Accessing Symbol Properties
---------------------------------

The following functions can be used to access symbol properties.

 -- Function: get symbol property
     This function returns the value of the property named PROPERTY in
     SYMBOL’s property list.  If there is no such property, it returns
     ‘nil’.  Thus, there is no distinction between a value of ‘nil’ and
     the absence of the property.

     The name PROPERTY is compared with the existing property names
     using ‘eq’, so any object is a legitimate property.

     See ‘put’ for an example.

 -- Function: put symbol property value
     This function puts VALUE onto SYMBOL’s property list under the
     property name PROPERTY, replacing any previous property value.  The
     ‘put’ function returns VALUE.

          (put 'fly 'verb 'transitive)
               ⇒'transitive
          (put 'fly 'noun '(a buzzing little bug))
               ⇒ (a buzzing little bug)
          (get 'fly 'verb)
               ⇒ transitive
          (symbol-plist 'fly)
               ⇒ (verb transitive noun (a buzzing little bug))

 -- Function: symbol-plist symbol
     This function returns the property list of SYMBOL.

 -- Function: setplist symbol plist
     This function sets SYMBOL’s property list to PLIST.  Normally,
     PLIST should be a well-formed property list, but this is not
     enforced.  The return value is PLIST.

          (setplist 'foo '(a 1 b (2 3) c nil))
               ⇒ (a 1 b (2 3) c nil)
          (symbol-plist 'foo)
               ⇒ (a 1 b (2 3) c nil)

     For symbols in special obarrays, which are not used for ordinary
     purposes, it may make sense to use the property list cell in a
     nonstandard fashion; in fact, the abbrev mechanism does so (*note
     Abbrevs::).

     You could define ‘put’ in terms of ‘setplist’ and ‘plist-put’, as
     follows:

          (defun put (symbol prop value)
            (setplist symbol
                      (plist-put (symbol-plist symbol) prop value)))

 -- Function: function-get symbol property &optional autoload
     This function is identical to ‘get’, except that if SYMBOL is the
     name of a function alias, it looks in the property list of the
     symbol naming the actual function.  *Note Defining Functions::.  If
     the optional argument AUTOLOAD is non-‘nil’, and SYMBOL is
     auto-loaded, this function will try to autoload it, since
     autoloading might set PROPERTY of SYMBOL.  If AUTOLOAD is the
     symbol ‘macro’, only try autoloading if SYMBOL is an auto-loaded
     macro.

 -- Function: function-put function property value
     This function sets PROPERTY of FUNCTION to VALUE.  FUNCTION should
     be a symbol.  This function is preferred to calling ‘put’ for
     setting properties of a function, because it will allow us some day
     to implement remapping of old properties to new ones.


File: elisp.info,  Node: Standard Properties,  Prev: Symbol Plists,  Up: Symbol Properties

9.4.2 Standard Symbol Properties
--------------------------------

Here, we list the symbol properties which are used for special purposes
in Emacs.  In the following table, whenever we say “the named function”,
that means the function whose name is the relevant symbol; similarly for
“the named variable” etc.

‘:advertised-binding’
     This property value specifies the preferred key binding, when
     showing documentation, for the named function.  *Note Keys in
     Documentation::.

‘char-table-extra-slots’
     The value, if non-‘nil’, specifies the number of extra slots in the
     named char-table type.  *Note Char-Tables::.

‘customized-face’
‘face-defface-spec’
‘saved-face’
‘theme-face’
     These properties are used to record a face’s standard, saved,
     customized, and themed face specs.  Do not set them directly; they
     are managed by ‘defface’ and related functions.  *Note Defining
     Faces::.

‘customized-value’
‘saved-value’
‘standard-value’
‘theme-value’
     These properties are used to record a customizable variable’s
     standard value, saved value, customized-but-unsaved value, and
     themed values.  Do not set them directly; they are managed by
     ‘defcustom’ and related functions.  *Note Variable Definitions::.

‘disabled’
     If the value is non-‘nil’, the named function is disabled as a
     command.  *Note Disabling Commands::.

‘face-documentation’
     The value stores the documentation string of the named face.  This
     is set automatically by ‘defface’.  *Note Defining Faces::.

‘history-length’
     The value, if non-‘nil’, specifies the maximum minibuffer history
     length for the named history list variable.  *Note Minibuffer
     History::.

‘interactive-form’
     The value is an interactive form for the named function.  Normally,
     you should not set this directly; use the ‘interactive’ special
     form instead.  *Note Interactive Call::.

‘menu-enable’
     The value is an expression for determining whether the named menu
     item should be enabled in menus.  *Note Simple Menu Items::.

‘mode-class’
     If the value is ‘special’, the named major mode is special.  *Note
     Major Mode Conventions::.

‘permanent-local’
     If the value is non-‘nil’, the named variable is a buffer-local
     variable whose value should not be reset when changing major modes.
     *Note Creating Buffer-Local::.

‘permanent-local-hook’
     If the value is non-‘nil’, the named function should not be deleted
     from the local value of a hook variable when changing major modes.
     *Note Setting Hooks::.

‘pure’
     If the value is non-‘nil’, the named function is considered to be
     side-effect free.  Calls with constant arguments can be evaluated
     at compile time.  This may shift run time errors to compile time.

‘risky-local-variable’
     If the value is non-‘nil’, the named variable is considered risky
     as a file-local variable.  *Note File Local Variables::.

‘safe-function’
     If the value is non-‘nil’, the named function is considered
     generally safe for evaluation.  *Note Function Safety::.

‘safe-local-eval-function’
     If the value is non-‘nil’, the named function is safe to call in
     file-local evaluation forms.  *Note File Local Variables::.

‘safe-local-variable’
     The value specifies a function for determining safe file-local
     values for the named variable.  *Note File Local Variables::.

‘side-effect-free’
     A non-‘nil’ value indicates that the named function is free of
     side-effects, for determining function safety (*note Function
     Safety::) as well as for byte compiler optimizations.  Do not set
     it.

‘variable-documentation’
     If non-‘nil’, this specifies the named variable’s documentation
     string.  This is set automatically by ‘defvar’ and related
     functions.  *Note Defining Faces::.


File: elisp.info,  Node: Evaluation,  Next: Control Structures,  Prev: Symbols,  Up: Top

10 Evaluation
*************

The “evaluation” of expressions in Emacs Lisp is performed by the “Lisp
interpreter”—a program that receives a Lisp object as input and computes
its “value as an expression”.  How it does this depends on the data type
of the object, according to rules described in this chapter.  The
interpreter runs automatically to evaluate portions of your program, but
can also be called explicitly via the Lisp primitive function ‘eval’.

* Menu:

* Intro Eval::  Evaluation in the scheme of things.
* Forms::       How various sorts of objects are evaluated.
* Quoting::     Avoiding evaluation (to put constants in the program).
* Backquote::   Easier construction of list structure.
* Eval::        How to invoke the Lisp interpreter explicitly.


File: elisp.info,  Node: Intro Eval,  Next: Forms,  Up: Evaluation

10.1 Introduction to Evaluation
===============================

The Lisp interpreter, or evaluator, is the part of Emacs that computes
the value of an expression that is given to it.  When a function written
in Lisp is called, the evaluator computes the value of the function by
evaluating the expressions in the function body.  Thus, running any Lisp
program really means running the Lisp interpreter.

   A Lisp object that is intended for evaluation is called a “form” or
“expression”(1).  The fact that forms are data objects and not merely
text is one of the fundamental differences between Lisp-like languages
and typical programming languages.  Any object can be evaluated, but in
practice only numbers, symbols, lists and strings are evaluated very
often.

   In subsequent sections, we will describe the details of what
evaluation means for each kind of form.

   It is very common to read a Lisp form and then evaluate the form, but
reading and evaluation are separate activities, and either can be
performed alone.  Reading per se does not evaluate anything; it converts
the printed representation of a Lisp object to the object itself.  It is
up to the caller of ‘read’ to specify whether this object is a form to
be evaluated, or serves some entirely different purpose.  *Note Input
Functions::.

   Evaluation is a recursive process, and evaluating a form often
involves evaluating parts within that form.  For instance, when you
evaluate a “function call” form such as ‘(car x)’, Emacs first evaluates
the argument (the subform ‘x’).  After evaluating the argument, Emacs
“executes” the function (‘car’), and if the function is written in Lisp,
execution works by evaluating the “body” of the function (in this
example, however, ‘car’ is not a Lisp function; it is a primitive
function implemented in C). *Note Functions::, for more information
about functions and function calls.

   Evaluation takes place in a context called the “environment”, which
consists of the current values and bindings of all Lisp variables (*note
Variables::).(2)  Whenever a form refers to a variable without creating
a new binding for it, the variable evaluates to the value given by the
current environment.  Evaluating a form may also temporarily alter the
environment by binding variables (*note Local Variables::).

   Evaluating a form may also make changes that persist; these changes
are called “side effects”.  An example of a form that produces a side
effect is ‘(setq foo 1)’.

   Do not confuse evaluation with command key interpretation.  The
editor command loop translates keyboard input into a command (an
interactively callable function) using the active keymaps, and then uses
‘call-interactively’ to execute that command.  Executing the command
usually involves evaluation, if the command is written in Lisp; however,
this step is not considered a part of command key interpretation.  *Note
Command Loop::.

   ---------- Footnotes ----------

   (1) It is sometimes also referred to as an “S-expression” or “sexp”,
but we generally do not use this terminology in this manual.

   (2) This definition of “environment” is specifically not intended to
include all the data that can affect the result of a program.


File: elisp.info,  Node: Forms,  Next: Quoting,  Prev: Intro Eval,  Up: Evaluation

10.2 Kinds of Forms
===================

A Lisp object that is intended to be evaluated is called a “form” (or an
“expression”).  How Emacs evaluates a form depends on its data type.
Emacs has three different kinds of form that are evaluated differently:
symbols, lists, and all other types.  This section describes all three
kinds, one by one, starting with the other types, which are
self-evaluating forms.

* Menu:

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Indirection::    When a symbol appears as the car of a list,
                              we find the real function via the symbol.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           Special forms are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.


File: elisp.info,  Node: Self-Evaluating Forms,  Next: Symbol Forms,  Up: Forms

10.2.1 Self-Evaluating Forms
----------------------------

A “self-evaluating form” is any form that is not a list or symbol.
Self-evaluating forms evaluate to themselves: the result of evaluation
is the same object that was evaluated.  Thus, the number 25 evaluates to
25, and the string ‘"foo"’ evaluates to the string ‘"foo"’.  Likewise,
evaluating a vector does not cause evaluation of the elements of the
vector—it returns the same vector with its contents unchanged.

     '123               ; A number, shown without evaluation.
          ⇒ 123
     123                ; Evaluated as usual—result is the same.
          ⇒ 123
     (eval '123)        ; Evaluated "by hand"—result is the same.
          ⇒ 123
     (eval (eval '123)) ; Evaluating twice changes nothing.
          ⇒ 123

   It is common to write numbers, characters, strings, and even vectors
in Lisp code, taking advantage of the fact that they self-evaluate.
However, it is quite unusual to do this for types that lack a read
syntax, because there’s no way to write them textually.  It is possible
to construct Lisp expressions containing these types by means of a Lisp
program.  Here is an example:

     ;; Build an expression containing a buffer object.
     (setq print-exp (list 'print (current-buffer)))
          ⇒ (print #<buffer eval.texi>)
     ;; Evaluate it.
     (eval print-exp)
          ⊣ #<buffer eval.texi>
          ⇒ #<buffer eval.texi>


File: elisp.info,  Node: Symbol Forms,  Next: Classifying Lists,  Prev: Self-Evaluating Forms,  Up: Forms

10.2.2 Symbol Forms
-------------------

When a symbol is evaluated, it is treated as a variable.  The result is
the variable’s value, if it has one.  If the symbol has no value as a
variable, the Lisp interpreter signals an error.  For more information
on the use of variables, see *note Variables::.

   In the following example, we set the value of a symbol with ‘setq’.
Then we evaluate the symbol, and get back the value that ‘setq’ stored.

     (setq a 123)
          ⇒ 123
     (eval 'a)
          ⇒ 123
     a
          ⇒ 123

   The symbols ‘nil’ and ‘t’ are treated specially, so that the value of
‘nil’ is always ‘nil’, and the value of ‘t’ is always ‘t’; you cannot
set or bind them to any other values.  Thus, these two symbols act like
self-evaluating forms, even though ‘eval’ treats them like any other
symbol.  A symbol whose name starts with ‘:’ also self-evaluates in the
same way; likewise, its value ordinarily cannot be changed.  *Note
Constant Variables::.


File: elisp.info,  Node: Classifying Lists,  Next: Function Indirection,  Prev: Symbol Forms,  Up: Forms

10.2.3 Classification of List Forms
-----------------------------------

A form that is a nonempty list is either a function call, a macro call,
or a special form, according to its first element.  These three kinds of
forms are evaluated in different ways, described below.  The remaining
list elements constitute the “arguments” for the function, macro, or
special form.

   The first step in evaluating a nonempty list is to examine its first
element.  This element alone determines what kind of form the list is
and how the rest of the list is to be processed.  The first element is
_not_ evaluated, as it would be in some Lisp dialects such as Scheme.


File: elisp.info,  Node: Function Indirection,  Next: Function Forms,  Prev: Classifying Lists,  Up: Forms

10.2.4 Symbol Function Indirection
----------------------------------

If the first element of the list is a symbol then evaluation examines
the symbol’s function cell, and uses its contents instead of the
original symbol.  If the contents are another symbol, this process,
called “symbol function indirection”, is repeated until it obtains a
non-symbol.  *Note Function Names::, for more information about symbol
function indirection.

   One possible consequence of this process is an infinite loop, in the
event that a symbol’s function cell refers to the same symbol.
Otherwise, we eventually obtain a non-symbol, which ought to be a
function or other suitable object.

   More precisely, we should now have a Lisp function (a lambda
expression), a byte-code function, a primitive function, a Lisp macro, a
special form, or an autoload object.  Each of these types is a case
described in one of the following sections.  If the object is not one of
these types, Emacs signals an ‘invalid-function’ error.

   The following example illustrates the symbol indirection process.  We
use ‘fset’ to set the function cell of a symbol and ‘symbol-function’ to
get the function cell contents (*note Function Cells::).  Specifically,
we store the symbol ‘car’ into the function cell of ‘first’, and the
symbol ‘first’ into the function cell of ‘erste’.

     ;; Build this function cell linkage:
     ;;   -------------       -----        -------        -------
     ;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
     ;;   -------------       -----        -------        -------
     (symbol-function 'car)
          ⇒ #<subr car>
     (fset 'first 'car)
          ⇒ car
     (fset 'erste 'first)
          ⇒ first
     (erste '(1 2 3))   ; Call the function referenced by ‘erste’.
          ⇒ 1

   By contrast, the following example calls a function without any
symbol function indirection, because the first element is an anonymous
Lisp function, not a symbol.

     ((lambda (arg) (erste arg))
      '(1 2 3))
          ⇒ 1

Executing the function itself evaluates its body; this does involve
symbol function indirection when calling ‘erste’.

   This form is rarely used and is now deprecated.  Instead, you should
write it as:

     (funcall (lambda (arg) (erste arg))
              '(1 2 3))
   or just
     (let ((arg '(1 2 3))) (erste arg))

   The built-in function ‘indirect-function’ provides an easy way to
perform symbol function indirection explicitly.

 -- Function: indirect-function function &optional noerror
     This function returns the meaning of FUNCTION as a function.  If
     FUNCTION is a symbol, then it finds FUNCTION’s function definition
     and starts over with that value.  If FUNCTION is not a symbol, then
     it returns FUNCTION itself.

     This function returns ‘nil’ if the final symbol is unbound.  It
     signals a ‘cyclic-function-indirection’ error if there is a loop in
     the chain of symbols.

     The optional argument NOERROR is obsolete, kept for backward
     compatibility, and has no effect.

     Here is how you could define ‘indirect-function’ in Lisp:

          (defun indirect-function (function)
            (if (symbolp function)
                (indirect-function (symbol-function function))
              function))


File: elisp.info,  Node: Function Forms,  Next: Macro Forms,  Prev: Function Indirection,  Up: Forms

10.2.5 Evaluation of Function Forms
-----------------------------------

If the first element of a list being evaluated is a Lisp function
object, byte-code object or primitive function object, then that list is
a “function call”.  For example, here is a call to the function ‘+’:

     (+ 1 x)

   The first step in evaluating a function call is to evaluate the
remaining elements of the list from left to right.  The results are the
actual argument values, one value for each list element.  The next step
is to call the function with this list of arguments, effectively using
the function ‘apply’ (*note Calling Functions::).  If the function is
written in Lisp, the arguments are used to bind the argument variables
of the function (*note Lambda Expressions::); then the forms in the
function body are evaluated in order, and the value of the last body
form becomes the value of the function call.


File: elisp.info,  Node: Macro Forms,  Next: Special Forms,  Prev: Function Forms,  Up: Forms

10.2.6 Lisp Macro Evaluation
----------------------------

If the first element of a list being evaluated is a macro object, then
the list is a “macro call”.  When a macro call is evaluated, the
elements of the rest of the list are _not_ initially evaluated.
Instead, these elements themselves are used as the arguments of the
macro.  The macro definition computes a replacement form, called the
“expansion” of the macro, to be evaluated in place of the original form.
The expansion may be any sort of form: a self-evaluating constant, a
symbol, or a list.  If the expansion is itself a macro call, this
process of expansion repeats until some other sort of form results.

   Ordinary evaluation of a macro call finishes by evaluating the
expansion.  However, the macro expansion is not necessarily evaluated
right away, or at all, because other programs also expand macro calls,
and they may or may not evaluate the expansions.

   Normally, the argument expressions are not evaluated as part of
computing the macro expansion, but instead appear as part of the
expansion, so they are computed when the expansion is evaluated.

   For example, given a macro defined as follows:

     (defmacro cadr (x)
       (list 'car (list 'cdr x)))

an expression such as ‘(cadr (assq 'handler list))’ is a macro call, and
its expansion is:

     (car (cdr (assq 'handler list)))

Note that the argument ‘(assq 'handler list)’ appears in the expansion.

   *Note Macros::, for a complete description of Emacs Lisp macros.


File: elisp.info,  Node: Special Forms,  Next: Autoloading,  Prev: Macro Forms,  Up: Forms

10.2.7 Special Forms
--------------------

A “special form” is a primitive function specially marked so that its
arguments are not all evaluated.  Most special forms define control
structures or perform variable bindings—things which functions cannot
do.

   Each special form has its own rules for which arguments are evaluated
and which are used without evaluation.  Whether a particular argument is
evaluated may depend on the results of evaluating other arguments.

   If an expression’s first symbol is that of a special form, the
expression should follow the rules of that special form; otherwise,
Emacs’s behavior is not well-defined (though it will not crash).  For
example, ‘((lambda (x) x . 3) 4)’ contains a subexpression that begins
with ‘lambda’ but is not a well-formed ‘lambda’ expression, so Emacs may
signal an error, or may return 3 or 4 or ‘nil’, or may behave in other
ways.

 -- Function: special-form-p object
     This predicate tests whether its argument is a special form, and
     returns ‘t’ if so, ‘nil’ otherwise.

   Here is a list, in alphabetical order, of all of the special forms in
Emacs Lisp with a reference to where each is described.

‘and’
     *note Combining Conditions::

‘catch’
     *note Catch and Throw::

‘cond’
     *note Conditionals::

‘condition-case’
     *note Handling Errors::

‘defconst’
     *note Defining Variables::

‘defvar’
     *note Defining Variables::

‘function’
     *note Anonymous Functions::

‘if’
     *note Conditionals::

‘interactive’
     *note Interactive Call::

‘lambda’
     *note Lambda Expressions::

‘let’
‘let*’
     *note Local Variables::

‘or’
     *note Combining Conditions::

‘prog1’
‘prog2’
‘progn’
     *note Sequencing::

‘quote’
     *note Quoting::

‘save-current-buffer’
     *note Current Buffer::

‘save-excursion’
     *note Excursions::

‘save-restriction’
     *note Narrowing::

‘setq’
     *note Setting Variables::

‘setq-default’
     *note Creating Buffer-Local::

‘track-mouse’
     *note Mouse Tracking::

‘unwind-protect’
     *note Nonlocal Exits::

‘while’
     *note Iteration::

     Common Lisp note: Here are some comparisons of special forms in GNU
     Emacs Lisp and Common Lisp.  ‘setq’, ‘if’, and ‘catch’ are special
     forms in both Emacs Lisp and Common Lisp.  ‘save-excursion’ is a
     special form in Emacs Lisp, but doesn’t exist in Common Lisp.
     ‘throw’ is a special form in Common Lisp (because it must be able
     to throw multiple values), but it is a function in Emacs Lisp
     (which doesn’t have multiple values).


File: elisp.info,  Node: Autoloading,  Prev: Special Forms,  Up: Forms

10.2.8 Autoloading
------------------

The “autoload” feature allows you to call a function or macro whose
function definition has not yet been loaded into Emacs.  It specifies
which file contains the definition.  When an autoload object appears as
a symbol’s function definition, calling that symbol as a function
automatically loads the specified file; then it calls the real
definition loaded from that file.  The way to arrange for an autoload
object to appear as a symbol’s function definition is described in *note
Autoload::.


File: elisp.info,  Node: Quoting,  Next: Backquote,  Prev: Forms,  Up: Evaluation

10.3 Quoting
============

The special form ‘quote’ returns its single argument, as written,
without evaluating it.  This provides a way to include constant symbols
and lists, which are not self-evaluating objects, in a program.  (It is
not necessary to quote self-evaluating objects such as numbers, strings,
and vectors.)

 -- Special Form: quote object
     This special form returns OBJECT, without evaluating it.

   Because ‘quote’ is used so often in programs, Lisp provides a
convenient read syntax for it.  An apostrophe character (‘'’) followed
by a Lisp object (in read syntax) expands to a list whose first element
is ‘quote’, and whose second element is the object.  Thus, the read
syntax ‘'x’ is an abbreviation for ‘(quote x)’.

   Here are some examples of expressions that use ‘quote’:

     (quote (+ 1 2))
          ⇒ (+ 1 2)
     (quote foo)
          ⇒ foo
     'foo
          ⇒ foo
     ''foo
          ⇒ (quote foo)
     '(quote foo)
          ⇒ (quote foo)
     ['foo]
          ⇒ [(quote foo)]

   Other quoting constructs include ‘function’ (*note Anonymous
Functions::), which causes an anonymous lambda expression written in
Lisp to be compiled, and ‘`’ (*note Backquote::), which is used to quote
only part of a list, while computing and substituting other parts.


File: elisp.info,  Node: Backquote,  Next: Eval,  Prev: Quoting,  Up: Evaluation

10.4 Backquote
==============

“Backquote constructs” allow you to quote a list, but selectively
evaluate elements of that list.  In the simplest case, it is identical
to the special form ‘quote’ (described in the previous section; *note
Quoting::).  For example, these two forms yield identical results:

     `(a list of (+ 2 3) elements)
          ⇒ (a list of (+ 2 3) elements)
     '(a list of (+ 2 3) elements)
          ⇒ (a list of (+ 2 3) elements)

   The special marker ‘,’ inside of the argument to backquote indicates
a value that isn’t constant.  The Emacs Lisp evaluator evaluates the
argument of ‘,’, and puts the value in the list structure:

     `(a list of ,(+ 2 3) elements)
          ⇒ (a list of 5 elements)

Substitution with ‘,’ is allowed at deeper levels of the list structure
also.  For example:

     `(1 2 (3 ,(+ 4 5)))
          ⇒ (1 2 (3 9))

   You can also “splice” an evaluated value into the resulting list,
using the special marker ‘,@’.  The elements of the spliced list become
elements at the same level as the other elements of the resulting list.
The equivalent code without using ‘`’ is often unreadable.  Here are
some examples:

     (setq some-list '(2 3))
          ⇒ (2 3)
     (cons 1 (append some-list '(4) some-list))
          ⇒ (1 2 3 4 2 3)
     `(1 ,@some-list 4 ,@some-list)
          ⇒ (1 2 3 4 2 3)

     (setq list '(hack foo bar))
          ⇒ (hack foo bar)
     (cons 'use
       (cons 'the
         (cons 'words (append (cdr list) '(as elements)))))
          ⇒ (use the words foo bar as elements)
     `(use the words ,@(cdr list) as elements)
          ⇒ (use the words foo bar as elements)


File: elisp.info,  Node: Eval,  Prev: Backquote,  Up: Evaluation

10.5 Eval
=========

Most often, forms are evaluated automatically, by virtue of their
occurrence in a program being run.  On rare occasions, you may need to
write code that evaluates a form that is computed at run time, such as
after reading a form from text being edited or getting one from a
property list.  On these occasions, use the ‘eval’ function.  Often
‘eval’ is not needed and something else should be used instead.  For
example, to get the value of a variable, while ‘eval’ works,
‘symbol-value’ is preferable; or rather than store expressions in a
property list that then need to go through ‘eval’, it is better to store
functions instead that are then passed to ‘funcall’.

   The functions and variables described in this section evaluate forms,
specify limits to the evaluation process, or record recently returned
values.  Loading a file also does evaluation (*note Loading::).

   It is generally cleaner and more flexible to store a function in a
data structure, and call it with ‘funcall’ or ‘apply’, than to store an
expression in the data structure and evaluate it.  Using functions
provides the ability to pass information to them as arguments.

 -- Function: eval form &optional lexical
     This is the basic function for evaluating an expression.  It
     evaluates FORM in the current environment, and returns the result.
     The type of the FORM object determines how it is evaluated.  *Note
     Forms::.

     The argument LEXICAL specifies the scoping rule for local variables
     (*note Variable Scoping::).  If it is omitted or ‘nil’, that means
     to evaluate FORM using the default dynamic scoping rule.  If it is
     ‘t’, that means to use the lexical scoping rule.  The value of
     LEXICAL can also be a non-empty alist specifying a particular
     “lexical environment” for lexical bindings; however, this feature
     is only useful for specialized purposes, such as in Emacs Lisp
     debuggers.  *Note Lexical Binding::.

     Since ‘eval’ is a function, the argument expression that appears in
     a call to ‘eval’ is evaluated twice: once as preparation before
     ‘eval’ is called, and again by the ‘eval’ function itself.  Here is
     an example:

          (setq foo 'bar)
               ⇒ bar
          (setq bar 'baz)
               ⇒ baz
          ;; Here ‘eval’ receives argument ‘foo’
          (eval 'foo)
               ⇒ bar
          ;; Here ‘eval’ receives argument ‘bar’, which is the value of ‘foo’
          (eval foo)
               ⇒ baz

     The number of currently active calls to ‘eval’ is limited to
     ‘max-lisp-eval-depth’ (see below).

 -- Command: eval-region start end &optional stream read-function
     This function evaluates the forms in the current buffer in the
     region defined by the positions START and END.  It reads forms from
     the region and calls ‘eval’ on them until the end of the region is
     reached, or until an error is signaled and not handled.

     By default, ‘eval-region’ does not produce any output.  However, if
     STREAM is non-‘nil’, any output produced by output functions (*note
     Output Functions::), as well as the values that result from
     evaluating the expressions in the region are printed using STREAM.
     *Note Output Streams::.

     If READ-FUNCTION is non-‘nil’, it should be a function, which is
     used instead of ‘read’ to read expressions one by one.  This
     function is called with one argument, the stream for reading input.
     You can also use the variable ‘load-read-function’ (*note How
     Programs Do Loading: Definition of load-read-function.) to specify
     this function, but it is more robust to use the READ-FUNCTION
     argument.

     ‘eval-region’ does not move point.  It always returns ‘nil’.

 -- Command: eval-buffer &optional buffer-or-name stream filename
          unibyte print
     This is similar to ‘eval-region’, but the arguments provide
     different optional features.  ‘eval-buffer’ operates on the entire
     accessible portion of buffer BUFFER-OR-NAME (*note
     (emacs)Narrowing::).  BUFFER-OR-NAME can be a buffer, a buffer name
     (a string), or ‘nil’ (or omitted), which means to use the current
     buffer.  STREAM is used as in ‘eval-region’, unless STREAM is ‘nil’
     and PRINT non-‘nil’.  In that case, values that result from
     evaluating the expressions are still discarded, but the output of
     the output functions is printed in the echo area.  FILENAME is the
     file name to use for ‘load-history’ (*note Unloading::), and
     defaults to ‘buffer-file-name’ (*note Buffer File Name::).  If
     UNIBYTE is non-‘nil’, ‘read’ converts strings to unibyte whenever
     possible.

     ‘eval-current-buffer’ is an alias for this command.

 -- User Option: max-lisp-eval-depth
     This variable defines the maximum depth allowed in calls to ‘eval’,
     ‘apply’, and ‘funcall’ before an error is signaled (with error
     message ‘"Lisp nesting exceeds max-lisp-eval-depth"’).

     This limit, with the associated error when it is exceeded, is one
     way Emacs Lisp avoids infinite recursion on an ill-defined
     function.  If you increase the value of ‘max-lisp-eval-depth’ too
     much, such code can cause stack overflow instead.  On some systems,
     this overflow can be handled.  In that case, normal Lisp evaluation
     is interrupted and control is transferred back to the top level
     command loop (‘top-level’).  Note that there is no way to enter
     Emacs Lisp debugger in this situation.  *Note Error Debugging::.

     The depth limit counts internal uses of ‘eval’, ‘apply’, and
     ‘funcall’, such as for calling the functions mentioned in Lisp
     expressions, and recursive evaluation of function call arguments
     and function body forms, as well as explicit calls in Lisp code.

     The default value of this variable is 800.  If you set it to a
     value less than 100, Lisp will reset it to 100 if the given value
     is reached.  Entry to the Lisp debugger increases the value, if
     there is little room left, to make sure the debugger itself has
     room to execute.

     ‘max-specpdl-size’ provides another limit on nesting.  *Note Local
     Variables: Definition of max-specpdl-size.

 -- Variable: values
     The value of this variable is a list of the values returned by all
     the expressions that were read, evaluated, and printed from buffers
     (including the minibuffer) by the standard Emacs commands which do
     this.  (Note that this does _not_ include evaluation in ‘*ielm*’
     buffers, nor evaluation using ‘C-j’, ‘C-x C-e’, and similar
     evaluation commands in ‘lisp-interaction-mode’.)  The elements are
     ordered most recent first.

          (setq x 1)
               ⇒ 1
          (list 'A (1+ 2) auto-save-default)
               ⇒ (A 3 t)
          values
               ⇒ ((A 3 t) 1 ...)

     This variable is useful for referring back to values of forms
     recently evaluated.  It is generally a bad idea to print the value
     of ‘values’ itself, since this may be very long.  Instead, examine
     particular elements, like this:

          ;; Refer to the most recent evaluation result.
          (nth 0 values)
               ⇒ (A 3 t)
          ;; That put a new element on,
          ;;   so all elements move back one.
          (nth 1 values)
               ⇒ (A 3 t)
          ;; This gets the element that was next-to-most-recent
          ;;   before this example.
          (nth 3 values)
               ⇒ 1


File: elisp.info,  Node: Control Structures,  Next: Variables,  Prev: Evaluation,  Up: Top

11 Control Structures
*********************

A Lisp program consists of a set of “expressions”, or “forms” (*note
Forms::).  We control the order of execution of these forms by enclosing
them in “control structures”.  Control structures are special forms
which control when, whether, or how many times to execute the forms they
contain.

   The simplest order of execution is sequential execution: first form
A, then form B, and so on.  This is what happens when you write several
forms in succession in the body of a function, or at top level in a file
of Lisp code—the forms are executed in the order written.  We call this
“textual order”.  For example, if a function body consists of two forms
A and B, evaluation of the function evaluates first A and then B.  The
result of evaluating B becomes the value of the function.

   Explicit control structures make possible an order of execution other
than sequential.

   Emacs Lisp provides several kinds of control structure, including
other varieties of sequencing, conditionals, iteration, and (controlled)
jumps—all discussed below.  The built-in control structures are special
forms since their subforms are not necessarily evaluated or not
evaluated sequentially.  You can use macros to define your own control
structure constructs (*note Macros::).

* Menu:

* Sequencing::             Evaluation in textual order.
* Conditionals::           ‘if’, ‘cond’, ‘when’, ‘unless’.
* Combining Conditions::   ‘and’, ‘or’, ‘not’.
* Iteration::              ‘while’ loops.
* Generators::             Generic sequences and coroutines.
* Nonlocal Exits::         Jumping out of a sequence.


File: elisp.info,  Node: Sequencing,  Next: Conditionals,  Up: Control Structures

11.1 Sequencing
===============

Evaluating forms in the order they appear is the most common way control
passes from one form to another.  In some contexts, such as in a
function body, this happens automatically.  Elsewhere you must use a
control structure construct to do this: ‘progn’, the simplest control
construct of Lisp.

   A ‘progn’ special form looks like this:

     (progn A B C ...)

and it says to execute the forms A, B, C, and so on, in that order.
These forms are called the “body” of the ‘progn’ form.  The value of the
last form in the body becomes the value of the entire ‘progn’.
‘(progn)’ returns ‘nil’.

   In the early days of Lisp, ‘progn’ was the only way to execute two or
more forms in succession and use the value of the last of them.  But
programmers found they often needed to use a ‘progn’ in the body of a
function, where (at that time) only one form was allowed.  So the body
of a function was made into an implicit ‘progn’: several forms are
allowed just as in the body of an actual ‘progn’.  Many other control
structures likewise contain an implicit ‘progn’.  As a result, ‘progn’
is not used as much as it was many years ago.  It is needed now most
often inside an ‘unwind-protect’, ‘and’, ‘or’, or in the THEN-part of an
‘if’.

 -- Special Form: progn forms...
     This special form evaluates all of the FORMS, in textual order,
     returning the result of the final form.

          (progn (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               ⊣ "The first form"
               ⊣ "The second form"
               ⊣ "The third form"
          ⇒ "The third form"

   Two other constructs likewise evaluate a series of forms but return
different values:

 -- Special Form: prog1 form1 forms...
     This special form evaluates FORM1 and all of the FORMS, in textual
     order, returning the result of FORM1.

          (prog1 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               ⊣ "The first form"
               ⊣ "The second form"
               ⊣ "The third form"
          ⇒ "The first form"

     Here is a way to remove the first element from a list in the
     variable ‘x’, then return the value of that former element:

          (prog1 (car x) (setq x (cdr x)))

 -- Special Form: prog2 form1 form2 forms...
     This special form evaluates FORM1, FORM2, and all of the following
     FORMS, in textual order, returning the result of FORM2.

          (prog2 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               ⊣ "The first form"
               ⊣ "The second form"
               ⊣ "The third form"
          ⇒ "The second form"


File: elisp.info,  Node: Conditionals,  Next: Combining Conditions,  Prev: Sequencing,  Up: Control Structures

11.2 Conditionals
=================

Conditional control structures choose among alternatives.  Emacs Lisp
has four conditional forms: ‘if’, which is much the same as in other
languages; ‘when’ and ‘unless’, which are variants of ‘if’; and ‘cond’,
which is a generalized case statement.

 -- Special Form: if condition then-form else-forms...
     ‘if’ chooses between the THEN-FORM and the ELSE-FORMS based on the
     value of CONDITION.  If the evaluated CONDITION is non-‘nil’,
     THEN-FORM is evaluated and the result returned.  Otherwise, the
     ELSE-FORMS are evaluated in textual order, and the value of the
     last one is returned.  (The ELSE part of ‘if’ is an example of an
     implicit ‘progn’.  *Note Sequencing::.)

     If CONDITION has the value ‘nil’, and no ELSE-FORMS are given, ‘if’
     returns ‘nil’.

     ‘if’ is a special form because the branch that is not selected is
     never evaluated—it is ignored.  Thus, in this example, ‘true’ is
     not printed because ‘print’ is never called:

          (if nil
              (print 'true)
            'very-false)
          ⇒ very-false

 -- Macro: when condition then-forms...
     This is a variant of ‘if’ where there are no ELSE-FORMS, and
     possibly several THEN-FORMS.  In particular,

          (when CONDITION A B C)

     is entirely equivalent to

          (if CONDITION (progn A B C) nil)

 -- Macro: unless condition forms...
     This is a variant of ‘if’ where there is no THEN-FORM:

          (unless CONDITION A B C)

     is entirely equivalent to

          (if CONDITION nil
             A B C)

 -- Special Form: cond clause...
     ‘cond’ chooses among an arbitrary number of alternatives.  Each
     CLAUSE in the ‘cond’ must be a list.  The CAR of this list is the
     CONDITION; the remaining elements, if any, the BODY-FORMS.  Thus, a
     clause looks like this:

          (CONDITION BODY-FORMS...)

     ‘cond’ tries the clauses in textual order, by evaluating the
     CONDITION of each clause.  If the value of CONDITION is non-‘nil’,
     the clause succeeds; then ‘cond’ evaluates its BODY-FORMS, and
     returns the value of the last of BODY-FORMS.  Any remaining clauses
     are ignored.

     If the value of CONDITION is ‘nil’, the clause fails, so the ‘cond’
     moves on to the following clause, trying its CONDITION.

     A clause may also look like this:

          (CONDITION)

     Then, if CONDITION is non-‘nil’ when tested, the ‘cond’ form
     returns the value of CONDITION.

     If every CONDITION evaluates to ‘nil’, so that every clause fails,
     ‘cond’ returns ‘nil’.

     The following example has four clauses, which test for the cases
     where the value of ‘x’ is a number, string, buffer and symbol,
     respectively:

          (cond ((numberp x) x)
                ((stringp x) x)
                ((bufferp x)
                 (setq temporary-hack x) ; multiple body-forms
                 (buffer-name x))        ; in one clause
                ((symbolp x) (symbol-value x)))

     Often we want to execute the last clause whenever none of the
     previous clauses was successful.  To do this, we use ‘t’ as the
     CONDITION of the last clause, like this: ‘(t BODY-FORMS)’.  The
     form ‘t’ evaluates to ‘t’, which is never ‘nil’, so this clause
     never fails, provided the ‘cond’ gets to it at all.  For example:

          (setq a 5)
          (cond ((eq a 'hack) 'foo)
                (t "default"))
          ⇒ "default"

     This ‘cond’ expression returns ‘foo’ if the value of ‘a’ is ‘hack’,
     and returns the string ‘"default"’ otherwise.

   Any conditional construct can be expressed with ‘cond’ or with ‘if’.
Therefore, the choice between them is a matter of style.  For example:

     (if A B C)
     ≡
     (cond (A B) (t C))

* Menu:

* Pattern matching case statement::


File: elisp.info,  Node: Pattern matching case statement,  Up: Conditionals

11.2.1 Pattern matching case statement
--------------------------------------

The ‘cond’ form lets you choose between alternatives using predicate
conditions that compare values of expressions against specific values
known and written in advance.  However, sometimes it is useful to select
alternatives based on more general conditions that distinguish between
broad classes of values.  The ‘pcase’ macro allows you to choose between
alternatives based on matching the value of an expression against a
series of patterns.  A pattern can be a literal value (for comparisons
to literal values you’d use ‘cond’), or it can be a more general
description of the expected structure of the expression’s value.

 -- Macro: pcase expression &rest clauses
     Evaluate EXPRESSION and choose among an arbitrary number of
     alternatives based on the value of EXPRESSION.  The possible
     alternatives are specified by CLAUSES, each of which must be a list
     of the form ‘(PATTERN BODY-FORMS...)’.  ‘pcase’ tries to match the
     value of EXPRESSION to the PATTERN of each clause, in textual
     order.  If the value matches, the clause succeeds; ‘pcase’ then
     evaluates its BODY-FORMS, and returns the value of the last of
     BODY-FORMS.  Any remaining CLAUSES are ignored.  If no clauses
     match, then the ‘pcase’ form evaluates to ‘nil’.

     The PATTERN part of a clause can be of one of two types:
     “QPattern”, a pattern quoted with a backquote; or a “UPattern”,
     which is not quoted.  UPatterns are simpler, so we describe them
     first.

     Note: In the description of the patterns below, we use “the value
     being matched” to refer to the value of the EXPRESSION that is the
     first argument of ‘pcase’.

     A UPattern can have the following forms:

     ‘'VAL’
          Matches if the value being matched is ‘equal’ to VAL.
     ‘ATOM’
          Matches any ATOM, which can be a keyword, a number, or a
          string.  (These are self-quoting, so this kind of UPattern is
          actually a shorthand for ‘'ATOM’.)  Note that a string or a
          float matches any string or float with the same
          contents/value.
     ‘_’
          Matches any value.  This is known as “don’t care” or
          “wildcard”.
     ‘SYMBOL’
          Matches any value, and additionally let-binds SYMBOL to the
          value it matched, so that you can later refer to it, either in
          the BODY-FORMS or also later in the pattern.
     ‘(pred PREDFUN)’
          Matches if the predicate function PREDFUN returns non-‘nil’
          when called with the value being matched as its argument.
          PREDFUN can be one of the possible forms described below.
     ‘(guard BOOLEAN-EXPRESSION)’
          Matches if BOOLEAN-EXPRESSION evaluates to non-‘nil’.  This
          allows you to include in a UPattern boolean conditions that
          refer to symbols bound to values (including the value being
          matched) by previous UPatterns.  Typically used inside an
          ‘and’ UPattern, see below.  For example,
          ‘(and x (guard (< x 10)))’ is a pattern which matches any
          number smaller than 10 and let-binds the variable ‘x’ to that
          number.
     ‘(let UPATTERN EXPRESSION)’
          Matches if the specified EXPRESSION matches the specified
          UPATTERN.  This allows matching a pattern against the value of
          an _arbitrary_ expression, not just the expression that is the
          first argument to ‘pcase’.  (It is called ‘let’ because
          UPATTERN can bind symbols to values using the SYMBOL UPattern.
          For example: ‘((or `(key . ,val) (let val 5)) val)’.)
     ‘(app FUNCTION UPATTERN)’
          Matches if FUNCTION applied to the value being matched returns
          a value that matches UPATTERN.  This is like the ‘pred’
          UPattern, except that it tests the result against UPATTERN,
          rather than against a boolean truth value.  The FUNCTION call
          can use one of the forms described below.
     ‘(or UPATTERN1 UPATTERN2...)’
          Matches if one the argument UPatterns matches.  As soon as the
          first matching UPattern is found, the rest are not tested.
          For this reason, if any of the UPatterns let-bind symbols to
          the matched value, they should all bind the same symbols.
     ‘(and UPATTERN1 UPATTERN2...)’
          Matches if all the argument UPatterns match.

     The function calls used in the ‘pred’ and ‘app’ UPatterns can have
     one of the following forms:

     function symbol, like ‘integerp’
          In this case, the named function is applied to the value being
          matched.
     lambda-function ‘(lambda (ARG) BODY)’
          In this case, the lambda-function is called with one argument,
          the value being matched.
     ‘(FUNC ARGS...)’
          This is a function call with N specified arguments; the
          function is called with these N arguments and an additional
          N+1-th argument that is the value being matched.

     Here’s an illustrative example of using UPatterns:

          (pcase (get-return-code x)
            ('success       (message "Done!"))
            ('would-block   (message "Sorry, can't do it now"))
            ('read-only     (message "The shmliblick is read-only"))
            ('access-denied (message "You do not have the needed rights"))
            (code           (message "Unknown return code %S" code)))

     In addition, you can use backquoted patterns that are more
     powerful.  They allow matching the value of the EXPRESSION that is
     the first argument of ‘pcase’ against specifications of its
     _structure_.  For example, you can specify that the value must be a
     list of 2 elements whose first element is a specific string and the
     second element is any value with a backquoted pattern like
     ‘`("first" ,second-elem)’.

     Backquoted patterns have the form ‘`QPATTERN’ where QPATTERN can
     have the following forms:

     ‘(QPATTERN1 . QPATTERN2)’
          Matches if the value being matched is a cons cell whose ‘car’
          matches QPATTERN1 and whose ‘cdr’ matches QPATTERN2.  This
          readily generalizes to backquoted lists as in
          ‘(QPATTERN1 QPATTERN2 ...)’.
     ‘[QPATTERN1 QPATTERN2 ... QPATTERNM]’
          Matches if the value being matched is a vector of length M
          whose ‘0’..‘(M-1)’th elements match QPATTERN1, QPATTERN2 ...
          QPATTERNM, respectively.
     ‘ATOM’
          Matches if corresponding element of the value being matched is
          ‘equal’ to the specified ATOM.
     ‘,UPATTERN’
          Matches if the corresponding element of the value being
          matched matches the specified UPATTERN.

     Note that uses of QPatterns can be expressed using only UPatterns,
     as QPatterns are implemented on top of UPatterns using
     ‘pcase-defmacro’, described below.  However, using QPatterns will
     in many cases lead to a more readable code.

   Here is an example of using ‘pcase’ to implement a simple interpreter
for a little expression language (note that this example requires
lexical binding, *note Lexical Binding::):

     (defun evaluate (exp env)
       (pcase exp
         (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))
         (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))
         (`(fn ,arg ,body)   (lambda (val)
                               (evaluate body (cons (cons arg val) env))))
         ((pred numberp)     exp)
         ((pred symbolp)     (cdr (assq exp env)))
         (_                  (error "Unknown expression %S" exp))))

   Here ‘`(add ,x ,y)’ is a pattern that checks that ‘exp’ is a
three-element list starting with the literal symbol ‘add’, then extracts
the second and third elements and binds them to the variables ‘x’ and
‘y’.  Then it evaluates ‘x’ and ‘y’ and adds the results.  The ‘call’
and ‘fn’ patterns similarly implement two flavors of function calls.
‘(pred numberp)’ is a pattern that simply checks that ‘exp’ is a number
and if so, evaluates it.  ‘(pred symbolp)’ matches symbols, and returns
their association.  Finally, ‘_’ is the catch-all pattern that matches
anything, so it’s suitable for reporting syntax errors.

   Here are some sample programs in this small language, including their
evaluation results:

     (evaluate '(add 1 2) nil)                 ;=> 3
     (evaluate '(add x y) '((x . 1) (y . 2)))  ;=> 3
     (evaluate '(call (fn x (add 1 x)) 2) nil) ;=> 3
     (evaluate '(sub 1 2) nil)                 ;=> error

   Additional UPatterns can be defined using the ‘pcase-defmacro’ macro.

 -- Macro: pcase-defmacro name args &rest body
     Define a new kind of UPattern for ‘pcase’.  The new UPattern will
     be invoked as ‘(NAME ACTUAL-ARGS)’.  The BODY should describe how
     to rewrite the UPattern NAME into some other UPattern.  The
     rewriting will be the result of evaluating BODY in an environment
     where ARGS are bound to ACTUAL-ARGS.


File: elisp.info,  Node: Combining Conditions,  Next: Iteration,  Prev: Conditionals,  Up: Control Structures

11.3 Constructs for Combining Conditions
========================================

This section describes three constructs that are often used together
with ‘if’ and ‘cond’ to express complicated conditions.  The constructs
‘and’ and ‘or’ can also be used individually as kinds of multiple
conditional constructs.

 -- Function: not condition
     This function tests for the falsehood of CONDITION.  It returns ‘t’
     if CONDITION is ‘nil’, and ‘nil’ otherwise.  The function ‘not’ is
     identical to ‘null’, and we recommend using the name ‘null’ if you
     are testing for an empty list.

 -- Special Form: and conditions...
     The ‘and’ special form tests whether all the CONDITIONS are true.
     It works by evaluating the CONDITIONS one by one in the order
     written.

     If any of the CONDITIONS evaluates to ‘nil’, then the result of the
     ‘and’ must be ‘nil’ regardless of the remaining CONDITIONS; so
     ‘and’ returns ‘nil’ right away, ignoring the remaining CONDITIONS.

     If all the CONDITIONS turn out non-‘nil’, then the value of the
     last of them becomes the value of the ‘and’ form.  Just ‘(and)’,
     with no CONDITIONS, returns ‘t’, appropriate because all the
     CONDITIONS turned out non-‘nil’.  (Think about it; which one did
     not?)

     Here is an example.  The first condition returns the integer 1,
     which is not ‘nil’.  Similarly, the second condition returns the
     integer 2, which is not ‘nil’.  The third condition is ‘nil’, so
     the remaining condition is never evaluated.

          (and (print 1) (print 2) nil (print 3))
               ⊣ 1
               ⊣ 2
          ⇒ nil

     Here is a more realistic example of using ‘and’:

          (if (and (consp foo) (eq (car foo) 'x))
              (message "foo is a list starting with x"))

     Note that ‘(car foo)’ is not executed if ‘(consp foo)’ returns
     ‘nil’, thus avoiding an error.

     ‘and’ expressions can also be written using either ‘if’ or ‘cond’.
     Here’s how:

          (and ARG1 ARG2 ARG3)
          ≡
          (if ARG1 (if ARG2 ARG3))
          ≡
          (cond (ARG1 (cond (ARG2 ARG3))))

 -- Special Form: or conditions...
     The ‘or’ special form tests whether at least one of the CONDITIONS
     is true.  It works by evaluating all the CONDITIONS one by one in
     the order written.

     If any of the CONDITIONS evaluates to a non-‘nil’ value, then the
     result of the ‘or’ must be non-‘nil’; so ‘or’ returns right away,
     ignoring the remaining CONDITIONS.  The value it returns is the
     non-‘nil’ value of the condition just evaluated.

     If all the CONDITIONS turn out ‘nil’, then the ‘or’ expression
     returns ‘nil’.  Just ‘(or)’, with no CONDITIONS, returns ‘nil’,
     appropriate because all the CONDITIONS turned out ‘nil’.  (Think
     about it; which one did not?)

     For example, this expression tests whether ‘x’ is either ‘nil’ or
     the integer zero:

          (or (eq x nil) (eq x 0))

     Like the ‘and’ construct, ‘or’ can be written in terms of ‘cond’.
     For example:

          (or ARG1 ARG2 ARG3)
          ≡
          (cond (ARG1)
                (ARG2)
                (ARG3))

     You could almost write ‘or’ in terms of ‘if’, but not quite:

          (if ARG1 ARG1
            (if ARG2 ARG2
              ARG3))

     This is not completely equivalent because it can evaluate ARG1 or
     ARG2 twice.  By contrast, ‘(or ARG1 ARG2 ARG3)’ never evaluates any
     argument more than once.


File: elisp.info,  Node: Iteration,  Next: Generators,  Prev: Combining Conditions,  Up: Control Structures

11.4 Iteration
==============

Iteration means executing part of a program repetitively.  For example,
you might want to repeat some computation once for each element of a
list, or once for each integer from 0 to N.  You can do this in Emacs
Lisp with the special form ‘while’:

 -- Special Form: while condition forms...
     ‘while’ first evaluates CONDITION.  If the result is non-‘nil’, it
     evaluates FORMS in textual order.  Then it reevaluates CONDITION,
     and if the result is non-‘nil’, it evaluates FORMS again.  This
     process repeats until CONDITION evaluates to ‘nil’.

     There is no limit on the number of iterations that may occur.  The
     loop will continue until either CONDITION evaluates to ‘nil’ or
     until an error or ‘throw’ jumps out of it (*note Nonlocal Exits::).

     The value of a ‘while’ form is always ‘nil’.

          (setq num 0)
               ⇒ 0
          (while (< num 4)
            (princ (format "Iteration %d." num))
            (setq num (1+ num)))
               ⊣ Iteration 0.
               ⊣ Iteration 1.
               ⊣ Iteration 2.
               ⊣ Iteration 3.
               ⇒ nil

     To write a repeat-until loop, which will execute something on each
     iteration and then do the end-test, put the body followed by the
     end-test in a ‘progn’ as the first argument of ‘while’, as shown
     here:

          (while (progn
                   (forward-line 1)
                   (not (looking-at "^$"))))

     This moves forward one line and continues moving by lines until it
     reaches an empty line.  It is peculiar in that the ‘while’ has no
     body, just the end test (which also does the real work of moving
     point).

   The ‘dolist’ and ‘dotimes’ macros provide convenient ways to write
two common kinds of loops.

 -- Macro: dolist (var list [result]) body...
     This construct executes BODY once for each element of LIST, binding
     the variable VAR locally to hold the current element.  Then it
     returns the value of evaluating RESULT, or ‘nil’ if RESULT is
     omitted.  For example, here is how you could use ‘dolist’ to define
     the ‘reverse’ function:

          (defun reverse (list)
            (let (value)
              (dolist (elt list value)
                (setq value (cons elt value)))))

 -- Macro: dotimes (var count [result]) body...
     This construct executes BODY once for each integer from 0
     (inclusive) to COUNT (exclusive), binding the variable VAR to the
     integer for the current iteration.  Then it returns the value of
     evaluating RESULT, or ‘nil’ if RESULT is omitted.  Here is an
     example of using ‘dotimes’ to do something 100 times:

          (dotimes (i 100)
            (insert "I will not obey absurd orders\n"))


File: elisp.info,  Node: Generators,  Next: Nonlocal Exits,  Prev: Iteration,  Up: Control Structures

11.5 Generators
===============

A “generator” is a function that produces a potentially-infinite stream
of values.  Each time the function produces a value, it suspends itself
and waits for a caller to request the next value.

 -- Macro: iter-defun name args [doc] [declare] [interactive] body...
     ‘iter-defun’ defines a generator function.  A generator function
     has the same signature as a normal function, but works differently.
     Instead of executing BODY when called, a generator function returns
     an iterator object.  That iterator runs BODY to generate values,
     emitting a value and pausing where ‘iter-yield’ or
     ‘iter-yield-from’ appears.  When BODY returns normally, ‘iter-next’
     signals ‘iter-end-of-sequence’ with BODY’s result as its condition
     data.

     Any kind of Lisp code is valid inside BODY, but ‘iter-yield’ and
     ‘iter-yield-from’ cannot appear inside ‘unwind-protect’ forms.

 -- Macro: iter-lambda args [doc] [interactive] body...
     ‘iter-lambda’ produces an unnamed generator function that works
     just like a generator function produced with ‘iter-defun’.

 -- Macro: iter-yield value
     When it appears inside a generator function, ‘iter-yield’ indicates
     that the current iterator should pause and return VALUE from
     ‘iter-next’.  ‘iter-yield’ evaluates to the ‘value’ parameter of
     next call to ‘iter-next’.

 -- Macro: iter-yield-from iterator
     ‘iter-yield-from’ yields all the values that ITERATOR produces and
     evaluates to the value that ITERATOR’s generator function returns
     normally.  While it has control, ITERATOR receives values sent to
     the iterator using ‘iter-next’.

   To use a generator function, first call it normally, producing a
“iterator” object.  An iterator is a specific instance of a generator.
Then use ‘iter-next’ to retrieve values from this iterator.  When there
are no more values to pull from an iterator, ‘iter-next’ raises an
‘iter-end-of-sequence’ condition with the iterator’s final value.

   It’s important to note that generator function bodies only execute
inside calls to ‘iter-next’.  A call to a function defined with
‘iter-defun’ produces an iterator; you must drive this iterator with
‘iter-next’ for anything interesting to happen.  Each call to a
generator function produces a _different_ iterator, each with its own
state.

 -- Function: iter-next iterator value
     Retrieve the next value from ITERATOR.  If there are no more values
     to be generated (because ITERATOR’s generator function returned),
     ‘iter-next’ signals the ‘iter-end-of-sequence’ condition; the data
     value associated with this condition is the value with which
     ITERATOR’s generator function returned.

     VALUE is sent into the iterator and becomes the value to which
     ‘iter-yield’ evaluates.  VALUE is ignored for the first ‘iter-next’
     call to a given iterator, since at the start of ITERATOR’s
     generator function, the generator function is not evaluating any
     ‘iter-yield’ form.

 -- Function: iter-close iterator
     If ITERATOR is suspended inside an ‘unwind-protect’’s ‘bodyform’
     and becomes unreachable, Emacs will eventually run unwind handlers
     after a garbage collection pass.  (Note that ‘iter-yield’ is
     illegal inside an ‘unwind-protect’’s ‘unwindforms’.)  To ensure
     that these handlers are run before then, use ‘iter-close’.

   Some convenience functions are provided to make working with
iterators easier:

 -- Macro: iter-do (var iterator) body ...
     Run BODY with VAR bound to each value that ITERATOR produces.

   The Common Lisp loop facility also contains features for working with
iterators.  See *Note (cl)Loop Facility::.

   The following piece of code demonstrates some important principles of
working with iterators.

     (require 'generator)
     (iter-defun my-iter (x)
       (iter-yield (1+ (iter-yield (1+ x))))
        ;; Return normally
       -1)

     (let* ((iter (my-iter 5))
            (iter2 (my-iter 0)))
       ;; Prints 6
       (print (iter-next iter))
       ;; Prints 9
       (print (iter-next iter 8))
       ;; Prints 1; iter and iter2 have distinct states
       (print (iter-next iter2 nil))

       ;; We expect the iter sequence to end now
       (condition-case x
           (iter-next iter)
         (iter-end-of-sequence
           ;; Prints -1, which my-iter returned normally
           (print (cdr x)))))


File: elisp.info,  Node: Nonlocal Exits,  Prev: Generators,  Up: Control Structures

11.6 Nonlocal Exits
===================

A “nonlocal exit” is a transfer of control from one point in a program
to another remote point.  Nonlocal exits can occur in Emacs Lisp as a
result of errors; you can also use them under explicit control.
Nonlocal exits unbind all variable bindings made by the constructs being
exited.

* Menu:

* Catch and Throw::     Nonlocal exits for the program’s own purposes.
* Examples of Catch::   Showing how such nonlocal exits can be written.
* Errors::              How errors are signaled and handled.
* Cleanups::            Arranging to run a cleanup form if an error happens.


File: elisp.info,  Node: Catch and Throw,  Next: Examples of Catch,  Up: Nonlocal Exits

11.6.1 Explicit Nonlocal Exits: ‘catch’ and ‘throw’
---------------------------------------------------

Most control constructs affect only the flow of control within the
construct itself.  The function ‘throw’ is the exception to this rule of
normal program execution: it performs a nonlocal exit on request.
(There are other exceptions, but they are for error handling only.)
‘throw’ is used inside a ‘catch’, and jumps back to that ‘catch’.  For
example:

     (defun foo-outer ()
       (catch 'foo
         (foo-inner)))

     (defun foo-inner ()
       ...
       (if x
           (throw 'foo t))
       ...)

The ‘throw’ form, if executed, transfers control straight back to the
corresponding ‘catch’, which returns immediately.  The code following
the ‘throw’ is not executed.  The second argument of ‘throw’ is used as
the return value of the ‘catch’.

   The function ‘throw’ finds the matching ‘catch’ based on the first
argument: it searches for a ‘catch’ whose first argument is ‘eq’ to the
one specified in the ‘throw’.  If there is more than one applicable
‘catch’, the innermost one takes precedence.  Thus, in the above
example, the ‘throw’ specifies ‘foo’, and the ‘catch’ in ‘foo-outer’
specifies the same symbol, so that ‘catch’ is the applicable one
(assuming there is no other matching ‘catch’ in between).

   Executing ‘throw’ exits all Lisp constructs up to the matching
‘catch’, including function calls.  When binding constructs such as
‘let’ or function calls are exited in this way, the bindings are
unbound, just as they are when these constructs exit normally (*note
Local Variables::).  Likewise, ‘throw’ restores the buffer and position
saved by ‘save-excursion’ (*note Excursions::), and the narrowing status
saved by ‘save-restriction’.  It also runs any cleanups established with
the ‘unwind-protect’ special form when it exits that form (*note
Cleanups::).

   The ‘throw’ need not appear lexically within the ‘catch’ that it
jumps to.  It can equally well be called from another function called
within the ‘catch’.  As long as the ‘throw’ takes place chronologically
after entry to the ‘catch’, and chronologically before exit from it, it
has access to that ‘catch’.  This is why ‘throw’ can be used in commands
such as ‘exit-recursive-edit’ that throw back to the editor command loop
(*note Recursive Editing::).

     Common Lisp note: Most other versions of Lisp, including Common
     Lisp, have several ways of transferring control nonsequentially:
     ‘return’, ‘return-from’, and ‘go’, for example.  Emacs Lisp has
     only ‘throw’.  The ‘cl-lib’ library provides versions of some of
     these.  *Note (cl)Blocks and Exits::.

 -- Special Form: catch tag body...
     ‘catch’ establishes a return point for the ‘throw’ function.  The
     return point is distinguished from other such return points by TAG,
     which may be any Lisp object except ‘nil’.  The argument TAG is
     evaluated normally before the return point is established.

     With the return point in effect, ‘catch’ evaluates the forms of the
     BODY in textual order.  If the forms execute normally (without
     error or nonlocal exit) the value of the last body form is returned
     from the ‘catch’.

     If a ‘throw’ is executed during the execution of BODY, specifying
     the same value TAG, the ‘catch’ form exits immediately; the value
     it returns is whatever was specified as the second argument of
     ‘throw’.

 -- Function: throw tag value
     The purpose of ‘throw’ is to return from a return point previously
     established with ‘catch’.  The argument TAG is used to choose among
     the various existing return points; it must be ‘eq’ to the value
     specified in the ‘catch’.  If multiple return points match TAG, the
     innermost one is used.

     The argument VALUE is used as the value to return from that
     ‘catch’.

     If no return point is in effect with tag TAG, then a ‘no-catch’
     error is signaled with data ‘(TAG VALUE)’.


File: elisp.info,  Node: Examples of Catch,  Next: Errors,  Prev: Catch and Throw,  Up: Nonlocal Exits

11.6.2 Examples of ‘catch’ and ‘throw’
--------------------------------------

One way to use ‘catch’ and ‘throw’ is to exit from a doubly nested loop.
(In most languages, this would be done with a ‘goto’.)  Here we compute
‘(foo I J)’ for I and J varying from 0 to 9:

     (defun search-foo ()
       (catch 'loop
         (let ((i 0))
           (while (< i 10)
             (let ((j 0))
               (while (< j 10)
                 (if (foo i j)
                     (throw 'loop (list i j)))
                 (setq j (1+ j))))
             (setq i (1+ i))))))

If ‘foo’ ever returns non-‘nil’, we stop immediately and return a list
of I and J.  If ‘foo’ always returns ‘nil’, the ‘catch’ returns
normally, and the value is ‘nil’, since that is the result of the
‘while’.

   Here are two tricky examples, slightly different, showing two return
points at once.  First, two return points with the same tag, ‘hack’:

     (defun catch2 (tag)
       (catch tag
         (throw 'hack 'yes)))
     ⇒ catch2

     (catch 'hack
       (print (catch2 'hack))
       'no)
     ⊣ yes
     ⇒ no

Since both return points have tags that match the ‘throw’, it goes to
the inner one, the one established in ‘catch2’.  Therefore, ‘catch2’
returns normally with value ‘yes’, and this value is printed.  Finally
the second body form in the outer ‘catch’, which is ‘'no’, is evaluated
and returned from the outer ‘catch’.

   Now let’s change the argument given to ‘catch2’:

     (catch 'hack
       (print (catch2 'quux))
       'no)
     ⇒ yes

We still have two return points, but this time only the outer one has
the tag ‘hack’; the inner one has the tag ‘quux’ instead.  Therefore,
‘throw’ makes the outer ‘catch’ return the value ‘yes’.  The function
‘print’ is never called, and the body-form ‘'no’ is never evaluated.


File: elisp.info,  Node: Errors,  Next: Cleanups,  Prev: Examples of Catch,  Up: Nonlocal Exits

11.6.3 Errors
-------------

When Emacs Lisp attempts to evaluate a form that, for some reason,
cannot be evaluated, it “signals” an “error”.

   When an error is signaled, Emacs’s default reaction is to print an
error message and terminate execution of the current command.  This is
the right thing to do in most cases, such as if you type ‘C-f’ at the
end of the buffer.

   In complicated programs, simple termination may not be what you want.
For example, the program may have made temporary changes in data
structures, or created temporary buffers that should be deleted before
the program is finished.  In such cases, you would use ‘unwind-protect’
to establish “cleanup expressions” to be evaluated in case of error.
(*Note Cleanups::.)  Occasionally, you may wish the program to continue
execution despite an error in a subroutine.  In these cases, you would
use ‘condition-case’ to establish “error handlers” to recover control in
case of error.

   Resist the temptation to use error handling to transfer control from
one part of the program to another; use ‘catch’ and ‘throw’ instead.
*Note Catch and Throw::.

* Menu:

* Signaling Errors::      How to report an error.
* Processing of Errors::  What Emacs does when you report an error.
* Handling Errors::       How you can trap errors and continue execution.
* Error Symbols::         How errors are classified for trapping them.


File: elisp.info,  Node: Signaling Errors,  Next: Processing of Errors,  Up: Errors

11.6.3.1 How to Signal an Error
...............................

“Signaling” an error means beginning error processing.  Error processing
normally aborts all or part of the running program and returns to a
point that is set up to handle the error (*note Processing of Errors::).
Here we describe how to signal an error.

   Most errors are signaled automatically within Lisp primitives which
you call for other purposes, such as if you try to take the CAR of an
integer or move forward a character at the end of the buffer.  You can
also signal errors explicitly with the functions ‘error’ and ‘signal’.

   Quitting, which happens when the user types ‘C-g’, is not considered
an error, but it is handled almost like an error.  *Note Quitting::.

   Every error specifies an error message, one way or another.  The
message should state what is wrong (“File does not exist”), not how
things ought to be (“File must exist”).  The convention in Emacs Lisp is
that error messages should start with a capital letter, but should not
end with any sort of punctuation.

 -- Function: error format-string &rest args
     This function signals an error with an error message constructed by
     applying ‘format-message’ (*note Formatting Strings::) to
     FORMAT-STRING and ARGS.

     These examples show typical uses of ‘error’:

          (error "That is an error -- try something else")
               error→ That is an error -- try something else

          (error "Invalid name `%s'" "A%%B")
               error→ Invalid name ‘A%%B’

     ‘error’ works by calling ‘signal’ with two arguments: the error
     symbol ‘error’, and a list containing the string returned by
     ‘format-message’.

     Typically grave accent and apostrophe in the format translate to
     matching curved quotes, e.g., "Missing `%s'" might result in
     "Missing ‘foo’".  *Note Text Quoting Style::, for how to influence
     or inhibit this translation.

     *Warning:* If you want to use your own string as an error message
     verbatim, don’t just write ‘(error STRING)’.  If STRING STRING
     contains ‘%’, ‘`’, or ‘'’ it may be reformatted, with undesirable
     results.  Instead, use ‘(error "%s" STRING)’.

 -- Function: signal error-symbol data
     This function signals an error named by ERROR-SYMBOL.  The argument
     DATA is a list of additional Lisp objects relevant to the
     circumstances of the error.

     The argument ERROR-SYMBOL must be an “error symbol”—a symbol
     defined with ‘define-error’.  This is how Emacs Lisp classifies
     different sorts of errors.  *Note Error Symbols::, for a
     description of error symbols, error conditions and condition names.

     If the error is not handled, the two arguments are used in printing
     the error message.  Normally, this error message is provided by the
     ‘error-message’ property of ERROR-SYMBOL.  If DATA is non-‘nil’,
     this is followed by a colon and a comma separated list of the
     unevaluated elements of DATA.  For ‘error’, the error message is
     the CAR of DATA (that must be a string).  Subcategories of
     ‘file-error’ are handled specially.

     The number and significance of the objects in DATA depends on
     ERROR-SYMBOL.  For example, with a ‘wrong-type-argument’ error,
     there should be two objects in the list: a predicate that describes
     the type that was expected, and the object that failed to fit that
     type.

     Both ERROR-SYMBOL and DATA are available to any error handlers that
     handle the error: ‘condition-case’ binds a local variable to a list
     of the form ‘(ERROR-SYMBOL . DATA)’ (*note Handling Errors::).

     The function ‘signal’ never returns.

          (signal 'wrong-number-of-arguments '(x y))
               error→ Wrong number of arguments: x, y

          (signal 'no-such-error '("My unknown error condition"))
               error→ peculiar error: "My unknown error condition"

 -- Function: user-error format-string &rest args
     This function behaves exactly like ‘error’, except that it uses the
     error symbol ‘user-error’ rather than ‘error’.  As the name
     suggests, this is intended to report errors on the part of the
     user, rather than errors in the code itself.  For example, if you
     try to use the command ‘Info-history-back’ (‘l’) to move back
     beyond the start of your Info browsing history, Emacs signals a
     ‘user-error’.  Such errors do not cause entry to the debugger, even
     when ‘debug-on-error’ is non-‘nil’.  *Note Error Debugging::.

     Common Lisp note: Emacs Lisp has nothing like the Common Lisp
     concept of continuable errors.


File: elisp.info,  Node: Processing of Errors,  Next: Handling Errors,  Prev: Signaling Errors,  Up: Errors

11.6.3.2 How Emacs Processes Errors
...................................

When an error is signaled, ‘signal’ searches for an active “handler” for
the error.  A handler is a sequence of Lisp expressions designated to be
executed if an error happens in part of the Lisp program.  If the error
has an applicable handler, the handler is executed, and control resumes
following the handler.  The handler executes in the environment of the
‘condition-case’ that established it; all functions called within that
‘condition-case’ have already been exited, and the handler cannot return
to them.

   If there is no applicable handler for the error, it terminates the
current command and returns control to the editor command loop.  (The
command loop has an implicit handler for all kinds of errors.)  The
command loop’s handler uses the error symbol and associated data to
print an error message.  You can use the variable
‘command-error-function’ to control how this is done:

 -- Variable: command-error-function
     This variable, if non-‘nil’, specifies a function to use to handle
     errors that return control to the Emacs command loop.  The function
     should take three arguments: DATA, a list of the same form that
     ‘condition-case’ would bind to its variable; CONTEXT, a string
     describing the situation in which the error occurred, or (more
     often) ‘nil’; and CALLER, the Lisp function which called the
     primitive that signaled the error.

   An error that has no explicit handler may call the Lisp debugger.
The debugger is enabled if the variable ‘debug-on-error’ (*note Error
Debugging::) is non-‘nil’.  Unlike error handlers, the debugger runs in
the environment of the error, so that you can examine values of
variables precisely as they were at the time of the error.


File: elisp.info,  Node: Handling Errors,  Next: Error Symbols,  Prev: Processing of Errors,  Up: Errors

11.6.3.3 Writing Code to Handle Errors
......................................

The usual effect of signaling an error is to terminate the command that
is running and return immediately to the Emacs editor command loop.  You
can arrange to trap errors occurring in a part of your program by
establishing an error handler, with the special form ‘condition-case’.
A simple example looks like this:

     (condition-case nil
         (delete-file filename)
       (error nil))

This deletes the file named FILENAME, catching any error and returning
‘nil’ if an error occurs.  (You can use the macro ‘ignore-errors’ for a
simple case like this; see below.)

   The ‘condition-case’ construct is often used to trap errors that are
predictable, such as failure to open a file in a call to
‘insert-file-contents’.  It is also used to trap errors that are totally
unpredictable, such as when the program evaluates an expression read
from the user.

   The second argument of ‘condition-case’ is called the “protected
form”.  (In the example above, the protected form is a call to
‘delete-file’.)  The error handlers go into effect when this form begins
execution and are deactivated when this form returns.  They remain in
effect for all the intervening time.  In particular, they are in effect
during the execution of functions called by this form, in their
subroutines, and so on.  This is a good thing, since, strictly speaking,
errors can be signaled only by Lisp primitives (including ‘signal’ and
‘error’) called by the protected form, not by the protected form itself.

   The arguments after the protected form are handlers.  Each handler
lists one or more “condition names” (which are symbols) to specify which
errors it will handle.  The error symbol specified when an error is
signaled also defines a list of condition names.  A handler applies to
an error if they have any condition names in common.  In the example
above, there is one handler, and it specifies one condition name,
‘error’, which covers all errors.

   The search for an applicable handler checks all the established
handlers starting with the most recently established one.  Thus, if two
nested ‘condition-case’ forms offer to handle the same error, the inner
of the two gets to handle it.

   If an error is handled by some ‘condition-case’ form, this ordinarily
prevents the debugger from being run, even if ‘debug-on-error’ says this
error should invoke the debugger.

   If you want to be able to debug errors that are caught by a
‘condition-case’, set the variable ‘debug-on-signal’ to a non-‘nil’
value.  You can also specify that a particular handler should let the
debugger run first, by writing ‘debug’ among the conditions, like this:

     (condition-case nil
         (delete-file filename)
       ((debug error) nil))

The effect of ‘debug’ here is only to prevent ‘condition-case’ from
suppressing the call to the debugger.  Any given error will invoke the
debugger only if ‘debug-on-error’ and the other usual filtering
mechanisms say it should.  *Note Error Debugging::.

 -- Macro: condition-case-unless-debug var protected-form handlers...
     The macro ‘condition-case-unless-debug’ provides another way to
     handle debugging of such forms.  It behaves exactly like
     ‘condition-case’, unless the variable ‘debug-on-error’ is
     non-‘nil’, in which case it does not handle any errors at all.

   Once Emacs decides that a certain handler handles the error, it
returns control to that handler.  To do so, Emacs unbinds all variable
bindings made by binding constructs that are being exited, and executes
the cleanups of all ‘unwind-protect’ forms that are being exited.  Once
control arrives at the handler, the body of the handler executes
normally.

   After execution of the handler body, execution returns from the
‘condition-case’ form.  Because the protected form is exited completely
before execution of the handler, the handler cannot resume execution at
the point of the error, nor can it examine variable bindings that were
made within the protected form.  All it can do is clean up and proceed.

   Error signaling and handling have some resemblance to ‘throw’ and
‘catch’ (*note Catch and Throw::), but they are entirely separate
facilities.  An error cannot be caught by a ‘catch’, and a ‘throw’
cannot be handled by an error handler (though using ‘throw’ when there
is no suitable ‘catch’ signals an error that can be handled).

 -- Special Form: condition-case var protected-form handlers...
     This special form establishes the error handlers HANDLERS around
     the execution of PROTECTED-FORM.  If PROTECTED-FORM executes
     without error, the value it returns becomes the value of the
     ‘condition-case’ form; in this case, the ‘condition-case’ has no
     effect.  The ‘condition-case’ form makes a difference when an error
     occurs during PROTECTED-FORM.

     Each of the HANDLERS is a list of the form ‘(CONDITIONS BODY...)’.
     Here CONDITIONS is an error condition name to be handled, or a list
     of condition names (which can include ‘debug’ to allow the debugger
     to run before the handler); BODY is one or more Lisp expressions to
     be executed when this handler handles an error.  Here are examples
     of handlers:

          (error nil)

          (arith-error (message "Division by zero"))

          ((arith-error file-error)
           (message
            "Either division by zero or failure to open a file"))

     Each error that occurs has an “error symbol” that describes what
     kind of error it is, and which describes also a list of condition
     names (*note Error Symbols::).  Emacs searches all the active
     ‘condition-case’ forms for a handler that specifies one or more of
     these condition names; the innermost matching ‘condition-case’
     handles the error.  Within this ‘condition-case’, the first
     applicable handler handles the error.

     After executing the body of the handler, the ‘condition-case’
     returns normally, using the value of the last form in the handler
     body as the overall value.

     The argument VAR is a variable.  ‘condition-case’ does not bind
     this variable when executing the PROTECTED-FORM, only when it
     handles an error.  At that time, it binds VAR locally to an “error
     description”, which is a list giving the particulars of the error.
     The error description has the form ‘(ERROR-SYMBOL . DATA)’.  The
     handler can refer to this list to decide what to do.  For example,
     if the error is for failure opening a file, the file name is the
     second element of DATA—the third element of the error description.

     If VAR is ‘nil’, that means no variable is bound.  Then the error
     symbol and associated data are not available to the handler.

     Sometimes it is necessary to re-throw a signal caught by
     ‘condition-case’, for some outer-level handler to catch.  Here’s
     how to do that:

            (signal (car err) (cdr err))

     where ‘err’ is the error description variable, the first argument
     to ‘condition-case’ whose error condition you want to re-throw.
     *Note Definition of signal::.

 -- Function: error-message-string error-descriptor
     This function returns the error message string for a given error
     descriptor.  It is useful if you want to handle an error by
     printing the usual error message for that error.  *Note Definition
     of signal::.

   Here is an example of using ‘condition-case’ to handle the error that
results from dividing by zero.  The handler displays the error message
(but without a beep), then returns a very large number.

     (defun safe-divide (dividend divisor)
       (condition-case err
           ;; Protected form.
           (/ dividend divisor)
         ;; The handler.
         (arith-error                        ; Condition.
          ;; Display the usual message for this error.
          (message "%s" (error-message-string err))
          1000000)))
     ⇒ safe-divide

     (safe-divide 5 0)
          ⊣ Arithmetic error: (arith-error)
     ⇒ 1000000

The handler specifies condition name ‘arith-error’ so that it will
handle only division-by-zero errors.  Other kinds of errors will not be
handled (by this ‘condition-case’).  Thus:

     (safe-divide nil 3)
          error→ Wrong type argument: number-or-marker-p, nil

   Here is a ‘condition-case’ that catches all kinds of errors,
including those from ‘error’:

     (setq baz 34)
          ⇒ 34

     (condition-case err
         (if (eq baz 35)
             t
           ;; This is a call to the function ‘error’.
           (error "Rats!  The variable %s was %s, not 35" 'baz baz))
       ;; This is the handler; it is not a form.
       (error (princ (format "The error was: %s" err))
              2))
     ⊣ The error was: (error "Rats!  The variable baz was 34, not 35")
     ⇒ 2

 -- Macro: ignore-errors body...
     This construct executes BODY, ignoring any errors that occur during
     its execution.  If the execution is without error, ‘ignore-errors’
     returns the value of the last form in BODY; otherwise, it returns
     ‘nil’.

     Here’s the example at the beginning of this subsection rewritten
     using ‘ignore-errors’:

            (ignore-errors
             (delete-file filename))

 -- Macro: with-demoted-errors format body...
     This macro is like a milder version of ‘ignore-errors’.  Rather
     than suppressing errors altogether, it converts them into messages.
     It uses the string FORMAT to format the message.  FORMAT should
     contain a single ‘%’-sequence; e.g., ‘"Error: %S"’.  Use
     ‘with-demoted-errors’ around code that is not expected to signal
     errors, but should be robust if one does occur.  Note that this
     macro uses ‘condition-case-unless-debug’ rather than
     ‘condition-case’.


File: elisp.info,  Node: Error Symbols,  Prev: Handling Errors,  Up: Errors

11.6.3.4 Error Symbols and Condition Names
..........................................

When you signal an error, you specify an “error symbol” to specify the
kind of error you have in mind.  Each error has one and only one error
symbol to categorize it.  This is the finest classification of errors
defined by the Emacs Lisp language.

   These narrow classifications are grouped into a hierarchy of wider
classes called “error conditions”, identified by “condition names”.  The
narrowest such classes belong to the error symbols themselves: each
error symbol is also a condition name.  There are also condition names
for more extensive classes, up to the condition name ‘error’ which takes
in all kinds of errors (but not ‘quit’).  Thus, each error has one or
more condition names: ‘error’, the error symbol if that is distinct from
‘error’, and perhaps some intermediate classifications.

 -- Function: define-error name message &optional parent
     In order for a symbol to be an error symbol, it must be defined
     with ‘define-error’ which takes a parent condition (defaults to
     ‘error’).  This parent defines the conditions that this kind of
     error belongs to.  The transitive set of parents always includes
     the error symbol itself, and the symbol ‘error’.  Because quitting
     is not considered an error, the set of parents of ‘quit’ is just
     ‘(quit)’.

   In addition to its parents, the error symbol has a MESSAGE which is a
string to be printed when that error is signaled but not handled.  If
that message is not valid, the error message ‘peculiar error’ is used.
*Note Definition of signal::.

   Internally, the set of parents is stored in the ‘error-conditions’
property of the error symbol and the message is stored in the
‘error-message’ property of the error symbol.

   Here is how we define a new error symbol, ‘new-error’:

     (define-error 'new-error "A new error" 'my-own-errors)

This error has several condition names: ‘new-error’, the narrowest
classification; ‘my-own-errors’, which we imagine is a wider
classification; and all the conditions of ‘my-own-errors’ which should
include ‘error’, which is the widest of all.

   The error string should start with a capital letter but it should not
end with a period.  This is for consistency with the rest of Emacs.

   Naturally, Emacs will never signal ‘new-error’ on its own; only an
explicit call to ‘signal’ (*note Definition of signal::) in your code
can do this:

     (signal 'new-error '(x y))
          error→ A new error: x, y

   This error can be handled through any of its condition names.  This
example handles ‘new-error’ and any other errors in the class
‘my-own-errors’:

     (condition-case foo
         (bar nil t)
       (my-own-errors nil))

   The significant way that errors are classified is by their condition
names—the names used to match errors with handlers.  An error symbol
serves only as a convenient way to specify the intended error message
and list of condition names.  It would be cumbersome to give ‘signal’ a
list of condition names rather than one error symbol.

   By contrast, using only error symbols without condition names would
seriously decrease the power of ‘condition-case’.  Condition names make
it possible to categorize errors at various levels of generality when
you write an error handler.  Using error symbols alone would eliminate
all but the narrowest level of classification.

   *Note Standard Errors::, for a list of the main error symbols and
their conditions.


File: elisp.info,  Node: Cleanups,  Prev: Errors,  Up: Nonlocal Exits

11.6.4 Cleaning Up from Nonlocal Exits
--------------------------------------

The ‘unwind-protect’ construct is essential whenever you temporarily put
a data structure in an inconsistent state; it permits you to make the
data consistent again in the event of an error or throw.  (Another more
specific cleanup construct that is used only for changes in buffer
contents is the atomic change group; *note Atomic Changes::.)

 -- Special Form: unwind-protect body-form cleanup-forms...
     ‘unwind-protect’ executes BODY-FORM with a guarantee that the
     CLEANUP-FORMS will be evaluated if control leaves BODY-FORM, no
     matter how that happens.  BODY-FORM may complete normally, or
     execute a ‘throw’ out of the ‘unwind-protect’, or cause an error;
     in all cases, the CLEANUP-FORMS will be evaluated.

     If BODY-FORM finishes normally, ‘unwind-protect’ returns the value
     of BODY-FORM, after it evaluates the CLEANUP-FORMS.  If BODY-FORM
     does not finish, ‘unwind-protect’ does not return any value in the
     normal sense.

     Only BODY-FORM is protected by the ‘unwind-protect’.  If any of the
     CLEANUP-FORMS themselves exits nonlocally (via a ‘throw’ or an
     error), ‘unwind-protect’ is _not_ guaranteed to evaluate the rest
     of them.  If the failure of one of the CLEANUP-FORMS has the
     potential to cause trouble, then protect it with another
     ‘unwind-protect’ around that form.

     The number of currently active ‘unwind-protect’ forms counts,
     together with the number of local variable bindings, against the
     limit ‘max-specpdl-size’ (*note Local Variables: Definition of
     max-specpdl-size.).

   For example, here we make an invisible buffer for temporary use, and
make sure to kill it before finishing:

     (let ((buffer (get-buffer-create " *temp*")))
       (with-current-buffer buffer
         (unwind-protect
             BODY-FORM
           (kill-buffer buffer))))

You might think that we could just as well write ‘(kill-buffer
(current-buffer))’ and dispense with the variable ‘buffer’.  However,
the way shown above is safer, if BODY-FORM happens to get an error after
switching to a different buffer!  (Alternatively, you could write a
‘save-current-buffer’ around BODY-FORM, to ensure that the temporary
buffer becomes current again in time to kill it.)

   Emacs includes a standard macro called ‘with-temp-buffer’ which
expands into more or less the code shown above (*note Current Buffer:
Definition of with-temp-buffer.).  Several of the macros defined in this
manual use ‘unwind-protect’ in this way.

   Here is an actual example derived from an FTP package.  It creates a
process (*note Processes::) to try to establish a connection to a remote
machine.  As the function ‘ftp-login’ is highly susceptible to numerous
problems that the writer of the function cannot anticipate, it is
protected with a form that guarantees deletion of the process in the
event of failure.  Otherwise, Emacs might fill up with useless
subprocesses.

     (let ((win nil))
       (unwind-protect
           (progn
             (setq process (ftp-setup-buffer host file))
             (if (setq win (ftp-login process host user password))
                 (message "Logged in")
               (error "Ftp login failed")))
         (or win (and process (delete-process process)))))

   This example has a small bug: if the user types ‘C-g’ to quit, and
the quit happens immediately after the function ‘ftp-setup-buffer’
returns but before the variable ‘process’ is set, the process will not
be killed.  There is no easy way to fix this bug, but at least it is
very unlikely.


File: elisp.info,  Node: Variables,  Next: Functions,  Prev: Control Structures,  Up: Top

12 Variables
************

A “variable” is a name used in a program to stand for a value.  In Lisp,
each variable is represented by a Lisp symbol (*note Symbols::).  The
variable name is simply the symbol’s name, and the variable’s value is
stored in the symbol’s value cell(1).  *Note Symbol Components::.  In
Emacs Lisp, the use of a symbol as a variable is independent of its use
as a function name.

   As previously noted in this manual, a Lisp program is represented
primarily by Lisp objects, and only secondarily as text.  The textual
form of a Lisp program is given by the read syntax of the Lisp objects
that constitute the program.  Hence, the textual form of a variable in a
Lisp program is written using the read syntax for the symbol
representing the variable.

* Menu:

* Global Variables::            Variable values that exist permanently, everywhere.
* Constant Variables::          Variables that never change.
* Local Variables::             Variable values that exist only temporarily.
* Void Variables::              Symbols that lack values.
* Defining Variables::          A definition says a symbol is used as a variable.
* Tips for Defining::           Things you should think about when you
                            define a variable.
* Accessing Variables::         Examining values of variables whose names
                            are known only at run time.
* Setting Variables::           Storing new values in variables.
* Watching Variables::          Running a function when a variable is changed.
* Variable Scoping::            How Lisp chooses among local and global values.
* Buffer-Local Variables::      Variable values in effect only in one buffer.
* File Local Variables::        Handling local variable lists in files.
* Directory Local Variables::   Local variables common to all files in a directory.
* Connection Local Variables::  Local variables common for remote connections.
* Variable Aliases::            Variables that are aliases for other variables.
* Variables with Restricted Values::  Non-constant variables whose value can
                                        _not_ be an arbitrary Lisp object.
* Generalized Variables::       Extending the concept of variables.

   ---------- Footnotes ----------

   (1) To be precise, under the default “dynamic scoping” rule, the
value cell always holds the variable’s current value, but this is not
the case under the “lexical scoping” rule.  *Note Variable Scoping::,
for details.


File: elisp.info,  Node: Global Variables,  Next: Constant Variables,  Up: Variables

12.1 Global Variables
=====================

The simplest way to use a variable is “globally”.  This means that the
variable has just one value at a time, and this value is in effect (at
least for the moment) throughout the Lisp system.  The value remains in
effect until you specify a new one.  When a new value replaces the old
one, no trace of the old value remains in the variable.

   You specify a value for a symbol with ‘setq’.  For example,

     (setq x '(a b))

gives the variable ‘x’ the value ‘(a b)’.  Note that ‘setq’ is a special
form (*note Special Forms::); it does not evaluate its first argument,
the name of the variable, but it does evaluate the second argument, the
new value.

   Once the variable has a value, you can refer to it by using the
symbol itself as an expression.  Thus,

     x ⇒ (a b)

assuming the ‘setq’ form shown above has already been executed.

   If you do set the same variable again, the new value replaces the old
one:

     x
          ⇒ (a b)
     (setq x 4)
          ⇒ 4
     x
          ⇒ 4


File: elisp.info,  Node: Constant Variables,  Next: Local Variables,  Prev: Global Variables,  Up: Variables

12.2 Variables that Never Change
================================

In Emacs Lisp, certain symbols normally evaluate to themselves.  These
include ‘nil’ and ‘t’, as well as any symbol whose name starts with ‘:’
(these are called “keywords”).  These symbols cannot be rebound, nor can
their values be changed.  Any attempt to set or bind ‘nil’ or ‘t’
signals a ‘setting-constant’ error.  The same is true for a keyword (a
symbol whose name starts with ‘:’), if it is interned in the standard
obarray, except that setting such a symbol to itself is not an error.

     nil ≡ 'nil
          ⇒ nil
     (setq nil 500)
     error→ Attempt to set constant symbol: nil

 -- Function: keywordp object
     function returns ‘t’ if OBJECT is a symbol whose name starts with
     ‘:’, interned in the standard obarray, and returns ‘nil’ otherwise.

   These constants are fundamentally different from the constants
defined using the ‘defconst’ special form (*note Defining Variables::).
A ‘defconst’ form serves to inform human readers that you do not intend
to change the value of a variable, but Emacs does not raise an error if
you actually change it.

   A small number of additional symbols are made read-only for various
practical reasons.  These include ‘enable-multibyte-characters’,
‘most-positive-fixnum’, ‘most-negative-fixnum’, and a few others.  Any
attempt to set or bind these also signals a ‘setting-constant’ error.


File: elisp.info,  Node: Local Variables,  Next: Void Variables,  Prev: Constant Variables,  Up: Variables

12.3 Local Variables
====================

Global variables have values that last until explicitly superseded with
new values.  Sometimes it is useful to give a variable a “local value”—a
value that takes effect only within a certain part of a Lisp program.
When a variable has a local value, we say that it is “locally bound” to
that value, and that it is a “local variable”.

   For example, when a function is called, its argument variables
receive local values, which are the actual arguments supplied to the
function call; these local bindings take effect within the body of the
function.  To take another example, the ‘let’ special form explicitly
establishes local bindings for specific variables, which take effect
only within the body of the ‘let’ form.

   We also speak of the “global binding”, which is where (conceptually)
the global value is kept.

   Establishing a local binding saves away the variable’s previous value
(or lack of one).  We say that the previous value is “shadowed”.  Both
global and local values may be shadowed.  If a local binding is in
effect, using ‘setq’ on the local variable stores the specified value in
the local binding.  When that local binding is no longer in effect, the
previously shadowed value (or lack of one) comes back.

   A variable can have more than one local binding at a time (e.g., if
there are nested ‘let’ forms that bind the variable).  The “current
binding” is the local binding that is actually in effect.  It determines
the value returned by evaluating the variable symbol, and it is the
binding acted on by ‘setq’.

   For most purposes, you can think of the current binding as the
innermost local binding, or the global binding if there is no local
binding.  To be more precise, a rule called the “scoping rule”
determines where in a program a local binding takes effect.  The default
scoping rule in Emacs Lisp is called “dynamic scoping”, which simply
states that the current binding at any given point in the execution of a
program is the most recently-created binding for that variable that
still exists.  For details about dynamic scoping, and an alternative
scoping rule called “lexical scoping”, *Note Variable Scoping::.

   The special forms ‘let’ and ‘let*’ exist to create local bindings:

 -- Special Form: let (bindings...) forms...
     This special form sets up local bindings for a certain set of
     variables, as specified by BINDINGS, and then evaluates all of the
     FORMS in textual order.  Its return value is the value of the last
     form in FORMS.  The local bindings set up by ‘let’ will be in
     effect only within the body of FORMS.

     Each of the BINDINGS is either (i) a symbol, in which case that
     symbol is locally bound to ‘nil’; or (ii) a list of the form
     ‘(SYMBOL VALUE-FORM)’, in which case SYMBOL is locally bound to the
     result of evaluating VALUE-FORM.  If VALUE-FORM is omitted, ‘nil’
     is used.

     All of the VALUE-FORMs in BINDINGS are evaluated in the order they
     appear and _before_ binding any of the symbols to them.  Here is an
     example of this: ‘z’ is bound to the old value of ‘y’, which is 2,
     not the new value of ‘y’, which is 1.

          (setq y 2)
               ⇒ 2

          (let ((y 1)
                (z y))
            (list y z))
               ⇒ (1 2)

     On the other hand, the order of _bindings_ is unspecified: in the
     following example, either 1 or 2 might be printed.

          (let ((x 1)
                (x 2))
            (print x))

     Therefore, avoid binding a variable more than once in a single
     ‘let’ form.

 -- Special Form: let* (bindings...) forms...
     This special form is like ‘let’, but it binds each variable right
     after computing its local value, before computing the local value
     for the next variable.  Therefore, an expression in BINDINGS can
     refer to the preceding symbols bound in this ‘let*’ form.  Compare
     the following example with the example above for ‘let’.

          (setq y 2)
               ⇒ 2

          (let* ((y 1)
                 (z y))    ; Use the just-established value of ‘y’.
            (list y z))
               ⇒ (1 1)

   Here is a complete list of the other facilities that create local
bindings:

   • Function calls (*note Functions::).

   • Macro calls (*note Macros::).

   • ‘condition-case’ (*note Errors::).

   Variables can also have buffer-local bindings (*note Buffer-Local
Variables::); a few variables have terminal-local bindings (*note
Multiple Terminals::).  These kinds of bindings work somewhat like
ordinary local bindings, but they are localized depending on where you
are in Emacs.

 -- User Option: max-specpdl-size
     This variable defines the limit on the total number of local
     variable bindings and ‘unwind-protect’ cleanups (see *note Cleaning
     Up from Nonlocal Exits: Cleanups.) that are allowed before Emacs
     signals an error (with data ‘"Variable binding depth exceeds
     max-specpdl-size"’).

     This limit, with the associated error when it is exceeded, is one
     way that Lisp avoids infinite recursion on an ill-defined function.
     ‘max-lisp-eval-depth’ provides another limit on depth of nesting.
     *Note Eval: Definition of max-lisp-eval-depth.

     The default value is 1300.  Entry to the Lisp debugger increases
     the value, if there is little room left, to make sure the debugger
     itself has room to execute.


File: elisp.info,  Node: Void Variables,  Next: Defining Variables,  Prev: Local Variables,  Up: Variables

12.4 When a Variable is Void
============================

We say that a variable is void if its symbol has an unassigned value
cell (*note Symbol Components::).

   Under Emacs Lisp’s default dynamic scoping rule (*note Variable
Scoping::), the value cell stores the variable’s current (local or
global) value.  Note that an unassigned value cell is _not_ the same as
having ‘nil’ in the value cell.  The symbol ‘nil’ is a Lisp object and
can be the value of a variable, just as any other object can be; but it
is still a value.  If a variable is void, trying to evaluate the
variable signals a ‘void-variable’ error, instead of returning a value.

   Under the optional lexical scoping rule, the value cell only holds
the variable’s global value—the value outside of any lexical binding
construct.  When a variable is lexically bound, the local value is
determined by the lexical environment; hence, variables can have local
values even if their symbols’ value cells are unassigned.

 -- Function: makunbound symbol
     This function empties out the value cell of SYMBOL, making the
     variable void.  It returns SYMBOL.

     If SYMBOL has a dynamic local binding, ‘makunbound’ voids the
     current binding, and this voidness lasts only as long as the local
     binding is in effect.  Afterwards, the previously shadowed local or
     global binding is reexposed; then the variable will no longer be
     void, unless the reexposed binding is void too.

     Here are some examples (assuming dynamic binding is in effect):

          (setq x 1)               ; Put a value in the global binding.
               ⇒ 1
          (let ((x 2))             ; Locally bind it.
            (makunbound 'x)        ; Void the local binding.
            x)
          error→ Symbol's value as variable is void: x
          x                        ; The global binding is unchanged.
               ⇒ 1

          (let ((x 2))             ; Locally bind it.
            (let ((x 3))           ; And again.
              (makunbound 'x)      ; Void the innermost-local binding.
              x))                  ; And refer: it’s void.
          error→ Symbol's value as variable is void: x

          (let ((x 2))
            (let ((x 3))
              (makunbound 'x))     ; Void inner binding, then remove it.
            x)                     ; Now outer ‘let’ binding is visible.
               ⇒ 2

 -- Function: boundp variable
     This function returns ‘t’ if VARIABLE (a symbol) is not void, and
     ‘nil’ if it is void.

     Here are some examples (assuming dynamic binding is in effect):

          (boundp 'abracadabra)          ; Starts out void.
               ⇒ nil
          (let ((abracadabra 5))         ; Locally bind it.
            (boundp 'abracadabra))
               ⇒ t
          (boundp 'abracadabra)          ; Still globally void.
               ⇒ nil
          (setq abracadabra 5)           ; Make it globally nonvoid.
               ⇒ 5
          (boundp 'abracadabra)
               ⇒ t


File: elisp.info,  Node: Defining Variables,  Next: Tips for Defining,  Prev: Void Variables,  Up: Variables

12.5 Defining Global Variables
==============================

A “variable definition” is a construct that announces your intention to
use a symbol as a global variable.  It uses the special forms ‘defvar’
or ‘defconst’, which are documented below.

   A variable definition serves three purposes.  First, it informs
people who read the code that the symbol is _intended_ to be used a
certain way (as a variable).  Second, it informs the Lisp system of
this, optionally supplying an initial value and a documentation string.
Third, it provides information to programming tools such as ‘etags’,
allowing them to find where the variable was defined.

   The difference between ‘defconst’ and ‘defvar’ is mainly a matter of
intent, serving to inform human readers of whether the value should ever
change.  Emacs Lisp does not actually prevent you from changing the
value of a variable defined with ‘defconst’.  One notable difference
between the two forms is that ‘defconst’ unconditionally initializes the
variable, whereas ‘defvar’ initializes it only if it is originally void.

   To define a customizable variable, you should use ‘defcustom’ (which
calls ‘defvar’ as a subroutine).  *Note Variable Definitions::.

 -- Special Form: defvar symbol [value [doc-string]]
     This special form defines SYMBOL as a variable.  Note that SYMBOL
     is not evaluated; the symbol to be defined should appear explicitly
     in the ‘defvar’ form.  The variable is marked as “special”, meaning
     that it should always be dynamically bound (*note Variable
     Scoping::).

     If VALUE is specified, and SYMBOL is void (i.e., it has no
     dynamically bound value; *note Void Variables::), then VALUE is
     evaluated and SYMBOL is set to the result.  But if SYMBOL is not
     void, VALUE is not evaluated, and SYMBOL’s value is left unchanged.
     If VALUE is omitted, the value of SYMBOL is not changed in any
     case.

     Note that specifying a value, even ‘nil’, marks the variable as
     special permanently.  Whereas if VALUE is omitted then the variable
     is only marked special locally (i.e. within the current lexical
     scope, or file if at the top-level).  This can be useful for
     suppressing byte compilation warnings, see *note Compiler Errors::.

     If SYMBOL has a buffer-local binding in the current buffer,
     ‘defvar’ acts on the default value, which is buffer-independent,
     rather than the buffer-local binding.  It sets the default value if
     the default value is void.  *Note Buffer-Local Variables::.

     If SYMBOL is already lexically bound (e.g., if the ‘defvar’ form
     occurs in a ‘let’ form with lexical binding enabled), then ‘defvar’
     sets the dynamic value.  The lexical binding remains in effect
     until its binding construct exits.  *Note Variable Scoping::.

     When you evaluate a top-level ‘defvar’ form with ‘C-M-x’ in Emacs
     Lisp mode (‘eval-defun’), a special feature of ‘eval-defun’
     arranges to set the variable unconditionally, without testing
     whether its value is void.

     If the DOC-STRING argument is supplied, it specifies the
     documentation string for the variable (stored in the symbol’s
     ‘variable-documentation’ property).  *Note Documentation::.

     Here are some examples.  This form defines ‘foo’ but does not
     initialize it:

          (defvar foo)
               ⇒ foo

     This example initializes the value of ‘bar’ to ‘23’, and gives it a
     documentation string:

          (defvar bar 23
            "The normal weight of a bar.")
               ⇒ bar

     The ‘defvar’ form returns SYMBOL, but it is normally used at top
     level in a file where its value does not matter.

     For a more elaborate example of using ‘defvar’ without a value, see
     *note Local defvar example::.

 -- Special Form: defconst symbol value [doc-string]
     This special form defines SYMBOL as a value and initializes it.  It
     informs a person reading your code that SYMBOL has a standard
     global value, established here, that should not be changed by the
     user or by other programs.  Note that SYMBOL is not evaluated; the
     symbol to be defined must appear explicitly in the ‘defconst’.

     The ‘defconst’ form, like ‘defvar’, marks the variable as
     “special”, meaning that it should always be dynamically bound
     (*note Variable Scoping::).  In addition, it marks the variable as
     risky (*note File Local Variables::).

     ‘defconst’ always evaluates VALUE, and sets the value of SYMBOL to
     the result.  If SYMBOL does have a buffer-local binding in the
     current buffer, ‘defconst’ sets the default value, not the
     buffer-local value.  (But you should not be making buffer-local
     bindings for a symbol that is defined with ‘defconst’.)

     An example of the use of ‘defconst’ is Emacs’s definition of
     ‘float-pi’—the mathematical constant pi, which ought not to be
     changed by anyone (attempts by the Indiana State Legislature
     notwithstanding).  As the second form illustrates, however,
     ‘defconst’ is only advisory.

          (defconst float-pi 3.141592653589793 "The value of Pi.")
               ⇒ float-pi
          (setq float-pi 3)
               ⇒ float-pi
          float-pi
               ⇒ 3

   *Warning:* If you use a ‘defconst’ or ‘defvar’ special form while the
variable has a local binding (made with ‘let’, or a function argument),
it sets the local binding rather than the global binding.  This is not
what you usually want.  To prevent this, use these special forms at top
level in a file, where normally no local binding is in effect, and make
sure to load the file before making a local binding for the variable.


File: elisp.info,  Node: Tips for Defining,  Next: Accessing Variables,  Prev: Defining Variables,  Up: Variables

12.6 Tips for Defining Variables Robustly
=========================================

When you define a variable whose value is a function, or a list of
functions, use a name that ends in ‘-function’ or ‘-functions’,
respectively.

   There are several other variable name conventions; here is a complete
list:

‘...-hook’
     The variable is a normal hook (*note Hooks::).

‘...-function’
     The value is a function.

‘...-functions’
     The value is a list of functions.

‘...-form’
     The value is a form (an expression).

‘...-forms’
     The value is a list of forms (expressions).

‘...-predicate’
     The value is a predicate—a function of one argument that returns
     non-‘nil’ for success and ‘nil’ for failure.

‘...-flag’
     The value is significant only as to whether it is ‘nil’ or not.
     Since such variables often end up acquiring more values over time,
     this convention is not strongly recommended.

‘...-program’
     The value is a program name.

‘...-command’
     The value is a whole shell command.

‘...-switches’
     The value specifies options for a command.

‘PREFIX--...’
     The variable is intended for internal use and is defined in the
     file ‘PREFIX.el’.  (Emacs code contributed before 2018 may follow
     other conventions, which are being phased out.)

‘...-internal’
     The variable is intended for internal use and is defined in C code.
     (Emacs code contributed before 2018 may follow other conventions,
     which are being phased out.)

   When you define a variable, always consider whether you should mark
it as safe or risky; see *note File Local Variables::.

   When defining and initializing a variable that holds a complicated
value (such as a keymap with bindings in it), it’s best to put the
entire computation of the value into the ‘defvar’, like this:

     (defvar my-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\C-c\C-a" 'my-command)
         ...
         map)
       DOCSTRING)

This method has several benefits.  First, if the user quits while
loading the file, the variable is either still uninitialized or
initialized properly, never in-between.  If it is still uninitialized,
reloading the file will initialize it properly.  Second, reloading the
file once the variable is initialized will not alter it; that is
important if the user has run hooks to alter part of the contents (such
as, to rebind keys).  Third, evaluating the ‘defvar’ form with ‘C-M-x’
will reinitialize the map completely.

   Putting so much code in the ‘defvar’ form has one disadvantage: it
puts the documentation string far away from the line which names the
variable.  Here’s a safe way to avoid that:

     (defvar my-mode-map nil
       DOCSTRING)
     (unless my-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\C-c\C-a" 'my-command)
         ...
         (setq my-mode-map map)))

This has all the same advantages as putting the initialization inside
the ‘defvar’, except that you must type ‘C-M-x’ twice, once on each
form, if you do want to reinitialize the variable.


File: elisp.info,  Node: Accessing Variables,  Next: Setting Variables,  Prev: Tips for Defining,  Up: Variables

12.7 Accessing Variable Values
==============================

The usual way to reference a variable is to write the symbol which names
it.  *Note Symbol Forms::.

   Occasionally, you may want to reference a variable which is only
determined at run time.  In that case, you cannot specify the variable
name in the text of the program.  You can use the ‘symbol-value’
function to extract the value.

 -- Function: symbol-value symbol
     This function returns the value stored in SYMBOL’s value cell.
     This is where the variable’s current (dynamic) value is stored.  If
     the variable has no local binding, this is simply its global value.
     If the variable is void, a ‘void-variable’ error is signaled.

     If the variable is lexically bound, the value reported by
     ‘symbol-value’ is not necessarily the same as the variable’s
     lexical value, which is determined by the lexical environment
     rather than the symbol’s value cell.  *Note Variable Scoping::.

          (setq abracadabra 5)
               ⇒ 5
          (setq foo 9)
               ⇒ 9

          ;; Here the symbol ‘abracadabra’
          ;;   is the symbol whose value is examined.
          (let ((abracadabra 'foo))
            (symbol-value 'abracadabra))
               ⇒ foo

          ;; Here, the value of ‘abracadabra’,
          ;;   which is ‘foo’,
          ;;   is the symbol whose value is examined.
          (let ((abracadabra 'foo))
            (symbol-value abracadabra))
               ⇒ 9

          (symbol-value 'abracadabra)
               ⇒ 5


File: elisp.info,  Node: Setting Variables,  Next: Watching Variables,  Prev: Accessing Variables,  Up: Variables

12.8 Setting Variable Values
============================

The usual way to change the value of a variable is with the special form
‘setq’.  When you need to compute the choice of variable at run time,
use the function ‘set’.

 -- Special Form: setq [symbol form]...
     This special form is the most common method of changing a
     variable’s value.  Each SYMBOL is given a new value, which is the
     result of evaluating the corresponding FORM.  The current binding
     of the symbol is changed.

     ‘setq’ does not evaluate SYMBOL; it sets the symbol that you write.
     We say that this argument is “automatically quoted”.  The ‘q’ in
     ‘setq’ stands for “quoted”.

     The value of the ‘setq’ form is the value of the last FORM.

          (setq x (1+ 2))
               ⇒ 3
          x                   ; ‘x’ now has a global value.
               ⇒ 3
          (let ((x 5))
            (setq x 6)        ; The local binding of ‘x’ is set.
            x)
               ⇒ 6
          x                   ; The global value is unchanged.
               ⇒ 3

     Note that the first FORM is evaluated, then the first SYMBOL is
     set, then the second FORM is evaluated, then the second SYMBOL is
     set, and so on:

          (setq x 10          ; Notice that ‘x’ is set before
                y (1+ x))     ;   the value of ‘y’ is computed.
               ⇒ 11

 -- Function: set symbol value
     This function puts VALUE in the value cell of SYMBOL.  Since it is
     a function rather than a special form, the expression written for
     SYMBOL is evaluated to obtain the symbol to set.  The return value
     is VALUE.

     When dynamic variable binding is in effect (the default), ‘set’ has
     the same effect as ‘setq’, apart from the fact that ‘set’ evaluates
     its SYMBOL argument whereas ‘setq’ does not.  But when a variable
     is lexically bound, ‘set’ affects its _dynamic_ value, whereas
     ‘setq’ affects its current (lexical) value.  *Note Variable
     Scoping::.

          (set one 1)
          error→ Symbol's value as variable is void: one
          (set 'one 1)
               ⇒ 1
          (set 'two 'one)
               ⇒ one
          (set two 2)         ; ‘two’ evaluates to symbol ‘one’.
               ⇒ 2
          one                 ; So it is ‘one’ that was set.
               ⇒ 2
          (let ((one 1))      ; This binding of ‘one’ is set,
            (set 'one 3)      ;   not the global value.
            one)
               ⇒ 3
          one
               ⇒ 2

     If SYMBOL is not actually a symbol, a ‘wrong-type-argument’ error
     is signaled.

          (set '(x y) 'z)
          error→ Wrong type argument: symbolp, (x y)


File: elisp.info,  Node: Watching Variables,  Next: Variable Scoping,  Prev: Setting Variables,  Up: Variables

12.9 Running a function when a variable is changed.
===================================================

It is sometimes useful to take some action when a variable changes its
value.  The watchpoint facility provides the means to do so.  Some
possible uses for this feature include keeping display in sync with
variable settings, and invoking the debugger to track down unexpected
changes to variables (*note Variable Debugging::).

   The following functions may be used to manipulate and query the watch
functions for a variable.

 -- Function: add-variable-watcher symbol watch-function
     This function arranges for WATCH-FUNCTION to be called whenever
     SYMBOL is modified.  Modifications through aliases (*note Variable
     Aliases::) will have the same effect.

     WATCH-FUNCTION will be called with 4 arguments: (SYMBOL NEWVAL
     OPERATION WHERE).

     SYMBOL is the variable being changed.  NEWVAL is the value it will
     be changed to.  OPERATION is a symbol representing the kind of
     change, one of: ‘set’, ‘let’, ‘unlet’, ‘makunbound’, and
     ‘defvaralias’.  WHERE is a buffer if the buffer-local value of the
     variable is being changed, ‘nil’ otherwise.

 -- Function: remove-variable-watch symbol watch-function
     This function removes WATCH-FUNCTION from SYMBOL’s list of
     watchers.

 -- Function: get-variable-watchers symbol
     This function returns the list of SYMBOL’s active watcher
     functions.

12.9.1 Limitations
------------------

There are a couple of ways in which a variable could be modified (or at
least appear to be modified) without triggering a watchpoint.

   Since watchpoints are attached to symbols, modification to the
objects contained within variables (e.g., by a list modification
function *note Modifying Lists::) is not caught by this mechanism.

   Additionally, C code can modify the value of variables directly,
bypassing the watchpoint mechanism.

   A minor limitation of this feature, again because it targets symbols,
is that only variables of dynamic scope may be watched.  This poses
little difficulty, since modifications to lexical variables can be
discovered easily by inspecting the code within the scope of the
variable (unlike dynamic variables, which can be modified by any code at
all, *note Variable Scoping::).


File: elisp.info,  Node: Variable Scoping,  Next: Buffer-Local Variables,  Prev: Watching Variables,  Up: Variables

12.10 Scoping Rules for Variable Bindings
=========================================

When you create a local binding for a variable, that binding takes
effect only within a limited portion of the program (*note Local
Variables::).  This section describes exactly what this means.

   Each local binding has a certain “scope” and “extent”.  “Scope”
refers to _where_ in the textual source code the binding can be
accessed.  “Extent” refers to _when_, as the program is executing, the
binding exists.

   By default, the local bindings that Emacs creates are “dynamic
bindings”.  Such a binding has “dynamic scope”, meaning that any part of
the program can potentially access the variable binding.  It also has
“dynamic extent”, meaning that the binding lasts only while the binding
construct (such as the body of a ‘let’ form) is being executed.

   Emacs can optionally create “lexical bindings”.  A lexical binding
has “lexical scope”, meaning that any reference to the variable must be
located textually within the binding construct(1).  It also has
“indefinite extent”, meaning that under some circumstances the binding
can live on even after the binding construct has finished executing, by
means of special objects called “closures”.

   The following subsections describe dynamic binding and lexical
binding in greater detail, and how to enable lexical binding in Emacs
Lisp programs.

* Menu:

* Dynamic Binding::         The default for binding local variables in Emacs.
* Dynamic Binding Tips::    Avoiding problems with dynamic binding.
* Lexical Binding::         A different type of local variable binding.
* Using Lexical Binding::   How to enable lexical binding.

   ---------- Footnotes ----------

   (1) With some exceptions; for instance, a lexical binding can also be
accessed from the Lisp debugger.


File: elisp.info,  Node: Dynamic Binding,  Next: Dynamic Binding Tips,  Up: Variable Scoping

12.10.1 Dynamic Binding
-----------------------

By default, the local variable bindings made by Emacs are dynamic
bindings.  When a variable is dynamically bound, its current binding at
any point in the execution of the Lisp program is simply the most
recently-created dynamic local binding for that symbol, or the global
binding if there is no such local binding.

   Dynamic bindings have dynamic scope and extent, as shown by the
following example:

     (defvar x -99)  ; ‘x’ receives an initial value of −99.

     (defun getx ()
       x)            ; ‘x’ is used free in this function.

     (let ((x 1))    ; ‘x’ is dynamically bound.
       (getx))
          ⇒ 1

     ;; After the ‘let’ form finishes, ‘x’ reverts to its
     ;; previous value, which is −99.

     (getx)
          ⇒ -99

The function ‘getx’ refers to ‘x’.  This is a “free” reference, in the
sense that there is no binding for ‘x’ within that ‘defun’ construct
itself.  When we call ‘getx’ from within a ‘let’ form in which ‘x’ is
(dynamically) bound, it retrieves the local value (i.e., 1).  But when
we call ‘getx’ outside the ‘let’ form, it retrieves the global value
(i.e., −99).

   Here is another example, which illustrates setting a dynamically
bound variable using ‘setq’:

     (defvar x -99)      ; ‘x’ receives an initial value of −99.

     (defun addx ()
       (setq x (1+ x)))  ; Add 1 to ‘x’ and return its new value.

     (let ((x 1))
       (addx)
       (addx))
          ⇒ 3           ; The two ‘addx’ calls add to ‘x’ twice.

     ;; After the ‘let’ form finishes, ‘x’ reverts to its
     ;; previous value, which is −99.

     (addx)
          ⇒ -98

   Dynamic binding is implemented in Emacs Lisp in a simple way.  Each
symbol has a value cell, which specifies its current dynamic value (or
absence of value).  *Note Symbol Components::.  When a symbol is given a
dynamic local binding, Emacs records the contents of the value cell (or
absence thereof) in a stack, and stores the new local value in the value
cell.  When the binding construct finishes executing, Emacs pops the old
value off the stack, and puts it in the value cell.


File: elisp.info,  Node: Dynamic Binding Tips,  Next: Lexical Binding,  Prev: Dynamic Binding,  Up: Variable Scoping

12.10.2 Proper Use of Dynamic Binding
-------------------------------------

Dynamic binding is a powerful feature, as it allows programs to refer to
variables that are not defined within their local textual scope.
However, if used without restraint, this can also make programs hard to
understand.  There are two clean ways to use this technique:

   • If a variable has no global definition, use it as a local variable
     only within a binding construct, such as the body of the ‘let’ form
     where the variable was bound.  If this convention is followed
     consistently throughout a program, the value of the variable will
     not affect, nor be affected by, any uses of the same variable
     symbol elsewhere in the program.

   • Otherwise, define the variable with ‘defvar’, ‘defconst’ (*note
     Defining Variables::), or ‘defcustom’ (*note Variable
     Definitions::).  Usually, the definition should be at top-level in
     an Emacs Lisp file.  As far as possible, it should include a
     documentation string which explains the meaning and purpose of the
     variable.  You should also choose the variable’s name to avoid name
     conflicts (*note Coding Conventions::).

     Then you can bind the variable anywhere in a program, knowing
     reliably what the effect will be.  Wherever you encounter the
     variable, it will be easy to refer back to the definition, e.g.,
     via the ‘C-h v’ command (provided the variable definition has been
     loaded into Emacs).  *Note (emacs)Name Help::.

     For example, it is common to use local bindings for customizable
     variables like ‘case-fold-search’:

          (defun search-for-abc ()
            "Search for the string \"abc\", ignoring case differences."
            (let ((case-fold-search t))
              (re-search-forward "abc")))


File: elisp.info,  Node: Lexical Binding,  Next: Using Lexical Binding,  Prev: Dynamic Binding Tips,  Up: Variable Scoping

12.10.3 Lexical Binding
-----------------------

Lexical binding was introduced to Emacs, as an optional feature, in
version 24.1.  We expect its importance to increase with time.  Lexical
binding opens up many more opportunities for optimization, so programs
using it are likely to run faster in future Emacs versions.  Lexical
binding is also more compatible with concurrency, which was added to
Emacs in version 26.1.

   A lexically-bound variable has “lexical scope”, meaning that any
reference to the variable must be located textually within the binding
construct.  Here is an example (*note Using Lexical Binding::, for how
to actually enable lexical binding):

     (let ((x 1))    ; ‘x’ is lexically bound.
       (+ x 3))
          ⇒ 4

     (defun getx ()
       x)            ; ‘x’ is used free in this function.

     (let ((x 1))    ; ‘x’ is lexically bound.
       (getx))
     error→ Symbol's value as variable is void: x

Here, the variable ‘x’ has no global value.  When it is lexically bound
within a ‘let’ form, it can be used in the textual confines of that
‘let’ form.  But it can _not_ be used from within a ‘getx’ function
called from the ‘let’ form, since the function definition of ‘getx’
occurs outside the ‘let’ form itself.

   Here is how lexical binding works.  Each binding construct defines a
“lexical environment”, specifying the variables that are bound within
the construct and their local values.  When the Lisp evaluator wants the
current value of a variable, it looks first in the lexical environment;
if the variable is not specified in there, it looks in the symbol’s
value cell, where the dynamic value is stored.

   (Internally, the lexical environment is an alist of symbol-value
pairs, with the final element in the alist being the symbol ‘t’ rather
than a cons cell.  Such an alist can be passed as the second argument to
the ‘eval’ function, in order to specify a lexical environment in which
to evaluate a form.  *Note Eval::.  Most Emacs Lisp programs, however,
should not interact directly with lexical environments in this way; only
specialized programs like debuggers.)

   Lexical bindings have indefinite extent.  Even after a binding
construct has finished executing, its lexical environment can be “kept
around” in Lisp objects called “closures”.  A closure is created when
you define a named or anonymous function with lexical binding enabled.
*Note Closures::, for details.

   When a closure is called as a function, any lexical variable
references within its definition use the retained lexical environment.
Here is an example:

     (defvar my-ticker nil)   ; We will use this dynamically bound
                              ; variable to store a closure.

     (let ((x 0))             ; ‘x’ is lexically bound.
       (setq my-ticker (lambda ()
                         (setq x (1+ x)))))
         ⇒ (closure ((x . 0) t) ()
               (setq x (1+ x)))

     (funcall my-ticker)
         ⇒ 1

     (funcall my-ticker)
         ⇒ 2

     (funcall my-ticker)
         ⇒ 3

     x                        ; Note that ‘x’ has no global value.
     error→ Symbol's value as variable is void: x

The ‘let’ binding defines a lexical environment in which the variable
‘x’ is locally bound to 0.  Within this binding construct, we define a
lambda expression which increments ‘x’ by one and returns the
incremented value.  This lambda expression is automatically turned into
a closure, in which the lexical environment lives on even after the
‘let’ binding construct has exited.  Each time we evaluate the closure,
it increments ‘x’, using the binding of ‘x’ in that lexical environment.

   Note that unlike dynamic variables which are tied to the symbol
object itself, the relationship between lexical variables and symbols is
only present in the interpreter (or compiler).  Therefore, functions
which take a symbol argument (like ‘symbol-value’, ‘boundp’, and ‘set’)
can only retrieve or modify a variable’s dynamic binding (i.e., the
contents of its symbol’s value cell).


File: elisp.info,  Node: Using Lexical Binding,  Prev: Lexical Binding,  Up: Variable Scoping

12.10.4 Using Lexical Binding
-----------------------------

When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical
binding is enabled if the buffer-local variable ‘lexical-binding’ is
non-‘nil’:

 -- Variable: lexical-binding
     If this buffer-local variable is non-‘nil’, Emacs Lisp files and
     buffers are evaluated using lexical binding instead of dynamic
     binding.  (However, special variables are still dynamically bound;
     see below.)  If ‘nil’, dynamic binding is used for all local
     variables.  This variable is typically set for a whole Emacs Lisp
     file, as a file local variable (*note File Local Variables::).
     Note that unlike other such variables, this one must be set in the
     first line of a file.

When evaluating Emacs Lisp code directly using an ‘eval’ call, lexical
binding is enabled if the LEXICAL argument to ‘eval’ is non-‘nil’.
*Note Eval::.

   Even when lexical binding is enabled, certain variables will continue
to be dynamically bound.  These are called “special variables”.  Every
variable that has been defined with ‘defvar’, ‘defcustom’ or ‘defconst’
is a special variable (*note Defining Variables::).  All other variables
are subject to lexical binding.

   Using ‘defvar’ without a value, it is possible to bind a variable
dynamically just in one file, or in just one part of a file while still
binding it lexically elsewhere.  For example:

     (let (_)
       (defvar x)      ; Let-bindings of ‘x’ will be dynamic within this let.
       (let ((x -99))  ; This is a dynamic binding of ‘x’.
         (defun get-dynamic-x ()
           x)))

     (let ((x 'lexical)) ; This is a lexical binding of ‘x’.
       (defun get-lexical-x ()
         x))

     (let (_)
       (defvar x)
       (let ((x 'dynamic))
         (list (get-lexical-x)
               (get-dynamic-x))))
         ⇒ (lexical dynamic)

 -- Function: special-variable-p symbol
     This function returns non-‘nil’ if SYMBOL is a special variable
     (i.e., it has a ‘defvar’, ‘defcustom’, or ‘defconst’ variable
     definition).  Otherwise, the return value is ‘nil’.

   The use of a special variable as a formal argument in a function is
discouraged.  Doing so gives rise to unspecified behavior when lexical
binding mode is enabled (it may use lexical binding sometimes, and
dynamic binding other times).

   Converting an Emacs Lisp program to lexical binding is easy.  First,
add a file-local variable setting of ‘lexical-binding’ to ‘t’ in the
header line of the Emacs Lisp source file (*note File Local
Variables::).  Second, check that every variable in the program which
needs to be dynamically bound has a variable definition, so that it is
not inadvertently bound lexically.

   A simple way to find out which variables need a variable definition
is to byte-compile the source file.  *Note Byte Compilation::.  If a
non-special variable is used outside of a ‘let’ form, the byte-compiler
will warn about reference or assignment to a free variable.  If a
non-special variable is bound but not used within a ‘let’ form, the
byte-compiler will warn about an unused lexical variable.  The
byte-compiler will also issue a warning if you use a special variable as
a function argument.

   (To silence byte-compiler warnings about unused variables, just use a
variable name that starts with an underscore.  The byte-compiler
interprets this as an indication that this is a variable known not to be
used.)


File: elisp.info,  Node: Buffer-Local Variables,  Next: File Local Variables,  Prev: Variable Scoping,  Up: Variables

12.11 Buffer-Local Variables
============================

Global and local variable bindings are found in most programming
languages in one form or another.  Emacs, however, also supports
additional, unusual kinds of variable binding, such as “buffer-local”
bindings, which apply only in one buffer.  Having different values for a
variable in different buffers is an important customization method.
(Variables can also have bindings that are local to each terminal.
*Note Multiple Terminals::.)

* Menu:

* Intro to Buffer-Local::       Introduction and concepts.
* Creating Buffer-Local::       Creating and destroying buffer-local bindings.
* Default Value::               The default value is seen in buffers
                                 that don’t have their own buffer-local values.


File: elisp.info,  Node: Intro to Buffer-Local,  Next: Creating Buffer-Local,  Up: Buffer-Local Variables

12.11.1 Introduction to Buffer-Local Variables
----------------------------------------------

A buffer-local variable has a buffer-local binding associated with a
particular buffer.  The binding is in effect when that buffer is
current; otherwise, it is not in effect.  If you set the variable while
a buffer-local binding is in effect, the new value goes in that binding,
so its other bindings are unchanged.  This means that the change is
visible only in the buffer where you made it.

   The variable’s ordinary binding, which is not associated with any
specific buffer, is called the “default binding”.  In most cases, this
is the global binding.

   A variable can have buffer-local bindings in some buffers but not in
other buffers.  The default binding is shared by all the buffers that
don’t have their own bindings for the variable.  (This includes all
newly-created buffers.)  If you set the variable in a buffer that does
not have a buffer-local binding for it, this sets the default binding,
so the new value is visible in all the buffers that see the default
binding.

   The most common use of buffer-local bindings is for major modes to
change variables that control the behavior of commands.  For example, C
mode and Lisp mode both set the variable ‘paragraph-start’ to specify
that only blank lines separate paragraphs.  They do this by making the
variable buffer-local in the buffer that is being put into C mode or
Lisp mode, and then setting it to the new value for that mode.  *Note
Major Modes::.

   The usual way to make a buffer-local binding is with
‘make-local-variable’, which is what major mode commands typically use.
This affects just the current buffer; all other buffers (including those
yet to be created) will continue to share the default value unless they
are explicitly given their own buffer-local bindings.

   A more powerful operation is to mark the variable as “automatically
buffer-local” by calling ‘make-variable-buffer-local’.  You can think of
this as making the variable local in all buffers, even those yet to be
created.  More precisely, the effect is that setting the variable
automatically makes the variable local to the current buffer if it is
not already so.  All buffers start out by sharing the default value of
the variable as usual, but setting the variable creates a buffer-local
binding for the current buffer.  The new value is stored in the
buffer-local binding, leaving the default binding untouched.  This means
that the default value cannot be changed with ‘setq’ in any buffer; the
only way to change it is with ‘setq-default’.

   *Warning:* When a variable has buffer-local bindings in one or more
buffers, ‘let’ rebinds the binding that’s currently in effect.  For
instance, if the current buffer has a buffer-local value, ‘let’
temporarily rebinds that.  If no buffer-local bindings are in effect,
‘let’ rebinds the default value.  If inside the ‘let’ you then change to
a different current buffer in which a different binding is in effect,
you won’t see the ‘let’ binding any more.  And if you exit the ‘let’
while still in the other buffer, you won’t see the unbinding occur
(though it will occur properly).  Here is an example to illustrate:

     (setq foo 'g)
     (set-buffer "a")
     (make-local-variable 'foo)
     (setq foo 'a)
     (let ((foo 'temp))
       ;; foo ⇒ 'temp  ; let binding in buffer ‘a’
       (set-buffer "b")
       ;; foo ⇒ 'g     ; the global value since foo is not local in ‘b’
       BODY...)
     foo ⇒ 'g        ; exiting restored the local value in buffer ‘a’,
                      ; but we don’t see that in buffer ‘b’
     (set-buffer "a") ; verify the local value was restored
     foo ⇒ 'a

Note that references to ‘foo’ in BODY access the buffer-local binding of
buffer ‘b’.

   When a file specifies local variable values, these become
buffer-local values when you visit the file.  *Note (emacs)File
Variables::.

   A buffer-local variable cannot be made terminal-local (*note Multiple
Terminals::).


File: elisp.info,  Node: Creating Buffer-Local,  Next: Default Value,  Prev: Intro to Buffer-Local,  Up: Buffer-Local Variables

12.11.2 Creating and Deleting Buffer-Local Bindings
---------------------------------------------------

 -- Command: make-local-variable variable
     This function creates a buffer-local binding in the current buffer
     for VARIABLE (a symbol).  Other buffers are not affected.  The
     value returned is VARIABLE.

     The buffer-local value of VARIABLE starts out as the same value
     VARIABLE previously had.  If VARIABLE was void, it remains void.

          ;; In buffer ‘b1’:
          (setq foo 5)                ; Affects all buffers.
               ⇒ 5
          (make-local-variable 'foo)  ; Now it is local in ‘b1’.
               ⇒ foo
          foo                         ; That did not change
               ⇒ 5                   ;   the value.
          (setq foo 6)                ; Change the value
               ⇒ 6                   ;   in ‘b1’.
          foo
               ⇒ 6

          ;; In buffer ‘b2’, the value hasn’t changed.
          (with-current-buffer "b2"
            foo)
               ⇒ 5

     Making a variable buffer-local within a ‘let’-binding for that
     variable does not work reliably, unless the buffer in which you do
     this is not current either on entry to or exit from the ‘let’.
     This is because ‘let’ does not distinguish between different kinds
     of bindings; it knows only which variable the binding was made for.

     It is an error to make a constant or a read-only variable
     buffer-local.  *Note Constant Variables::.

     If the variable is terminal-local (*note Multiple Terminals::),
     this function signals an error.  Such variables cannot have
     buffer-local bindings as well.

     *Warning:* do not use ‘make-local-variable’ for a hook variable.
     The hook variables are automatically made buffer-local as needed if
     you use the LOCAL argument to ‘add-hook’ or ‘remove-hook’.

 -- Macro: setq-local variable value
     This macro creates a buffer-local binding in the current buffer for
     VARIABLE, and gives it the buffer-local value VALUE.  It is
     equivalent to calling ‘make-local-variable’ followed by ‘setq’.
     VARIABLE should be an unquoted symbol.

 -- Command: make-variable-buffer-local variable
     This function marks VARIABLE (a symbol) automatically buffer-local,
     so that any subsequent attempt to set it will make it local to the
     current buffer at the time.  Unlike ‘make-local-variable’, with
     which it is often confused, this cannot be undone, and affects the
     behavior of the variable in all buffers.

     A peculiar wrinkle of this feature is that binding the variable
     (with ‘let’ or other binding constructs) does not create a
     buffer-local binding for it.  Only setting the variable (with ‘set’
     or ‘setq’), while the variable does not have a ‘let’-style binding
     that was made in the current buffer, does so.

     If VARIABLE does not have a default value, then calling this
     command will give it a default value of ‘nil’.  If VARIABLE already
     has a default value, that value remains unchanged.  Subsequently
     calling ‘makunbound’ on VARIABLE will result in a void buffer-local
     value and leave the default value unaffected.

     The value returned is VARIABLE.

     It is an error to make a constant or a read-only variable
     buffer-local.  *Note Constant Variables::.

     *Warning:* Don’t assume that you should use
     ‘make-variable-buffer-local’ for user-option variables, simply
     because users _might_ want to customize them differently in
     different buffers.  Users can make any variable local, when they
     wish to.  It is better to leave the choice to them.

     The time to use ‘make-variable-buffer-local’ is when it is crucial
     that no two buffers ever share the same binding.  For example, when
     a variable is used for internal purposes in a Lisp program which
     depends on having separate values in separate buffers, then using
     ‘make-variable-buffer-local’ can be the best solution.

 -- Macro: defvar-local variable value &optional docstring
     This macro defines VARIABLE as a variable with initial value VALUE
     and DOCSTRING, and marks it as automatically buffer-local.  It is
     equivalent to calling ‘defvar’ followed by
     ‘make-variable-buffer-local’.  VARIABLE should be an unquoted
     symbol.

 -- Function: local-variable-p variable &optional buffer
     This returns ‘t’ if VARIABLE is buffer-local in buffer BUFFER
     (which defaults to the current buffer); otherwise, ‘nil’.

 -- Function: local-variable-if-set-p variable &optional buffer
     This returns ‘t’ if VARIABLE either has a buffer-local value in
     buffer BUFFER, or is automatically buffer-local.  Otherwise, it
     returns ‘nil’.  If omitted or ‘nil’, BUFFER defaults to the current
     buffer.

 -- Function: buffer-local-value variable buffer
     This function returns the buffer-local binding of VARIABLE (a
     symbol) in buffer BUFFER.  If VARIABLE does not have a buffer-local
     binding in buffer BUFFER, it returns the default value (*note
     Default Value::) of VARIABLE instead.

 -- Function: buffer-local-variables &optional buffer
     This function returns a list describing the buffer-local variables
     in buffer BUFFER.  (If BUFFER is omitted, the current buffer is
     used.)  Normally, each list element has the form ‘(SYM . VAL)’,
     where SYM is a buffer-local variable (a symbol) and VAL is its
     buffer-local value.  But when a variable’s buffer-local binding in
     BUFFER is void, its list element is just SYM.

          (make-local-variable 'foobar)
          (makunbound 'foobar)
          (make-local-variable 'bind-me)
          (setq bind-me 69)
          (setq lcl (buffer-local-variables))
              ;; First, built-in variables local in all buffers:
          ⇒ ((mark-active . nil)
              (buffer-undo-list . nil)
              (mode-name . "Fundamental")
              ...
              ;; Next, non-built-in buffer-local variables.
              ;; This one is buffer-local and void:
              foobar
              ;; This one is buffer-local and nonvoid:
              (bind-me . 69))

     Note that storing new values into the CDRs of cons cells in this
     list does _not_ change the buffer-local values of the variables.

 -- Command: kill-local-variable variable
     This function deletes the buffer-local binding (if any) for
     VARIABLE (a symbol) in the current buffer.  As a result, the
     default binding of VARIABLE becomes visible in this buffer.  This
     typically results in a change in the value of VARIABLE, since the
     default value is usually different from the buffer-local value just
     eliminated.

     If you kill the buffer-local binding of a variable that
     automatically becomes buffer-local when set, this makes the default
     value visible in the current buffer.  However, if you set the
     variable again, that will once again create a buffer-local binding
     for it.

     ‘kill-local-variable’ returns VARIABLE.

     This function is a command because it is sometimes useful to kill
     one buffer-local variable interactively, just as it is useful to
     create buffer-local variables interactively.

 -- Function: kill-all-local-variables
     This function eliminates all the buffer-local variable bindings of
     the current buffer except for variables marked as permanent and
     local hook functions that have a non-‘nil’ ‘permanent-local-hook’
     property (*note Setting Hooks::).  As a result, the buffer will see
     the default values of most variables.

     This function also resets certain other information pertaining to
     the buffer: it sets the local keymap to ‘nil’, the syntax table to
     the value of ‘(standard-syntax-table)’, the case table to
     ‘(standard-case-table)’, and the abbrev table to the value of
     ‘fundamental-mode-abbrev-table’.

     The very first thing this function does is run the normal hook
     ‘change-major-mode-hook’ (see below).

     Every major mode command begins by calling this function, which has
     the effect of switching to Fundamental mode and erasing most of the
     effects of the previous major mode.  To ensure that this does its
     job, the variables that major modes set should not be marked
     permanent.

     ‘kill-all-local-variables’ returns ‘nil’.

 -- Variable: change-major-mode-hook
     The function ‘kill-all-local-variables’ runs this normal hook
     before it does anything else.  This gives major modes a way to
     arrange for something special to be done if the user switches to a
     different major mode.  It is also useful for buffer-specific minor
     modes that should be forgotten if the user changes the major mode.

     For best results, make this variable buffer-local, so that it will
     disappear after doing its job and will not interfere with the
     subsequent major mode.  *Note Hooks::.

   A buffer-local variable is “permanent” if the variable name (a
symbol) has a ‘permanent-local’ property that is non-‘nil’.  Such
variables are unaffected by ‘kill-all-local-variables’, and their local
bindings are therefore not cleared by changing major modes.  Permanent
locals are appropriate for data pertaining to where the file came from
or how to save it, rather than with how to edit the contents.

