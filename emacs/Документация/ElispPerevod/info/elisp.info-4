This is elisp.info, produced by makeinfo version 6.1 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp.info,  Node: When to Autoload,  Up: Autoload

16.5.1 When to Use Autoload
---------------------------

Do not add an autoload comment unless it is really necessary.
Autoloading code means it is always globally visible.  Once an item is
autoloaded, there is no compatible way to transition back to it not
being autoloaded (after people become accustomed to being able to use it
without an explicit load).

   • The most common items to autoload are the interactive entry points
     to a library.  For example, if ‘python.el’ is a library defining a
     major-mode for editing Python code, autoload the definition of the
     ‘python-mode’ function, so that people can simply use ‘M-x
     python-mode’ to load the library.

   • Variables usually don’t need to be autoloaded.  An exception is if
     the variable on its own is generally useful without the whole
     defining library being loaded.  (An example of this might be
     something like ‘find-exec-terminator’.)

   • Don’t autoload a user option just so that a user can set it.

   • Never add an autoload _comment_ to silence a compiler warning in
     another file.  In the file that produces the warning, use ‘(defvar
     foo)’ to silence an undefined variable warning, and
     ‘declare-function’ (*note Declaring Functions::) to silence an
     undefined function warning; or require the relevant library; or use
     an explicit autoload _statement_.


File: elisp.info,  Node: Repeated Loading,  Next: Named Features,  Prev: Autoload,  Up: Loading

16.6 Repeated Loading
=====================

You can load a given file more than once in an Emacs session.  For
example, after you have rewritten and reinstalled a function definition
by editing it in a buffer, you may wish to return to the original
version; you can do this by reloading the file it came from.

   When you load or reload files, bear in mind that the ‘load’ and
‘load-library’ functions automatically load a byte-compiled file rather
than a non-compiled file of similar name.  If you rewrite a file that
you intend to save and reinstall, you need to byte-compile the new
version; otherwise Emacs will load the older, byte-compiled file instead
of your newer, non-compiled file!  If that happens, the message
displayed when loading the file includes, ‘(compiled; note, source is
newer)’, to remind you to recompile it.

   When writing the forms in a Lisp library file, keep in mind that the
file might be loaded more than once.  For example, think about whether
each variable should be reinitialized when you reload the library;
‘defvar’ does not change the value if the variable is already
initialized.  (*Note Defining Variables::.)

   The simplest way to add an element to an alist is like this:

     (push '(leif-mode " Leif") minor-mode-alist)

But this would add multiple elements if the library is reloaded.  To
avoid the problem, use ‘add-to-list’ (*note List Variables::):

     (add-to-list 'minor-mode-alist '(leif-mode " Leif"))

   Occasionally you will want to test explicitly whether a library has
already been loaded.  If the library uses ‘provide’ to provide a named
feature, you can use ‘featurep’ earlier in the file to test whether the
‘provide’ call has been executed before (*note Named Features::).
Alternatively, you could use something like this:

     (defvar foo-was-loaded nil)

     (unless foo-was-loaded
       EXECUTE-FIRST-TIME-ONLY
       (setq foo-was-loaded t))



File: elisp.info,  Node: Named Features,  Next: Where Defined,  Prev: Repeated Loading,  Up: Loading

16.7 Features
=============

‘provide’ and ‘require’ are an alternative to ‘autoload’ for loading
files automatically.  They work in terms of named “features”.
Autoloading is triggered by calling a specific function, but a feature
is loaded the first time another program asks for it by name.

   A feature name is a symbol that stands for a collection of functions,
variables, etc.  The file that defines them should “provide” the
feature.  Another program that uses them may ensure they are defined by
“requiring” the feature.  This loads the file of definitions if it
hasn’t been loaded already.

   To require the presence of a feature, call ‘require’ with the feature
name as argument.  ‘require’ looks in the global variable ‘features’ to
see whether the desired feature has been provided already.  If not, it
loads the feature from the appropriate file.  This file should call
‘provide’ at the top level to add the feature to ‘features’; if it fails
to do so, ‘require’ signals an error.

   For example, in ‘idlwave.el’, the definition for
‘idlwave-complete-filename’ includes the following code:

     (defun idlwave-complete-filename ()
       "Use the comint stuff to complete a file name."
        (require 'comint)
        (let* ((comint-file-name-chars "~/A-Za-z0-9+@:_.$#%={}\\-")
               (comint-completion-addsuffix nil)
               ...)
            (comint-dynamic-complete-filename)))

The expression ‘(require 'comint)’ loads the file ‘comint.el’ if it has
not yet been loaded, ensuring that ‘comint-dynamic-complete-filename’ is
defined.  Features are normally named after the files that provide them,
so that ‘require’ need not be given the file name.  (Note that it is
important that the ‘require’ statement be outside the body of the ‘let’.
Loading a library while its variables are let-bound can have unintended
consequences, namely the variables becoming unbound after the let
exits.)

   The ‘comint.el’ file contains the following top-level expression:

     (provide 'comint)

This adds ‘comint’ to the global ‘features’ list, so that ‘(require
'comint)’ will henceforth know that nothing needs to be done.

   When ‘require’ is used at top level in a file, it takes effect when
you byte-compile that file (*note Byte Compilation::) as well as when
you load it.  This is in case the required package contains macros that
the byte compiler must know about.  It also avoids byte compiler
warnings for functions and variables defined in the file loaded with
‘require’.

   Although top-level calls to ‘require’ are evaluated during byte
compilation, ‘provide’ calls are not.  Therefore, you can ensure that a
file of definitions is loaded before it is byte-compiled by including a
‘provide’ followed by a ‘require’ for the same feature, as in the
following example.

     (provide 'my-feature)  ; Ignored by byte compiler,
                            ;   evaluated by ‘load’.
     (require 'my-feature)  ; Evaluated by byte compiler.

The compiler ignores the ‘provide’, then processes the ‘require’ by
loading the file in question.  Loading the file does execute the
‘provide’ call, so the subsequent ‘require’ call does nothing when the
file is loaded.

 -- Function: provide feature &optional subfeatures
     This function announces that FEATURE is now loaded, or being
     loaded, into the current Emacs session.  This means that the
     facilities associated with FEATURE are or will be available for
     other Lisp programs.

     The direct effect of calling ‘provide’ is to add FEATURE to the
     front of ‘features’ if it is not already in that list and call any
     ‘eval-after-load’ code waiting for it (*note Hooks for Loading::).
     The argument FEATURE must be a symbol.  ‘provide’ returns FEATURE.

     If provided, SUBFEATURES should be a list of symbols indicating a
     set of specific subfeatures provided by this version of FEATURE.
     You can test the presence of a subfeature using ‘featurep’.  The
     idea of subfeatures is that you use them when a package (which is
     one FEATURE) is complex enough to make it useful to give names to
     various parts or functionalities of the package, which might or
     might not be loaded, or might or might not be present in a given
     version.  *Note Network Feature Testing::, for an example.

          features
               ⇒ (bar bish)

          (provide 'foo)
               ⇒ foo
          features
               ⇒ (foo bar bish)

     When a file is loaded to satisfy an autoload, and it stops due to
     an error in the evaluation of its contents, any function
     definitions or ‘provide’ calls that occurred during the load are
     undone.  *Note Autoload::.

 -- Function: require feature &optional filename noerror
     This function checks whether FEATURE is present in the current
     Emacs session (using ‘(featurep FEATURE)’; see below).  The
     argument FEATURE must be a symbol.

     If the feature is not present, then ‘require’ loads FILENAME with
     ‘load’.  If FILENAME is not supplied, then the name of the symbol
     FEATURE is used as the base file name to load.  However, in this
     case, ‘require’ insists on finding FEATURE with an added ‘.el’ or
     ‘.elc’ suffix (possibly extended with a compression suffix); a file
     whose name is just FEATURE won’t be used.  (The variable
     ‘load-suffixes’ specifies the exact required Lisp suffixes.)

     If NOERROR is non-‘nil’, that suppresses errors from actual loading
     of the file.  In that case, ‘require’ returns ‘nil’ if loading the
     file fails.  Normally, ‘require’ returns FEATURE.

     If loading the file succeeds but does not provide FEATURE,
     ‘require’ signals an error about the missing feature.

 -- Function: featurep feature &optional subfeature
     This function returns ‘t’ if FEATURE has been provided in the
     current Emacs session (i.e., if FEATURE is a member of ‘features’.)
     If SUBFEATURE is non-‘nil’, then the function returns ‘t’ only if
     that subfeature is provided as well (i.e., if SUBFEATURE is a
     member of the ‘subfeature’ property of the FEATURE symbol.)

 -- Variable: features
     The value of this variable is a list of symbols that are the
     features loaded in the current Emacs session.  Each symbol was put
     in this list with a call to ‘provide’.  The order of the elements
     in the ‘features’ list is not significant.


File: elisp.info,  Node: Where Defined,  Next: Unloading,  Prev: Named Features,  Up: Loading

16.8 Which File Defined a Certain Symbol
========================================

 -- Function: symbol-file symbol &optional type
     This function returns the name of the file that defined SYMBOL.  If
     TYPE is ‘nil’, then any kind of definition is acceptable.  If TYPE
     is ‘defun’, ‘defvar’, or ‘defface’, that specifies function
     definition, variable definition, or face definition only.

     The value is normally an absolute file name.  It can also be ‘nil’,
     if the definition is not associated with any file.  If SYMBOL
     specifies an autoloaded function, the value can be a relative file
     name without extension.

   The basis for ‘symbol-file’ is the data in the variable
‘load-history’.

 -- Variable: load-history
     The value of this variable is an alist that associates the names of
     loaded library files with the names of the functions and variables
     they defined, as well as the features they provided or required.

     Each element in this alist describes one loaded library (including
     libraries that are preloaded at startup).  It is a list whose CAR
     is the absolute file name of the library (a string).  The rest of
     the list elements have these forms:

     ‘VAR’
          The symbol VAR was defined as a variable.
     ‘(defun . FUN)’
          The function FUN was defined.
     ‘(t . FUN)’
          The function FUN was previously an autoload before this
          library redefined it as a function.  The following element is
          always ‘(defun . FUN)’, which represents defining FUN as a
          function.
     ‘(autoload . FUN)’
          The function FUN was defined as an autoload.
     ‘(defface . FACE)’
          The face FACE was defined.
     ‘(require . FEATURE)’
          The feature FEATURE was required.
     ‘(provide . FEATURE)’
          The feature FEATURE was provided.
     ‘(cl-defmethod METHOD SPECIALIZERS)’
          The named METHOD was defined by using ‘cl-defmethod’, with
          SPECIALIZERS as its specializers.
     ‘(define-type . TYPE)’
          The type TYPE was defined.

     The value of ‘load-history’ may have one element whose CAR is
     ‘nil’.  This element describes definitions made with ‘eval-buffer’
     on a buffer that is not visiting a file.

   The command ‘eval-region’ updates ‘load-history’, but does so by
adding the symbols defined to the element for the file being visited,
rather than replacing that element.  *Note Eval::.


File: elisp.info,  Node: Unloading,  Next: Hooks for Loading,  Prev: Where Defined,  Up: Loading

16.9 Unloading
==============

You can discard the functions and variables loaded by a library to
reclaim memory for other Lisp objects.  To do this, use the function
‘unload-feature’:

 -- Command: unload-feature feature &optional force
     This command unloads the library that provided feature FEATURE.  It
     undefines all functions, macros, and variables defined in that
     library with ‘defun’, ‘defalias’, ‘defsubst’, ‘defmacro’,
     ‘defconst’, ‘defvar’, and ‘defcustom’.  It then restores any
     autoloads formerly associated with those symbols.  (Loading saves
     these in the ‘autoload’ property of the symbol.)

     Before restoring the previous definitions, ‘unload-feature’ runs
     ‘remove-hook’ to remove functions in the library from certain
     hooks.  These hooks include variables whose names end in ‘-hook’
     (or the deprecated suffix ‘-hooks’), plus those listed in
     ‘unload-feature-special-hooks’, as well as ‘auto-mode-alist’.  This
     is to prevent Emacs from ceasing to function because important
     hooks refer to functions that are no longer defined.

     Standard unloading activities also undoes ELP profiling of
     functions in that library, unprovides any features provided by the
     library, and cancels timers held in variables defined by the
     library.

     If these measures are not sufficient to prevent malfunction, a
     library can define an explicit unloader named
     ‘FEATURE-unload-function’.  If that symbol is defined as a
     function, ‘unload-feature’ calls it with no arguments before doing
     anything else.  It can do whatever is appropriate to unload the
     library.  If it returns ‘nil’, ‘unload-feature’ proceeds to take
     the normal unload actions.  Otherwise it considers the job to be
     done.

     Ordinarily, ‘unload-feature’ refuses to unload a library on which
     other loaded libraries depend.  (A library A depends on library B
     if A contains a ‘require’ for B.)  If the optional argument FORCE
     is non-‘nil’, dependencies are ignored and you can unload any
     library.

   The ‘unload-feature’ function is written in Lisp; its actions are
based on the variable ‘load-history’.

 -- Variable: unload-feature-special-hooks
     This variable holds a list of hooks to be scanned before unloading
     a library, to remove functions defined in the library.


File: elisp.info,  Node: Hooks for Loading,  Next: Dynamic Modules,  Prev: Unloading,  Up: Loading

16.10 Hooks for Loading
=======================

You can ask for code to be executed each time Emacs loads a library, by
using the variable ‘after-load-functions’:

 -- Variable: after-load-functions
     This abnormal hook is run after loading a file.  Each function in
     the hook is called with a single argument, the absolute filename of
     the file that was just loaded.

   If you want code to be executed when a _particular_ library is
loaded, use the macro ‘with-eval-after-load’:

 -- Macro: with-eval-after-load library body...
     This macro arranges to evaluate BODY at the end of loading the file
     LIBRARY, each time LIBRARY is loaded.  If LIBRARY is already
     loaded, it evaluates BODY right away.

     You don’t need to give a directory or extension in the file name
     LIBRARY.  Normally, you just give a bare file name, like this:

          (with-eval-after-load "edebug" (def-edebug-spec c-point t))

     To restrict which files can trigger the evaluation, include a
     directory or an extension or both in LIBRARY.  Only a file whose
     absolute true name (i.e., the name with all symbolic links chased
     out) matches all the given name components will match.  In the
     following example, ‘my_inst.elc’ or ‘my_inst.elc.gz’ in some
     directory ‘..../foo/bar’ will trigger the evaluation, but not
     ‘my_inst.el’:

          (with-eval-after-load "foo/bar/my_inst.elc" ...)

     LIBRARY can also be a feature (i.e., a symbol), in which case BODY
     is evaluated at the end of any file where ‘(provide LIBRARY)’ is
     called.

     An error in BODY does not undo the load, but does prevent execution
     of the rest of BODY.

   Normally, well-designed Lisp programs should not use
‘with-eval-after-load’.  If you need to examine and set the variables
defined in another library (those meant for outside use), you can do it
immediately—there is no need to wait until the library is loaded.  If
you need to call functions defined by that library, you should load the
library, preferably with ‘require’ (*note Named Features::).


File: elisp.info,  Node: Dynamic Modules,  Prev: Hooks for Loading,  Up: Loading

16.11 Emacs Dynamic Modules
===========================

A “dynamic Emacs module” is a shared library that provides additional
functionality for use in Emacs Lisp programs, just like a package
written in Emacs Lisp would.

   Functions that load Emacs Lisp packages can also load dynamic
modules.  They recognize dynamic modules by looking at their file-name
extension, a.k.a. “suffix”.  This suffix is platform-dependent.

 -- Variable: module-file-suffix
     This variable holds the system-dependent value of the file-name
     extension of the module files.  Its value is ‘.so’ on POSIX hosts
     and ‘.dll’ on MS-Windows.

   Every dynamic module should export a C-callable function named
‘emacs_module_init’, which Emacs will call as part of the call to ‘load’
or ‘require’ which loads the module.  It should also export a symbol
named ‘plugin_is_GPL_compatible’ to indicate that its code is released
under the GPL or compatible license; Emacs will refuse to load modules
that don’t export such a symbol.

   If a module needs to call Emacs functions, it should do so through
the API defined and documented in the header file ‘emacs-module.h’ that
is part of the Emacs distribution.

   Modules can create ‘user-ptr’ Lisp objects that embed pointers to C
struct’s defined by the module.  This is useful for keeping around
complex data structures created by a module, to be passed back to the
module’s functions.  User-ptr objects can also have associated
“finalizers” – functions to be run when the object is GC’ed; this is
useful for freeing any resources allocated for the underlying data
structure, such as memory, open file descriptors, etc.

 -- Function: user-ptrp object
     This function returns ‘t’ if its argument is a ‘user-ptr’ object.

   Loadable modules in Emacs are enabled by using the ‘--with-modules’
option at configure time.

   If you write your own dynamic modules, you may wish to verify their
conformance to the Emacs dynamic module API. Invoking Emacs with the
‘--module-assertions’ option will help you in this matter.  *Note
(emacs)Initial Options::.


File: elisp.info,  Node: Byte Compilation,  Next: Debugging,  Prev: Loading,  Up: Top

17 Byte Compilation
*******************

Emacs Lisp has a “compiler” that translates functions written in Lisp
into a special representation called “byte-code” that can be executed
more efficiently.  The compiler replaces Lisp function definitions with
byte-code.  When a byte-code function is called, its definition is
evaluated by the “byte-code interpreter”.

   Because the byte-compiled code is evaluated by the byte-code
interpreter, instead of being executed directly by the machine’s
hardware (as true compiled code is), byte-code is completely
transportable from machine to machine without recompilation.  It is not,
however, as fast as true compiled code.

   In general, any version of Emacs can run byte-compiled code produced
by recent earlier versions of Emacs, but the reverse is not true.

   If you do not want a Lisp file to be compiled, ever, put a file-local
variable binding for ‘no-byte-compile’ into it, like this:

     ;; -*-no-byte-compile: t; -*-

* Menu:

* Speed of Byte-Code::          An example of speedup from byte compilation.
* Compilation Functions::       Byte compilation functions.
* Docs and Compilation::        Dynamic loading of documentation strings.
* Dynamic Loading::             Dynamic loading of individual functions.
* Eval During Compile::         Code to be evaluated when you compile.
* Compiler Errors::             Handling compiler error messages.
* Byte-Code Objects::           The data type used for byte-compiled functions.
* Disassembly::                 Disassembling byte-code; how to read byte-code.


File: elisp.info,  Node: Speed of Byte-Code,  Next: Compilation Functions,  Up: Byte Compilation

17.1 Performance of Byte-Compiled Code
======================================

A byte-compiled function is not as efficient as a primitive function
written in C, but runs much faster than the version written in Lisp.
Here is an example:

     (defun silly-loop (n)
       "Return the time, in seconds, to run N iterations of a loop."
       (let ((t1 (float-time)))
         (while (> (setq n (1- n)) 0))
         (- (float-time) t1)))
     ⇒ silly-loop

     (silly-loop 50000000)
     ⇒ 10.235304117202759

     (byte-compile 'silly-loop)
     ⇒ [Compiled code not shown]

     (silly-loop 50000000)
     ⇒ 3.705854892730713

   In this example, the interpreted code required 10 seconds to run,
whereas the byte-compiled code required less than 4 seconds.  These
results are representative, but actual results may vary.


File: elisp.info,  Node: Compilation Functions,  Next: Docs and Compilation,  Prev: Speed of Byte-Code,  Up: Byte Compilation

17.2 Byte-Compilation Functions
===============================

You can byte-compile an individual function or macro definition with the
‘byte-compile’ function.  You can compile a whole file with
‘byte-compile-file’, or several files with ‘byte-recompile-directory’ or
‘batch-byte-compile’.

   Sometimes, the byte compiler produces warning and/or error messages
(*note Compiler Errors::, for details).  These messages are normally
recorded in a buffer called ‘*Compile-Log*’, which uses Compilation
mode.  *Note (emacs)Compilation Mode::.  However, if the variable
‘byte-compile-debug’ is non-‘nil’, error messages will be signaled as
Lisp errors instead (*note Errors::).

   Be careful when writing macro calls in files that you intend to
byte-compile.  Since macro calls are expanded when they are compiled,
the macros need to be loaded into Emacs or the byte compiler will not do
the right thing.  The usual way to handle this is with ‘require’ forms
which specify the files containing the needed macro definitions (*note
Named Features::).  Normally, the byte compiler does not evaluate the
code that it is compiling, but it handles ‘require’ forms specially, by
loading the specified libraries.  To avoid loading the macro definition
files when someone _runs_ the compiled program, write
‘eval-when-compile’ around the ‘require’ calls (*note Eval During
Compile::).  For more details, *Note Compiling Macros::.

   Inline (‘defsubst’) functions are less troublesome; if you compile a
call to such a function before its definition is known, the call will
still work right, it will just run slower.

 -- Function: byte-compile symbol
     This function byte-compiles the function definition of SYMBOL,
     replacing the previous definition with the compiled one.  The
     function definition of SYMBOL must be the actual code for the
     function; ‘byte-compile’ does not handle function indirection.  The
     return value is the byte-code function object which is the compiled
     definition of SYMBOL (*note Byte-Code Objects::).

          (defun factorial (integer)
            "Compute factorial of INTEGER."
            (if (= 1 integer) 1
              (* integer (factorial (1- integer)))))
          ⇒ factorial

          (byte-compile 'factorial)
          ⇒
          #[(integer)
            "^H\301U\203^H^@\301\207\302^H\303^HS!\"\207"
            [integer 1 * factorial]
            4 "Compute factorial of INTEGER."]

     If SYMBOL’s definition is a byte-code function object,
     ‘byte-compile’ does nothing and returns ‘nil’.  It does not compile
     the symbol’s definition again, since the original (non-compiled)
     code has already been replaced in the symbol’s function cell by the
     byte-compiled code.

     The argument to ‘byte-compile’ can also be a ‘lambda’ expression.
     In that case, the function returns the corresponding compiled code
     but does not store it anywhere.

 -- Command: compile-defun &optional arg
     This command reads the defun containing point, compiles it, and
     evaluates the result.  If you use this on a defun that is actually
     a function definition, the effect is to install a compiled version
     of that function.

     ‘compile-defun’ normally displays the result of evaluation in the
     echo area, but if ARG is non-‘nil’, it inserts the result in the
     current buffer after the form it has compiled.

 -- Command: byte-compile-file filename &optional load
     This function compiles a file of Lisp code named FILENAME into a
     file of byte-code.  The output file’s name is made by changing the
     ‘.el’ suffix into ‘.elc’; if FILENAME does not end in ‘.el’, it
     adds ‘.elc’ to the end of FILENAME.

     Compilation works by reading the input file one form at a time.  If
     it is a definition of a function or macro, the compiled function or
     macro definition is written out.  Other forms are batched together,
     then each batch is compiled, and written so that its compiled code
     will be executed when the file is read.  All comments are discarded
     when the input file is read.

     This command returns ‘t’ if there were no errors and ‘nil’
     otherwise.  When called interactively, it prompts for the file
     name.

     If LOAD is non-‘nil’, this command loads the compiled file after
     compiling it.  Interactively, LOAD is the prefix argument.

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el

          (byte-compile-file "~/emacs/push.el")
               ⇒ t

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
          -rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc

 -- Command: byte-recompile-directory directory &optional flag force
     This command recompiles every ‘.el’ file in DIRECTORY (or its
     subdirectories) that needs recompilation.  A file needs
     recompilation if a ‘.elc’ file exists but is older than the ‘.el’
     file.

     When a ‘.el’ file has no corresponding ‘.elc’ file, FLAG says what
     to do.  If it is ‘nil’, this command ignores these files.  If FLAG
     is 0, it compiles them.  If it is neither ‘nil’ nor 0, it asks the
     user whether to compile each such file, and asks about each
     subdirectory as well.

     Interactively, ‘byte-recompile-directory’ prompts for DIRECTORY and
     FLAG is the prefix argument.

     If FORCE is non-‘nil’, this command recompiles every ‘.el’ file
     that has a ‘.elc’ file.

     The returned value is unpredictable.

 -- Function: batch-byte-compile &optional noforce
     This function runs ‘byte-compile-file’ on files specified on the
     command line.  This function must be used only in a batch execution
     of Emacs, as it kills Emacs on completion.  An error in one file
     does not prevent processing of subsequent files, but no output file
     will be generated for it, and the Emacs process will terminate with
     a nonzero status code.

     If NOFORCE is non-‘nil’, this function does not recompile files
     that have an up-to-date ‘.elc’ file.

          $ emacs -batch -f batch-byte-compile *.el


File: elisp.info,  Node: Docs and Compilation,  Next: Dynamic Loading,  Prev: Compilation Functions,  Up: Byte Compilation

17.3 Documentation Strings and Compilation
==========================================

When Emacs loads functions and variables from a byte-compiled file, it
normally does not load their documentation strings into memory.  Each
documentation string is dynamically loaded from the byte-compiled file
only when needed.  This saves memory, and speeds up loading by skipping
the processing of the documentation strings.

   This feature has a drawback: if you delete, move, or alter the
compiled file (such as by compiling a new version), Emacs may no longer
be able to access the documentation string of previously-loaded
functions or variables.  Such a problem normally only occurs if you
build Emacs yourself, and happen to edit and/or recompile the Lisp
source files.  To solve it, just reload each file after recompilation.

   Dynamic loading of documentation strings from byte-compiled files is
determined, at compile time, for each byte-compiled file.  It can be
disabled via the option ‘byte-compile-dynamic-docstrings’.

 -- User Option: byte-compile-dynamic-docstrings
     If this is non-‘nil’, the byte compiler generates compiled files
     that are set up for dynamic loading of documentation strings.

     To disable the dynamic loading feature for a specific file, set
     this option to ‘nil’ in its header line (*note Local Variables in
     Files: (emacs)File Variables.), like this:

          -*-byte-compile-dynamic-docstrings: nil;-*-

     This is useful mainly if you expect to change the file, and you
     want Emacs sessions that have already loaded it to keep working
     when the file changes.

   Internally, the dynamic loading of documentation strings is
accomplished by writing compiled files with a special Lisp reader
construct, ‘#@COUNT’.  This construct skips the next COUNT characters.
It also uses the ‘#$’ construct, which stands for the name of this file,
as a string.  Do not use these constructs in Lisp source files; they are
not designed to be clear to humans reading the file.


File: elisp.info,  Node: Dynamic Loading,  Next: Eval During Compile,  Prev: Docs and Compilation,  Up: Byte Compilation

17.4 Dynamic Loading of Individual Functions
============================================

When you compile a file, you can optionally enable the “dynamic function
loading” feature (also known as “lazy loading”).  With dynamic function
loading, loading the file doesn’t fully read the function definitions in
the file.  Instead, each function definition contains a place-holder
which refers to the file.  The first time each function is called, it
reads the full definition from the file, to replace the place-holder.

   The advantage of dynamic function loading is that loading the file
becomes much faster.  This is a good thing for a file which contains
many separate user-callable functions, if using one of them does not
imply you will probably also use the rest.  A specialized mode which
provides many keyboard commands often has that usage pattern: a user may
invoke the mode, but use only a few of the commands it provides.

   The dynamic loading feature has certain disadvantages:

   • If you delete or move the compiled file after loading it, Emacs can
     no longer load the remaining function definitions not already
     loaded.

   • If you alter the compiled file (such as by compiling a new
     version), then trying to load any function not already loaded will
     usually yield nonsense results.

   These problems will never happen in normal circumstances with
installed Emacs files.  But they are quite likely to happen with Lisp
files that you are changing.  The easiest way to prevent these problems
is to reload the new compiled file immediately after each recompilation.

   The byte compiler uses the dynamic function loading feature if the
variable ‘byte-compile-dynamic’ is non-‘nil’ at compilation time.  Do
not set this variable globally, since dynamic loading is desirable only
for certain files.  Instead, enable the feature for specific source
files with file-local variable bindings.  For example, you could do it
by writing this text in the source file’s first line:

     -*-byte-compile-dynamic: t;-*-

 -- Variable: byte-compile-dynamic
     If this is non-‘nil’, the byte compiler generates compiled files
     that are set up for dynamic function loading.

 -- Function: fetch-bytecode function
     If FUNCTION is a byte-code function object, this immediately
     finishes loading the byte code of FUNCTION from its byte-compiled
     file, if it is not fully loaded already.  Otherwise, it does
     nothing.  It always returns FUNCTION.


File: elisp.info,  Node: Eval During Compile,  Next: Compiler Errors,  Prev: Dynamic Loading,  Up: Byte Compilation

17.5 Evaluation During Compilation
==================================

These features permit you to write code to be evaluated during
compilation of a program.

 -- Special Form: eval-and-compile body...
     This form marks BODY to be evaluated both when you compile the
     containing code and when you run it (whether compiled or not).

     You can get a similar result by putting BODY in a separate file and
     referring to that file with ‘require’.  That method is preferable
     when BODY is large.  Effectively ‘require’ is automatically
     ‘eval-and-compile’, the package is loaded both when compiling and
     executing.

     ‘autoload’ is also effectively ‘eval-and-compile’ too.  It’s
     recognized when compiling, so uses of such a function don’t produce
     “not known to be defined” warnings.

     Most uses of ‘eval-and-compile’ are fairly sophisticated.

     If a macro has a helper function to build its result, and that
     macro is used both locally and outside the package, then
     ‘eval-and-compile’ should be used to get the helper both when
     compiling and then later when running.

     If functions are defined programmatically (with ‘fset’ say), then
     ‘eval-and-compile’ can be used to have that done at compile-time as
     well as run-time, so calls to those functions are checked (and
     warnings about “not known to be defined” suppressed).

 -- Special Form: eval-when-compile body...
     This form marks BODY to be evaluated at compile time but not when
     the compiled program is loaded.  The result of evaluation by the
     compiler becomes a constant which appears in the compiled program.
     If you load the source file, rather than compiling it, BODY is
     evaluated normally.

     If you have a constant that needs some calculation to produce,
     ‘eval-when-compile’ can do that at compile-time.  For example,

          (defvar my-regexp
            (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))

     If you’re using another package, but only need macros from it (the
     byte compiler will expand those), then ‘eval-when-compile’ can be
     used to load it for compiling, but not executing.  For example,

          (eval-when-compile
            (require 'my-macro-package))

     The same sort of thing goes for macros and ‘defsubst’ functions
     defined locally and only for use within the file.  They are needed
     for compiling the file, but in most cases they are not needed for
     execution of the compiled file.  For example,

          (eval-when-compile
            (unless (fboundp 'some-new-thing)
              (defmacro 'some-new-thing ()
                (compatibility code))))

     This is often good for code that’s only a fallback for
     compatibility with other versions of Emacs.

     *Common Lisp Note:* At top level, ‘eval-when-compile’ is analogous
     to the Common Lisp idiom ‘(eval-when (compile eval) ...)’.
     Elsewhere, the Common Lisp ‘#.’ reader macro (but not when
     interpreting) is closer to what ‘eval-when-compile’ does.


File: elisp.info,  Node: Compiler Errors,  Next: Byte-Code Objects,  Prev: Eval During Compile,  Up: Byte Compilation

17.6 Compiler Errors
====================

Error and warning messages from byte compilation are printed in a buffer
named ‘*Compile-Log*’.  These messages include file names and line
numbers identifying the location of the problem.  The usual Emacs
commands for operating on compiler output can be used on these messages.

   When an error is due to invalid syntax in the program, the byte
compiler might get confused about the error’s exact location.  One way
to investigate is to switch to the buffer ‘ *Compiler Input*’.  (This
buffer name starts with a space, so it does not show up in the Buffer
Menu.)  This buffer contains the program being compiled, and point shows
how far the byte compiler was able to read; the cause of the error might
be nearby.  *Note Syntax Errors::, for some tips for locating syntax
errors.

   A common type of warning issued by the byte compiler is for functions
and variables that were used but not defined.  Such warnings report the
line number for the end of the file, not the locations where the missing
functions or variables were used; to find these, you must search the
file manually.

   If you are sure that a warning message about a missing function or
variable is unjustified, there are several ways to suppress it:

   • You can suppress the warning for a specific call to a function FUNC
     by conditionalizing it on an ‘fboundp’ test, like this:

          (if (fboundp 'FUNC) ...(FUNC ...)...)

     The call to FUNC must be in the THEN-FORM of the ‘if’, and FUNC
     must appear quoted in the call to ‘fboundp’.  (This feature
     operates for ‘cond’ as well.)

   • Likewise, you can suppress the warning for a specific use of a
     variable VARIABLE by conditionalizing it on a ‘boundp’ test:

          (if (boundp 'VARIABLE) ...VARIABLE...)

     The reference to VARIABLE must be in the THEN-FORM of the ‘if’, and
     VARIABLE must appear quoted in the call to ‘boundp’.

   • You can tell the compiler that a function is defined using
     ‘declare-function’.  *Note Declaring Functions::.

   • Likewise, you can tell the compiler that a variable is defined
     using ‘defvar’ with no initial value.  (Note that this marks the
     variable as special, i.e. dynamically bound, but only within the
     current lexical scope, or file if at top-level.)  *Note Defining
     Variables::.

   You can also suppress any and all compiler warnings within a certain
expression using the construct ‘with-no-warnings’:

 -- Special Form: with-no-warnings body...
     In execution, this is equivalent to ‘(progn BODY...)’, but the
     compiler does not issue warnings for anything that occurs inside
     BODY.

     We recommend that you use this construct around the smallest
     possible piece of code, to avoid missing possible warnings other
     than one you intend to suppress.

   Byte compiler warnings can be controlled more precisely by setting
the variable ‘byte-compile-warnings’.  See its documentation string for
details.

   Sometimes you may wish the byte-compiler warnings to be reported
using ‘error’.  If so, set ‘byte-compile-error-on-warn’ to a non-‘nil’
value.


File: elisp.info,  Node: Byte-Code Objects,  Next: Disassembly,  Prev: Compiler Errors,  Up: Byte Compilation

17.7 Byte-Code Function Objects
===============================

Byte-compiled functions have a special data type: they are “byte-code
function objects”.  Whenever such an object appears as a function to be
called, Emacs uses the byte-code interpreter to execute the byte-code.

   Internally, a byte-code function object is much like a vector; its
elements can be accessed using ‘aref’.  Its printed representation is
like that for a vector, with an additional ‘#’ before the opening ‘[’.
It must have at least four elements; there is no maximum number, but
only the first six elements have any normal use.  They are:

ARGDESC
     The descriptor of the arguments.  This can either be a list of
     arguments, as described in *note Argument List::, or an integer
     encoding the required number of arguments.  In the latter case, the
     value of the descriptor specifies the minimum number of arguments
     in the bits zero to 6, and the maximum number of arguments in bits
     8 to 14.  If the argument list uses ‘&rest’, then bit 7 is set;
     otherwise it’s cleared.

     If ARGDESC is a list, the arguments will be dynamically bound
     before executing the byte code.  If ARGDESC is an integer, the
     arguments will be instead pushed onto the stack of the byte-code
     interpreter, before executing the code.

BYTE-CODE
     The string containing the byte-code instructions.

CONSTANTS
     The vector of Lisp objects referenced by the byte code.  These
     include symbols used as function names and variable names.

STACKSIZE
     The maximum stack size this function needs.

DOCSTRING
     The documentation string (if any); otherwise, ‘nil’.  The value may
     be a number or a list, in case the documentation string is stored
     in a file.  Use the function ‘documentation’ to get the real
     documentation string (*note Accessing Documentation::).

INTERACTIVE
     The interactive spec (if any).  This can be a string or a Lisp
     expression.  It is ‘nil’ for a function that isn’t interactive.

   Here’s an example of a byte-code function object, in printed
representation.  It is the definition of the command ‘backward-sexp’.

     #[256
       "\211\204^G^@\300\262^A\301^A[!\207"
       [1 forward-sexp]
       3
       1793299
       "^p"]

   The primitive way to create a byte-code object is with
‘make-byte-code’:

 -- Function: make-byte-code &rest elements
     This function constructs and returns a byte-code function object
     with ELEMENTS as its elements.

   You should not try to come up with the elements for a byte-code
function yourself, because if they are inconsistent, Emacs may crash
when you call the function.  Always leave it to the byte compiler to
create these objects; it makes the elements consistent (we hope).


File: elisp.info,  Node: Disassembly,  Prev: Byte-Code Objects,  Up: Byte Compilation

17.8 Disassembled Byte-Code
===========================

People do not write byte-code; that job is left to the byte compiler.
But we provide a disassembler to satisfy a cat-like curiosity.  The
disassembler converts the byte-compiled code into human-readable form.

   The byte-code interpreter is implemented as a simple stack machine.
It pushes values onto a stack of its own, then pops them off to use them
in calculations whose results are themselves pushed back on the stack.
When a byte-code function returns, it pops a value off the stack and
returns it as the value of the function.

   In addition to the stack, byte-code functions can use, bind, and set
ordinary Lisp variables, by transferring values between variables and
the stack.

 -- Command: disassemble object &optional buffer-or-name
     This command displays the disassembled code for OBJECT.  In
     interactive use, or if BUFFER-OR-NAME is ‘nil’ or omitted, the
     output goes in a buffer named ‘*Disassemble*’.  If BUFFER-OR-NAME
     is non-‘nil’, it must be a buffer or the name of an existing
     buffer.  Then the output goes there, at point, and point is left
     before the output.

     The argument OBJECT can be a function name, a lambda expression
     (*note Lambda Expressions::), or a byte-code object (*note
     Byte-Code Objects::).  If it is a lambda expression, ‘disassemble’
     compiles it and disassembles the resulting compiled code.

   Here are two examples of using the ‘disassemble’ function.  We have
added explanatory comments to help you relate the byte-code to the Lisp
source; these do not appear in the output of ‘disassemble’.

     (defun factorial (integer)
       "Compute factorial of an integer."
       (if (= 1 integer) 1
         (* integer (factorial (1- integer)))))
          ⇒ factorial

     (factorial 4)
          ⇒ 24

     (disassemble 'factorial)
          ⊣ byte-code for factorial:
      doc: Compute factorial of an integer.
      args: (integer)

     0   varref   integer      ; Get the value of ‘integer’ and
                               ;   push it onto the stack.
     1   constant 1            ; Push 1 onto stack.
     2   eqlsign               ; Pop top two values off stack, compare
                               ;   them, and push result onto stack.
     3   goto-if-nil 1         ; Pop and test top of stack;
                               ;   if ‘nil’, go to 1, else continue.
     6   constant 1            ; Push 1 onto top of stack.
     7   return                ; Return the top element of the stack.
     8:1 varref   integer      ; Push value of ‘integer’ onto stack.
     9   constant factorial    ; Push ‘factorial’ onto stack.
     10  varref   integer      ; Push value of ‘integer’ onto stack.
     11  sub1                  ; Pop ‘integer’, decrement value,
                               ;   push new value onto stack.
     12  call     1            ; Call function ‘factorial’ using first
                               ;   (i.e., top) stack element as argument;
                               ;   push returned value onto stack.
     13 mult                   ; Pop top two values off stack, multiply
                               ;   them, and push result onto stack.
     14 return                 ; Return the top element of the stack.

   The ‘silly-loop’ function is somewhat more complex:

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n))
                   0))
         (list t1 (current-time-string))))
          ⇒ silly-loop

     (disassemble 'silly-loop)
          ⊣ byte-code for silly-loop:
      doc: Return time before and after N iterations of a loop.
      args: (n)

     0   constant current-time-string  ; Push ‘current-time-string’
                                       ;   onto top of stack.
     1   call     0            ; Call ‘current-time-string’ with no
                               ;   argument, push result onto stack.
     2   varbind  t1           ; Pop stack and bind ‘t1’ to popped value.
     3:1 varref   n            ; Get value of ‘n’ from the environment
                               ;   and push the value on the stack.
     4   sub1                  ; Subtract 1 from top of stack.
     5   dup                   ; Duplicate top of stack; i.e., copy the top
                               ;   of the stack and push copy onto stack.
     6   varset   n            ; Pop the top of the stack,
                               ;   and bind ‘n’ to the value.

     ;; (In effect, the sequence ‘dup varset’ copies the top of the stack
     ;; into the value of ‘n’ without popping it.)

     7   constant 0            ; Push 0 onto stack.
     8   gtr                   ; Pop top two values off stack,
                               ;   test if N is greater than 0
                               ;   and push result onto stack.
     9   goto-if-not-nil 1     ; Goto 1 if ‘n’ > 0
                               ;   (this continues the while loop)
                               ;   else continue.
     12  varref   t1           ; Push value of ‘t1’ onto stack.
     13  constant current-time-string  ; Push ‘current-time-string’
                                       ;   onto the top of the stack.
     14  call     0            ; Call ‘current-time-string’ again.
     15  unbind   1            ; Unbind ‘t1’ in local environment.
     16  list2                 ; Pop top two elements off stack, create a
                               ;   list of them, and push it onto stack.
     17  return                ; Return value of the top of stack.


File: elisp.info,  Node: Debugging,  Next: Read and Print,  Prev: Byte Compilation,  Up: Top

18 Debugging Lisp Programs
**************************

There are several ways to find and investigate problems in an Emacs Lisp
program.

   • If a problem occurs when you run the program, you can use the
     built-in Emacs Lisp debugger to suspend the Lisp evaluator, and
     examine and/or alter its internal state.

   • You can use Edebug, a source-level debugger for Emacs Lisp.

   • You can trace the execution of functions involved in the problem
     using the tracing facilities provided by the ‘trace.el’ package.
     This package provides the functions ‘trace-function-foreground’ and
     ‘trace-function-background’ for tracing function calls, and
     ‘trace-values’ for adding values of select variables to the trace.
     For the details, see the documentation of these facilities in
     ‘trace.el’.

   • If a syntactic problem is preventing Lisp from even reading the
     program, you can locate it using Lisp editing commands.

   • You can look at the error and warning messages produced by the byte
     compiler when it compiles the program.  *Note Compiler Errors::.

   • You can use the Testcover package to perform coverage testing on
     the program.

   • You can use the ERT package to write regression tests for the
     program.  *Note the ERT manual: (ert)Top.

   • You can profile the program to get hints about how to make it more
     efficient.

   Other useful tools for debugging input and output problems are the
dribble file (*note Terminal Input::) and the ‘open-termscript’ function
(*note Terminal Output::).

* Menu:

* Debugger::            A debugger for the Emacs Lisp evaluator.
* Edebug::              A source-level Emacs Lisp debugger.
* Syntax Errors::       How to find syntax errors.
* Test Coverage::       Ensuring you have tested all branches in your code.
* Profiling::           Measuring the resources that your code uses.


File: elisp.info,  Node: Debugger,  Next: Edebug,  Up: Debugging

18.1 The Lisp Debugger
======================

The ordinary “Lisp debugger” provides the ability to suspend evaluation
of a form.  While evaluation is suspended (a state that is commonly
known as a “break”), you may examine the run time stack, examine the
values of local or global variables, or change those values.  Since a
break is a recursive edit, all the usual editing facilities of Emacs are
available; you can even run programs that will enter the debugger
recursively.  *Note Recursive Editing::.

* Menu:

* Error Debugging::       Entering the debugger when an error happens.
* Infinite Loops::        Stopping and debugging a program that doesn’t exit.
* Function Debugging::    Entering it when a certain function is called.
* Variable Debugging::    Entering it when a variable is modified.
* Explicit Debug::        Entering it at a certain point in the program.
* Using Debugger::        What the debugger does; what you see while in it.
* Debugger Commands::     Commands used while in the debugger.
* Invoking the Debugger:: How to call the function ‘debug’.
* Internals of Debugger:: Subroutines of the debugger, and global variables.


File: elisp.info,  Node: Error Debugging,  Next: Infinite Loops,  Up: Debugger

18.1.1 Entering the Debugger on an Error
----------------------------------------

The most important time to enter the debugger is when a Lisp error
happens.  This allows you to investigate the immediate causes of the
error.

   However, entry to the debugger is not a normal consequence of an
error.  Many commands signal Lisp errors when invoked inappropriately,
and during ordinary editing it would be very inconvenient to enter the
debugger each time this happens.  So if you want errors to enter the
debugger, set the variable ‘debug-on-error’ to non-‘nil’.  (The command
‘toggle-debug-on-error’ provides an easy way to do this.)

 -- User Option: debug-on-error
     This variable determines whether the debugger is called when an
     error is signaled and not handled.  If ‘debug-on-error’ is ‘t’, all
     kinds of errors call the debugger, except those listed in
     ‘debug-ignored-errors’ (see below).  If it is ‘nil’, none call the
     debugger.

     The value can also be a list of error conditions (*note Signaling
     Errors::).  Then the debugger is called only for error conditions
     in this list (except those also listed in ‘debug-ignored-errors’).
     For example, if you set ‘debug-on-error’ to the list
     ‘(void-variable)’, the debugger is only called for errors about a
     variable that has no value.

     Note that ‘eval-expression-debug-on-error’ overrides this variable
     in some cases; see below.

     When this variable is non-‘nil’, Emacs does not create an error
     handler around process filter functions and sentinels.  Therefore,
     errors in these functions also invoke the debugger.  *Note
     Processes::.

 -- User Option: debug-ignored-errors
     This variable specifies errors which should not enter the debugger,
     regardless of the value of ‘debug-on-error’.  Its value is a list
     of error condition symbols and/or regular expressions.  If the
     error has any of those condition symbols, or if the error message
     matches any of the regular expressions, then that error does not
     enter the debugger.

     The normal value of this variable includes ‘user-error’, as well as
     several errors that happen often during editing but rarely result
     from bugs in Lisp programs.  However, “rarely” is not “never”; if
     your program fails with an error that matches this list, you may
     try changing this list to debug the error.  The easiest way is
     usually to set ‘debug-ignored-errors’ to ‘nil’.

 -- User Option: eval-expression-debug-on-error
     If this variable has a non-‘nil’ value (the default), running the
     command ‘eval-expression’ causes ‘debug-on-error’ to be temporarily
     bound to ‘t’.  *Note Evaluating Emacs-Lisp Expressions: (emacs)Lisp
     Eval.

     If ‘eval-expression-debug-on-error’ is ‘nil’, then the value of
     ‘debug-on-error’ is not changed during ‘eval-expression’.

 -- User Option: debug-on-signal
     Normally, errors caught by ‘condition-case’ never invoke the
     debugger.  The ‘condition-case’ gets a chance to handle the error
     before the debugger gets a chance.

     If you change ‘debug-on-signal’ to a non-‘nil’ value, the debugger
     gets the first chance at every error, regardless of the presence of
     ‘condition-case’.  (To invoke the debugger, the error must still
     fulfill the criteria specified by ‘debug-on-error’ and
     ‘debug-ignored-errors’.)

     For example, setting this variable is useful to get a backtrace
     from code evaluated by emacsclient’s ‘--eval’ option.  If Lisp code
     evaluated by emacsclient signals an error while this variable is
     non-‘nil’, the backtrace will popup in the running Emacs.

     *Warning:* Setting this variable to non-‘nil’ may have annoying
     effects.  Various parts of Emacs catch errors in the normal course
     of affairs, and you may not even realize that errors happen there.
     If you need to debug code wrapped in ‘condition-case’, consider
     using ‘condition-case-unless-debug’ (*note Handling Errors::).

 -- User Option: debug-on-event
     If you set ‘debug-on-event’ to a special event (*note Special
     Events::), Emacs will try to enter the debugger as soon as it
     receives this event, bypassing ‘special-event-map’.  At present,
     the only supported values correspond to the signals ‘SIGUSR1’ and
     ‘SIGUSR2’ (this is the default).  This can be helpful when
     ‘inhibit-quit’ is set and Emacs is not otherwise responding.

 -- Variable: debug-on-message
     If you set ‘debug-on-message’ to a regular expression, Emacs will
     enter the debugger if it displays a matching message in the echo
     area.  For example, this can be useful when trying to find the
     cause of a particular message.

   To debug an error that happens during loading of the init file, use
the option ‘--debug-init’.  This binds ‘debug-on-error’ to ‘t’ while
loading the init file, and bypasses the ‘condition-case’ which normally
catches errors in the init file.


File: elisp.info,  Node: Infinite Loops,  Next: Function Debugging,  Prev: Error Debugging,  Up: Debugger

18.1.2 Debugging Infinite Loops
-------------------------------

When a program loops infinitely and fails to return, your first problem
is to stop the loop.  On most operating systems, you can do this with
‘C-g’, which causes a “quit”.  *Note Quitting::.

   Ordinary quitting gives no information about why the program was
looping.  To get more information, you can set the variable
‘debug-on-quit’ to non-‘nil’.  Once you have the debugger running in the
middle of the infinite loop, you can proceed from the debugger using the
stepping commands.  If you step through the entire loop, you may get
enough information to solve the problem.

   Quitting with ‘C-g’ is not considered an error, and ‘debug-on-error’
has no effect on the handling of ‘C-g’.  Likewise, ‘debug-on-quit’ has
no effect on errors.

 -- User Option: debug-on-quit
     This variable determines whether the debugger is called when ‘quit’
     is signaled and not handled.  If ‘debug-on-quit’ is non-‘nil’, then
     the debugger is called whenever you quit (that is, type ‘C-g’).  If
     ‘debug-on-quit’ is ‘nil’ (the default), then the debugger is not
     called when you quit.


File: elisp.info,  Node: Function Debugging,  Next: Variable Debugging,  Prev: Infinite Loops,  Up: Debugger

18.1.3 Entering the Debugger on a Function Call
-----------------------------------------------

To investigate a problem that happens in the middle of a program, one
useful technique is to enter the debugger whenever a certain function is
called.  You can do this to the function in which the problem occurs,
and then step through the function, or you can do this to a function
called shortly before the problem, step quickly over the call to that
function, and then step through its caller.

 -- Command: debug-on-entry function-name
     This function requests FUNCTION-NAME to invoke the debugger each
     time it is called.

     Any function or macro defined as Lisp code may be set to break on
     entry, regardless of whether it is interpreted code or compiled
     code.  If the function is a command, it will enter the debugger
     when called from Lisp and when called interactively (after the
     reading of the arguments).  You can also set debug-on-entry for
     primitive functions (i.e., those written in C) this way, but it
     only takes effect when the primitive is called from Lisp code.
     Debug-on-entry is not allowed for special forms.

     When ‘debug-on-entry’ is called interactively, it prompts for
     FUNCTION-NAME in the minibuffer.  If the function is already set up
     to invoke the debugger on entry, ‘debug-on-entry’ does nothing.
     ‘debug-on-entry’ always returns FUNCTION-NAME.

     Here’s an example to illustrate use of this function:

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               ⇒ fact
          (debug-on-entry 'fact)
               ⇒ fact
          (fact 3)

          ------ Buffer: *Backtrace* ------
          Debugger entered--entering a function:
          * fact(3)
            eval((fact 3))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ------ Buffer: *Backtrace* ------


 -- Command: cancel-debug-on-entry &optional function-name
     This function undoes the effect of ‘debug-on-entry’ on
     FUNCTION-NAME.  When called interactively, it prompts for
     FUNCTION-NAME in the minibuffer.  If FUNCTION-NAME is omitted or
     ‘nil’, it cancels break-on-entry for all functions.  Calling
     ‘cancel-debug-on-entry’ does nothing to a function which is not
     currently set up to break on entry.


File: elisp.info,  Node: Variable Debugging,  Next: Explicit Debug,  Prev: Function Debugging,  Up: Debugger

18.1.4 Entering the debugger when a variable is modified
--------------------------------------------------------

Sometimes a problem with a function is due to a wrong setting of a
variable.  Setting up the debugger to trigger whenever the variable is
changed is a quick way to find the origin of the setting.

 -- Command: debug-on-variable-change variable
     This function arranges for the debugger to be called whenever
     VARIABLE is modified.

     It is implemented using the watchpoint mechanism, so it inherits
     the same characteristics and limitations: all aliases of VARIABLE
     will be watched together, only dynamic variables can be watched,
     and changes to the objects referenced by variables are not
     detected.  For details, see *note Watching Variables::.

 -- Command: cancel-debug-on-variable-change &optional variable
     This function undoes the effect of ‘debug-on-variable-change’ on
     VARIABLE.  When called interactively, it prompts for VARIABLE in
     the minibuffer.  If VARIABLE is omitted or ‘nil’, it cancels
     break-on-change for all variables.  Calling
     ‘cancel-debug-on-variable-change’ does nothing to a variable which
     is not currently set up to break on change.


File: elisp.info,  Node: Explicit Debug,  Next: Using Debugger,  Prev: Variable Debugging,  Up: Debugger

18.1.5 Explicit Entry to the Debugger
-------------------------------------

You can cause the debugger to be called at a certain point in your
program by writing the expression ‘(debug)’ at that point.  To do this,
visit the source file, insert the text ‘(debug)’ at the proper place,
and type ‘C-M-x’ (‘eval-defun’, a Lisp mode key binding).  *Warning:* if
you do this for temporary debugging purposes, be sure to undo this
insertion before you save the file!

   The place where you insert ‘(debug)’ must be a place where an
additional form can be evaluated and its value ignored.  (If the value
of ‘(debug)’ isn’t ignored, it will alter the execution of the program!)
The most common suitable places are inside a ‘progn’ or an implicit
‘progn’ (*note Sequencing::).

   If you don’t know exactly where in the source code you want to put
the debug statement, but you want to display a backtrace when a certain
message is displayed, you can set ‘debug-on-message’ to a regular
expression matching the desired message.


File: elisp.info,  Node: Using Debugger,  Next: Debugger Commands,  Prev: Explicit Debug,  Up: Debugger

18.1.6 Using the Debugger
-------------------------

When the debugger is entered, it displays the previously selected buffer
in one window and a buffer named ‘*Backtrace*’ in another window.  The
backtrace buffer contains one line for each level of Lisp function
execution currently going on.  At the beginning of this buffer is a
message describing the reason that the debugger was invoked (such as the
error message and associated data, if it was invoked due to an error).

   The backtrace buffer is read-only and uses a special major mode,
Debugger mode, in which letters are defined as debugger commands.  The
usual Emacs editing commands are available; thus, you can switch windows
to examine the buffer that was being edited at the time of the error,
switch buffers, visit files, or do any other sort of editing.  However,
the debugger is a recursive editing level (*note Recursive Editing::)
and it is wise to go back to the backtrace buffer and exit the debugger
(with the ‘q’ command) when you are finished with it.  Exiting the
debugger gets out of the recursive edit and buries the backtrace buffer.
(You can customize what the ‘q’ command does with the backtrace buffer
by setting the variable ‘debugger-bury-or-kill’.  For example, set it to
‘kill’ if you prefer to kill the buffer rather than bury it.  Consult
the variable’s documentation for more possibilities.)

   When the debugger has been entered, the ‘debug-on-error’ variable is
temporarily set according to ‘eval-expression-debug-on-error’.  If the
latter variable is non-‘nil’, ‘debug-on-error’ will temporarily be set
to ‘t’.  This means that any further errors that occur while doing a
debugging session will (by default) trigger another backtrace.  If this
is not what you want, you can either set
‘eval-expression-debug-on-error’ to ‘nil’, or set ‘debug-on-error’ to
‘nil’ in ‘debugger-mode-hook’.

   The backtrace buffer shows you the functions that are executing and
their argument values.  It also allows you to specify a stack frame by
moving point to the line describing that frame.  (A stack frame is the
place where the Lisp interpreter records information about a particular
invocation of a function.)  The frame whose line point is on is
considered the “current frame”.  Some of the debugger commands operate
on the current frame.  If a line starts with a star, that means that
exiting that frame will call the debugger again.  This is useful for
examining the return value of a function.

   If a function name is underlined, that means the debugger knows where
its source code is located.  You can click with the mouse on that name,
or move to it and type <RET>, to visit the source code.

   The debugger itself must be run byte-compiled, since it makes
assumptions about how many stack frames are used for the debugger
itself.  These assumptions are false if the debugger is running
interpreted.


File: elisp.info,  Node: Debugger Commands,  Next: Invoking the Debugger,  Prev: Using Debugger,  Up: Debugger

18.1.7 Debugger Commands
------------------------

The debugger buffer (in Debugger mode) provides special commands in
addition to the usual Emacs commands.  The most important use of
debugger commands is for stepping through code, so that you can see how
control flows.  The debugger can step through the control structures of
an interpreted function, but cannot do so in a byte-compiled function.
If you would like to step through a byte-compiled function, replace it
with an interpreted definition of the same function.  (To do this, visit
the source for the function and type ‘C-M-x’ on its definition.)  You
cannot use the Lisp debugger to step through a primitive function.

   Here is a list of Debugger mode commands:

‘c’
     Exit the debugger and continue execution.  This resumes execution
     of the program as if the debugger had never been entered (aside
     from any side-effects that you caused by changing variable values
     or data structures while inside the debugger).

‘d’
     Continue execution, but enter the debugger the next time any Lisp
     function is called.  This allows you to step through the
     subexpressions of an expression, seeing what values the
     subexpressions compute, and what else they do.

     The stack frame made for the function call which enters the
     debugger in this way will be flagged automatically so that the
     debugger will be called again when the frame is exited.  You can
     use the ‘u’ command to cancel this flag.

‘b’
     Flag the current frame so that the debugger will be entered when
     the frame is exited.  Frames flagged in this way are marked with
     stars in the backtrace buffer.

‘u’
     Don’t enter the debugger when the current frame is exited.  This
     cancels a ‘b’ command on that frame.  The visible effect is to
     remove the star from the line in the backtrace buffer.

‘j’
     Flag the current frame like ‘b’.  Then continue execution like ‘c’,
     but temporarily disable break-on-entry for all functions that are
     set up to do so by ‘debug-on-entry’.

‘e’
     Read a Lisp expression in the minibuffer, evaluate it (with the
     relevant lexical environment, if applicable), and print the value
     in the echo area.  The debugger alters certain important variables,
     and the current buffer, as part of its operation; ‘e’ temporarily
     restores their values from outside the debugger, so you can examine
     and change them.  This makes the debugger more transparent.  By
     contrast, ‘M-:’ does nothing special in the debugger; it shows you
     the variable values within the debugger.

‘R’
     Like ‘e’, but also save the result of evaluation in the buffer
     ‘*Debugger-record*’.

‘q’
     Terminate the program being debugged; return to top-level Emacs
     command execution.

     If the debugger was entered due to a ‘C-g’ but you really want to
     quit, and not debug, use the ‘q’ command.

‘r’
     Return a value from the debugger.  The value is computed by reading
     an expression with the minibuffer and evaluating it.

     The ‘r’ command is useful when the debugger was invoked due to exit
     from a Lisp call frame (as requested with ‘b’ or by entering the
     frame with ‘d’); then the value specified in the ‘r’ command is
     used as the value of that frame.  It is also useful if you call
     ‘debug’ and use its return value.  Otherwise, ‘r’ has the same
     effect as ‘c’, and the specified return value does not matter.

     You can’t use ‘r’ when the debugger was entered due to an error.

‘l’
     Display a list of functions that will invoke the debugger when
     called.  This is a list of functions that are set to break on entry
     by means of ‘debug-on-entry’.

‘v’
     Toggle the display of local variables of the current stack frame.


File: elisp.info,  Node: Invoking the Debugger,  Next: Internals of Debugger,  Prev: Debugger Commands,  Up: Debugger

18.1.8 Invoking the Debugger
----------------------------

Here we describe in full detail the function ‘debug’ that is used to
invoke the debugger.

 -- Command: debug &rest debugger-args
     This function enters the debugger.  It switches buffers to a buffer
     named ‘*Backtrace*’ (or ‘*Backtrace*<2>’ if it is the second
     recursive entry to the debugger, etc.), and fills it with
     information about the stack of Lisp function calls.  It then enters
     a recursive edit, showing the backtrace buffer in Debugger mode.

     The Debugger mode ‘c’, ‘d’, ‘j’, and ‘r’ commands exit the
     recursive edit; then ‘debug’ switches back to the previous buffer
     and returns to whatever called ‘debug’.  This is the only way the
     function ‘debug’ can return to its caller.

     The use of the DEBUGGER-ARGS is that ‘debug’ displays the rest of
     its arguments at the top of the ‘*Backtrace*’ buffer, so that the
     user can see them.  Except as described below, this is the _only_
     way these arguments are used.

     However, certain values for first argument to ‘debug’ have a
     special significance.  (Normally, these values are used only by the
     internals of Emacs, and not by programmers calling ‘debug’.)  Here
     is a table of these special values:

     ‘lambda’
          A first argument of ‘lambda’ means ‘debug’ was called because
          of entry to a function when ‘debug-on-next-call’ was
          non-‘nil’.  The debugger displays ‘Debugger entered--entering
          a function:’ as a line of text at the top of the buffer.

     ‘debug’
          ‘debug’ as first argument means ‘debug’ was called because of
          entry to a function that was set to debug on entry.  The
          debugger displays the string ‘Debugger entered--entering a
          function:’, just as in the ‘lambda’ case.  It also marks the
          stack frame for that function so that it will invoke the
          debugger when exited.

     ‘t’
          When the first argument is ‘t’, this indicates a call to
          ‘debug’ due to evaluation of a function call form when
          ‘debug-on-next-call’ is non-‘nil’.  The debugger displays
          ‘Debugger entered--beginning evaluation of function call
          form:’ as the top line in the buffer.

     ‘exit’
          When the first argument is ‘exit’, it indicates the exit of a
          stack frame previously marked to invoke the debugger on exit.
          The second argument given to ‘debug’ in this case is the value
          being returned from the frame.  The debugger displays
          ‘Debugger entered--returning value:’ in the top line of the
          buffer, followed by the value being returned.

     ‘error’
          When the first argument is ‘error’, the debugger indicates
          that it is being entered because an error or ‘quit’ was
          signaled and not handled, by displaying ‘Debugger
          entered--Lisp error:’ followed by the error signaled and any
          arguments to ‘signal’.  For example,

               (let ((debug-on-error t))
                 (/ 1 0))

               ------ Buffer: *Backtrace* ------
               Debugger entered--Lisp error: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: *Backtrace* ------

          If an error was signaled, presumably the variable
          ‘debug-on-error’ is non-‘nil’.  If ‘quit’ was signaled, then
          presumably the variable ‘debug-on-quit’ is non-‘nil’.

     ‘nil’
          Use ‘nil’ as the first of the DEBUGGER-ARGS when you want to
          enter the debugger explicitly.  The rest of the DEBUGGER-ARGS
          are printed on the top line of the buffer.  You can use this
          feature to display messages—for example, to remind yourself of
          the conditions under which ‘debug’ is called.


File: elisp.info,  Node: Internals of Debugger,  Prev: Invoking the Debugger,  Up: Debugger

18.1.9 Internals of the Debugger
--------------------------------

This section describes functions and variables used internally by the
debugger.

 -- Variable: debugger
     The value of this variable is the function to call to invoke the
     debugger.  Its value must be a function of any number of arguments,
     or, more typically, the name of a function.  This function should
     invoke some kind of debugger.  The default value of the variable is
     ‘debug’.

     The first argument that Lisp hands to the function indicates why it
     was called.  The convention for arguments is detailed in the
     description of ‘debug’ (*note Invoking the Debugger::).

 -- Function: backtrace
     This function prints a trace of Lisp function calls currently
     active.  This is the function used by ‘debug’ to fill up the
     ‘*Backtrace*’ buffer.  It is written in C, since it must have
     access to the stack to determine which function calls are active.
     The return value is always ‘nil’.

     In the following example, a Lisp expression calls ‘backtrace’
     explicitly.  This prints the backtrace to the stream
     ‘standard-output’, which, in this case, is the buffer
     ‘backtrace-output’.

     Each line of the backtrace represents one function call.  The line
     shows the values of the function’s arguments if they are all known;
     if they are still being computed, the line says so.  The arguments
     of special forms are elided.

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))

               ⇒ (testing nil)

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval((with-output-to-temp-buffer ...))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ----------- Buffer: backtrace-output ------------

 -- User Option: debugger-stack-frame-as-list
     If this variable is non-‘nil’, every stack frame of the backtrace
     is displayed as a list.  This aims at improving the backtrace
     readability at the cost of special forms no longer being visually
     different from regular function calls.

     With ‘debugger-stack-frame-as-list’ non-‘nil’, the above example
     would look as follows:

          ----------- Buffer: backtrace-output ------------
            (backtrace)
            (list ...computing arguments...)
            (progn ...)
            (eval (progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            (eval (with-output-to-temp-buffer ...))
            (eval-last-sexp-1 nil)
            (eval-last-sexp nil)
            (call-interactively eval-last-sexp)
          ----------- Buffer: backtrace-output ------------

 -- Variable: debug-on-next-call
     If this variable is non-‘nil’, it says to call the debugger before
     the next ‘eval’, ‘apply’ or ‘funcall’.  Entering the debugger sets
     ‘debug-on-next-call’ to ‘nil’.

     The ‘d’ command in the debugger works by setting this variable.

 -- Function: backtrace-debug level flag
     This function sets the debug-on-exit flag of the stack frame LEVEL
     levels down the stack, giving it the value FLAG.  If FLAG is
     non-‘nil’, this will cause the debugger to be entered when that
     frame later exits.  Even a nonlocal exit through that frame will
     enter the debugger.

     This function is used only by the debugger.

 -- Variable: command-debug-status
     This variable records the debugging status of the current
     interactive command.  Each time a command is called interactively,
     this variable is bound to ‘nil’.  The debugger can set this
     variable to leave information for future debugger invocations
     during the same command invocation.

     The advantage of using this variable rather than an ordinary global
     variable is that the data will never carry over to a subsequent
     command invocation.

     This variable is obsolete and will be removed in future versions.

 -- Function: backtrace-frame frame-number &optional base
     The function ‘backtrace-frame’ is intended for use in Lisp
     debuggers.  It returns information about what computation is
     happening in the stack frame FRAME-NUMBER levels down.

     If that frame has not evaluated the arguments yet, or is a special
     form, the value is ‘(nil FUNCTION ARG-FORMS...)’.

     If that frame has evaluated its arguments and called its function
     already, the return value is ‘(t FUNCTION ARG-VALUES...)’.

     In the return value, FUNCTION is whatever was supplied as the CAR
     of the evaluated list, or a ‘lambda’ expression in the case of a
     macro call.  If the function has a ‘&rest’ argument, that is
     represented as the tail of the list ARG-VALUES.

     If BASE is specified, FRAME-NUMBER counts relative to the topmost
     frame whose FUNCTION is BASE.

     If FRAME-NUMBER is out of range, ‘backtrace-frame’ returns ‘nil’.

 -- Function: mapbacktrace function &optional base
     The function ‘mapbacktrace’ calls FUNCTION once for each frame in
     the backtrace, starting at the first frame whose function is BASE
     (or from the top if BASE is omitted or ‘nil’).

     FUNCTION is called with four arguments: EVALD, FUNC, ARGS, and
     FLAGS.

     If a frame has not evaluated its arguments yet or is a special
     form, EVALD is ‘nil’ and ARGS is a list of forms.

     If a frame has evaluated its arguments and called its function
     already, EVALD is ‘t’ and ARGS is a list of values.  FLAGS is a
     plist of properties of the current frame: currently, the only
     supported property is ‘:debug-on-exit’, which is ‘t’ if the stack
     frame’s ‘debug-on-exit’ flag is set.


File: elisp.info,  Node: Edebug,  Next: Syntax Errors,  Prev: Debugger,  Up: Debugging

18.2 Edebug
===========

Edebug is a source-level debugger for Emacs Lisp programs, with which
you can:

   • Step through evaluation, stopping before and after each expression.

   • Set conditional or unconditional breakpoints.

   • Stop when a specified condition is true (the global break event).

   • Trace slow or fast, stopping briefly at each stop point, or at each
     breakpoint.

   • Display expression results and evaluate expressions as if outside
     of Edebug.

   • Automatically re-evaluate a list of expressions and display their
     results each time Edebug updates the display.

   • Output trace information on function calls and returns.

   • Stop when an error occurs.

   • Display a backtrace, omitting Edebug’s own frames.

   • Specify argument evaluation for macros and defining forms.

   • Obtain rudimentary coverage testing and frequency counts.

   The first three sections below should tell you enough about Edebug to
start using it.

* Menu:

* Using Edebug::                Introduction to use of Edebug.
* Instrumenting::               You must instrument your code
                                  in order to debug it with Edebug.
* Modes: Edebug Execution Modes. Execution modes, stopping more or less often.
* Jumping::                     Commands to jump to a specified place.
* Misc: Edebug Misc.            Miscellaneous commands.
* Breaks::                      Setting breakpoints to make the program stop.
* Trapping Errors::             Trapping errors with Edebug.
* Views: Edebug Views.          Views inside and outside of Edebug.
* Eval: Edebug Eval.            Evaluating expressions within Edebug.
* Eval List::                   Expressions whose values are displayed
                                  each time you enter Edebug.
* Printing in Edebug::          Customization of printing.
* Trace Buffer::                How to produce trace output in a buffer.
* Coverage Testing::            How to test evaluation coverage.
* The Outside Context::         Data that Edebug saves and restores.
* Edebug and Macros::           Specifying how to handle macro calls.
* Options: Edebug Options.      Option variables for customizing Edebug.


File: elisp.info,  Node: Using Edebug,  Next: Instrumenting,  Up: Edebug

18.2.1 Using Edebug
-------------------

To debug a Lisp program with Edebug, you must first “instrument” the
Lisp code that you want to debug.  A simple way to do this is to first
move point into the definition of a function or macro and then do ‘C-u
C-M-x’ (‘eval-defun’ with a prefix argument).  See *note
Instrumenting::, for alternative ways to instrument code.

   Once a function is instrumented, any call to the function activates
Edebug.  Depending on which Edebug execution mode you have selected,
activating Edebug may stop execution and let you step through the
function, or it may update the display and continue execution while
checking for debugging commands.  The default execution mode is step,
which stops execution.  *Note Edebug Execution Modes::.

   Within Edebug, you normally view an Emacs buffer showing the source
of the Lisp code you are debugging.  This is referred to as the “source
code buffer”, and it is temporarily read-only.

   An arrow in the left fringe indicates the line where the function is
executing.  Point initially shows where within the line the function is
executing, but this ceases to be true if you move point yourself.

   If you instrument the definition of ‘fac’ (shown below) and then
execute ‘(fac 3)’, here is what you would normally see.  Point is at the
open-parenthesis before ‘if’.

     (defun fac (n)
     =>★(if (< 0 n)
           (* n (fac (1- n)))
         1))

   The places within a function where Edebug can stop execution are
called “stop points”.  These occur both before and after each
subexpression that is a list, and also after each variable reference.
Here we use periods to show the stop points in the function ‘fac’:

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac .(1- n.).).).
         1).)

   The special commands of Edebug are available in the source code
buffer in addition to the commands of Emacs Lisp mode.  For example, you
can type the Edebug command <SPC> to execute until the next stop point.
If you type <SPC> once after entry to ‘fac’, here is the display you
will see:

     (defun fac (n)
     =>(if ★(< 0 n)
           (* n (fac (1- n)))
         1))

   When Edebug stops execution after an expression, it displays the
expression’s value in the echo area.

   Other frequently used commands are ‘b’ to set a breakpoint at a stop
point, ‘g’ to execute until a breakpoint is reached, and ‘q’ to exit
Edebug and return to the top-level command loop.  Type ‘?’ to display a
list of all Edebug commands.


File: elisp.info,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

18.2.2 Instrumenting for Edebug
-------------------------------

In order to use Edebug to debug Lisp code, you must first “instrument”
the code.  Instrumenting code inserts additional code into it, to invoke
Edebug at the proper places.

   When you invoke command ‘C-M-x’ (‘eval-defun’) with a prefix argument
on a function definition, it instruments the definition before
evaluating it.  (This does not modify the source code itself.)  If the
variable ‘edebug-all-defs’ is non-‘nil’, that inverts the meaning of the
prefix argument: in this case, ‘C-M-x’ instruments the definition
_unless_ it has a prefix argument.  The default value of
‘edebug-all-defs’ is ‘nil’.  The command ‘M-x edebug-all-defs’ toggles
the value of the variable ‘edebug-all-defs’.

   If ‘edebug-all-defs’ is non-‘nil’, then the commands ‘eval-region’,
‘eval-current-buffer’, and ‘eval-buffer’ also instrument any definitions
they evaluate.  Similarly, ‘edebug-all-forms’ controls whether
‘eval-region’ should instrument _any_ form, even non-defining forms.
This doesn’t apply to loading or evaluations in the minibuffer.  The
command ‘M-x edebug-all-forms’ toggles this option.

   Another command, ‘M-x edebug-eval-top-level-form’, is available to
instrument any top-level form regardless of the values of
‘edebug-all-defs’ and ‘edebug-all-forms’.  ‘edebug-defun’ is an alias
for ‘edebug-eval-top-level-form’.

   While Edebug is active, the command ‘I’ (‘edebug-instrument-callee’)
instruments the definition of the function or macro called by the list
form after point, if it is not already instrumented.  This is possible
only if Edebug knows where to find the source for that function; for
this reason, after loading Edebug, ‘eval-region’ records the position of
every definition it evaluates, even if not instrumenting it.  See also
the ‘i’ command (*note Jumping::), which steps into the call after
instrumenting the function.

   Edebug knows how to instrument all the standard special forms,
‘interactive’ forms with an expression argument, anonymous lambda
expressions, and other defining forms.  However, Edebug cannot determine
on its own what a user-defined macro will do with the arguments of a
macro call, so you must provide that information using Edebug
specifications; for details, *note Edebug and Macros::.

   When Edebug is about to instrument code for the first time in a
session, it runs the hook ‘edebug-setup-hook’, then sets it to ‘nil’.
You can use this to load Edebug specifications associated with a package
you are using, but only when you use Edebug.

   If Edebug detects a syntax error while instrumenting, it leaves point
at the erroneous code and signals an ‘invalid-read-syntax’ error.
Example:

     error→ Invalid read syntax: "Expected lambda expression"

   One potential reason for such a failure to instrument is that some
macro definitions are not yet known to Emacs.  To work around this, load
the file which defines the function you are about to instrument.

   To remove instrumentation from a definition, simply re-evaluate its
definition in a way that does not instrument.  There are two ways of
evaluating forms that never instrument them: from a file with ‘load’,
and from the minibuffer with ‘eval-expression’ (‘M-:’).

   *Note Edebug Eval::, for other evaluation functions available inside
of Edebug.


File: elisp.info,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

18.2.3 Edebug Execution Modes
-----------------------------

Edebug supports several execution modes for running the program you are
debugging.  We call these alternatives “Edebug execution modes”; do not
confuse them with major or minor modes.  The current Edebug execution
mode determines how far Edebug continues execution before
stopping—whether it stops at each stop point, or continues to the next
breakpoint, for example—and how much Edebug displays the progress of the
evaluation before it stops.

   Normally, you specify the Edebug execution mode by typing a command
to continue the program in a certain mode.  Here is a table of these
commands; all except for ‘S’ resume execution of the program, at least
for a certain distance.

‘S’
     Stop: don’t execute any more of the program, but wait for more
     Edebug commands (‘edebug-stop’).

‘<SPC>’
     Step: stop at the next stop point encountered (‘edebug-step-mode’).

‘n’
     Next: stop at the next stop point encountered after an expression
     (‘edebug-next-mode’).  Also see ‘edebug-forward-sexp’ in *note
     Jumping::.

‘t’
     Trace: pause (normally one second) at each Edebug stop point
     (‘edebug-trace-mode’).

‘T’
     Rapid trace: update the display at each stop point, but don’t
     actually pause (‘edebug-Trace-fast-mode’).

‘g’
     Go: run until the next breakpoint (‘edebug-go-mode’).  *Note
     Breakpoints::.

‘c’
     Continue: pause one second at each breakpoint, and then continue
     (‘edebug-continue-mode’).

‘C’
     Rapid continue: move point to each breakpoint, but don’t pause
     (‘edebug-Continue-fast-mode’).

‘G’
     Go non-stop: ignore breakpoints (‘edebug-Go-nonstop-mode’).  You
     can still stop the program by typing ‘S’, or any editing command.

   In general, the execution modes earlier in the above list run the
program more slowly or stop sooner than the modes later in the list.

   When you enter a new Edebug level, Edebug will normally stop at the
first instrumented function it encounters.  If you prefer to stop only
at a break point, or not at all (for example, when gathering coverage
data), change the value of ‘edebug-initial-mode’ from its default ‘step’
to ‘go’, or ‘Go-nonstop’, or one of its other values (*note Edebug
Options::).  You can do this readily with ‘C-x C-a C-m’
(‘edebug-set-initial-mode’):

 -- Command: edebug-set-initial-mode
     This command, bound to ‘C-x C-a C-m’, sets ‘edebug-initial-mode’.
     It prompts you for a key to indicate the mode.  You should enter
     one of the eight keys listed above, which sets the corresponding
     mode.

   Note that you may reenter the same Edebug level several times if, for
example, an instrumented function is called several times from one
command.

   While executing or tracing, you can interrupt the execution by typing
any Edebug command.  Edebug stops the program at the next stop point and
then executes the command you typed.  For example, typing ‘t’ during
execution switches to trace mode at the next stop point.  You can use
‘S’ to stop execution without doing anything else.

   If your function happens to read input, a character you type
intending to interrupt execution may be read by the function instead.
You can avoid such unintended results by paying attention to when your
program wants input.

   Keyboard macros containing the commands in this section do not
completely work: exiting from Edebug, to resume the program, loses track
of the keyboard macro.  This is not easy to fix.  Also, defining or
executing a keyboard macro outside of Edebug does not affect commands
inside Edebug.  This is usually an advantage.  See also the
‘edebug-continue-kbd-macro’ option in *note Edebug Options::.

 -- User Option: edebug-sit-for-seconds
     This option specifies how many seconds to wait between execution
     steps in trace mode or continue mode.  The default is 1 second.


File: elisp.info,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

18.2.4 Jumping
--------------

The commands described in this section execute until they reach a
specified location.  All except ‘i’ make a temporary breakpoint to
establish the place to stop, then switch to go mode.  Any other
breakpoint reached before the intended stop point will also stop
execution.  *Note Breakpoints::, for the details on breakpoints.

   These commands may fail to work as expected in case of nonlocal exit,
as that can bypass the temporary breakpoint where you expected the
program to stop.

‘h’
     Proceed to the stop point near where point is (‘edebug-goto-here’).

‘f’
     Run the program for one expression (‘edebug-forward-sexp’).

‘o’
     Run the program until the end of the containing sexp
     (‘edebug-step-out’).

‘i’
     Step into the function or macro called by the form after point
     (‘edebug-step-in’).

   The ‘h’ command proceeds to the stop point at or after the current
location of point, using a temporary breakpoint.

   The ‘f’ command runs the program forward over one expression.  More
precisely, it sets a temporary breakpoint at the position that
‘forward-sexp’ would reach, then executes in go mode so that the program
will stop at breakpoints.

   With a prefix argument N, the temporary breakpoint is placed N sexps
beyond point.  If the containing list ends before N more elements, then
the place to stop is after the containing expression.

   You must check that the position ‘forward-sexp’ finds is a place that
the program will really get to.  In ‘cond’, for example, this may not be
true.

   For flexibility, the ‘f’ command does ‘forward-sexp’ starting at
point, rather than at the stop point.  If you want to execute one
expression _from the current stop point_, first type ‘w’
(‘edebug-where’) to move point there, and then type ‘f’.

   The ‘o’ command continues out of an expression.  It places a
temporary breakpoint at the end of the sexp containing point.  If the
containing sexp is a function definition itself, ‘o’ continues until
just before the last sexp in the definition.  If that is where you are
now, it returns from the function and then stops.  In other words, this
command does not exit the currently executing function unless you are
positioned after the last sexp.

   Normally, the ‘h’, ‘f’, and ‘o’ commands display “Break” and pause
for ‘edebug-sit-for-seconds’ before showing the result of the form just
evaluated.  You can avoid this pause by setting ‘edebug-sit-on-break’ to
‘nil’.  *Note Edebug Options::.

   The ‘i’ command steps into the function or macro called by the list
form after point, and stops at its first stop point.  Note that the form
need not be the one about to be evaluated.  But if the form is a
function call about to be evaluated, remember to use this command before
any of the arguments are evaluated, since otherwise it will be too late.

   The ‘i’ command instruments the function or macro it’s supposed to
step into, if it isn’t instrumented already.  This is convenient, but
keep in mind that the function or macro remains instrumented unless you
explicitly arrange to deinstrument it.


File: elisp.info,  Node: Edebug Misc,  Next: Breaks,  Prev: Jumping,  Up: Edebug

18.2.5 Miscellaneous Edebug Commands
------------------------------------

Some miscellaneous Edebug commands are described here.

‘?’
     Display the help message for Edebug (‘edebug-help’).

‘C-]’
     Abort one level back to the previous command level
     (‘abort-recursive-edit’).

‘q’
     Return to the top level editor command loop (‘top-level’).  This
     exits all recursive editing levels, including all levels of Edebug
     activity.  However, instrumented code protected with
     ‘unwind-protect’ or ‘condition-case’ forms may resume debugging.

‘Q’
     Like ‘q’, but don’t stop even for protected code
     (‘edebug-top-level-nonstop’).

‘r’
     Redisplay the most recently known expression result in the echo
     area (‘edebug-previous-result’).

‘d’
     Display a backtrace, excluding Edebug’s own functions for clarity
     (‘edebug-backtrace’).

     You cannot use debugger commands in the backtrace buffer in Edebug
     as you would in the standard debugger.

     The backtrace buffer is killed automatically when you continue
     execution.

   You can invoke commands from Edebug that activate Edebug again
recursively.  Whenever Edebug is active, you can quit to the top level
with ‘q’ or abort one recursive edit level with ‘C-]’.  You can display
a backtrace of all the pending evaluations with ‘d’.


File: elisp.info,  Node: Breaks,  Next: Trapping Errors,  Prev: Edebug Misc,  Up: Edebug

18.2.6 Breaks
-------------

Edebug’s step mode stops execution when the next stop point is reached.
There are three other ways to stop Edebug execution once it has started:
breakpoints, the global break condition, and source breakpoints.

* Menu:

* Breakpoints::                 Breakpoints at stop points.
* Global Break Condition::      Breaking on an event.
* Source Breakpoints::          Embedding breakpoints in source code.


File: elisp.info,  Node: Breakpoints,  Next: Global Break Condition,  Up: Breaks

18.2.6.1 Edebug Breakpoints
...........................

While using Edebug, you can specify “breakpoints” in the program you are
testing: these are places where execution should stop.  You can set a
breakpoint at any stop point, as defined in *note Using Edebug::.  For
setting and unsetting breakpoints, the stop point that is affected is
the first one at or after point in the source code buffer.  Here are the
Edebug commands for breakpoints:

‘b’
     Set a breakpoint at the stop point at or after point
     (‘edebug-set-breakpoint’).  If you use a prefix argument, the
     breakpoint is temporary—it turns off the first time it stops the
     program.

‘u’
     Unset the breakpoint (if any) at the stop point at or after point
     (‘edebug-unset-breakpoint’).

‘x CONDITION <RET>’
     Set a conditional breakpoint which stops the program only if
     evaluating CONDITION produces a non-‘nil’ value
     (‘edebug-set-conditional-breakpoint’).  With a prefix argument, the
     breakpoint is temporary.

‘B’
     Move point to the next breakpoint in the current definition
     (‘edebug-next-breakpoint’).

   While in Edebug, you can set a breakpoint with ‘b’ and unset one with
‘u’.  First move point to the Edebug stop point of your choice, then
type ‘b’ or ‘u’ to set or unset a breakpoint there.  Unsetting a
breakpoint where none has been set has no effect.

   Re-evaluating or reinstrumenting a definition removes all of its
previous breakpoints.

   A “conditional breakpoint” tests a condition each time the program
gets there.  Any errors that occur as a result of evaluating the
condition are ignored, as if the result were ‘nil’.  To set a
conditional breakpoint, use ‘x’, and specify the condition expression in
the minibuffer.  Setting a conditional breakpoint at a stop point that
has a previously established conditional breakpoint puts the previous
condition expression in the minibuffer so you can edit it.

   You can make a conditional or unconditional breakpoint “temporary” by
using a prefix argument with the command to set the breakpoint.  When a
temporary breakpoint stops the program, it is automatically unset.

   Edebug always stops or pauses at a breakpoint, except when the Edebug
mode is Go-nonstop.  In that mode, it ignores breakpoints entirely.

   To find out where your breakpoints are, use the ‘B’ command, which
moves point to the next breakpoint following point, within the same
function, or to the first breakpoint if there are no following
breakpoints.  This command does not continue execution—it just moves
point in the buffer.


File: elisp.info,  Node: Global Break Condition,  Next: Source Breakpoints,  Prev: Breakpoints,  Up: Breaks

18.2.6.2 Global Break Condition
...............................

A “global break condition” stops execution when a specified condition is
satisfied, no matter where that may occur.  Edebug evaluates the global
break condition at every stop point; if it evaluates to a non-‘nil’
value, then execution stops or pauses depending on the execution mode,
as if a breakpoint had been hit.  If evaluating the condition gets an
error, execution does not stop.

   The condition expression is stored in
‘edebug-global-break-condition’.  You can specify a new expression using
the ‘X’ command from the source code buffer while Edebug is active, or
using ‘C-x X X’ from any buffer at any time, as long as Edebug is loaded
(‘edebug-set-global-break-condition’).

   The global break condition is the simplest way to find where in your
code some event occurs, but it makes code run much more slowly.  So you
should reset the condition to ‘nil’ when not using it.


File: elisp.info,  Node: Source Breakpoints,  Prev: Global Break Condition,  Up: Breaks

18.2.6.3 Source Breakpoints
...........................

All breakpoints in a definition are forgotten each time you reinstrument
it.  If you wish to make a breakpoint that won’t be forgotten, you can
write a “source breakpoint”, which is simply a call to the function
‘edebug’ in your source code.  You can, of course, make such a call
conditional.  For example, in the ‘fac’ function, you can insert the
first line as shown below, to stop when the argument reaches zero:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   When the ‘fac’ definition is instrumented and the function is called,
the call to ‘edebug’ acts as a breakpoint.  Depending on the execution
mode, Edebug stops or pauses there.

   If no instrumented code is being executed when ‘edebug’ is called,
that function calls ‘debug’.


File: elisp.info,  Node: Trapping Errors,  Next: Edebug Views,  Prev: Breaks,  Up: Edebug

18.2.7 Trapping Errors
----------------------

Emacs normally displays an error message when an error is signaled and
not handled with ‘condition-case’.  While Edebug is active and executing
instrumented code, it normally responds to all unhandled errors.  You
can customize this with the options ‘edebug-on-error’ and
‘edebug-on-quit’; see *note Edebug Options::.

   When Edebug responds to an error, it shows the last stop point
encountered before the error.  This may be the location of a call to a
function which was not instrumented, and within which the error actually
occurred.  For an unbound variable error, the last known stop point
might be quite distant from the offending variable reference.  In that
case, you might want to display a full backtrace (*note Edebug Misc::).

   If you change ‘debug-on-error’ or ‘debug-on-quit’ while Edebug is
active, these changes will be forgotten when Edebug becomes inactive.
Furthermore, during Edebug’s recursive edit, these variables are bound
to the values they had outside of Edebug.


File: elisp.info,  Node: Edebug Views,  Next: Edebug Eval,  Prev: Trapping Errors,  Up: Edebug

18.2.8 Edebug Views
-------------------

These Edebug commands let you view aspects of the buffer and window
status as they were before entry to Edebug.  The outside window
configuration is the collection of windows and contents that were in
effect outside of Edebug.

‘v’
     Switch to viewing the outside window configuration
     (‘edebug-view-outside’).  Type ‘C-x X w’ to return to Edebug.

‘p’
     Temporarily display the outside current buffer with point at its
     outside position (‘edebug-bounce-point’), pausing for one second
     before returning to Edebug.  With a prefix argument N, pause for N
     seconds instead.

‘w’
     Move point back to the current stop point in the source code buffer
     (‘edebug-where’).

     If you use this command in a different window displaying the same
     buffer, that window will be used instead to display the current
     definition in the future.

‘W’
     Toggle whether Edebug saves and restores the outside window
     configuration (‘edebug-toggle-save-windows’).

     With a prefix argument, ‘W’ only toggles saving and restoring of
     the selected window.  To specify a window that is not displaying
     the source code buffer, you must use ‘C-x X W’ from the global
     keymap.

   You can view the outside window configuration with ‘v’ or just bounce
to the point in the current buffer with ‘p’, even if it is not normally
displayed.

   After moving point, you may wish to jump back to the stop point.  You
can do that with ‘w’ from a source code buffer.  You can jump back to
the stop point in the source code buffer from any buffer using ‘C-x X
w’.

   Each time you use ‘W’ to turn saving _off_, Edebug forgets the saved
outside window configuration—so that even if you turn saving back _on_,
the current window configuration remains unchanged when you next exit
Edebug (by continuing the program).  However, the automatic redisplay of
‘*edebug*’ and ‘*edebug-trace*’ may conflict with the buffers you wish
to see unless you have enough windows open.


File: elisp.info,  Node: Edebug Eval,  Next: Eval List,  Prev: Edebug Views,  Up: Edebug

18.2.9 Evaluation
-----------------

While within Edebug, you can evaluate expressions as if Edebug were not
running.  Edebug tries to be invisible to the expression’s evaluation
and printing.  Evaluation of expressions that cause side effects will
work as expected, except for changes to data that Edebug explicitly
saves and restores.  *Note The Outside Context::, for details on this
process.

‘e EXP <RET>’
     Evaluate expression EXP in the context outside of Edebug
     (‘edebug-eval-expression’).  That is, Edebug tries to minimize its
     interference with the evaluation.

‘M-: EXP <RET>’
     Evaluate expression EXP in the context of Edebug itself
     (‘eval-expression’).

‘C-x C-e’
     Evaluate the expression before point, in the context outside of
     Edebug (‘edebug-eval-last-sexp’).

   Edebug supports evaluation of expressions containing references to
lexically bound symbols created by the following constructs in ‘cl.el’:
‘lexical-let’, ‘macrolet’, and ‘symbol-macrolet’.


File: elisp.info,  Node: Eval List,  Next: Printing in Edebug,  Prev: Edebug Eval,  Up: Edebug

18.2.10 Evaluation List Buffer
------------------------------

You can use the “evaluation list buffer”, called ‘*edebug*’, to evaluate
expressions interactively.  You can also set up the “evaluation list” of
expressions to be evaluated automatically each time Edebug updates the
display.

‘E’
     Switch to the evaluation list buffer ‘*edebug*’
     (‘edebug-visit-eval-list’).

   In the ‘*edebug*’ buffer you can use the commands of Lisp Interaction
mode (*note (emacs)Lisp Interaction::) as well as these special
commands:

‘C-j’
     Evaluate the expression before point, in the outside context, and
     insert the value in the buffer (‘edebug-eval-print-last-sexp’).

‘C-x C-e’
     Evaluate the expression before point, in the context outside of
     Edebug (‘edebug-eval-last-sexp’).

‘C-c C-u’
     Build a new evaluation list from the contents of the buffer
     (‘edebug-update-eval-list’).

‘C-c C-d’
     Delete the evaluation list group that point is in
     (‘edebug-delete-eval-item’).

‘C-c C-w’
     Switch back to the source code buffer at the current stop point
     (‘edebug-where’).

   You can evaluate expressions in the evaluation list window with ‘C-j’
or ‘C-x C-e’, just as you would in ‘*scratch*’; but they are evaluated
in the context outside of Edebug.

   The expressions you enter interactively (and their results) are lost
when you continue execution; but you can set up an “evaluation list”
consisting of expressions to be evaluated each time execution stops.

   To do this, write one or more “evaluation list groups” in the
evaluation list buffer.  An evaluation list group consists of one or
more Lisp expressions.  Groups are separated by comment lines.

   The command ‘C-c C-u’ (‘edebug-update-eval-list’) rebuilds the
evaluation list, scanning the buffer and using the first expression of
each group.  (The idea is that the second expression of the group is the
value previously computed and displayed.)

   Each entry to Edebug redisplays the evaluation list by inserting each
expression in the buffer, followed by its current value.  It also
inserts comment lines so that each expression becomes its own group.
Thus, if you type ‘C-c C-u’ again without changing the buffer text, the
evaluation list is effectively unchanged.

   If an error occurs during an evaluation from the evaluation list, the
error message is displayed in a string as if it were the result.
Therefore, expressions using variables that are not currently valid do
not interrupt your debugging.

   Here is an example of what the evaluation list window looks like
after several expressions have been added to it:

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   To delete a group, move point into it and type ‘C-c C-d’, or simply
delete the text for the group and update the evaluation list with ‘C-c
C-u’.  To add a new expression to the evaluation list, insert the
expression at a suitable place, insert a new comment line, then type
‘C-c C-u’.  You need not insert dashes in the comment line—its contents
don’t matter.

   After selecting ‘*edebug*’, you can return to the source code buffer
with ‘C-c C-w’.  The ‘*edebug*’ buffer is killed when you continue
execution, and recreated next time it is needed.


File: elisp.info,  Node: Printing in Edebug,  Next: Trace Buffer,  Prev: Eval List,  Up: Edebug

18.2.11 Printing in Edebug
--------------------------

If an expression in your program produces a value containing circular
list structure, you may get an error when Edebug attempts to print it.

   One way to cope with circular structure is to set ‘print-length’ or
‘print-level’ to truncate the printing.  Edebug does this for you; it
binds ‘print-length’ and ‘print-level’ to the values of the variables
‘edebug-print-length’ and ‘edebug-print-level’ (so long as they have
non-‘nil’ values).  *Note Output Variables::.

 -- User Option: edebug-print-length
     If non-‘nil’, Edebug binds ‘print-length’ to this value while
     printing results.  The default value is ‘50’.

 -- User Option: edebug-print-level
     If non-‘nil’, Edebug binds ‘print-level’ to this value while
     printing results.  The default value is ‘50’.

   You can also print circular structures and structures that share
elements more informatively by binding ‘print-circle’ to a non-‘nil’
value.

   Here is an example of code that creates a circular structure:

     (setq a '(x y))
     (setcar a a)

Custom printing prints this as ‘Result: #1=(#1# y)’.  The ‘#1=’ notation
labels the structure that follows it with the label ‘1’, and the ‘#1#’
notation references the previously labeled structure.  This notation is
used for any shared elements of lists or vectors.

 -- User Option: edebug-print-circle
     If non-‘nil’, Edebug binds ‘print-circle’ to this value while
     printing results.  The default value is ‘t’.

   Other programs can also use custom printing; see ‘cust-print.el’ for
details.


File: elisp.info,  Node: Trace Buffer,  Next: Coverage Testing,  Prev: Printing in Edebug,  Up: Edebug

18.2.12 Trace Buffer
--------------------

Edebug can record an execution trace, storing it in a buffer named
‘*edebug-trace*’.  This is a log of function calls and returns, showing
the function names and their arguments and values.  To enable trace
recording, set ‘edebug-trace’ to a non-‘nil’ value.

   Making a trace buffer is not the same thing as using trace execution
mode (*note Edebug Execution Modes::).

   When trace recording is enabled, each function entry and exit adds
lines to the trace buffer.  A function entry record consists of ‘::::{’,
followed by the function name and argument values.  A function exit
record consists of ‘::::}’, followed by the function name and result of
the function.

   The number of ‘:’s in an entry shows its recursion depth.  You can
use the braces in the trace buffer to find the matching beginning or end
of function calls.

   You can customize trace recording for function entry and exit by
redefining the functions ‘edebug-print-trace-before’ and
‘edebug-print-trace-after’.

 -- Macro: edebug-tracing string body...
     This macro requests additional trace information around the
     execution of the BODY forms.  The argument STRING specifies text to
     put in the trace buffer, after the ‘{’ or ‘}’.  All the arguments
     are evaluated, and ‘edebug-tracing’ returns the value of the last
     form in BODY.

 -- Function: edebug-trace format-string &rest format-args
     This function inserts text in the trace buffer.  It computes the
     text with ‘(apply 'format FORMAT-STRING FORMAT-ARGS)’.  It also
     appends a newline to separate entries.

   ‘edebug-tracing’ and ‘edebug-trace’ insert lines in the trace buffer
whenever they are called, even if Edebug is not active.  Adding text to
the trace buffer also scrolls its window to show the last lines
inserted.


File: elisp.info,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Trace Buffer,  Up: Edebug

18.2.13 Coverage Testing
------------------------

Edebug provides rudimentary coverage testing and display of execution
frequency.

   Coverage testing works by comparing the result of each expression
with the previous result; each form in the program is considered covered
if it has returned two different values since you began testing coverage
in the current Emacs session.  Thus, to do coverage testing on your
program, execute it under various conditions and note whether it behaves
correctly; Edebug will tell you when you have tried enough different
conditions that each form has returned two different values.

   Coverage testing makes execution slower, so it is only done if
‘edebug-test-coverage’ is non-‘nil’.  Frequency counting is performed
for all executions of an instrumented function, even if the execution
mode is Go-nonstop, and regardless of whether coverage testing is
enabled.

   Use ‘C-x X =’ (‘edebug-display-freq-count’) to display both the
coverage information and the frequency counts for a definition.  Just
‘=’ (‘edebug-temp-display-freq-count’) displays the same information
temporarily, only until you type another key.

 -- Command: edebug-display-freq-count
     This command displays the frequency count data for each line of the
     current definition.

     It inserts frequency counts as comment lines after each line of
     code.  You can undo all insertions with one ‘undo’ command.  The
     counts appear under the ‘(’ before an expression or the ‘)’ after
     an expression, or on the last character of a variable.  To simplify
     the display, a count is not shown if it is equal to the count of an
     earlier expression on the same line.

     The character ‘=’ following the count for an expression says that
     the expression has returned the same value each time it was
     evaluated.  In other words, it is not yet covered for coverage
     testing purposes.

     To clear the frequency count and coverage data for a definition,
     simply reinstrument it with ‘eval-defun’.

   For example, after evaluating ‘(fac 5)’ with a source breakpoint, and
setting ‘edebug-test-coverage’ to ‘t’, when the breakpoint is reached,
the frequency data looks like this:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      = =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   The comment lines show that ‘fac’ was called 6 times.  The first ‘if’
statement returned 5 times with the same result each time; the same is
true of the condition on the second ‘if’.  The recursive call of ‘fac’
did not return at all.


File: elisp.info,  Node: The Outside Context,  Next: Edebug and Macros,  Prev: Coverage Testing,  Up: Edebug

18.2.14 The Outside Context
---------------------------

Edebug tries to be transparent to the program you are debugging, but it
does not succeed completely.  Edebug also tries to be transparent when
you evaluate expressions with ‘e’ or with the evaluation list buffer, by
temporarily restoring the outside context.  This section explains
precisely what context Edebug restores, and how Edebug fails to be
completely transparent.

* Menu:

* Checking Whether to Stop::    When Edebug decides what to do.
* Edebug Display Update::       When Edebug updates the display.
* Edebug Recursive Edit::       When Edebug stops execution.


File: elisp.info,  Node: Checking Whether to Stop,  Next: Edebug Display Update,  Up: The Outside Context

18.2.14.1 Checking Whether to Stop
..................................

Whenever Edebug is entered, it needs to save and restore certain data
before even deciding whether to make trace information or stop the
program.

   • ‘max-lisp-eval-depth’ (*note Eval::) and ‘max-specpdl-size’ (*note
     Local Variables::) are both increased to reduce Edebug’s impact on
     the stack.  You could, however, still run out of stack space when
     using Edebug.  You can also enlarge the value of ‘edebug-max-depth’
     if Edebug reaches the limit of recursion depth instrumenting code
     that contains very large quoted lists.

   • The state of keyboard macro execution is saved and restored.  While
     Edebug is active, ‘executing-kbd-macro’ is bound to ‘nil’ unless
     ‘edebug-continue-kbd-macro’ is non-‘nil’.


File: elisp.info,  Node: Edebug Display Update,  Next: Edebug Recursive Edit,  Prev: Checking Whether to Stop,  Up: The Outside Context

18.2.14.2 Edebug Display Update
...............................

When Edebug needs to display something (e.g., in trace mode), it saves
the current window configuration from outside Edebug (*note Window
Configurations::).  When you exit Edebug, it restores the previous
window configuration.

   Emacs redisplays only when it pauses.  Usually, when you continue
execution, the program re-enters Edebug at a breakpoint or after
stepping, without pausing or reading input in between.  In such cases,
Emacs never gets a chance to redisplay the outside configuration.
Consequently, what you see is the same window configuration as the last
time Edebug was active, with no interruption.

   Entry to Edebug for displaying something also saves and restores the
following data (though some of them are deliberately not restored if an
error or quit signal occurs).

   • Which buffer is current, and the positions of point and the mark in
     the current buffer, are saved and restored.

   • The outside window configuration is saved and restored if
     ‘edebug-save-windows’ is non-‘nil’ (*note Edebug Options::).

     The window configuration is not restored on error or quit, but the
     outside selected window _is_ reselected even on error or quit in
     case a ‘save-excursion’ is active.  If the value of
     ‘edebug-save-windows’ is a list, only the listed windows are saved
     and restored.

     The window start and horizontal scrolling of the source code buffer
     are not restored, however, so that the display remains coherent
     within Edebug.

   • The value of point in each displayed buffer is saved and restored
     if ‘edebug-save-displayed-buffer-points’ is non-‘nil’.

   • The variables ‘overlay-arrow-position’ and ‘overlay-arrow-string’
     are saved and restored, so you can safely invoke Edebug from the
     recursive edit elsewhere in the same buffer.

   • ‘cursor-in-echo-area’ is locally bound to ‘nil’ so that the cursor
     shows up in the window.


File: elisp.info,  Node: Edebug Recursive Edit,  Prev: Edebug Display Update,  Up: The Outside Context

18.2.14.3 Edebug Recursive Edit
...............................

When Edebug is entered and actually reads commands from the user, it
saves (and later restores) these additional data:

   • The current match data.  *Note Match Data::.

   • The variables ‘last-command’, ‘this-command’, ‘last-command-event’,
     ‘last-input-event’, ‘last-event-frame’, ‘last-nonmenu-event’, and
     ‘track-mouse’.  Commands in Edebug do not affect these variables
     outside of Edebug.

     Executing commands within Edebug can change the key sequence that
     would be returned by ‘this-command-keys’, and there is no way to
     reset the key sequence from Lisp.

     Edebug cannot save and restore the value of
     ‘unread-command-events’.  Entering Edebug while this variable has a
     nontrivial value can interfere with execution of the program you
     are debugging.

   • Complex commands executed while in Edebug are added to the variable
     ‘command-history’.  In rare cases this can alter execution.

   • Within Edebug, the recursion depth appears one deeper than the
     recursion depth outside Edebug.  This is not true of the
     automatically updated evaluation list window.

   • ‘standard-output’ and ‘standard-input’ are bound to ‘nil’ by the
     ‘recursive-edit’, but Edebug temporarily restores them during
     evaluations.

   • The state of keyboard macro definition is saved and restored.
     While Edebug is active, ‘defining-kbd-macro’ is bound to
     ‘edebug-continue-kbd-macro’.


File: elisp.info,  Node: Edebug and Macros,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

18.2.15 Edebug and Macros
-------------------------

To make Edebug properly instrument expressions that call macros, some
extra care is needed.  This subsection explains the details.

* Menu:

* Instrumenting Macro Calls::   The basic problem.
* Specification List::          How to specify complex patterns of evaluation.
* Backtracking::                What Edebug does when matching fails.
* Specification Examples::      To help understand specifications.


File: elisp.info,  Node: Instrumenting Macro Calls,  Next: Specification List,  Up: Edebug and Macros

18.2.15.1 Instrumenting Macro Calls
...................................

When Edebug instruments an expression that calls a Lisp macro, it needs
additional information about the macro to do the job properly.  This is
because there is no a-priori way to tell which subexpressions of the
macro call are forms to be evaluated.  (Evaluation may occur explicitly
in the macro body, or when the resulting expansion is evaluated, or any
time later.)

   Therefore, you must define an Edebug specification for each macro
that Edebug will encounter, to explain the format of calls to that
macro.  To do this, add a ‘debug’ declaration to the macro definition.
Here is a simple example that shows the specification for the ‘for’
example macro (*note Argument Evaluation::).

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (declare (debug (symbolp "from" form "to" form "do" &rest form)))
       ...)

   The Edebug specification says which parts of a call to the macro are
forms to be evaluated.  For simple macros, the specification often looks
very similar to the formal argument list of the macro definition, but
specifications are much more general than macro arguments.  *Note
Defining Macros::, for more explanation of the ‘declare’ form.

   Take care to ensure that the specifications are known to Edebug when
you instrument code.  If you are instrumenting a function which uses a
macro defined in another file, you may first need to either evaluate the
‘require’ forms in the file containing your function, or explicitly load
the file containing the macro.  If the definition of a macro is wrapped
by ‘eval-when-compile’, you may need to evaluate it.

   You can also define an edebug specification for a macro separately
from the macro definition with ‘def-edebug-spec’.  Adding ‘debug’
declarations is preferred, and more convenient, for macro definitions in
Lisp, but ‘def-edebug-spec’ makes it possible to define Edebug
specifications for special forms implemented in C.

 -- Macro: def-edebug-spec macro specification
     Specify which expressions of a call to macro MACRO are forms to be
     evaluated.  SPECIFICATION should be the edebug specification.
     Neither argument is evaluated.

     The MACRO argument can actually be any symbol, not just a macro
     name.

   Here is a table of the possibilities for SPECIFICATION and how each
directs processing of arguments.

‘t’
     All arguments are instrumented for evaluation.

‘0’
     None of the arguments is instrumented.

a symbol
     The symbol must have an Edebug specification, which is used
     instead.  This indirection is repeated until another kind of
     specification is found.  This allows you to inherit the
     specification from another macro.

a list
     The elements of the list describe the types of the arguments of a
     calling form.  The possible elements of a specification list are
     described in the following sections.

   If a macro has no Edebug specification, neither through a ‘debug’
declaration nor through a ‘def-edebug-spec’ call, the variable
‘edebug-eval-macro-args’ comes into play.

 -- User Option: edebug-eval-macro-args
     This controls the way Edebug treats macro arguments with no
     explicit Edebug specification.  If it is ‘nil’ (the default), none
     of the arguments is instrumented for evaluation.  Otherwise, all
     arguments are instrumented.


File: elisp.info,  Node: Specification List,  Next: Backtracking,  Prev: Instrumenting Macro Calls,  Up: Edebug and Macros

18.2.15.2 Specification List
............................

A “specification list” is required for an Edebug specification if some
arguments of a macro call are evaluated while others are not.  Some
elements in a specification list match one or more arguments, but others
modify the processing of all following elements.  The latter, called
“specification keywords”, are symbols beginning with ‘&’ (such as
‘&optional’).

   A specification list may contain sublists, which match arguments that
are themselves lists, or it may contain vectors used for grouping.
Sublists and groups thus subdivide the specification list into a
hierarchy of levels.  Specification keywords apply only to the remainder
of the sublist or group they are contained in.

   When a specification list involves alternatives or repetition,
matching it against an actual macro call may require backtracking.  For
more details, *note Backtracking::.

   Edebug specifications provide the power of regular expression
matching, plus some context-free grammar constructs: the matching of
sublists with balanced parentheses, recursive processing of forms, and
recursion via indirect specifications.

   Here’s a table of the possible elements of a specification list, with
their meanings (see *note Specification Examples::, for the referenced
examples):

‘sexp’
     A single unevaluated Lisp object, which is not instrumented.

‘form’
     A single evaluated expression, which is instrumented.  If your
     macro wraps the expression with ‘lambda’ before it is evaluated,
     use ‘def-form’ instead.  See ‘def-form’ below.

‘place’
     A generalized variable.  *Note Generalized Variables::.

‘body’
     Short for ‘&rest form’.  See ‘&rest’ below.  If your macro wraps
     its body of code with ‘lambda’ before it is evaluated, use
     ‘def-body’ instead.  See ‘def-body’ below.

‘function-form’
     A function form: either a quoted function symbol, a quoted lambda
     expression, or a form (that should evaluate to a function symbol or
     lambda expression).  This is useful when an argument that’s a
     lambda expression might be quoted with ‘quote’ rather than
     ‘function’, since it instruments the body of the lambda expression
     either way.

‘lambda-expr’
     A lambda expression with no quoting.

‘&optional’
     All following elements in the specification list are optional; as
     soon as one does not match, Edebug stops matching at this level.

     To make just a few elements optional, followed by non-optional
     elements, use ‘[&optional SPECS...]’.  To specify that several
     elements must all match or none, use ‘&optional [SPECS...]’.  See
     the ‘defun’ example.

‘&rest’
     All following elements in the specification list are repeated zero
     or more times.  In the last repetition, however, it is not a
     problem if the expression runs out before matching all of the
     elements of the specification list.

     To repeat only a few elements, use ‘[&rest SPECS...]’.  To specify
     several elements that must all match on every repetition, use
     ‘&rest [SPECS...]’.

‘&or’
     Each of the following elements in the specification list is an
     alternative.  One of the alternatives must match, or the ‘&or’
     specification fails.

     Each list element following ‘&or’ is a single alternative.  To
     group two or more list elements as a single alternative, enclose
     them in ‘[...]’.

‘&not’
     Each of the following elements is matched as alternatives as if by
     using ‘&or’, but if any of them match, the specification fails.  If
     none of them match, nothing is matched, but the ‘&not’
     specification succeeds.

‘&define’

     Indicates that the specification is for a defining form.  Edebug’s
     definition of a defining form is a form containing one or more code
     forms which are saved and executed later, after the execution of
     the defining form.

     The defining form itself is not instrumented (that is, Edebug does
     not stop before and after the defining form), but forms inside it
     typically will be instrumented.  The ‘&define’ keyword should be
     the first element in a list specification.

‘nil’
     This is successful when there are no more arguments to match at the
     current argument list level; otherwise it fails.  See sublist
     specifications and the backquote example.

‘gate’
     No argument is matched but backtracking through the gate is
     disabled while matching the remainder of the specifications at this
     level.  This is primarily used to generate more specific syntax
     error messages.  See *note Backtracking::, for more details.  Also
     see the ‘let’ example.

‘OTHER-SYMBOL’
     Any other symbol in a specification list may be a predicate or an
     indirect specification.

     If the symbol has an Edebug specification, this “indirect
     specification” should be either a list specification that is used
     in place of the symbol, or a function that is called to process the
     arguments.  The specification may be defined with ‘def-edebug-spec’
     just as for macros.  See the ‘defun’ example.

     Otherwise, the symbol should be a predicate.  The predicate is
     called with the argument, and if the predicate returns ‘nil’, the
     specification fails and the argument is not instrumented.

     Some suitable predicates include ‘symbolp’, ‘integerp’, ‘stringp’,
     ‘vectorp’, and ‘atom’.

‘[ELEMENTS...]’
     A vector of elements groups the elements into a single “group
     specification”.  Its meaning has nothing to do with vectors.

‘"STRING"’
     The argument should be a symbol named STRING.  This specification
     is equivalent to the quoted symbol, ‘'SYMBOL’, where the name of
     SYMBOL is the STRING, but the string form is preferred.

‘(vector ELEMENTS...)’
     The argument should be a vector whose elements must match the
     ELEMENTS in the specification.  See the backquote example.

‘(ELEMENTS...)’
     Any other list is a “sublist specification” and the argument must
     be a list whose elements match the specification ELEMENTS.

     A sublist specification may be a dotted list and the corresponding
     list argument may then be a dotted list.  Alternatively, the last
     CDR of a dotted list specification may be another sublist
     specification (via a grouping or an indirect specification, e.g.,
     ‘(spec . [(more specs...)])’) whose elements match the non-dotted
     list arguments.  This is useful in recursive specifications such as
     in the backquote example.  Also see the description of a ‘nil’
     specification above for terminating such recursion.

     Note that a sublist specification written as ‘(specs . nil)’ is
     equivalent to ‘(specs)’, and ‘(specs . (sublist-elements...))’ is
     equivalent to ‘(specs sublist-elements...)’.

   Here is a list of additional specifications that may appear only
after ‘&define’.  See the ‘defun’ example.

‘name’
     The argument, a symbol, is the name of the defining form.

     A defining form is not required to have a name field; and it may
     have multiple name fields.

‘:name’
     This construct does not actually match an argument.  The element
     following ‘:name’ should be a symbol; it is used as an additional
     name component for the definition.  You can use this to add a
     unique, static component to the name of the definition.  It may be
     used more than once.

‘arg’
     The argument, a symbol, is the name of an argument of the defining
     form.  However, lambda-list keywords (symbols starting with ‘&’)
     are not allowed.

‘lambda-list’
     This matches a lambda list—the argument list of a lambda
     expression.

‘def-body’
     The argument is the body of code in a definition.  This is like
     ‘body’, described above, but a definition body must be instrumented
     with a different Edebug call that looks up information associated
     with the definition.  Use ‘def-body’ for the highest level list of
     forms within the definition.

‘def-form’
     The argument is a single, highest-level form in a definition.  This
     is like ‘def-body’, except it is used to match a single form rather
     than a list of forms.  As a special case, ‘def-form’ also means
     that tracing information is not output when the form is executed.
     See the ‘interactive’ example.


File: elisp.info,  Node: Backtracking,  Next: Specification Examples,  Prev: Specification List,  Up: Edebug and Macros

18.2.15.3 Backtracking in Specifications
........................................

If a specification fails to match at some point, this does not
necessarily mean a syntax error will be signaled; instead,
“backtracking” will take place until all alternatives have been
exhausted.  Eventually every element of the argument list must be
matched by some element in the specification, and every required element
in the specification must match some argument.

   When a syntax error is detected, it might not be reported until much
later, after higher-level alternatives have been exhausted, and with the
point positioned further from the real error.  But if backtracking is
disabled when an error occurs, it can be reported immediately.  Note
that backtracking is also reenabled automatically in several situations;
when a new alternative is established by ‘&optional’, ‘&rest’, or ‘&or’,
or at the start of processing a sublist, group, or indirect
specification.  The effect of enabling or disabling backtracking is
limited to the remainder of the level currently being processed and
lower levels.

   Backtracking is disabled while matching any of the form
specifications (that is, ‘form’, ‘body’, ‘def-form’, and ‘def-body’).
These specifications will match any form so any error must be in the
form itself rather than at a higher level.

   Backtracking is also disabled after successfully matching a quoted
symbol or string specification, since this usually indicates a
recognized construct.  But if you have a set of alternative constructs
that all begin with the same symbol, you can usually work around this
constraint by factoring the symbol out of the alternatives, e.g.,
‘["foo" &or [first case] [second case] ...]’.

   Most needs are satisfied by these two ways that backtracking is
automatically disabled, but occasionally it is useful to explicitly
disable backtracking by using the ‘gate’ specification.  This is useful
when you know that no higher alternatives could apply.  See the example
of the ‘let’ specification.


File: elisp.info,  Node: Specification Examples,  Prev: Backtracking,  Up: Edebug and Macros

18.2.15.4 Specification Examples
................................

It may be easier to understand Edebug specifications by studying the
examples provided here.

   A ‘let’ special form has a sequence of bindings and a body.  Each of
the bindings is either a symbol or a sublist with a symbol and optional
expression.  In the specification below, notice the ‘gate’ inside of the
sublist to prevent backtracking once a sublist is found.

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

   Edebug uses the following specifications for ‘defun’ and the
associated argument list and ‘interactive’ specifications.  It is
necessary to handle interactive forms specially since an expression
argument is actually evaluated outside of the function body.  (The
specification for ‘defmacro’ is very similar to that for ‘defun’, but
allows for the ‘declare’ statement.)

     (def-edebug-spec defun
       (&define name lambda-list
                [&optional stringp]   ; Match the doc string, if present.
                [&optional ("interactive" interactive)]
                def-body))

     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))

     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; Notice: ‘def-form’

   The specification for backquote below illustrates how to match dotted
lists and use ‘nil’ to terminate recursion.  It also illustrates how
components of a vector may be matched.  (The actual specification
defined by Edebug is a little different, and does not support dotted
lists because doing so causes very deep recursion that could fail.)

     (def-edebug-spec \` (backquote-form))   ; Alias just for clarity.

     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))


File: elisp.info,  Node: Edebug Options,  Prev: Edebug and Macros,  Up: Edebug

18.2.16 Edebug Options
----------------------

These options affect the behavior of Edebug:

 -- User Option: edebug-setup-hook
     Functions to call before Edebug is used.  Each time it is set to a
     new value, Edebug will call those functions once and then reset
     ‘edebug-setup-hook’ to ‘nil’.  You could use this to load up Edebug
     specifications associated with a package you are using, but only
     when you also use Edebug.  *Note Instrumenting::.

 -- User Option: edebug-all-defs
     If this is non-‘nil’, normal evaluation of defining forms such as
     ‘defun’ and ‘defmacro’ instruments them for Edebug.  This applies
     to ‘eval-defun’, ‘eval-region’, ‘eval-buffer’, and
     ‘eval-current-buffer’.

     Use the command ‘M-x edebug-all-defs’ to toggle the value of this
     option.  *Note Instrumenting::.

 -- User Option: edebug-all-forms
     If this is non-‘nil’, the commands ‘eval-defun’, ‘eval-region’,
     ‘eval-buffer’, and ‘eval-current-buffer’ instrument all forms, even
     those that don’t define anything.  This doesn’t apply to loading or
     evaluations in the minibuffer.

     Use the command ‘M-x edebug-all-forms’ to toggle the value of this
     option.  *Note Instrumenting::.

 -- User Option: edebug-eval-macro-args
     When this is non-‘nil’, all macro arguments will be instrumented in
     the generated code.  For any macro, an ‘edebug-form-spec’ overrides
     this option.  So to specify exceptions for macros that have some
     arguments evaluated and some not, use ‘def-edebug-spec’ to specify
     an ‘edebug-form-spec’.

 -- User Option: edebug-save-windows
     If this is non-‘nil’, Edebug saves and restores the window
     configuration.  That takes some time, so if your program does not
     care what happens to the window configurations, it is better to set
     this variable to ‘nil’.

     If the value is a list, only the listed windows are saved and
     restored.

     You can use the ‘W’ command in Edebug to change this variable
     interactively.  *Note Edebug Display Update::.

 -- User Option: edebug-save-displayed-buffer-points
     If this is non-‘nil’, Edebug saves and restores point in all
     displayed buffers.

     Saving and restoring point in other buffers is necessary if you are
     debugging code that changes the point of a buffer that is displayed
     in a non-selected window.  If Edebug or the user then selects the
     window, point in that buffer will move to the window’s value of
     point.

     Saving and restoring point in all buffers is expensive, since it
     requires selecting each window twice, so enable this only if you
     need it.  *Note Edebug Display Update::.

 -- User Option: edebug-initial-mode
     If this variable is non-‘nil’, it specifies the initial execution
     mode for Edebug when it is first activated.  Possible values are
     ‘step’, ‘next’, ‘go’, ‘Go-nonstop’, ‘trace’, ‘Trace-fast’,
     ‘continue’, and ‘Continue-fast’.

     The default value is ‘step’.  This variable can be set
     interactively with ‘C-x C-a C-m’ (‘edebug-set-initial-mode’).
     *Note Edebug Execution Modes::.

 -- User Option: edebug-trace
     If this is non-‘nil’, trace each function entry and exit.  Tracing
     output is displayed in a buffer named ‘*edebug-trace*’, one
     function entry or exit per line, indented by the recursion level.

     Also see ‘edebug-tracing’, in *note Trace Buffer::.

 -- User Option: edebug-test-coverage
     If non-‘nil’, Edebug tests coverage of all expressions debugged.
     *Note Coverage Testing::.

 -- User Option: edebug-continue-kbd-macro
     If non-‘nil’, continue defining or executing any keyboard macro
     that is executing outside of Edebug.  Use this with caution since
     it is not debugged.  *Note Edebug Execution Modes::.

 -- User Option: edebug-print-length
     If non-‘nil’, the default value of ‘print-length’ for printing
     results in Edebug.  *Note Output Variables::.

 -- User Option: edebug-print-level
     If non-‘nil’, the default value of ‘print-level’ for printing
     results in Edebug.  *Note Output Variables::.

 -- User Option: edebug-print-circle
     If non-‘nil’, the default value of ‘print-circle’ for printing
     results in Edebug.  *Note Output Variables::.

 -- User Option: edebug-unwrap-results
     If non-‘nil’, Edebug tries to remove any of its own instrumentation
     when showing the results of expressions.  This is relevant when
     debugging macros where the results of expressions are themselves
     instrumented expressions.  As a very artificial example, suppose
     that the example function ‘fac’ has been instrumented, and consider
     a macro of the form:

          (defmacro test () "Edebug example."
            (if (symbol-function 'fac)
                ...))

     If you instrument the ‘test’ macro and step through it, then by
     default the result of the ‘symbol-function’ call has numerous
     ‘edebug-after’ and ‘edebug-before’ forms, which can make it
     difficult to see the actual result.  If ‘edebug-unwrap-results’ is
     non-‘nil’, Edebug tries to remove these forms from the result.

 -- User Option: edebug-on-error
     Edebug binds ‘debug-on-error’ to this value, if ‘debug-on-error’
     was previously ‘nil’.  *Note Trapping Errors::.

 -- User Option: edebug-on-quit
     Edebug binds ‘debug-on-quit’ to this value, if ‘debug-on-quit’ was
     previously ‘nil’.  *Note Trapping Errors::.

   If you change the values of ‘edebug-on-error’ or ‘edebug-on-quit’
while Edebug is active, their values won’t be used until the _next_ time
Edebug is invoked via a new command.

 -- User Option: edebug-global-break-condition
     If non-‘nil’, an expression to test for at every stop point.  If
     the result is non-‘nil’, then break.  Errors are ignored.  *Note
     Global Break Condition::.

 -- User Option: edebug-sit-for-seconds
     Number of seconds to pause when a breakpoint is reached and the
     execution mode is trace or continue.  *Note Edebug Execution
     Modes::.

 -- User Option: edebug-sit-on-break
     Whether or not to pause for ‘edebug-sit-for-seconds’ on reaching a
     breakpoint.  Set to ‘nil’ to prevent the pause, non-‘nil’ to allow
     it.


File: elisp.info,  Node: Syntax Errors,  Next: Test Coverage,  Prev: Edebug,  Up: Debugging

18.3 Debugging Invalid Lisp Syntax
==================================

The Lisp reader reports invalid syntax, but cannot say where the real
problem is.  For example, the error ‘End of file during parsing’ in
evaluating an expression indicates an excess of open parentheses (or
square brackets).  The reader detects this imbalance at the end of the
file, but it cannot figure out where the close parenthesis should have
been.  Likewise, ‘Invalid read syntax: ")"’ indicates an excess close
parenthesis or missing open parenthesis, but does not say where the
missing parenthesis belongs.  How, then, to find what to change?

   If the problem is not simply an imbalance of parentheses, a useful
technique is to try ‘C-M-e’ at the beginning of each defun, and see if
it goes to the place where that defun appears to end.  If it does not,
there is a problem in that defun.

   However, unmatched parentheses are the most common syntax errors in
Lisp, and we can give further advice for those cases.  (In addition,
just moving point through the code with Show Paren mode enabled might
find the mismatch.)

* Menu:

* Excess Open::     How to find a spurious open paren or missing close.
* Excess Close::    How to find a spurious close paren or missing open.


File: elisp.info,  Node: Excess Open,  Next: Excess Close,  Up: Syntax Errors

18.3.1 Excess Open Parentheses
------------------------------

The first step is to find the defun that is unbalanced.  If there is an
excess open parenthesis, the way to do this is to go to the end of the
file and type ‘C-u C-M-u’.  This will move you to the beginning of the
first defun that is unbalanced.

   The next step is to determine precisely what is wrong.  There is no
way to be sure of this except by studying the program, but often the
existing indentation is a clue to where the parentheses should have
been.  The easiest way to use this clue is to reindent with ‘C-M-q’ and
see what moves.  *But don’t do this yet!*  Keep reading, first.

   Before you do this, make sure the defun has enough close parentheses.
Otherwise, ‘C-M-q’ will get an error, or will reindent all the rest of
the file until the end.  So move to the end of the defun and insert a
close parenthesis there.  Don’t use ‘C-M-e’ to move there, since that
too will fail to work until the defun is balanced.

   Now you can go to the beginning of the defun and type ‘C-M-q’.
Usually all the lines from a certain point to the end of the function
will shift to the right.  There is probably a missing close parenthesis,
or a superfluous open parenthesis, near that point.  (However, don’t
assume this is true; study the code to make sure.)  Once you have found
the discrepancy, undo the ‘C-M-q’ with ‘C-_’, since the old indentation
is probably appropriate to the intended parentheses.

   After you think you have fixed the problem, use ‘C-M-q’ again.  If
the old indentation actually fit the intended nesting of parentheses,
and you have put back those parentheses, ‘C-M-q’ should not change
anything.


File: elisp.info,  Node: Excess Close,  Prev: Excess Open,  Up: Syntax Errors

18.3.2 Excess Close Parentheses
-------------------------------

To deal with an excess close parenthesis, first go to the beginning of
the file, then type ‘C-u -1 C-M-u’ to find the end of the first
unbalanced defun.

   Then find the actual matching close parenthesis by typing ‘C-M-f’ at
the beginning of that defun.  This will leave you somewhere short of the
place where the defun ought to end.  It is possible that you will find a
spurious close parenthesis in that vicinity.

   If you don’t see a problem at that point, the next thing to do is to
type ‘C-M-q’ at the beginning of the defun.  A range of lines will
probably shift left; if so, the missing open parenthesis or spurious
close parenthesis is probably near the first of those lines.  (However,
don’t assume this is true; study the code to make sure.)  Once you have
found the discrepancy, undo the ‘C-M-q’ with ‘C-_’, since the old
indentation is probably appropriate to the intended parentheses.

   After you think you have fixed the problem, use ‘C-M-q’ again.  If
the old indentation actually fits the intended nesting of parentheses,
and you have put back those parentheses, ‘C-M-q’ should not change
anything.


File: elisp.info,  Node: Test Coverage,  Next: Profiling,  Prev: Syntax Errors,  Up: Debugging

18.4 Test Coverage
==================

You can do coverage testing for a file of Lisp code by loading the
‘testcover’ library and using the command ‘M-x testcover-start <RET>
FILE <RET>’ to instrument the code.  Then test your code by calling it
one or more times.  Then use the command ‘M-x testcover-mark-all’ to
display colored highlights on the code to show where coverage is
insufficient.  The command ‘M-x testcover-next-mark’ will move point
forward to the next highlighted spot.

   Normally, a red highlight indicates the form was never completely
evaluated; a brown highlight means it always evaluated to the same value
(meaning there has been little testing of what is done with the result).
However, the red highlight is skipped for forms that can’t possibly
complete their evaluation, such as ‘error’.  The brown highlight is
skipped for forms that are expected to always evaluate to the same
value, such as ‘(setq x 14)’.

   For difficult cases, you can add do-nothing macros to your code to
give advice to the test coverage tool.

 -- Macro: 1value form
     Evaluate FORM and return its value, but inform coverage testing
     that FORM’s value should always be the same.

 -- Macro: noreturn form
     Evaluate FORM, informing coverage testing that FORM should never
     return.  If it ever does return, you get a run-time error.

   Edebug also has a coverage testing feature (*note Coverage
Testing::).  These features partly duplicate each other, and it would be
cleaner to combine them.


File: elisp.info,  Node: Profiling,  Prev: Test Coverage,  Up: Debugging

18.5 Profiling
==============

If your program is working correctly, but not fast enough, and you want
to make it run more quickly or efficiently, the first thing to do is
“profile” your code so that you know where it spends most of the
execution time.  If you find that one particular function is responsible
for a significant portion of the execution time, you can start looking
for ways to optimize that piece.

   Emacs has built-in support for this.  To begin profiling, type ‘M-x
profiler-start’.  You can choose to profile by processor usage, memory
usage, or both.  Then run the code you’d like to speed up.  After that,
type ‘M-x profiler-report’ to display a summary buffer for each resource
(cpu and memory) that you chose to profile.  The names of the report
buffers include the times at which the reports were generated, so you
can generate another report later on without erasing previous results.
When you have finished profiling, type ‘M-x profiler-stop’ (there is a
small overhead associated with profiling, so we don’t recommend leaving
it active except when you are actually running the code you want to
examine).

   The profiler report buffer shows, on each line, a function that was
called, followed by how much resources (cpu or memory) it used in
absolute and percentage terms since profiling started.  If a given line
has a ‘+’ symbol at the left-hand side, you can expand that line by
typing ‘<RET>’, in order to see the function(s) called by the
higher-level function.  Use a prefix argument (‘C-u <RET>’) to see the
whole call tree below a function.  Pressing ‘<RET>’ again will collapse
back to the original state.

   Press ‘j’ or ‘mouse-2’ to jump to the definition of a function at
point.  Press ‘d’ to view a function’s documentation.  You can save a
profile to a file using ‘C-x C-w’.  You can compare two profiles using
‘=’.

   The ‘elp’ library offers an alternative approach, which is useful
when you know in advance which Lisp function(s) you want to profile.
Using that library, you begin by setting ‘elp-function-list’ to the list
of function symbols—those are the functions you want to profile.  Then
type ‘M-x elp-instrument-list <RET> nil <RET>’ to arrange for profiling
those functions.  After running the code you want to profile, invoke
‘M-x elp-results’ to display the current results.  See the file ‘elp.el’
for more detailed instructions.  This approach is limited to profiling
functions written in Lisp, it cannot profile Emacs primitives.

   You can measure the time it takes to evaluate individual Emacs Lisp
forms using the ‘benchmark’ library.  See the macros ‘benchmark-run’ and
‘benchmark-run-compiled’ in ‘benchmark.el’.  You can also use the
‘benchmark’ command for timing forms interactively.

   To profile Emacs at the level of its C code, you can build it using
the ‘--enable-profiling’ option of ‘configure’.  When Emacs exits, it
generates a file ‘gmon.out’ that you can examine using the ‘gprof’
utility.  This feature is mainly useful for debugging Emacs.  It
actually stops the Lisp-level ‘M-x profiler-...’ commands described
above from working.


File: elisp.info,  Node: Read and Print,  Next: Minibuffers,  Prev: Debugging,  Up: Top

19 Reading and Printing Lisp Objects
************************************

“Printing” and “reading” are the operations of converting Lisp objects
to textual form and vice versa.  They use the printed representations
and read syntax described in *note Lisp Data Types::.

   This chapter describes the Lisp functions for reading and printing.
It also describes “streams”, which specify where to get the text (if
reading) or where to put it (if printing).

* Menu:

* Streams Intro::     Overview of streams, reading and printing.
* Input Streams::     Various data types that can be used as input streams.
* Input Functions::   Functions to read Lisp objects from text.
* Output Streams::    Various data types that can be used as output streams.
* Output Functions::  Functions to print Lisp objects as text.
* Output Variables::  Variables that control what the printing functions do.


File: elisp.info,  Node: Streams Intro,  Next: Input Streams,  Up: Read and Print

19.1 Introduction to Reading and Printing
=========================================

“Reading” a Lisp object means parsing a Lisp expression in textual form
and producing a corresponding Lisp object.  This is how Lisp programs
get into Lisp from files of Lisp code.  We call the text the “read
syntax” of the object.  For example, the text ‘(a . 5)’ is the read
syntax for a cons cell whose CAR is ‘a’ and whose CDR is the number 5.

   “Printing” a Lisp object means producing text that represents that
object—converting the object to its “printed representation” (*note
Printed Representation::).  Printing the cons cell described above
produces the text ‘(a . 5)’.

   Reading and printing are more or less inverse operations: printing
the object that results from reading a given piece of text often
produces the same text, and reading the text that results from printing
an object usually produces a similar-looking object.  For example,
printing the symbol ‘foo’ produces the text ‘foo’, and reading that text
returns the symbol ‘foo’.  Printing a list whose elements are ‘a’ and
‘b’ produces the text ‘(a b)’, and reading that text produces a list
(but not the same list) with elements ‘a’ and ‘b’.

   However, these two operations are not precisely inverse to each
other.  There are three kinds of exceptions:

   • Printing can produce text that cannot be read.  For example,
     buffers, windows, frames, subprocesses and markers print as text
     that starts with ‘#’; if you try to read this text, you get an
     error.  There is no way to read those data types.

   • One object can have multiple textual representations.  For example,
     ‘1’ and ‘01’ represent the same integer, and ‘(a b)’ and ‘(a .
     (b))’ represent the same list.  Reading will accept any of the
     alternatives, but printing must choose one of them.

   • Comments can appear at certain points in the middle of an object’s
     read sequence without affecting the result of reading it.


File: elisp.info,  Node: Input Streams,  Next: Input Functions,  Prev: Streams Intro,  Up: Read and Print

19.2 Input Streams
==================

Most of the Lisp functions for reading text take an “input stream” as an
argument.  The input stream specifies where or how to get the characters
of the text to be read.  Here are the possible types of input stream:

BUFFER
     The input characters are read from BUFFER, starting with the
     character directly after point.  Point advances as characters are
     read.

MARKER
     The input characters are read from the buffer that MARKER is in,
     starting with the character directly after the marker.  The marker
     position advances as characters are read.  The value of point in
     the buffer has no effect when the stream is a marker.

STRING
     The input characters are taken from STRING, starting at the first
     character in the string and using as many characters as required.

FUNCTION
     The input characters are generated by FUNCTION, which must support
     two kinds of calls:

        • When it is called with no arguments, it should return the next
          character.

        • When it is called with one argument (always a character),
          FUNCTION should save the argument and arrange to return it on
          the next call.  This is called “unreading” the character; it
          happens when the Lisp reader reads one character too many and
          wants to put it back where it came from.  In this case, it
          makes no difference what value FUNCTION returns.

‘t’
     ‘t’ used as a stream means that the input is read from the
     minibuffer.  In fact, the minibuffer is invoked once and the text
     given by the user is made into a string that is then used as the
     input stream.  If Emacs is running in batch mode, standard input is
     used instead of the minibuffer.  For example,
          (message "%s" (read t))
     will read a Lisp expression from standard input and print the
     result to standard output.

‘nil’
     ‘nil’ supplied as an input stream means to use the value of
     ‘standard-input’ instead; that value is the “default input stream”,
     and must be a non-‘nil’ input stream.

SYMBOL
     A symbol as input stream is equivalent to the symbol’s function
     definition (if any).

   Here is an example of reading from a stream that is a buffer, showing
where point is located before and after:

     ---------- Buffer: foo ----------
     This★ is the contents of foo.
     ---------- Buffer: foo ----------

     (read (get-buffer "foo"))
          ⇒ is
     (read (get-buffer "foo"))
          ⇒ the

     ---------- Buffer: foo ----------
     This is the★ contents of foo.
     ---------- Buffer: foo ----------

Note that the first read skips a space.  Reading skips any amount of
whitespace preceding the significant text.

   Here is an example of reading from a stream that is a marker,
initially positioned at the beginning of the buffer shown.  The value
read is the symbol ‘This’.


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------

     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          ⇒ #<marker at 1 in foo>
     (read m)
          ⇒ This
     m
          ⇒ #<marker at 5 in foo>   ;; Before the first space.

   Here we read from the contents of a string:

     (read "(When in) the course")
          ⇒ (When in)

   The following example reads from the minibuffer.  The prompt is:
‘Lisp expression: ’.  (That is always the prompt used when you read from
the stream ‘t’.)  The user’s input is shown following the prompt.

     (read t)
          ⇒ 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 <RET>
     ---------- Buffer: Minibuffer ----------

   Finally, here is an example of a stream that is a function, named
‘useless-stream’.  Before we use the stream, we initialize the variable
‘useless-list’ to a list of characters.  Then each call to the function
‘useless-stream’ obtains the next character in the list or unreads a
character by adding it to the front of the list.

     (setq useless-list (append "XY()" nil))
          ⇒ (88 89 40 41)

     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          ⇒ useless-stream

Now we read using the stream thus constructed:

     (read 'useless-stream)
          ⇒ XY

     useless-list
          ⇒ (40 41)

Note that the open and close parentheses remain in the list.  The Lisp
reader encountered the open parenthesis, decided that it ended the
input, and unread it.  Another attempt to read from the stream at this
point would read ‘()’ and return ‘nil’.


File: elisp.info,  Node: Input Functions,  Next: Output Streams,  Prev: Input Streams,  Up: Read and Print

19.3 Input Functions
====================

This section describes the Lisp functions and variables that pertain to
reading.

   In the functions below, STREAM stands for an input stream (see the
previous section).  If STREAM is ‘nil’ or omitted, it defaults to the
value of ‘standard-input’.

   An ‘end-of-file’ error is signaled if reading encounters an
unterminated list, vector, or string.

 -- Function: read &optional stream
     This function reads one textual Lisp expression from STREAM,
     returning it as a Lisp object.  This is the basic Lisp input
     function.

 -- Function: read-from-string string &optional start end
     This function reads the first textual Lisp expression from the text
     in STRING.  It returns a cons cell whose CAR is that expression,
     and whose CDR is an integer giving the position of the next
     remaining character in the string (i.e., the first one not read).

     If START is supplied, then reading begins at index START in the
     string (where the first character is at index 0).  If you specify
     END, then reading is forced to stop just before that index, as if
     the rest of the string were not there.

     For example:

          (read-from-string "(setq x 55) (setq y 5)")
               ⇒ ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               ⇒ ("A short string" . 16)

          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
               ⇒ ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
               ⇒ (list . 5)
          ;; Read starting at the seventh character,
          ;;   and stopping at the ninth.
          (read-from-string "(list 112)" 6 8)
               ⇒ (11 . 8)

 -- Variable: standard-input
     This variable holds the default input stream—the stream that ‘read’
     uses when the STREAM argument is ‘nil’.  The default is ‘t’,
     meaning use the minibuffer.

 -- Variable: read-circle
     If non-‘nil’, this variable enables the reading of circular and
     shared structures.  *Note Circular Objects::.  Its default value is
     ‘t’.

   When reading or writing from the standard input/output streams of the
Emacs process in batch mode, it is sometimes required to make sure any
arbitrary binary data will be read/written verbatim, and/or that no
translation of newlines to or from CR-LF pairs is performed.  This issue
does not exist on POSIX hosts, only on MS-Windows and MS-DOS.  The
following function allows you to control the I/O mode of any standard
stream of the Emacs process.

 -- Function: set-binary-mode stream mode
     Switch STREAM into binary or text I/O mode.  If MODE is non-‘nil’,
     switch to binary mode, otherwise switch to text mode.  The value of
     STREAM can be one of ‘stdin’, ‘stdout’, or ‘stderr’.  This function
     flushes any pending output data of STREAM as a side effect, and
     returns the previous value of I/O mode for STREAM.  On POSIX hosts,
     it always returns a non-‘nil’ value and does nothing except
     flushing pending output.


File: elisp.info,  Node: Output Streams,  Next: Output Functions,  Prev: Input Functions,  Up: Read and Print

19.4 Output Streams
===================

An output stream specifies what to do with the characters produced by
printing.  Most print functions accept an output stream as an optional
argument.  Here are the possible types of output stream:

BUFFER
     The output characters are inserted into BUFFER at point.  Point
     advances as characters are inserted.

MARKER
     The output characters are inserted into the buffer that MARKER
     points into, at the marker position.  The marker position advances
     as characters are inserted.  The value of point in the buffer has
     no effect on printing when the stream is a marker, and this kind of
     printing does not move point (except that if the marker points at
     or before the position of point, point advances with the
     surrounding text, as usual).

FUNCTION
     The output characters are passed to FUNCTION, which is responsible
     for storing them away.  It is called with a single character as
     argument, as many times as there are characters to be output, and
     is responsible for storing the characters wherever you want to put
     them.

‘t’
     The output characters are displayed in the echo area.

‘nil’
     ‘nil’ specified as an output stream means to use the value of
     ‘standard-output’ instead; that value is the “default output
     stream”, and must not be ‘nil’.

SYMBOL
     A symbol as output stream is equivalent to the symbol’s function
     definition (if any).

   Many of the valid output streams are also valid as input streams.
The difference between input and output streams is therefore more a
matter of how you use a Lisp object, than of different types of object.

   Here is an example of a buffer used as an output stream.  Point is
initially located as shown immediately before the ‘h’ in ‘the’.  At the
end, point is located directly before that same ‘h’.

     ---------- Buffer: foo ----------
     This is t★he contents of foo.
     ---------- Buffer: foo ----------

     (print "This is the output" (get-buffer "foo"))
          ⇒ "This is the output"

     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     ★he contents of foo.
     ---------- Buffer: foo ----------

   Now we show a use of a marker as an output stream.  Initially, the
marker is in buffer ‘foo’, between the ‘t’ and the ‘h’ in the word
‘the’.  At the end, the marker has advanced over the inserted text so
that it remains positioned before the same ‘h’.  Note that the location
of point, shown in the usual fashion, has no effect.

     ---------- Buffer: foo ----------
     This is the ★output
     ---------- Buffer: foo ----------

     (setq m (copy-marker 10))
          ⇒ #<marker at 10 in foo>

     (print "More output for foo." m)
          ⇒ "More output for foo."

     ---------- Buffer: foo ----------
     This is t
     "More output for foo."
     he ★output
     ---------- Buffer: foo ----------

     m
          ⇒ #<marker at 34 in foo>

   The following example shows output to the echo area:

     (print "Echo Area output" t)
          ⇒ "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------

   Finally, we show the use of a function as an output stream.  The
function ‘eat-output’ takes each character that it is given and conses
it onto the front of the list ‘last-output’ (*note Building Lists::).
At the end, the list contains all the characters output, but in reverse
order.

     (setq last-output nil)
          ⇒ nil

     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          ⇒ eat-output

     (print "This is the output" #'eat-output)
          ⇒ "This is the output"

     last-output
          ⇒ (10 34 116 117 112 116 117 111 32 101 104
         116 32 115 105 32 115 105 104 84 34 10)

Now we can put the output in the proper order by reversing the list:

     (concat (nreverse last-output))
          ⇒ "
     \"This is the output\"
     "

Calling ‘concat’ converts the list to a string so you can see its
contents more clearly.

 -- Function: external-debugging-output character
     This function can be useful as an output stream when debugging.  It
     writes CHARACTER to the standard error stream.

     For example
          (print "This is the output" #'external-debugging-output)
          ⊣ This is the output
          ⇒ "This is the output"


File: elisp.info,  Node: Output Functions,  Next: Output Variables,  Prev: Output Streams,  Up: Read and Print

19.5 Output Functions
=====================

This section describes the Lisp functions for printing Lisp
objects—converting objects into their printed representation.

   Some of the Emacs printing functions add quoting characters to the
output when necessary so that it can be read properly.  The quoting
characters used are ‘"’ and ‘\’; they distinguish strings from symbols,
and prevent punctuation characters in strings and symbols from being
taken as delimiters when reading.  *Note Printed Representation::, for
full details.  You specify quoting or no quoting by the choice of
printing function.

   If the text is to be read back into Lisp, then you should print with
quoting characters to avoid ambiguity.  Likewise, if the purpose is to
describe a Lisp object clearly for a Lisp programmer.  However, if the
purpose of the output is to look nice for humans, then it is usually
better to print without quoting.

   Lisp objects can refer to themselves.  Printing a self-referential
object in the normal way would require an infinite amount of text, and
the attempt could cause infinite recursion.  Emacs detects such
recursion and prints ‘#LEVEL’ instead of recursively printing an object
already being printed.  For example, here ‘#0’ indicates a recursive
reference to the object at level 0 of the current print operation:

     (setq foo (list nil))
          ⇒ (nil)
     (setcar foo foo)
          ⇒ (#0)

   In the functions below, STREAM stands for an output stream.  (See the
previous section for a description of output streams.  Also *Note
external-debugging-output::, a useful stream value for debugging.)  If
STREAM is ‘nil’ or omitted, it defaults to the value of
‘standard-output’.

 -- Function: print object &optional stream
     The ‘print’ function is a convenient way of printing.  It outputs
     the printed representation of OBJECT to STREAM, printing in
     addition one newline before OBJECT and another after it.  Quoting
     characters are used.  ‘print’ returns OBJECT.  For example:

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               ⊣
               ⊣ The\ cat\ in
               ⊣
               ⊣ "the hat"
               ⊣
               ⊣ " came back"
               ⇒ " came back"

 -- Function: prin1 object &optional stream
     This function outputs the printed representation of OBJECT to
     STREAM.  It does not print newlines to separate output as ‘print’
     does, but it does use quoting characters just like ‘print’.  It
     returns OBJECT.

          (progn (prin1 'The\ cat\ in)
                 (prin1 "the hat")
                 (prin1 " came back"))
               ⊣ The\ cat\ in"the hat"" came back"
               ⇒ " came back"

 -- Function: princ object &optional stream
     This function outputs the printed representation of OBJECT to
     STREAM.  It returns OBJECT.

     This function is intended to produce output that is readable by
     people, not by ‘read’, so it doesn’t insert quoting characters and
     doesn’t put double-quotes around the contents of strings.  It does
     not add any spacing between calls.

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               ⊣ The cat in the "hat"
               ⇒ " in the \"hat\""

 -- Function: terpri &optional stream ensure
     This function outputs a newline to STREAM.  The name stands for
     “terminate print”.  If ENSURE is non-‘nil’ no newline is printed if
     STREAM is already at the beginning of a line.  Note in this case
     STREAM can not be a function and an error is signaled if it is.
     This function returns ‘t’ if a newline is printed.

 -- Function: write-char character &optional stream
     This function outputs CHARACTER to STREAM.  It returns CHARACTER.

 -- Function: prin1-to-string object &optional noescape
     This function returns a string containing the text that ‘prin1’
     would have printed for the same argument.

          (prin1-to-string 'foo)
               ⇒ "foo"
          (prin1-to-string (mark-marker))
               ⇒ "#<marker at 2773 in strings.texi>"

     If NOESCAPE is non-‘nil’, that inhibits use of quoting characters
     in the output.  (This argument is supported in Emacs versions 19
     and later.)

          (prin1-to-string "foo")
               ⇒ "\"foo\""
          (prin1-to-string "foo" t)
               ⇒ "foo"

     See ‘format’, in *note Formatting Strings::, for other ways to
     obtain the printed representation of a Lisp object as a string.

 -- Macro: with-output-to-string body...
     This macro executes the BODY forms with ‘standard-output’ set up to
     feed output into a string.  Then it returns that string.

     For example, if the current buffer name is ‘foo’,

          (with-output-to-string
            (princ "The buffer is ")
            (princ (buffer-name)))

     returns ‘"The buffer is foo"’.

 -- Function: pp object &optional stream
     This function outputs OBJECT to STREAM, just like ‘prin1’, but does
     it in a prettier way.  That is, it’ll indent and fill the object to
     make it more readable for humans.

   If you need to use binary I/O in batch mode, e.g., use the functions
described in this section to write out arbitrary binary data or avoid
conversion of newlines on non-POSIX hosts, see *note set-binary-mode:
Input Functions.


File: elisp.info,  Node: Output Variables,  Prev: Output Functions,  Up: Read and Print

19.6 Variables Affecting Output
===============================

 -- Variable: standard-output
     The value of this variable is the default output stream—the stream
     that print functions use when the STREAM argument is ‘nil’.  The
     default is ‘t’, meaning display in the echo area.

 -- Variable: print-quoted
     If this is non-‘nil’, that means to print quoted forms using
     abbreviated reader syntax, e.g., ‘(quote foo)’ prints as ‘'foo’,
     and ‘(function foo)’ as ‘#'foo’.

 -- Variable: print-escape-newlines
     If this variable is non-‘nil’, then newline characters in strings
     are printed as ‘\n’ and formfeeds are printed as ‘\f’.  Normally
     these characters are printed as actual newlines and formfeeds.

     This variable affects the print functions ‘prin1’ and ‘print’ that
     print with quoting.  It does not affect ‘princ’.  Here is an
     example using ‘prin1’:

          (prin1 "a\nb")
               ⊣ "a
               ⊣ b"
               ⇒ "a
          b"

          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               ⊣ "a\nb"
               ⇒ "a
          b"

     In the second expression, the local binding of
     ‘print-escape-newlines’ is in effect during the call to ‘prin1’,
     but not during the printing of the result.

 -- Variable: print-escape-control-characters
     If this variable is non-‘nil’, control characters in strings are
     printed as backslash sequences by the print functions ‘prin1’ and
     ‘print’ that print with quoting.  If this variable and
     ‘print-escape-newlines’ are both non-‘nil’, the latter takes
     precedences for newlines and formfeeds.

 -- Variable: print-escape-nonascii
     If this variable is non-‘nil’, then unibyte non-ASCII characters in
     strings are unconditionally printed as backslash sequences by the
     print functions ‘prin1’ and ‘print’ that print with quoting.

     Those functions also use backslash sequences for unibyte non-ASCII
     characters, regardless of the value of this variable, when the
     output stream is a multibyte buffer or a marker pointing into one.

 -- Variable: print-escape-multibyte
     If this variable is non-‘nil’, then multibyte non-ASCII characters
     in strings are unconditionally printed as backslash sequences by
     the print functions ‘prin1’ and ‘print’ that print with quoting.

     Those functions also use backslash sequences for multibyte
     non-ASCII characters, regardless of the value of this variable,
     when the output stream is a unibyte buffer or a marker pointing
     into one.

 -- Variable: print-length
     The value of this variable is the maximum number of elements to
     print in any list, vector or bool-vector.  If an object being
     printed has more than this many elements, it is abbreviated with an
     ellipsis.

     If the value is ‘nil’ (the default), then there is no limit.

          (setq print-length 2)
               ⇒ 2
          (print '(1 2 3 4 5))
               ⊣ (1 2 ...)
               ⇒ (1 2 ...)

 -- Variable: print-level
     The value of this variable is the maximum depth of nesting of
     parentheses and brackets when printed.  Any list or vector at a
     depth exceeding this limit is abbreviated with an ellipsis.  A
     value of ‘nil’ (which is the default) means no limit.

 -- User Option: eval-expression-print-length
 -- User Option: eval-expression-print-level
     These are the values for ‘print-length’ and ‘print-level’ used by
     ‘eval-expression’, and thus, indirectly, by many interactive
     evaluation commands (*note Evaluating Emacs-Lisp Expressions:
     (emacs)Lisp Eval.).

   These variables are used for detecting and reporting circular and
shared structure:

 -- Variable: print-circle
     If non-‘nil’, this variable enables detection of circular and
     shared structure in printing.  *Note Circular Objects::.

 -- Variable: print-gensym
     If non-‘nil’, this variable enables detection of uninterned symbols
     (*note Creating Symbols::) in printing.  When this is enabled,
     uninterned symbols print with the prefix ‘#:’, which tells the Lisp
     reader to produce an uninterned symbol.

 -- Variable: print-continuous-numbering
     If non-‘nil’, that means number continuously across print calls.
     This affects the numbers printed for ‘#N=’ labels and ‘#M#’
     references.  Don’t set this variable with ‘setq’; you should only
     bind it temporarily to ‘t’ with ‘let’.  When you do that, you
     should also bind ‘print-number-table’ to ‘nil’.

 -- Variable: print-number-table
     This variable holds a vector used internally by printing to
     implement the ‘print-circle’ feature.  You should not use it except
     to bind it to ‘nil’ when you bind ‘print-continuous-numbering’.

 -- Variable: float-output-format
     This variable specifies how to print floating-point numbers.  The
     default is ‘nil’, meaning use the shortest output that represents
     the number without losing information.

     To control output format more precisely, you can put a string in
     this variable.  The string should hold a ‘%’-specification to be
     used in the C function ‘sprintf’.  For further restrictions on what
     you can use, see the variable’s documentation string.


File: elisp.info,  Node: Minibuffers,  Next: Command Loop,  Prev: Read and Print,  Up: Top

20 Minibuffers
**************

A “minibuffer” is a special buffer that Emacs commands use to read
arguments more complicated than the single numeric prefix argument.
These arguments include file names, buffer names, and command names (as
in ‘M-x’).  The minibuffer is displayed on the bottom line of the frame,
in the same place as the echo area (*note The Echo Area::), but only
while it is in use for reading an argument.

* Menu:

* Intro to Minibuffers::      Basic information about minibuffers.
* Text from Minibuffer::      How to read a straight text string.
* Object from Minibuffer::    How to read a Lisp object or expression.
* Minibuffer History::        Recording previous minibuffer inputs
                                so the user can reuse them.
* Initial Input::             Specifying initial contents for the minibuffer.
* Completion::                How to invoke and customize completion.
* Yes-or-No Queries::         Asking a question with a simple answer.
* Multiple Queries::          Asking a series of similar questions.
* Reading a Password::        Reading a password from the terminal.
* Minibuffer Commands::       Commands used as key bindings in minibuffers.
* Minibuffer Windows::        Operating on the special minibuffer windows.
* Minibuffer Contents::       How such commands access the minibuffer text.
* Recursive Mini::            Whether recursive entry to minibuffer is allowed.
* Minibuffer Misc::           Various customization hooks and variables.


File: elisp.info,  Node: Intro to Minibuffers,  Next: Text from Minibuffer,  Up: Minibuffers

20.1 Introduction to Minibuffers
================================

In most ways, a minibuffer is a normal Emacs buffer.  Most operations
_within_ a buffer, such as editing commands, work normally in a
minibuffer.  However, many operations for managing buffers do not apply
to minibuffers.  The name of a minibuffer always has the form
‘ *Minibuf-NUMBER*’, and it cannot be changed.  Minibuffers are
displayed only in special windows used only for minibuffers; these
windows always appear at the bottom of a frame.  (Sometimes frames have
no minibuffer window, and sometimes a special kind of frame contains
nothing but a minibuffer window; see *note Minibuffers and Frames::.)

   The text in the minibuffer always starts with the “prompt string”,
the text that was specified by the program that is using the minibuffer
to tell the user what sort of input to type.  This text is marked
read-only so you won’t accidentally delete or change it.  It is also
marked as a field (*note Fields::), so that certain motion functions,
including ‘beginning-of-line’, ‘forward-word’, ‘forward-sentence’, and
‘forward-paragraph’, stop at the boundary between the prompt and the
actual text.

   The minibuffer’s window is normally a single line; it grows
automatically if the contents require more space.  Whilst the minibuffer
is active, you can explicitly resize its window temporarily with the
window sizing commands; the window reverts to its normal size when the
minibuffer is exited.  When the minibuffer is not active, you can resize
its window permanently by using the window sizing commands in the
frame’s other window, or dragging the mode line with the mouse.  (Due to
details of the current implementation, for this to work
‘resize-mini-windows’ must be ‘nil’.)  If the frame contains just a
minibuffer window, you can change its size by changing the frame’s size.

   Use of the minibuffer reads input events, and that alters the values
of variables such as ‘this-command’ and ‘last-command’ (*note Command
Loop Info::).  Your program should bind them around the code that uses
the minibuffer, if you do not want that to change them.

   Under some circumstances, a command can use a minibuffer even if
there is an active minibuffer; such a minibuffer is called a “recursive
minibuffer”.  The first minibuffer is named ‘ *Minibuf-1*’.  Recursive
minibuffers are named by incrementing the number at the end of the name.
(The names begin with a space so that they won’t show up in normal
buffer lists.)  Of several recursive minibuffers, the innermost (or most
recently entered) is the active minibuffer.  We usually call this _the_
minibuffer.  You can permit or forbid recursive minibuffers by setting
the variable ‘enable-recursive-minibuffers’, or by putting properties of
that name on command symbols (*Note Recursive Mini::.)

   Like other buffers, a minibuffer uses a local keymap (*note
Keymaps::) to specify special key bindings.  The function that invokes
the minibuffer also sets up its local map according to the job to be
done.  *Note Text from Minibuffer::, for the non-completion minibuffer
local maps.  *Note Completion Commands::, for the minibuffer local maps
for completion.

   When a minibuffer is inactive, its major mode is
‘minibuffer-inactive-mode’, with keymap ‘minibuffer-inactive-mode-map’.
This is only really useful if the minibuffer is in a separate frame.
*Note Minibuffers and Frames::.

   When Emacs is running in batch mode, any request to read from the
minibuffer actually reads a line from the standard input descriptor that
was supplied when Emacs was started.  This supports only basic input:
none of the special minibuffer features (history, completion, etc.) are
available in batch mode.


File: elisp.info,  Node: Text from Minibuffer,  Next: Object from Minibuffer,  Prev: Intro to Minibuffers,  Up: Minibuffers

20.2 Reading Text Strings with the Minibuffer
=============================================

The most basic primitive for minibuffer input is ‘read-from-minibuffer’,
which can be used to read either a string or a Lisp object in textual
form.  The function ‘read-regexp’ is used for reading regular
expressions (*note Regular Expressions::), which are a special kind of
string.  There are also specialized functions for reading commands,
variables, file names, etc. (*note Completion::).

   In most cases, you should not call minibuffer input functions in the
middle of a Lisp function.  Instead, do all minibuffer input as part of
reading the arguments for a command, in the ‘interactive’ specification.
*Note Defining Commands::.

 -- Function: read-from-minibuffer prompt &optional initial keymap read
          history default inherit-input-method
     This function is the most general way to get input from the
     minibuffer.  By default, it accepts arbitrary text and returns it
     as a string; however, if READ is non-‘nil’, then it uses ‘read’ to
     convert the text into a Lisp object (*note Input Functions::).

     The first thing this function does is to activate a minibuffer and
     display it with PROMPT (which must be a string) as the prompt.
     Then the user can edit text in the minibuffer.

     When the user types a command to exit the minibuffer,
     ‘read-from-minibuffer’ constructs the return value from the text in
     the minibuffer.  Normally it returns a string containing that text.
     However, if READ is non-‘nil’, ‘read-from-minibuffer’ reads the
     text and returns the resulting Lisp object, unevaluated.  (*Note
     Input Functions::, for information about reading.)

     The argument DEFAULT specifies default values to make available
     through the history commands.  It should be a string, a list of
     strings, or ‘nil’.  The string or strings become the minibuffer’s
     “future history”, available to the user with ‘M-n’.

     If READ is non-‘nil’, then DEFAULT is also used as the input to
     ‘read’, if the user enters empty input.  If DEFAULT is a list of
     strings, the first string is used as the input.  If DEFAULT is
     ‘nil’, empty input results in an ‘end-of-file’ error.  However, in
     the usual case (where READ is ‘nil’), ‘read-from-minibuffer’
     ignores DEFAULT when the user enters empty input and returns an
     empty string, ‘""’.  In this respect, it differs from all the other
     minibuffer input functions in this chapter.

     If KEYMAP is non-‘nil’, that keymap is the local keymap to use in
     the minibuffer.  If KEYMAP is omitted or ‘nil’, the value of
     ‘minibuffer-local-map’ is used as the keymap.  Specifying a keymap
     is the most important way to customize the minibuffer for various
     applications such as completion.

     The argument HISTORY specifies a history list variable to use for
     saving the input and for history commands used in the minibuffer.
     It defaults to ‘minibuffer-history’.  You can optionally specify a
     starting position in the history list as well.  *Note Minibuffer
     History::.

     If the variable ‘minibuffer-allow-text-properties’ is non-‘nil’,
     then the string that is returned includes whatever text properties
     were present in the minibuffer.  Otherwise all the text properties
     are stripped when the value is returned.

     The text properties in ‘minibuffer-prompt-properties’ are applied
     to the prompt.  By default, this property list defines a face to
     use for the prompt.  This face, if present, is applied to the end
     of the face list and merged before display.

     If the user wants to completely control the look of the prompt, the
     most convenient way to do that is to specify the ‘default’ face at
     the end of all face lists.  For instance:

          (read-from-minibuffer
           (concat
            (propertize "Bold" 'face '(bold default))
            (propertize " and normal: " 'face '(default))))

     If the argument INHERIT-INPUT-METHOD is non-‘nil’, then the
     minibuffer inherits the current input method (*note Input
     Methods::) and the setting of ‘enable-multibyte-characters’ (*note
     Text Representations::) from whichever buffer was current before
     entering the minibuffer.

     Use of INITIAL is mostly deprecated; we recommend using a non-‘nil’
     value only in conjunction with specifying a cons cell for HISTORY.
     *Note Initial Input::.

 -- Function: read-string prompt &optional initial history default
          inherit-input-method
     This function reads a string from the minibuffer and returns it.
     The arguments PROMPT, INITIAL, HISTORY and INHERIT-INPUT-METHOD are
     used as in ‘read-from-minibuffer’.  The keymap used is
     ‘minibuffer-local-map’.

     The optional argument DEFAULT is used as in ‘read-from-minibuffer’,
     except that, if non-‘nil’, it also specifies a default value to
     return if the user enters null input.  As in ‘read-from-minibuffer’
     it should be a string, a list of strings, or ‘nil’, which is
     equivalent to an empty string.  When DEFAULT is a string, that
     string is the default value.  When it is a list of strings, the
     first string is the default value.  (All these strings are
     available to the user in the “future minibuffer history”.)

     This function works by calling the ‘read-from-minibuffer’ function:

          (read-string PROMPT INITIAL HISTORY DEFAULT INHERIT)
          ≡
          (let ((value
                 (read-from-minibuffer PROMPT INITIAL nil nil
                                       HISTORY DEFAULT INHERIT)))
            (if (and (equal value "") DEFAULT)
                (if (consp DEFAULT) (car DEFAULT) DEFAULT)
              value))

 -- Function: read-regexp prompt &optional defaults history
     This function reads a regular expression as a string from the
     minibuffer and returns it.  If the minibuffer prompt string PROMPT
     does not end in ‘:’ (followed by optional whitespace), the function
     adds ‘: ’ to the end, preceded by the default return value (see
     below), if that is non-empty.

     The optional argument DEFAULTS controls the default value to return
     if the user enters null input, and should be one of: a string;
     ‘nil’, which is equivalent to an empty string; a list of strings;
     or a symbol.

     If DEFAULTS is a symbol, ‘read-regexp’ consults the value of the
     variable ‘read-regexp-defaults-function’ (see below), and if that
     is non-‘nil’ uses it in preference to DEFAULTS.  The value in this
     case should be either:

        − ‘regexp-history-last’, which means to use the first element of
          the appropriate minibuffer history list (see below).

        − A function of no arguments, whose return value (which should
          be ‘nil’, a string, or a list of strings) becomes the value of
          DEFAULTS.

     ‘read-regexp’ now ensures that the result of processing DEFAULTS is
     a list (i.e., if the value is ‘nil’ or a string, it converts it to
     a list of one element).  To this list, ‘read-regexp’ then appends a
     few potentially useful candidates for input.  These are:

        − The word or symbol at point.
        − The last regexp used in an incremental search.
        − The last string used in an incremental search.
        − The last string or pattern used in query-replace commands.

     The function now has a list of regular expressions that it passes
     to ‘read-from-minibuffer’ to obtain the user’s input.  The first
     element of the list is the default result in case of empty input.
     All elements of the list are available to the user as the “future
     minibuffer history” list (*note future list: (emacs)Minibuffer
     History.).

     The optional argument HISTORY, if non-‘nil’, is a symbol specifying
     a minibuffer history list to use (*note Minibuffer History::).  If
     it is omitted or ‘nil’, the history list defaults to
     ‘regexp-history’.

 -- User Option: read-regexp-defaults-function
     The function ‘read-regexp’ may use the value of this variable to
     determine its list of default regular expressions.  If non-‘nil’,
     the value of this variable should be either:

        − The symbol ‘regexp-history-last’.

        − A function of no arguments that returns either ‘nil’, a
          string, or a list of strings.

     See ‘read-regexp’ above for details of how these values are used.

 -- Variable: minibuffer-allow-text-properties
     If this variable is ‘nil’, then ‘read-from-minibuffer’ and
     ‘read-string’ strip all text properties from the minibuffer input
     before returning it.  However, ‘read-no-blanks-input’ (see below),
     as well as ‘read-minibuffer’ and related functions (*note Reading
     Lisp Objects With the Minibuffer: Object from Minibuffer.), and all
     functions that do minibuffer input with completion, discard text
     properties unconditionally, regardless of the value of this
     variable.

 -- Variable: minibuffer-local-map
     This is the default local keymap for reading from the minibuffer.
     By default, it makes the following bindings:

     ‘C-j’
          ‘exit-minibuffer’

     <RET>
          ‘exit-minibuffer’

     ‘C-g’
          ‘abort-recursive-edit’

     ‘M-n’
     <DOWN>
          ‘next-history-element’

     ‘M-p’
     <UP>
          ‘previous-history-element’

     ‘M-s’
          ‘next-matching-history-element’

     ‘M-r’
          ‘previous-matching-history-element’

 -- Function: read-no-blanks-input prompt &optional initial
          inherit-input-method
     This function reads a string from the minibuffer, but does not
     allow whitespace characters as part of the input: instead, those
     characters terminate the input.  The arguments PROMPT, INITIAL, and
     INHERIT-INPUT-METHOD are used as in ‘read-from-minibuffer’.

     This is a simplified interface to the ‘read-from-minibuffer’
     function, and passes the value of the ‘minibuffer-local-ns-map’
     keymap as the KEYMAP argument for that function.  Since the keymap
     ‘minibuffer-local-ns-map’ does not rebind ‘C-q’, it _is_ possible
     to put a space into the string, by quoting it.

     This function discards text properties, regardless of the value of
     ‘minibuffer-allow-text-properties’.

          (read-no-blanks-input PROMPT INITIAL)
          ≡
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL minibuffer-local-ns-map))

 -- Variable: minibuffer-local-ns-map
     This built-in variable is the keymap used as the minibuffer local
     keymap in the function ‘read-no-blanks-input’.  By default, it
     makes the following bindings, in addition to those of
     ‘minibuffer-local-map’:

     <SPC>
          ‘exit-minibuffer’

     <TAB>
          ‘exit-minibuffer’

     ‘?’
          ‘self-insert-and-exit’


File: elisp.info,  Node: Object from Minibuffer,  Next: Minibuffer History,  Prev: Text from Minibuffer,  Up: Minibuffers

20.3 Reading Lisp Objects with the Minibuffer
=============================================

This section describes functions for reading Lisp objects with the
minibuffer.

 -- Function: read-minibuffer prompt &optional initial
     This function reads a Lisp object using the minibuffer, and returns
     it without evaluating it.  The arguments PROMPT and INITIAL are
     used as in ‘read-from-minibuffer’.

     This is a simplified interface to the ‘read-from-minibuffer’
     function:

          (read-minibuffer PROMPT INITIAL)
          ≡
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL nil t))

     Here is an example in which we supply the string ‘"(testing)"’ as
     initial input:

          (read-minibuffer
           "Enter an expression: " (format "%s" '(testing)))

          ;; Here is how the minibuffer is displayed:

          ---------- Buffer: Minibuffer ----------
          Enter an expression: (testing)★
          ---------- Buffer: Minibuffer ----------

     The user can type <RET> immediately to use the initial input as a
     default, or can edit the input.

 -- Function: eval-minibuffer prompt &optional initial
     This function reads a Lisp expression using the minibuffer,
     evaluates it, then returns the result.  The arguments PROMPT and
     INITIAL are used as in ‘read-from-minibuffer’.

     This function simply evaluates the result of a call to
     ‘read-minibuffer’:

          (eval-minibuffer PROMPT INITIAL)
          ≡
          (eval (read-minibuffer PROMPT INITIAL))

 -- Function: edit-and-eval-command prompt form
     This function reads a Lisp expression in the minibuffer, evaluates
     it, then returns the result.  The difference between this command
     and ‘eval-minibuffer’ is that here the initial FORM is not optional
     and it is treated as a Lisp object to be converted to printed
     representation rather than as a string of text.  It is printed with
     ‘prin1’, so if it is a string, double-quote characters (‘"’) appear
     in the initial text.  *Note Output Functions::.

     In the following example, we offer the user an expression with
     initial text that is already a valid form:

          (edit-and-eval-command "Please edit: " '(forward-word 1))

          ;; After evaluation of the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          Please edit: (forward-word 1)★
          ---------- Buffer: Minibuffer ----------

     Typing <RET> right away would exit the minibuffer and evaluate the
     expression, thus moving point forward one word.


File: elisp.info,  Node: Minibuffer History,  Next: Initial Input,  Prev: Object from Minibuffer,  Up: Minibuffers

20.4 Minibuffer History
=======================

A “minibuffer history list” records previous minibuffer inputs so the
user can reuse them conveniently.  It is a variable whose value is a
list of strings (previous inputs), most recent first.

   There are many separate minibuffer history lists, used for different
kinds of inputs.  It’s the Lisp programmer’s job to specify the right
history list for each use of the minibuffer.

   You specify a minibuffer history list with the optional HISTORY
argument to ‘read-from-minibuffer’ or ‘completing-read’.  Here are the
possible values for it:

VARIABLE
     Use VARIABLE (a symbol) as the history list.

(VARIABLE . STARTPOS)
     Use VARIABLE (a symbol) as the history list, and assume that the
     initial history position is STARTPOS (a nonnegative integer).

     Specifying 0 for STARTPOS is equivalent to just specifying the
     symbol VARIABLE.  ‘previous-history-element’ will display the most
     recent element of the history list in the minibuffer.  If you
     specify a positive STARTPOS, the minibuffer history functions
     behave as if ‘(elt VARIABLE (1- STARTPOS))’ were the history
     element currently shown in the minibuffer.

     For consistency, you should also specify that element of the
     history as the initial minibuffer contents, using the INITIAL
     argument to the minibuffer input function (*note Initial Input::).

   If you don’t specify HISTORY, then the default history list
‘minibuffer-history’ is used.  For other standard history lists, see
below.  You can also create your own history list variable; just
initialize it to ‘nil’ before the first use.

   Both ‘read-from-minibuffer’ and ‘completing-read’ add new elements to
the history list automatically, and provide commands to allow the user
to reuse items on the list.  The only thing your program needs to do to
use a history list is to initialize it and to pass its name to the input
functions when you wish.  But it is safe to modify the list by hand when
the minibuffer input functions are not using it.

   Emacs functions that add a new element to a history list can also
delete old elements if the list gets too long.  The variable
‘history-length’ specifies the maximum length for most history lists.
To specify a different maximum length for a particular history list, put
the length in the ‘history-length’ property of the history list symbol.
The variable ‘history-delete-duplicates’ specifies whether to delete
duplicates in history.

 -- Function: add-to-history history-var newelt &optional maxelt
          keep-all
     This function adds a new element NEWELT, if it isn’t the empty
     string, to the history list stored in the variable HISTORY-VAR, and
     returns the updated history list.  It limits the list length to the
     value of MAXELT (if non-‘nil’) or ‘history-length’ (described
     below).  The possible values of MAXELT have the same meaning as the
     values of ‘history-length’.

     Normally, ‘add-to-history’ removes duplicate members from the
     history list if ‘history-delete-duplicates’ is non-‘nil’.  However,
     if KEEP-ALL is non-‘nil’, that says not to remove duplicates, and
     to add NEWELT to the list even if it is empty.

 -- Variable: history-add-new-input
     If the value of this variable is ‘nil’, standard functions that
     read from the minibuffer don’t add new elements to the history
     list.  This lets Lisp programs explicitly manage input history by
     using ‘add-to-history’.  The default value is ‘t’.

 -- User Option: history-length
     The value of this variable specifies the maximum length for all
     history lists that don’t specify their own maximum lengths.  If the
     value is ‘t’, that means there is no maximum (don’t delete old
     elements).  If a history list variable’s symbol has a non-‘nil’
     ‘history-length’ property, it overrides this variable for that
     particular history list.

 -- User Option: history-delete-duplicates
     If the value of this variable is ‘t’, that means when adding a new
     history element, all previous identical elements are deleted.

   Here are some of the standard minibuffer history list variables:

 -- Variable: minibuffer-history
     The default history list for minibuffer history input.

 -- Variable: query-replace-history
     A history list for arguments to ‘query-replace’ (and similar
     arguments to other commands).

 -- Variable: file-name-history
     A history list for file-name arguments.

 -- Variable: buffer-name-history
     A history list for buffer-name arguments.

 -- Variable: regexp-history
     A history list for regular expression arguments.

 -- Variable: extended-command-history
     A history list for arguments that are names of extended commands.

 -- Variable: shell-command-history
     A history list for arguments that are shell commands.

 -- Variable: read-expression-history
     A history list for arguments that are Lisp expressions to evaluate.

 -- Variable: face-name-history
     A history list for arguments that are faces.


File: elisp.info,  Node: Initial Input,  Next: Completion,  Prev: Minibuffer History,  Up: Minibuffers

20.5 Initial Input
==================

Several of the functions for minibuffer input have an argument called
INITIAL.  This is a mostly-deprecated feature for specifying that the
minibuffer should start out with certain text, instead of empty as
usual.

   If INITIAL is a string, the minibuffer starts out containing the text
of the string, with point at the end, when the user starts to edit the
text.  If the user simply types <RET> to exit the minibuffer, it will
use the initial input string to determine the value to return.

   *We discourage use of a non-‘nil’ value for INITIAL*, because initial
input is an intrusive interface.  History lists and default values
provide a much more convenient method to offer useful default inputs to
the user.

   There is just one situation where you should specify a string for an
INITIAL argument.  This is when you specify a cons cell for the HISTORY
argument.  *Note Minibuffer History::.

   INITIAL can also be a cons cell of the form ‘(STRING . POSITION)’.
This means to insert STRING in the minibuffer but put point at POSITION
within the string’s text.

   As a historical accident, POSITION was implemented inconsistently in
different functions.  In ‘completing-read’, POSITION’s value is
interpreted as origin-zero; that is, a value of 0 means the beginning of
the string, 1 means after the first character, etc.  In
‘read-minibuffer’, and the other non-completion minibuffer input
functions that support this argument, 1 means the beginning of the
string, 2 means after the first character, etc.

   Use of a cons cell as the value for INITIAL arguments is deprecated.


File: elisp.info,  Node: Completion,  Next: Yes-or-No Queries,  Prev: Initial Input,  Up: Minibuffers

20.6 Completion
===============

“Completion” is a feature that fills in the rest of a name starting from
an abbreviation for it.  Completion works by comparing the user’s input
against a list of valid names and determining how much of the name is
determined uniquely by what the user has typed.  For example, when you
type ‘C-x b’ (‘switch-to-buffer’) and then type the first few letters of
the name of the buffer to which you wish to switch, and then type <TAB>
(‘minibuffer-complete’), Emacs extends the name as far as it can.

   Standard Emacs commands offer completion for names of symbols, files,
buffers, and processes; with the functions in this section, you can
implement completion for other kinds of names.

   The ‘try-completion’ function is the basic primitive for completion:
it returns the longest determined completion of a given initial string,
with a given set of strings to match against.

   The function ‘completing-read’ provides a higher-level interface for
completion.  A call to ‘completing-read’ specifies how to determine the
list of valid names.  The function then activates the minibuffer with a
local keymap that binds a few keys to commands useful for completion.
Other functions provide convenient simple interfaces for reading certain
kinds of names with completion.

* Menu:

* Basic Completion::       Low-level functions for completing strings.
* Minibuffer Completion::  Invoking the minibuffer with completion.
* Completion Commands::    Minibuffer commands that do completion.
* High-Level Completion::  Convenient special cases of completion
                             (reading buffer names, variable names, etc.).
* Reading File Names::     Using completion to read file names and
                             shell commands.
* Completion Variables::   Variables controlling completion behavior.
* Programmed Completion::  Writing your own completion function.
* Completion in Buffers::  Completing text in ordinary buffers.


File: elisp.info,  Node: Basic Completion,  Next: Minibuffer Completion,  Up: Completion

20.6.1 Basic Completion Functions
---------------------------------

The following completion functions have nothing in themselves to do with
minibuffers.  We describe them here to keep them near the higher-level
completion features that do use the minibuffer.

 -- Function: try-completion string collection &optional predicate
     This function returns the longest common substring of all possible
     completions of STRING in COLLECTION.

     COLLECTION is called the “completion table”.  Its value must be a
     list of strings or cons cells, an obarray, a hash table, or a
     completion function.

     ‘try-completion’ compares STRING against each of the permissible
     completions specified by the completion table.  If no permissible
     completions match, it returns ‘nil’.  If there is just one matching
     completion, and the match is exact, it returns ‘t’.  Otherwise, it
     returns the longest initial sequence common to all possible
     matching completions.

     If COLLECTION is a list, the permissible completions are specified
     by the elements of the list, each of which should be either a
     string, or a cons cell whose CAR is either a string or a symbol (a
     symbol is converted to a string using ‘symbol-name’).  If the list
     contains elements of any other type, those are ignored.

     If COLLECTION is an obarray (*note Creating Symbols::), the names
     of all symbols in the obarray form the set of permissible
     completions.

     If COLLECTION is a hash table, then the keys that are strings or
     symbols are the possible completions.  Other keys are ignored.

     You can also use a function as COLLECTION.  Then the function is
     solely responsible for performing completion; ‘try-completion’
     returns whatever this function returns.  The function is called
     with three arguments: STRING, PREDICATE and ‘nil’ (the third
     argument is so that the same function can be used in
     ‘all-completions’ and do the appropriate thing in either case).
     *Note Programmed Completion::.

     If the argument PREDICATE is non-‘nil’, then it must be a function
     of one argument, unless COLLECTION is a hash table, in which case
     it should be a function of two arguments.  It is used to test each
     possible match, and the match is accepted only if PREDICATE returns
     non-‘nil’.  The argument given to PREDICATE is either a string or a
     cons cell (the CAR of which is a string) from the alist, or a
     symbol (_not_ a symbol name) from the obarray.  If COLLECTION is a
     hash table, PREDICATE is called with two arguments, the string key
     and the associated value.

     In addition, to be acceptable, a completion must also match all the
     regular expressions in ‘completion-regexp-list’.  (Unless
     COLLECTION is a function, in which case that function has to handle
     ‘completion-regexp-list’ itself.)

     In the first of the following examples, the string ‘foo’ is matched
     by three of the alist CARs.  All of the matches begin with the
     characters ‘fooba’, so that is the result.  In the second example,
     there is only one possible match, and it is exact, so the return
     value is ‘t’.

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               ⇒ "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               ⇒ t

     In the following example, numerous symbols begin with the
     characters ‘forw’, and all of them begin with the word ‘forward’.
     In most of the symbols, this is followed with a ‘-’, but not in
     all, so no more than ‘forward’ can be completed.

          (try-completion "forw" obarray)
               ⇒ "forward"

     Finally, in the following example, only two of the three possible
     matches pass the predicate ‘test’ (the string ‘foobaz’ is too
     short).  Both of those begin with the string ‘foobar’.

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test
          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ "foobar"

 -- Function: all-completions string collection &optional predicate
     This function returns a list of all possible completions of STRING.
     The arguments to this function are the same as those of
     ‘try-completion’, and it uses ‘completion-regexp-list’ in the same
     way that ‘try-completion’ does.

     If COLLECTION is a function, it is called with three arguments:
     STRING, PREDICATE and ‘t’; then ‘all-completions’ returns whatever
     the function returns.  *Note Programmed Completion::.

     Here is an example, using the function ‘test’ shown in the example
     for ‘try-completion’:

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test

          (all-completions
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ ("foobar1" "foobar2")

 -- Function: test-completion string collection &optional predicate
     This function returns non-‘nil’ if STRING is a valid completion
     alternative specified by COLLECTION and PREDICATE.  The arguments
     are the same as in ‘try-completion’.  For instance, if COLLECTION
     is a list of strings, this is true if STRING appears in the list
     and PREDICATE is satisfied.

     This function uses ‘completion-regexp-list’ in the same way that
     ‘try-completion’ does.

     If PREDICATE is non-‘nil’ and if COLLECTION contains several
     strings that are equal to each other, as determined by
     ‘compare-strings’ according to ‘completion-ignore-case’, then
     PREDICATE should accept either all or none of them.  Otherwise, the
     return value of ‘test-completion’ is essentially unpredictable.

     If COLLECTION is a function, it is called with three arguments, the
     values STRING, PREDICATE and ‘lambda’; whatever it returns,
     ‘test-completion’ returns in turn.

 -- Function: completion-boundaries string collection predicate suffix
     This function returns the boundaries of the field on which
     COLLECTION will operate, assuming that STRING holds the text before
     point and SUFFIX holds the text after point.

     Normally completion operates on the whole string, so for all normal
     collections, this will always return ‘(0 . (length SUFFIX))’.  But
     more complex completion such as completion on files is done one
     field at a time.  For example, completion of ‘"/usr/sh"’ will
     include ‘"/usr/share/"’ but not ‘"/usr/share/doc"’ even if
     ‘"/usr/share/doc"’ exists.  Also ‘all-completions’ on ‘"/usr/sh"’
     will not include ‘"/usr/share/"’ but only ‘"share/"’.  So if STRING
     is ‘"/usr/sh"’ and SUFFIX is ‘"e/doc"’, ‘completion-boundaries’
     will return ‘(5 . 1)’ which tells us that the COLLECTION will only
     return completion information that pertains to the area after
     ‘"/usr/"’ and before ‘"/doc"’.

   If you store a completion alist in a variable, you should mark the
variable as risky by giving it a non-‘nil’ ‘risky-local-variable’
property.  *Note File Local Variables::.

 -- Variable: completion-ignore-case
     If the value of this variable is non-‘nil’, case is not considered
     significant in completion.  Within ‘read-file-name’, this variable
     is overridden by ‘read-file-name-completion-ignore-case’ (*note
     Reading File Names::); within ‘read-buffer’, it is overridden by
     ‘read-buffer-completion-ignore-case’ (*note High-Level
     Completion::).

 -- Variable: completion-regexp-list
     This is a list of regular expressions.  The completion functions
     only consider a completion acceptable if it matches all regular
     expressions in this list, with ‘case-fold-search’ (*note Searching
     and Case::) bound to the value of ‘completion-ignore-case’.

 -- Macro: lazy-completion-table var fun
     This macro provides a way to initialize the variable VAR as a
     collection for completion in a lazy way, not computing its actual
     contents until they are first needed.  You use this macro to
     produce a value that you store in VAR.  The actual computation of
     the proper value is done the first time you do completion using
     VAR.  It is done by calling FUN with no arguments.  The value FUN
     returns becomes the permanent value of VAR.

     Here is an example:

          (defvar foo (lazy-completion-table foo make-my-alist))

   There are several functions that take an existing completion table
and return a modified version.  ‘completion-table-case-fold’ returns a
case-insensitive table.  ‘completion-table-in-turn’ and
‘completion-table-merge’ combine multiple input tables in different
ways.  ‘completion-table-subvert’ alters a table to use a different
initial prefix.  ‘completion-table-with-quoting’ returns a table
suitable for operating on quoted text.
‘completion-table-with-predicate’ filters a table with a predicate
function.  ‘completion-table-with-terminator’ adds a terminating string.


File: elisp.info,  Node: Minibuffer Completion,  Next: Completion Commands,  Prev: Basic Completion,  Up: Completion

20.6.2 Completion and the Minibuffer
------------------------------------

This section describes the basic interface for reading from the
minibuffer with completion.

 -- Function: completing-read prompt collection &optional predicate
          require-match initial history default inherit-input-method
     This function reads a string in the minibuffer, assisting the user
     by providing completion.  It activates the minibuffer with prompt
     PROMPT, which must be a string.

     The actual completion is done by passing the completion table
     COLLECTION and the completion predicate PREDICATE to the function
     ‘try-completion’ (*note Basic Completion::).  This happens in
     certain commands bound in the local keymaps used for completion.
     Some of these commands also call ‘test-completion’.  Thus, if
     PREDICATE is non-‘nil’, it should be compatible with COLLECTION and
     ‘completion-ignore-case’.  *Note Definition of test-completion::.

     *Note Programmed Completion::, for detailed requirements when
     COLLECTION is a function.

     The value of the optional argument REQUIRE-MATCH determines how the
     user may exit the minibuffer:

        • If ‘nil’, the usual minibuffer exit commands work regardless
          of the input in the minibuffer.

        • If ‘t’, the usual minibuffer exit commands won’t exit unless
          the input completes to an element of COLLECTION.

        • If ‘confirm’, the user can exit with any input, but is asked
          for confirmation if the input is not an element of COLLECTION.

        • If ‘confirm-after-completion’, the user can exit with any
          input, but is asked for confirmation if the preceding command
          was a completion command (i.e., one of the commands in
          ‘minibuffer-confirm-exit-commands’) and the resulting input is
          not an element of COLLECTION.  *Note Completion Commands::.

        • Any other value of REQUIRE-MATCH behaves like ‘t’, except that
          the exit commands won’t exit if it performs completion.

     However, empty input is always permitted, regardless of the value
     of REQUIRE-MATCH; in that case, ‘completing-read’ returns the first
     element of DEFAULT, if it is a list; ‘""’, if DEFAULT is ‘nil’; or
     DEFAULT.  The string or strings in DEFAULT are also available to
     the user through the history commands.

     The function ‘completing-read’ uses
     ‘minibuffer-local-completion-map’ as the keymap if REQUIRE-MATCH is
     ‘nil’, and uses ‘minibuffer-local-must-match-map’ if REQUIRE-MATCH
     is non-‘nil’.  *Note Completion Commands::.

     The argument HISTORY specifies which history list variable to use
     for saving the input and for minibuffer history commands.  It
     defaults to ‘minibuffer-history’.  *Note Minibuffer History::.

     The argument INITIAL is mostly deprecated; we recommend using a
     non-‘nil’ value only in conjunction with specifying a cons cell for
     HISTORY.  *Note Initial Input::.  For default input, use DEFAULT
     instead.

     If the argument INHERIT-INPUT-METHOD is non-‘nil’, then the
     minibuffer inherits the current input method (*note Input
     Methods::) and the setting of ‘enable-multibyte-characters’ (*note
     Text Representations::) from whichever buffer was current before
     entering the minibuffer.

     If the variable ‘completion-ignore-case’ is non-‘nil’, completion
     ignores case when comparing the input against the possible matches.
     *Note Basic Completion::.  In this mode of operation, PREDICATE
     must also ignore case, or you will get surprising results.

     Here’s an example of using ‘completing-read’:

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; After evaluation of the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo★
          ---------- Buffer: Minibuffer ----------

     If the user then types ‘<DEL> <DEL> b <RET>’, ‘completing-read’
     returns ‘barfoo’.

     The ‘completing-read’ function binds variables to pass information
     to the commands that actually do completion.  They are described in
     the following section.

 -- Variable: completing-read-function
     The value of this variable must be a function, which is called by
     ‘completing-read’ to actually do its work.  It should accept the
     same arguments as ‘completing-read’.  This can be bound to a
     different function to completely override the normal behavior of
     ‘completing-read’.


File: elisp.info,  Node: Completion Commands,  Next: High-Level Completion,  Prev: Minibuffer Completion,  Up: Completion

20.6.3 Minibuffer Commands that Do Completion
---------------------------------------------

This section describes the keymaps, commands and user options used in
the minibuffer to do completion.

 -- Variable: minibuffer-completion-table
     The value of this variable is the completion table used for
     completion in the minibuffer.  This is the global variable that
     contains what ‘completing-read’ passes to ‘try-completion’.  It is
     used by minibuffer completion commands such as
     ‘minibuffer-complete-word’.

 -- Variable: minibuffer-completion-predicate
     This variable’s value is the predicate that ‘completing-read’
     passes to ‘try-completion’.  The variable is also used by the other
     minibuffer completion functions.

 -- Variable: minibuffer-completion-confirm
     This variable determines whether Emacs asks for confirmation before
     exiting the minibuffer; ‘completing-read’ binds this variable, and
     the function ‘minibuffer-complete-and-exit’ checks the value before
     exiting.  If the value is ‘nil’, confirmation is not required.  If
     the value is ‘confirm’, the user may exit with an input that is not
     a valid completion alternative, but Emacs asks for confirmation.
     If the value is ‘confirm-after-completion’, the user may exit with
     an input that is not a valid completion alternative, but Emacs asks
     for confirmation if the user submitted the input right after any of
     the completion commands in ‘minibuffer-confirm-exit-commands’.

 -- Variable: minibuffer-confirm-exit-commands
     This variable holds a list of commands that cause Emacs to ask for
     confirmation before exiting the minibuffer, if the REQUIRE-MATCH
     argument to ‘completing-read’ is ‘confirm-after-completion’.  The
     confirmation is requested if the user attempts to exit the
     minibuffer immediately after calling any command in this list.

 -- Command: minibuffer-complete-word
     This function completes the minibuffer contents by at most a single
     word.  Even if the minibuffer contents have only one completion,
     ‘minibuffer-complete-word’ does not add any characters beyond the
     first character that is not a word constituent.  *Note Syntax
     Tables::.

 -- Command: minibuffer-complete
     This function completes the minibuffer contents as far as possible.

 -- Command: minibuffer-complete-and-exit
     This function completes the minibuffer contents, and exits if
     confirmation is not required, i.e., if
     ‘minibuffer-completion-confirm’ is ‘nil’.  If confirmation _is_
     required, it is given by repeating this command immediately—the
     command is programmed to work without confirmation when run twice
     in succession.

 -- Command: minibuffer-completion-help
     This function creates a list of the possible completions of the
     current minibuffer contents.  It works by calling ‘all-completions’
     using the value of the variable ‘minibuffer-completion-table’ as
     the COLLECTION argument, and the value of
     ‘minibuffer-completion-predicate’ as the PREDICATE argument.  The
     list of completions is displayed as text in a buffer named
     ‘*Completions*’.

 -- Function: display-completion-list completions
     This function displays COMPLETIONS to the stream in
     ‘standard-output’, usually a buffer.  (*Note Read and Print::, for
     more information about streams.)  The argument COMPLETIONS is
     normally a list of completions just returned by ‘all-completions’,
     but it does not have to be.  Each element may be a symbol or a
     string, either of which is simply printed.  It can also be a list
     of two strings, which is printed as if the strings were
     concatenated.  The first of the two strings is the actual
     completion, the second string serves as annotation.

     This function is called by ‘minibuffer-completion-help’.  A common
     way to use it is together with ‘with-output-to-temp-buffer’, like
     this:

          (with-output-to-temp-buffer "*Completions*"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))

 -- User Option: completion-auto-help
     If this variable is non-‘nil’, the completion commands
     automatically display a list of possible completions whenever
     nothing can be completed because the next character is not uniquely
     determined.

 -- Variable: minibuffer-local-completion-map
     ‘completing-read’ uses this value as the local keymap when an exact
     match of one of the completions is not required.  By default, this
     keymap makes the following bindings:

     ‘?’
          ‘minibuffer-completion-help’

     <SPC>
          ‘minibuffer-complete-word’

     <TAB>
          ‘minibuffer-complete’

     and uses ‘minibuffer-local-map’ as its parent keymap (*note
     Definition of minibuffer-local-map::).

 -- Variable: minibuffer-local-must-match-map
     ‘completing-read’ uses this value as the local keymap when an exact
     match of one of the completions is required.  Therefore, no keys
     are bound to ‘exit-minibuffer’, the command that exits the
     minibuffer unconditionally.  By default, this keymap makes the
     following bindings:

     ‘C-j’
          ‘minibuffer-complete-and-exit’

     <RET>
          ‘minibuffer-complete-and-exit’

     and uses ‘minibuffer-local-completion-map’ as its parent keymap.

 -- Variable: minibuffer-local-filename-completion-map
     This is a sparse keymap that simply unbinds <SPC>; because
     filenames can contain spaces.  The function ‘read-file-name’
     combines this keymap with either ‘minibuffer-local-completion-map’
     or ‘minibuffer-local-must-match-map’.


File: elisp.info,  Node: High-Level Completion,  Next: Reading File Names,  Prev: Completion Commands,  Up: Completion

20.6.4 High-Level Completion Functions
--------------------------------------

This section describes the higher-level convenience functions for
reading certain sorts of names with completion.

   In most cases, you should not call these functions in the middle of a
Lisp function.  When possible, do all minibuffer input as part of
reading the arguments for a command, in the ‘interactive’ specification.
*Note Defining Commands::.

 -- Function: read-buffer prompt &optional default require-match
          predicate
     This function reads the name of a buffer and returns it as a
     string.  It prompts with PROMPT.  The argument DEFAULT is the
     default name to use, the value to return if the user exits with an
     empty minibuffer.  If non-‘nil’, it should be a string, a list of
     strings, or a buffer.  If it is a list, the default value is the
     first element of this list.  It is mentioned in the prompt, but is
     not inserted in the minibuffer as initial input.

     The argument PROMPT should be a string ending with a colon and a
     space.  If DEFAULT is non-‘nil’, the function inserts it in PROMPT
     before the colon to follow the convention for reading from the
     minibuffer with a default value (*note Programming Tips::).

     The optional argument REQUIRE-MATCH has the same meaning as in
     ‘completing-read’.  *Note Minibuffer Completion::.

     The optional argument PREDICATE, if non-‘nil’, specifies a function
     to filter the buffers that should be considered: the function will
     be called with every potential candidate as its argument, and
     should return ‘nil’ to reject the candidate, non-‘nil’ to accept
     it.

     In the following example, the user enters ‘minibuffer.t’, and then
     types <RET>.  The argument REQUIRE-MATCH is ‘t’, and the only
     buffer name starting with the given input is ‘minibuffer.texi’, so
     that name is the value.

          (read-buffer "Buffer name: " "foo" t)
          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Buffer name (default foo): ★
          ---------- Buffer: Minibuffer ----------

          ;; The user types ‘minibuffer.t <RET>’.
               ⇒ "minibuffer.texi"

 -- User Option: read-buffer-function
     This variable, if non-‘nil’, specifies a function for reading
     buffer names.  ‘read-buffer’ calls this function instead of doing
     its usual work, with the same arguments passed to ‘read-buffer’.

 -- User Option: read-buffer-completion-ignore-case
     If this variable is non-‘nil’, ‘read-buffer’ ignores case when
     performing completion while reading the buffer name.

 -- Function: read-command prompt &optional default
     This function reads the name of a command and returns it as a Lisp
     symbol.  The argument PROMPT is used as in ‘read-from-minibuffer’.
     Recall that a command is anything for which ‘commandp’ returns ‘t’,
     and a command name is a symbol for which ‘commandp’ returns ‘t’.
     *Note Interactive Call::.

     The argument DEFAULT specifies what to return if the user enters
     null input.  It can be a symbol, a string or a list of strings.  If
     it is a string, ‘read-command’ interns it before returning it.  If
     it is a list, ‘read-command’ interns the first element of this
     list.  If DEFAULT is ‘nil’, that means no default has been
     specified; then if the user enters null input, the return value is
     ‘(intern "")’, that is, a symbol whose name is an empty string.

          (read-command "Command name? ")

          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Command name?
          ---------- Buffer: Minibuffer ----------

     If the user types ‘forward-c <RET>’, then this function returns
     ‘forward-char’.

     The ‘read-command’ function is a simplified interface to
     ‘completing-read’.  It uses the variable ‘obarray’ so as to
     complete in the set of extant Lisp symbols, and it uses the
     ‘commandp’ predicate so as to accept only command names:

          (read-command PROMPT)
          ≡
          (intern (completing-read PROMPT obarray
                                   'commandp t nil))

 -- Function: read-variable prompt &optional default
     This function reads the name of a customizable variable and returns
     it as a symbol.  Its arguments have the same form as those of
     ‘read-command’.  It behaves just like ‘read-command’, except that
     it uses the predicate ‘custom-variable-p’ instead of ‘commandp’.

 -- Command: read-color &optional prompt convert allow-empty display
     This function reads a string that is a color specification, either
     the color’s name or an RGB hex value such as ‘#RRRGGGBBB’.  It
     prompts with PROMPT (default: ‘"Color (name or #RGB triplet):"’)
     and provides completion for color names, but not for hex RGB
     values.  In addition to names of standard colors, completion
     candidates include the foreground and background colors at point.

     Valid RGB values are described in *note Color Names::.

     The function’s return value is the string typed by the user in the
     minibuffer.  However, when called interactively or if the optional
     argument CONVERT is non-‘nil’, it converts any input color name
     into the corresponding RGB value string and instead returns that.
     This function requires a valid color specification to be input.
     Empty color names are allowed when ALLOW-EMPTY is non-‘nil’ and the
     user enters null input.

     Interactively, or when DISPLAY is non-‘nil’, the return value is
     also displayed in the echo area.

   See also the functions ‘read-coding-system’ and
‘read-non-nil-coding-system’, in *note User-Chosen Coding Systems::, and
‘read-input-method-name’, in *note Input Methods::.


File: elisp.info,  Node: Reading File Names,  Next: Completion Variables,  Prev: High-Level Completion,  Up: Completion

20.6.5 Reading File Names
-------------------------

The high-level completion functions ‘read-file-name’,
‘read-directory-name’, and ‘read-shell-command’ are designed to read
file names, directory names, and shell commands, respectively.  They
provide special features, including automatic insertion of the default
directory.

 -- Function: read-file-name prompt &optional directory default
          require-match initial predicate
     This function reads a file name, prompting with PROMPT and
     providing completion.

     As an exception, this function reads a file name using a graphical
     file dialog instead of the minibuffer, if all of the following are
     true:

       1. It is invoked via a mouse command.

       2. The selected frame is on a graphical display supporting such
          dialogs.

       3. The variable ‘use-dialog-box’ is non-‘nil’.  *Note Dialog
          Boxes: (emacs)Dialog Boxes.

       4. The DIRECTORY argument, described below, does not specify a
          remote file.  *Note Remote Files: (emacs)Remote Files.

     The exact behavior when using a graphical file dialog is
     platform-dependent.  Here, we simply document the behavior when
     using the minibuffer.

     ‘read-file-name’ does not automatically expand the returned file
     name.  You can call ‘expand-file-name’ yourself if an absolute file
     name is required.

     The optional argument REQUIRE-MATCH has the same meaning as in
     ‘completing-read’.  *Note Minibuffer Completion::.

     The argument DIRECTORY specifies the directory to use for
     completing relative file names.  It should be an absolute directory
     name.  If the variable ‘insert-default-directory’ is non-‘nil’,
     DIRECTORY is also inserted in the minibuffer as initial input.  It
     defaults to the current buffer’s value of ‘default-directory’.

     If you specify INITIAL, that is an initial file name to insert in
     the buffer (after DIRECTORY, if that is inserted).  In this case,
     point goes at the beginning of INITIAL.  The default for INITIAL is
     ‘nil’—don’t insert any file name.  To see what INITIAL does, try
     the command ‘C-x C-v’ in a buffer visiting a file.  *Please note:*
     we recommend using DEFAULT rather than INITIAL in most cases.

     If DEFAULT is non-‘nil’, then the function returns DEFAULT if the
     user exits the minibuffer with the same non-empty contents that
     ‘read-file-name’ inserted initially.  The initial minibuffer
     contents are always non-empty if ‘insert-default-directory’ is
     non-‘nil’, as it is by default.  DEFAULT is not checked for
     validity, regardless of the value of REQUIRE-MATCH.  However, if
     REQUIRE-MATCH is non-‘nil’, the initial minibuffer contents should
     be a valid file (or directory) name.  Otherwise ‘read-file-name’
     attempts completion if the user exits without any editing, and does
     not return DEFAULT.  DEFAULT is also available through the history
     commands.

     If DEFAULT is ‘nil’, ‘read-file-name’ tries to find a substitute
     default to use in its place, which it treats in exactly the same
     way as if it had been specified explicitly.  If DEFAULT is ‘nil’,
     but INITIAL is non-‘nil’, then the default is the absolute file
     name obtained from DIRECTORY and INITIAL.  If both DEFAULT and
     INITIAL are ‘nil’ and the buffer is visiting a file,
     ‘read-file-name’ uses the absolute file name of that file as
     default.  If the buffer is not visiting a file, then there is no
     default.  In that case, if the user types <RET> without any
     editing, ‘read-file-name’ simply returns the pre-inserted contents
     of the minibuffer.

     If the user types <RET> in an empty minibuffer, this function
     returns an empty string, regardless of the value of REQUIRE-MATCH.
     This is, for instance, how the user can make the current buffer
     visit no file using ‘M-x set-visited-file-name’.

     If PREDICATE is non-‘nil’, it specifies a function of one argument
     that decides which file names are acceptable completion
     alternatives.  A file name is an acceptable value if PREDICATE
     returns non-‘nil’ for it.

     Here is an example of using ‘read-file-name’:

          (read-file-name "The file is ")

          ;; After evaluation of the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/★
          ---------- Buffer: Minibuffer ----------

     Typing ‘manual <TAB>’ results in the following:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/manual.texi★
          ---------- Buffer: Minibuffer ----------

     If the user types <RET>, ‘read-file-name’ returns the file name as
     the string ‘"/gp/gnu/elisp/manual.texi"’.

 -- Variable: read-file-name-function
     If non-‘nil’, this should be a function that accepts the same
     arguments as ‘read-file-name’.  When ‘read-file-name’ is called, it
     calls this function with the supplied arguments instead of doing
     its usual work.

 -- User Option: read-file-name-completion-ignore-case
     If this variable is non-‘nil’, ‘read-file-name’ ignores case when
     performing completion.

 -- Function: read-directory-name prompt &optional directory default
          require-match initial
     This function is like ‘read-file-name’ but allows only directory
     names as completion alternatives.

     If DEFAULT is ‘nil’ and INITIAL is non-‘nil’, ‘read-directory-name’
     constructs a substitute default by combining DIRECTORY (or the
     current buffer’s default directory if DIRECTORY is ‘nil’) and
     INITIAL.  If both DEFAULT and INITIAL are ‘nil’, this function uses
     DIRECTORY as substitute default, or the current buffer’s default
     directory if DIRECTORY is ‘nil’.

 -- User Option: insert-default-directory
     This variable is used by ‘read-file-name’, and thus, indirectly, by
     most commands reading file names.  (This includes all commands that
     use the code letters ‘f’ or ‘F’ in their interactive form.  *Note
     Code Characters for interactive: Interactive Codes.)  Its value
     controls whether ‘read-file-name’ starts by placing the name of the
     default directory in the minibuffer, plus the initial file name, if
     any.  If the value of this variable is ‘nil’, then ‘read-file-name’
     does not place any initial input in the minibuffer (unless you
     specify initial input with the INITIAL argument).  In that case,
     the default directory is still used for completion of relative file
     names, but is not displayed.

     If this variable is ‘nil’ and the initial minibuffer contents are
     empty, the user may have to explicitly fetch the next history
     element to access a default value.  If the variable is non-‘nil’,
     the initial minibuffer contents are always non-empty and the user
     can always request a default value by immediately typing <RET> in
     an unedited minibuffer.  (See above.)

     For example:

          ;; Here the minibuffer starts out with the default directory.
          (let ((insert-default-directory t))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ~lewis/manual/★
          ---------- Buffer: Minibuffer ----------

          ;; Here the minibuffer is empty and only the prompt
          ;;   appears on its line.
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ★
          ---------- Buffer: Minibuffer ----------

 -- Function: read-shell-command prompt &optional initial history &rest
          args
     This function reads a shell command from the minibuffer, prompting
     with PROMPT and providing intelligent completion.  It completes the
     first word of the command using candidates that are appropriate for
     command names, and the rest of the command words as file names.

     This function uses ‘minibuffer-local-shell-command-map’ as the
     keymap for minibuffer input.  The HISTORY argument specifies the
     history list to use; if is omitted or ‘nil’, it defaults to
     ‘shell-command-history’ (*note shell-command-history: Minibuffer
     History.).  The optional argument INITIAL specifies the initial
     content of the minibuffer (*note Initial Input::).  The rest of
     ARGS, if present, are used as the DEFAULT and INHERIT-INPUT-METHOD
     arguments in ‘read-from-minibuffer’ (*note Text from Minibuffer::).

 -- Variable: minibuffer-local-shell-command-map
     This keymap is used by ‘read-shell-command’ for completing command
     and file names that are part of a shell command.  It uses
     ‘minibuffer-local-map’ as its parent keymap, and binds <TAB> to
     ‘completion-at-point’.


File: elisp.info,  Node: Completion Variables,  Next: Programmed Completion,  Prev: Reading File Names,  Up: Completion

20.6.6 Completion Variables
---------------------------

Here are some variables that can be used to alter the default completion
behavior.

 -- User Option: completion-styles
     The value of this variable is a list of completion style (symbols)
     to use for performing completion.  A “completion style” is a set of
     rules for generating completions.  Each symbol occurring this list
     must have a corresponding entry in ‘completion-styles-alist’.

 -- Variable: completion-styles-alist
     This variable stores a list of available completion styles.  Each
     element in the list has the form

          (STYLE TRY-COMPLETION ALL-COMPLETIONS DOC)

     Here, STYLE is the name of the completion style (a symbol), which
     may be used in the ‘completion-styles’ variable to refer to this
     style; TRY-COMPLETION is the function that does the completion;
     ALL-COMPLETIONS is the function that lists the completions; and DOC
     is a string describing the completion style.

     The TRY-COMPLETION and ALL-COMPLETIONS functions should each accept
     four arguments: STRING, COLLECTION, PREDICATE, and POINT.  The
     STRING, COLLECTION, and PREDICATE arguments have the same meanings
     as in ‘try-completion’ (*note Basic Completion::), and the POINT
     argument is the position of point within STRING.  Each function
     should return a non-‘nil’ value if it performed its job, and ‘nil’
     if it did not (e.g., if there is no way to complete STRING
     according to the completion style).

     When the user calls a completion command like ‘minibuffer-complete’
     (*note Completion Commands::), Emacs looks for the first style
     listed in ‘completion-styles’ and calls its TRY-COMPLETION
     function.  If this function returns ‘nil’, Emacs moves to the next
     listed completion style and calls its TRY-COMPLETION function, and
     so on until one of the TRY-COMPLETION functions successfully
     performs completion and returns a non-‘nil’ value.  A similar
     procedure is used for listing completions, via the ALL-COMPLETIONS
     functions.

     *Note (emacs)Completion Styles::, for a description of the
     available completion styles.

 -- User Option: completion-category-overrides
     This variable specifies special completion styles and other
     completion behaviors to use when completing certain types of text.
     Its value should be an alist with elements of the form ‘(CATEGORY .
     ALIST)’.  CATEGORY is a symbol describing what is being completed;
     currently, the ‘buffer’, ‘file’, and ‘unicode-name’ categories are
     defined, but others can be defined via specialized completion
     functions (*note Programmed Completion::).  ALIST is an association
     list describing how completion should behave for the corresponding
     category.  The following alist keys are supported:

     ‘styles’
          The value should be a list of completion styles (symbols).

     ‘cycle’
          The value should be a value for ‘completion-cycle-threshold’
          (*note (emacs)Completion Options::) for this category.

     Additional alist entries may be defined in the future.

 -- Variable: completion-extra-properties
     This variable is used to specify extra properties of the current
     completion command.  It is intended to be let-bound by specialized
     completion commands.  Its value should be a list of property and
     value pairs.  The following properties are supported:

     ‘:annotation-function’
          The value should be a function to add annotations in the
          completions buffer.  This function must accept one argument, a
          completion, and should either return ‘nil’ or a string to be
          displayed next to the completion.

     ‘:exit-function’
          The value should be a function to run after performing
          completion.  The function should accept two arguments, STRING
          and STATUS, where STRING is the text to which the field was
          completed, and STATUS indicates what kind of operation
          happened: ‘finished’ if text is now complete, ‘sole’ if the
          text cannot be further completed but completion is not
          finished, or ‘exact’ if the text is a valid completion but may
          be further completed.


File: elisp.info,  Node: Programmed Completion,  Next: Completion in Buffers,  Prev: Completion Variables,  Up: Completion

20.6.7 Programmed Completion
----------------------------

Sometimes it is not possible or convenient to create an alist or an
obarray containing all the intended possible completions ahead of time.
In such a case, you can supply your own function to compute the
completion of a given string.  This is called “programmed completion”.
Emacs uses programmed completion when completing file names (*note File
Name Completion::), among many other cases.

   To use this feature, pass a function as the COLLECTION argument to
‘completing-read’.  The function ‘completing-read’ arranges to pass your
completion function along to ‘try-completion’, ‘all-completions’, and
other basic completion functions, which will then let your function do
all the work.

   The completion function should accept three arguments:

   • The string to be completed.

   • A predicate function with which to filter possible matches, or
     ‘nil’ if none.  The function should call the predicate for each
     possible match, and ignore the match if the predicate returns
     ‘nil’.

   • A flag specifying the type of completion operation to perform.
     This flag may be one of the following values.

     ‘nil’
          This specifies a ‘try-completion’ operation.  The function
          should return ‘t’ if the specified string is a unique and
          exact match; if there is more than one match, it should return
          the common substring of all matches (if the string is an exact
          match for one completion alternative but also matches other
          longer alternatives, the return value is the string); if there
          are no matches, it should return ‘nil’.

     ‘t’
          This specifies an ‘all-completions’ operation.  The function
          should return a list of all possible completions of the
          specified string.

     ‘lambda’
          This specifies a ‘test-completion’ operation.  The function
          should return ‘t’ if the specified string is an exact match
          for some completion alternative; ‘nil’ otherwise.

     ‘(boundaries . SUFFIX)’
          This specifies a ‘completion-boundaries’ operation.  The
          function should return ‘(boundaries START . END)’, where START
          is the position of the beginning boundary in the specified
          string, and END is the position of the end boundary in SUFFIX.

     ‘metadata’
          This specifies a request for information about the state of
          the current completion.  The return value should have the form
          ‘(metadata . ALIST)’, where ALIST is an alist whose elements
          are described below.

     If the flag has any other value, the completion function should
     return ‘nil’.

   The following is a list of metadata entries that a completion
function may return in response to a ‘metadata’ flag argument:

‘category’
     The value should be a symbol describing what kind of text the
     completion function is trying to complete.  If the symbol matches
     one of the keys in ‘completion-category-overrides’, the usual
     completion behavior is overridden.  *Note Completion Variables::.

‘annotation-function’
     The value should be a function for “annotating” completions.  The
     function should take one argument, STRING, which is a possible
     completion.  It should return a string, which is displayed after
     the completion STRING in the ‘*Completions*’ buffer.

‘display-sort-function’
     The value should be a function for sorting completions.  The
     function should take one argument, a list of completion strings,
     and return a sorted list of completion strings.  It is allowed to
     alter the input list destructively.

‘cycle-sort-function’
     The value should be a function for sorting completions, when
     ‘completion-cycle-threshold’ is non-‘nil’ and the user is cycling
     through completion alternatives.  *Note (emacs)Completion
     Options::.  Its argument list and return value are the same as for
     ‘display-sort-function’.

 -- Function: completion-table-dynamic function &optional switch-buffer
     This function is a convenient way to write a function that can act
     as a programmed completion function.  The argument FUNCTION should
     be a function that takes one argument, a string, and returns an
     alist of possible completions of it.  It is allowed to ignore the
     argument and return a full list of all possible completions.  You
     can think of ‘completion-table-dynamic’ as a transducer between
     that interface and the interface for programmed completion
     functions.

     If the optional argument SWITCH-BUFFER is non-‘nil’, and completion
     is performed in the minibuffer, FUNCTION will be called with
     current buffer set to the buffer from which the minibuffer was
     entered.

 -- Function: completion-table-with-cache function &optional ignore-case
     This is a wrapper for ‘completion-table-dynamic’ that saves the
     last argument-result pair.  This means that multiple lookups with
     the same argument only need to call FUNCTION once.  This can be
     useful when a slow operation is involved, such as calling an
     external process.


File: elisp.info,  Node: Completion in Buffers,  Prev: Programmed Completion,  Up: Completion

20.6.8 Completion in Ordinary Buffers
-------------------------------------

Although completion is usually done in the minibuffer, the completion
facility can also be used on the text in ordinary Emacs buffers.  In
many major modes, in-buffer completion is performed by the ‘C-M-i’ or
‘M-<TAB>’ command, bound to ‘completion-at-point’.  *Note (emacs)Symbol
Completion::.  This command uses the abnormal hook variable
‘completion-at-point-functions’:

 -- Variable: completion-at-point-functions
     The value of this abnormal hook should be a list of functions,
     which are used to compute a completion table for completing the
     text at point.  It can be used by major modes to provide
     mode-specific completion tables (*note Major Mode Conventions::).

     When the command ‘completion-at-point’ runs, it calls the functions
     in the list one by one, without any argument.  Each function should
     return ‘nil’ unless it can and wants to take responsibility for the
     completion data for the text at point.  Otherwise it should return
     a list of the following form:

          (START END COLLECTION . PROPS)

     START and END delimit the text to complete (which should enclose
     point).  COLLECTION is a completion table for completing that text,
     in a form suitable for passing as the second argument to
     ‘try-completion’ (*note Basic Completion::); completion
     alternatives will be generated from this completion table in the
     usual way, via the completion styles defined in ‘completion-styles’
     (*note Completion Variables::).  PROPS is a property list for
     additional information; any of the properties in
     ‘completion-extra-properties’ are recognized (*note Completion
     Variables::), as well as the following additional ones:

     ‘:predicate’
          The value should be a predicate that completion candidates
          need to satisfy.

     ‘:exclusive’
          If the value is ‘no’, then if the completion table fails to
          match the text at point, ‘completion-at-point’ moves on to the
          next function in ‘completion-at-point-functions’ instead of
          reporting a completion failure.

     The functions on this hook should generally return quickly, since
     they may be called very often (e.g., from ‘post-command-hook’).
     Supplying a function for COLLECTION is strongly recommended if
     generating the list of completions is an expensive operation.
     Emacs may internally call functions in
     ‘completion-at-point-functions’ many times, but care about the
     value of COLLECTION for only some of these calls.  By supplying a
     function for COLLECTION, Emacs can defer generating completions
     until necessary.  You can use ‘completion-table-dynamic’ to create
     a wrapper function:

          ;; Avoid this pattern.
          (let ((beg ...) (end ...) (my-completions (my-make-completions)))
            (list beg end my-completions))

          ;; Use this instead.
          (let ((beg ...) (end ...))
            (list beg
                  end
                  (completion-table-dynamic
                    (lambda (_)
                      (my-make-completions)))))

     Additionally, the COLLECTION should generally not be pre-filtered
     based on the current text between START and END, because that is
     the responsibility of the caller of ‘completion-at-point-functions’
     to do that according to the completion styles it decides to use.

     A function in ‘completion-at-point-functions’ may also return a
     function instead of a list as described above.  In that case, that
     returned function is called, with no argument, and it is entirely
     responsible for performing the completion.  We discourage this
     usage; it is only intended to help convert old code to using
     ‘completion-at-point’.

     The first function in ‘completion-at-point-functions’ to return a
     non-‘nil’ value is used by ‘completion-at-point’.  The remaining
     functions are not called.  The exception to this is when there is
     an ‘:exclusive’ specification, as described above.

   The following function provides a convenient way to perform
completion on an arbitrary stretch of text in an Emacs buffer:

 -- Function: completion-in-region start end collection &optional
          predicate
     This function completes the text in the current buffer between the
     positions START and END, using COLLECTION.  The argument COLLECTION
     has the same meaning as in ‘try-completion’ (*note Basic
     Completion::).

     This function inserts the completion text directly into the current
     buffer.  Unlike ‘completing-read’ (*note Minibuffer Completion::),
     it does not activate the minibuffer.

     For this function to work, point must be somewhere between START
     and END.


File: elisp.info,  Node: Yes-or-No Queries,  Next: Multiple Queries,  Prev: Completion,  Up: Minibuffers

20.7 Yes-or-No Queries
======================

This section describes functions used to ask the user a yes-or-no
question.  The function ‘y-or-n-p’ can be answered with a single
character; it is useful for questions where an inadvertent wrong answer
will not have serious consequences.  ‘yes-or-no-p’ is suitable for more
momentous questions, since it requires three or four characters to
answer.

   If either of these functions is called in a command that was invoked
using the mouse—more precisely, if ‘last-nonmenu-event’ (*note Command
Loop Info::) is either ‘nil’ or a list—then it uses a dialog box or
pop-up menu to ask the question.  Otherwise, it uses keyboard input.
You can force use either of the mouse or of keyboard input by binding
‘last-nonmenu-event’ to a suitable value around the call.

   Strictly speaking, ‘yes-or-no-p’ uses the minibuffer and ‘y-or-n-p’
does not; but it seems best to describe them together.

 -- Function: y-or-n-p prompt
     This function asks the user a question, expecting input in the echo
     area.  It returns ‘t’ if the user types ‘y’, ‘nil’ if the user
     types ‘n’.  This function also accepts <SPC> to mean yes and <DEL>
     to mean no.  It accepts ‘C-]’ to quit, like ‘C-g’, because the
     question might look like a minibuffer and for that reason the user
     might try to use ‘C-]’ to get out.  The answer is a single
     character, with no <RET> needed to terminate it.  Upper and lower
     case are equivalent.

     “Asking the question” means printing PROMPT in the echo area,
     followed by the string ‘(y or n) ’.  If the input is not one of the
     expected answers (‘y’, ‘n’, ‘<SPC>’, ‘<DEL>’, or something that
     quits), the function responds ‘Please answer y or n.’, and repeats
     the request.

     This function does not actually use the minibuffer, since it does
     not allow editing of the answer.  It actually uses the echo area
     (*note The Echo Area::), which uses the same screen space as the
     minibuffer.  The cursor moves to the echo area while the question
     is being asked.

     The answers and their meanings, even ‘y’ and ‘n’, are not
     hardwired, and are specified by the keymap ‘query-replace-map’
     (*note Search and Replace::).  In particular, if the user enters
     the special responses ‘recenter’, ‘scroll-up’, ‘scroll-down’,
     ‘scroll-other-window’, or ‘scroll-other-window-down’ (respectively
     bound to ‘C-l’, ‘C-v’, ‘M-v’, ‘C-M-v’ and ‘C-M-S-v’ in
     ‘query-replace-map’), this function performs the specified window
     recentering or scrolling operation, and poses the question again.

     We show successive lines of echo area messages, but only one
     actually appears on the screen at a time.

 -- Function: y-or-n-p-with-timeout prompt seconds default
     Like ‘y-or-n-p’, except that if the user fails to answer within
     SECONDS seconds, this function stops waiting and returns DEFAULT.
     It works by setting up a timer; see *note Timers::.  The argument
     SECONDS should be a number.

 -- Function: yes-or-no-p prompt
     This function asks the user a question, expecting input in the
     minibuffer.  It returns ‘t’ if the user enters ‘yes’, ‘nil’ if the
     user types ‘no’.  The user must type <RET> to finalize the
     response.  Upper and lower case are equivalent.

     ‘yes-or-no-p’ starts by displaying PROMPT in the echo area,
     followed by ‘(yes or no) ’.  The user must type one of the expected
     responses; otherwise, the function responds ‘Please answer yes or
     no.’, waits about two seconds and repeats the request.

     ‘yes-or-no-p’ requires more work from the user than ‘y-or-n-p’ and
     is appropriate for more crucial decisions.

     Here is an example:

          (yes-or-no-p "Do you really want to remove everything? ")

          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

     If the user first types ‘y <RET>’, which is invalid because this
     function demands the entire word ‘yes’, it responds by displaying
     these prompts, with a brief pause between them:

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------


File: elisp.info,  Node: Multiple Queries,  Next: Reading a Password,  Prev: Yes-or-No Queries,  Up: Minibuffers

20.8 Asking Multiple Y-or-N Questions
=====================================

When you have a series of similar questions to ask, such as “Do you want
to save this buffer?” for each buffer in turn, you should use
‘map-y-or-n-p’ to ask the collection of questions, rather than asking
each question individually.  This gives the user certain convenient
facilities such as the ability to answer the whole series at once.

 -- Function: map-y-or-n-p prompter actor list &optional help
          action-alist no-cursor-in-echo-area
     This function asks the user a series of questions, reading a
     single-character answer in the echo area for each one.

     The value of LIST specifies the objects to ask questions about.  It
     should be either a list of objects or a generator function.  If it
     is a function, it should expect no arguments, and should return
     either the next object to ask about, or ‘nil’, meaning to stop
     asking questions.

     The argument PROMPTER specifies how to ask each question.  If
     PROMPTER is a string, the question text is computed like this:

          (format PROMPTER OBJECT)

     where OBJECT is the next object to ask about (as obtained from
     LIST).

     If not a string, PROMPTER should be a function of one argument (the
     next object to ask about) and should return the question text.  If
     the value is a string, that is the question to ask the user.  The
     function can also return ‘t’, meaning do act on this object (and
     don’t ask the user), or ‘nil’, meaning ignore this object (and
     don’t ask the user).

     The argument ACTOR says how to act on the answers that the user
     gives.  It should be a function of one argument, and it is called
     with each object that the user says yes for.  Its argument is
     always an object obtained from LIST.

     If the argument HELP is given, it should be a list of this form:

          (SINGULAR PLURAL ACTION)

     where SINGULAR is a string containing a singular noun that
     describes the objects conceptually being acted on, PLURAL is the
     corresponding plural noun, and ACTION is a transitive verb
     describing what ACTOR does.

     If you don’t specify HELP, the default is ‘("object" "objects" "act
     on")’.

     Each time a question is asked, the user may enter ‘y’, ‘Y’, or
     <SPC> to act on that object; ‘n’, ‘N’, or <DEL> to skip that
     object; ‘!’ to act on all following objects; <ESC> or ‘q’ to exit
     (skip all following objects); ‘.’ (period) to act on the current
     object and then exit; or ‘C-h’ to get help.  These are the same
     answers that ‘query-replace’ accepts.  The keymap
     ‘query-replace-map’ defines their meaning for ‘map-y-or-n-p’ as
     well as for ‘query-replace’; see *note Search and Replace::.

     You can use ACTION-ALIST to specify additional possible answers and
     what they mean.  It is an alist of elements of the form ‘(CHAR
     FUNCTION HELP)’, each of which defines one additional answer.  In
     this element, CHAR is a character (the answer); FUNCTION is a
     function of one argument (an object from LIST); HELP is a string.

     When the user responds with CHAR, ‘map-y-or-n-p’ calls FUNCTION.
     If it returns non-‘nil’, the object is considered acted upon, and
     ‘map-y-or-n-p’ advances to the next object in LIST.  If it returns
     ‘nil’, the prompt is repeated for the same object.

     Normally, ‘map-y-or-n-p’ binds ‘cursor-in-echo-area’ while
     prompting.  But if NO-CURSOR-IN-ECHO-AREA is non-‘nil’, it does not
     do that.

     If ‘map-y-or-n-p’ is called in a command that was invoked using the
     mouse—more precisely, if ‘last-nonmenu-event’ (*note Command Loop
     Info::) is either ‘nil’ or a list—then it uses a dialog box or
     pop-up menu to ask the question.  In this case, it does not use
     keyboard input or the echo area.  You can force use either of the
     mouse or of keyboard input by binding ‘last-nonmenu-event’ to a
     suitable value around the call.

     The return value of ‘map-y-or-n-p’ is the number of objects acted
     on.


File: elisp.info,  Node: Reading a Password,  Next: Minibuffer Commands,  Prev: Multiple Queries,  Up: Minibuffers

20.9 Reading a Password
=======================

To read a password to pass to another program, you can use the function
‘read-passwd’.

 -- Function: read-passwd prompt &optional confirm default
     This function reads a password, prompting with PROMPT.  It does not
     echo the password as the user types it; instead, it echoes ‘.’ for
     each character in the password.  If you want to apply another
     character to hide the password, let-bind the variable
     ‘read-hide-char’ with that character.

     The optional argument CONFIRM, if non-‘nil’, says to read the
     password twice and insist it must be the same both times.  If it
     isn’t the same, the user has to type it over and over until the
     last two times match.

     The optional argument DEFAULT specifies the default password to
     return if the user enters empty input.  If DEFAULT is ‘nil’, then
     ‘read-passwd’ returns the null string in that case.


File: elisp.info,  Node: Minibuffer Commands,  Next: Minibuffer Windows,  Prev: Reading a Password,  Up: Minibuffers

20.10 Minibuffer Commands
=========================

This section describes some commands meant for use in the minibuffer.

 -- Command: exit-minibuffer
     This command exits the active minibuffer.  It is normally bound to
     keys in minibuffer local keymaps.

 -- Command: self-insert-and-exit
     This command exits the active minibuffer after inserting the last
     character typed on the keyboard (found in ‘last-command-event’;
     *note Command Loop Info::).

 -- Command: previous-history-element n
     This command replaces the minibuffer contents with the value of the
     Nth previous (older) history element.

 -- Command: next-history-element n
     This command replaces the minibuffer contents with the value of the
     Nth more recent history element.

 -- Command: previous-matching-history-element pattern n
     This command replaces the minibuffer contents with the value of the
     Nth previous (older) history element that matches PATTERN (a
     regular expression).

 -- Command: next-matching-history-element pattern n
     This command replaces the minibuffer contents with the value of the
     Nth next (newer) history element that matches PATTERN (a regular
     expression).

 -- Command: previous-complete-history-element n
     This command replaces the minibuffer contents with the value of the
     Nth previous (older) history element that completes the current
     contents of the minibuffer before the point.

 -- Command: next-complete-history-element n
     This command replaces the minibuffer contents with the value of the
     Nth next (newer) history element that completes the current
     contents of the minibuffer before the point.


File: elisp.info,  Node: Minibuffer Windows,  Next: Minibuffer Contents,  Prev: Minibuffer Commands,  Up: Minibuffers

20.11 Minibuffer Windows
========================

These functions access and select minibuffer windows, test whether they
are active and control how they get resized.

 -- Function: minibuffer-window &optional frame
     This function returns the minibuffer window used for frame FRAME.
     If FRAME is ‘nil’, that stands for the selected frame.

     Note that the minibuffer window used by a frame need not be part of
     that frame—a frame that has no minibuffer of its own necessarily
     uses some other frame’s minibuffer window.  The minibuffer window
     of a minibuffer-less frame can be changed by setting that frame’s
     ‘minibuffer’ frame parameter (*note Buffer Parameters::).

 -- Function: set-minibuffer-window window
     This function specifies WINDOW as the minibuffer window to use.
     This affects where the minibuffer is displayed if you put text in
     it without invoking the usual minibuffer commands.  It has no
     effect on the usual minibuffer input functions because they all
     start by choosing the minibuffer window according to the selected
     frame.

 -- Function: window-minibuffer-p &optional window
     This function returns non-‘nil’ if WINDOW is a minibuffer window.
     WINDOW defaults to the selected window.

   The following function returns the window showing the currently
active minibuffer.

 -- Function: active-minibuffer-window
     This function returns the window of the currently active
     minibuffer, or ‘nil’ if there is no active minibuffer.

   It is not sufficient to determine whether a given window shows the
currently active minibuffer by comparing it with the result of
‘(minibuffer-window)’, because there can be more than one minibuffer
window if there is more than one frame.

 -- Function: minibuffer-window-active-p window
     This function returns non-‘nil’ if WINDOW shows the currently
     active minibuffer.

   The following two options control whether minibuffer windows are
resized automatically and how large they can get in the process.

 -- User Option: resize-mini-windows
     This option specifies whether minibuffer windows are resized
     automatically.  The default value is ‘grow-only’, which means that
     a minibuffer window by default expands automatically to accommodate
     the text it displays and shrinks back to one line as soon as the
     minibuffer gets empty.  If the value is ‘t’, Emacs will always try
     to fit the height of a minibuffer window to the text it displays
     (with a minimum of one line).  If the value is ‘nil’, a minibuffer
     window never changes size automatically.  In that case the window
     resizing commands (*note Resizing Windows::) can be used to adjust
     its height.

 -- User Option: max-mini-window-height
     This option provides a maximum height for resizing minibuffer
     windows automatically.  A floating-point number specifies a
     fraction of the frame’s height; an integer specifies the maximum
     number of lines.  The default value is 0.25.

   Note that the values of the above two variables take effect at
display time, so let-binding them around code which produces echo-area
messages will not work.  If you want to prevent resizing of minibuffer
windows when displaying long messages, bind the ‘message-truncate-lines’
variable instead (*note Echo Area Customization::).


File: elisp.info,  Node: Minibuffer Contents,  Next: Recursive Mini,  Prev: Minibuffer Windows,  Up: Minibuffers

20.12 Minibuffer Contents
=========================

These functions access the minibuffer prompt and contents.

 -- Function: minibuffer-prompt
     This function returns the prompt string of the currently active
     minibuffer.  If no minibuffer is active, it returns ‘nil’.

 -- Function: minibuffer-prompt-end
     This function returns the current position of the end of the
     minibuffer prompt, if a minibuffer is current.  Otherwise, it
     returns the minimum valid buffer position.

 -- Function: minibuffer-prompt-width
     This function returns the current display-width of the minibuffer
     prompt, if a minibuffer is current.  Otherwise, it returns zero.

 -- Function: minibuffer-contents
     This function returns the editable contents of the minibuffer (that
     is, everything except the prompt) as a string, if a minibuffer is
     current.  Otherwise, it returns the entire contents of the current
     buffer.

 -- Function: minibuffer-contents-no-properties
     This is like ‘minibuffer-contents’, except that it does not copy
     text properties, just the characters themselves.  *Note Text
     Properties::.

 -- Command: delete-minibuffer-contents
     This command erases the editable contents of the minibuffer (that
     is, everything except the prompt), if a minibuffer is current.
     Otherwise, it erases the entire current buffer.


File: elisp.info,  Node: Recursive Mini,  Next: Minibuffer Misc,  Prev: Minibuffer Contents,  Up: Minibuffers

20.13 Recursive Minibuffers
===========================

These functions and variables deal with recursive minibuffers (*note
Recursive Editing::):

 -- Function: minibuffer-depth
     This function returns the current depth of activations of the
     minibuffer, a nonnegative integer.  If no minibuffers are active,
     it returns zero.

 -- User Option: enable-recursive-minibuffers
     If this variable is non-‘nil’, you can invoke commands (such as
     ‘find-file’) that use minibuffers even while the minibuffer is
     active.  Such invocation produces a recursive editing level for a
     new minibuffer.  The outer-level minibuffer is invisible while you
     are editing the inner one.

     If this variable is ‘nil’, you cannot invoke minibuffer commands
     when the minibuffer is active, not even if you switch to another
     window to do it.

   If a command name has a property ‘enable-recursive-minibuffers’ that
is non-‘nil’, then the command can use the minibuffer to read arguments
even if it is invoked from the minibuffer.  A command can also achieve
this by binding ‘enable-recursive-minibuffers’ to ‘t’ in the interactive
declaration (*note Using Interactive::).  The minibuffer command
‘next-matching-history-element’ (normally ‘M-s’ in the minibuffer) does
the latter.


File: elisp.info,  Node: Minibuffer Misc,  Prev: Recursive Mini,  Up: Minibuffers

20.14 Minibuffer Miscellany
===========================

 -- Function: minibufferp &optional buffer-or-name
     This function returns non-‘nil’ if BUFFER-OR-NAME is a minibuffer.
     If BUFFER-OR-NAME is omitted, it tests the current buffer.

 -- Variable: minibuffer-setup-hook
     This is a normal hook that is run whenever the minibuffer is
     entered.  *Note Hooks::.

 -- Macro: minibuffer-with-setup-hook function &rest body
     This macro executes BODY after arranging for the specified FUNCTION
     to be called via ‘minibuffer-setup-hook’.  By default, FUNCTION is
     called before the other functions in the ‘minibuffer-setup-hook’
     list, but if FUNCTION is of the form ‘(:append FUNC)’, FUNC will be
     called _after_ the other hook functions.

     The BODY forms should not use the minibuffer more than once.  If
     the minibuffer is re-entered recursively, FUNCTION will only be
     called once, for the outermost use of the minibuffer.

 -- Variable: minibuffer-exit-hook
     This is a normal hook that is run whenever the minibuffer is
     exited.  *Note Hooks::.

 -- Variable: minibuffer-help-form
     The current value of this variable is used to rebind ‘help-form’
     locally inside the minibuffer (*note Help Functions::).

 -- Variable: minibuffer-scroll-window
     If the value of this variable is non-‘nil’, it should be a window
     object.  When the function ‘scroll-other-window’ is called in the
     minibuffer, it scrolls this window.

 -- Function: minibuffer-selected-window
     This function returns the window that was selected just before the
     minibuffer window was selected.  If the selected window is not a
     minibuffer window, it returns ‘nil’.

 -- Function: minibuffer-message string &rest args
     This function displays STRING temporarily at the end of the
     minibuffer text, for a few seconds, or until the next input event
     arrives, whichever comes first.  The variable
     ‘minibuffer-message-timeout’ specifies the number of seconds to
     wait in the absence of input.  It defaults to 2.  If ARGS is
     non-‘nil’, the actual message is obtained by passing STRING and
     ARGS through ‘format-message’.  *Note Formatting Strings::.

 -- Command: minibuffer-inactive-mode
     This is the major mode used in inactive minibuffers.  It uses
     keymap ‘minibuffer-inactive-mode-map’.  This can be useful if the
     minibuffer is in a separate frame.  *Note Minibuffers and Frames::.


File: elisp.info,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

21 Command Loop
***************

When you run Emacs, it enters the “editor command loop” almost
immediately.  This loop reads key sequences, executes their definitions,
and displays the results.  In this chapter, we describe how these things
are done, and the subroutines that allow Lisp programs to do them.

* Menu:

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Distinguish Interactive::     Making a command distinguish interactive calls.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Adjusting Point::     Adjustment of point after a command.
* Input Events::        What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Special Events::      Events processed immediately and individually.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How ‘C-g’ works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn’t.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.


File: elisp.info,  Node: Command Overview,  Next: Defining Commands,  Up: Command Loop

21.1 Command Loop Overview
==========================

The first thing the command loop must do is read a key sequence, which
is a sequence of input events that translates into a command.  It does
this by calling the function ‘read-key-sequence’.  Lisp programs can
also call this function (*note Key Sequence Input::).  They can also
read input at a lower level with ‘read-key’ or ‘read-event’ (*note
Reading One Event::), or discard pending input with ‘discard-input’
(*note Event Input Misc::).

   The key sequence is translated into a command through the currently
active keymaps.  *Note Key Lookup::, for information on how this is
done.  The result should be a keyboard macro or an interactively
callable function.  If the key is ‘M-x’, then it reads the name of
another command, which it then calls.  This is done by the command
‘execute-extended-command’ (*note Interactive Call::).

   Prior to executing the command, Emacs runs ‘undo-boundary’ to create
an undo boundary.  *Note Maintaining Undo::.

   To execute a command, Emacs first reads its arguments by calling
‘command-execute’ (*note Interactive Call::).  For commands written in
Lisp, the ‘interactive’ specification says how to read the arguments.
This may use the prefix argument (*note Prefix Command Arguments::) or
may read with prompting in the minibuffer (*note Minibuffers::).  For
example, the command ‘find-file’ has an ‘interactive’ specification
which says to read a file name using the minibuffer.  The function body
of ‘find-file’ does not use the minibuffer, so if you call ‘find-file’
as a function from Lisp code, you must supply the file name string as an
ordinary Lisp function argument.

   If the command is a keyboard macro (i.e., a string or vector), Emacs
executes it using ‘execute-kbd-macro’ (*note Keyboard Macros::).

 -- Variable: pre-command-hook
     This normal hook is run by the editor command loop before it
     executes each command.  At that time, ‘this-command’ contains the
     command that is about to run, and ‘last-command’ describes the
     previous command.  *Note Command Loop Info::.

 -- Variable: post-command-hook
     This normal hook is run by the editor command loop after it
     executes each command (including commands terminated prematurely by
     quitting or by errors).  At that time, ‘this-command’ refers to the
     command that just ran, and ‘last-command’ refers to the command
     before that.

     This hook is also run when Emacs first enters the command loop (at
     which point ‘this-command’ and ‘last-command’ are both ‘nil’).

   Quitting is suppressed while running ‘pre-command-hook’ and
‘post-command-hook’.  If an error happens while executing one of these
hooks, it does not terminate execution of the hook; instead the error is
silenced and the function in which the error occurred is removed from
the hook.

   A request coming into the Emacs server (*note (emacs)Emacs Server::)
runs these two hooks just as a keyboard command does.


File: elisp.info,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

21.2 Defining Commands
======================

The special form ‘interactive’ turns a Lisp function into a command.
The ‘interactive’ form must be located at top-level in the function
body, usually as the first form in the body; this applies to both lambda
expressions (*note Lambda Expressions::) and ‘defun’ forms (*note
Defining Functions::).  This form does nothing during the actual
execution of the function; its presence serves as a flag, telling the
Emacs command loop that the function can be called interactively.  The
argument of the ‘interactive’ form specifies how the arguments for an
interactive call should be read.

   Alternatively, an ‘interactive’ form may be specified in a function
symbol’s ‘interactive-form’ property.  A non-‘nil’ value for this
property takes precedence over any ‘interactive’ form in the function
body itself.  This feature is seldom used.

   Sometimes, a function is only intended to be called interactively,
never directly from Lisp.  In that case, give the function a non-‘nil’
‘interactive-only’ property, either directly or via ‘declare’ (*note
Declare Form::).  This causes the byte compiler to warn if the command
is called from Lisp.  The output of ‘describe-function’ will include
similar information.  The value of the property can be: a string, which
the byte-compiler will use directly in its warning (it should end with a
period, and not start with a capital, e.g., ‘"use (system-name)
instead."’); ‘t’; any other symbol, which should be an alternative
function to use in Lisp code.

* Menu:

* Using Interactive::     General rules for ‘interactive’.
* Interactive Codes::     The standard letter-codes for reading arguments
                             in various ways.
* Interactive Examples::  Examples of how to read interactive arguments.
* Generic Commands::      Select among command alternatives.


File: elisp.info,  Node: Using Interactive,  Next: Interactive Codes,  Up: Defining Commands

21.2.1 Using ‘interactive’
--------------------------

This section describes how to write the ‘interactive’ form that makes a
Lisp function an interactively-callable command, and how to examine a
command’s ‘interactive’ form.

 -- Special Form: interactive arg-descriptor
     This special form declares that a function is a command, and that
     it may therefore be called interactively (via ‘M-x’ or by entering
     a key sequence bound to it).  The argument ARG-DESCRIPTOR declares
     how to compute the arguments to the command when the command is
     called interactively.

     A command may be called from Lisp programs like any other function,
     but then the caller supplies the arguments and ARG-DESCRIPTOR has
     no effect.

     The ‘interactive’ form must be located at top-level in the function
     body, or in the function symbol’s ‘interactive-form’ property
     (*note Symbol Properties::).  It has its effect because the command
     loop looks for it before calling the function (*note Interactive
     Call::).  Once the function is called, all its body forms are
     executed; at this time, if the ‘interactive’ form occurs within the
     body, the form simply returns ‘nil’ without even evaluating its
     argument.

     By convention, you should put the ‘interactive’ form in the
     function body, as the first top-level form.  If there is an
     ‘interactive’ form in both the ‘interactive-form’ symbol property
     and the function body, the former takes precedence.  The
     ‘interactive-form’ symbol property can be used to add an
     interactive form to an existing function, or change how its
     arguments are processed interactively, without redefining the
     function.

   There are three possibilities for the argument ARG-DESCRIPTOR:

   • It may be omitted or ‘nil’; then the command is called with no
     arguments.  This leads quickly to an error if the command requires
     one or more arguments.

   • It may be a string; its contents are a sequence of elements
     separated by newlines, one for each argument(1).  Each element
     consists of a code character (*note Interactive Codes::) optionally
     followed by a prompt (which some code characters use and some
     ignore).  Here is an example:

          (interactive "P\nbFrobnicate buffer: ")

     The code letter ‘P’ sets the command’s first argument to the raw
     command prefix (*note Prefix Command Arguments::).  ‘bFrobnicate
     buffer: ’ prompts the user with ‘Frobnicate buffer: ’ to enter the
     name of an existing buffer, which becomes the second and final
     argument.

     The prompt string can use ‘%’ to include previous argument values
     (starting with the first argument) in the prompt.  This is done
     using ‘format-message’ (*note Formatting Strings::).  For example,
     here is how you could read the name of an existing buffer followed
     by a new name to give to that buffer:

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     If ‘*’ appears at the beginning of the string, then an error is
     signaled if the buffer is read-only.

     If ‘@’ appears at the beginning of the string, and if the key
     sequence used to invoke the command includes any mouse events, then
     the window associated with the first of those events is selected
     before the command is run.

     If ‘^’ appears at the beginning of the string, and if the command
     was invoked through “shift-translation”, set the mark and activate
     the region temporarily, or extend an already active region, before
     the command is run.  If the command was invoked without
     shift-translation, and the region is temporarily active, deactivate
     the region before the command is run.  Shift-translation is
     controlled on the user level by ‘shift-select-mode’; see *note
     (emacs)Shift Selection::.

     You can use ‘*’, ‘@’, and ‘^’ together; the order does not matter.
     Actual reading of arguments is controlled by the rest of the prompt
     string (starting with the first character that is not ‘*’, ‘@’, or
     ‘^’).

   • It may be a Lisp expression that is not a string; then it should be
     a form that is evaluated to get a list of arguments to pass to the
     command.  Usually this form will call various functions to read
     input from the user, most often through the minibuffer (*note
     Minibuffers::) or directly from the keyboard (*note Reading
     Input::).

     Providing point or the mark as an argument value is also common,
     but if you do this _and_ read input (whether using the minibuffer
     or not), be sure to get the integer values of point or the mark
     after reading.  The current buffer may be receiving subprocess
     output; if subprocess output arrives while the command is waiting
     for input, it could relocate point and the mark.

     Here’s an example of what _not_ to do:

          (interactive
           (list (region-beginning) (region-end)
                 (read-string "Foo: " nil 'my-history)))

     Here’s how to avoid the problem, by examining point and the mark
     after reading the keyboard input:

          (interactive
           (let ((string (read-string "Foo: " nil 'my-history)))
             (list (region-beginning) (region-end) string)))

     *Warning:* the argument values should not include any data types
     that can’t be printed and then read.  Some facilities save
     ‘command-history’ in a file to be read in the subsequent sessions;
     if a command’s arguments contain a data type that prints using
     ‘#<...>’ syntax, those facilities won’t work.

     There are, however, a few exceptions: it is ok to use a limited set
     of expressions such as ‘(point)’, ‘(mark)’, ‘(region-beginning)’,
     and ‘(region-end)’, because Emacs recognizes them specially and
     puts the expression (rather than its value) into the command
     history.  To see whether the expression you wrote is one of these
     exceptions, run the command, then examine ‘(car command-history)’.

 -- Function: interactive-form function
     This function returns the ‘interactive’ form of FUNCTION.  If
     FUNCTION is an interactively callable function (*note Interactive
     Call::), the value is the command’s ‘interactive’ form
     ‘(interactive SPEC)’, which specifies how to compute its arguments.
     Otherwise, the value is ‘nil’.  If FUNCTION is a symbol, its
     function definition is used.

   ---------- Footnotes ----------

   (1) Some elements actually supply two arguments.

