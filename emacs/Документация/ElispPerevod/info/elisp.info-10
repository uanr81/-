This is elisp.info, produced by makeinfo version 6.1 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp.info,  Node: Char Classes,  Next: Regexp Backslash,  Prev: Regexp Special,  Up: Syntax of Regexps

34.3.1.2 Character Classes
..........................

Here is a table of the classes you can use in a character alternative,
and what they mean:

‘[:ascii:]’
     This matches any ASCII character (codes 0–127).
‘[:alnum:]’
     This matches any letter or digit.  For multibyte characters, it
     matches characters whose Unicode ‘general-category’ property (*note
     Character Properties::) indicates they are alphabetic or decimal
     number characters.
‘[:alpha:]’
     This matches any letter.  For multibyte characters, it matches
     characters whose Unicode ‘general-category’ property (*note
     Character Properties::) indicates they are alphabetic characters.
‘[:blank:]’
     This matches horizontal whitespace, as defined by Annex C of the
     Unicode Technical Standard #18.  In particular, it matches spaces,
     tabs, and other characters whose Unicode ‘general-category’
     property (*note Character Properties::) indicates they are spacing
     separators.
‘[:cntrl:]’
     This matches any ASCII control character.
‘[:digit:]’
     This matches ‘0’ through ‘9’.  Thus, ‘[-+[:digit:]]’ matches any
     digit, as well as ‘+’ and ‘-’.
‘[:graph:]’
     This matches graphic characters—everything except whitespace, ASCII
     and non-ASCII control characters, surrogates, and codepoints
     unassigned by Unicode, as indicated by the Unicode
     ‘general-category’ property (*note Character Properties::).
‘[:lower:]’
     This matches any lower-case letter, as determined by the current
     case table (*note Case Tables::).  If ‘case-fold-search’ is
     non-‘nil’, this also matches any upper-case letter.
‘[:multibyte:]’
     This matches any multibyte character (*note Text
     Representations::).
‘[:nonascii:]’
     This matches any non-ASCII character.
‘[:print:]’
     This matches any printing character—either whitespace, or a graphic
     character matched by ‘[:graph:]’.
‘[:punct:]’
     This matches any punctuation character.  (At present, for multibyte
     characters, it matches anything that has non-word syntax.)
‘[:space:]’
     This matches any character that has whitespace syntax (*note Syntax
     Class Table::).
‘[:unibyte:]’
     This matches any unibyte character (*note Text Representations::).
‘[:upper:]’
     This matches any upper-case letter, as determined by the current
     case table (*note Case Tables::).  If ‘case-fold-search’ is
     non-‘nil’, this also matches any lower-case letter.
‘[:word:]’
     This matches any character that has word syntax (*note Syntax Class
     Table::).
‘[:xdigit:]’
     This matches the hexadecimal digits: ‘0’ through ‘9’, ‘a’ through
     ‘f’ and ‘A’ through ‘F’.


File: elisp.info,  Node: Regexp Backslash,  Prev: Char Classes,  Up: Syntax of Regexps

34.3.1.3 Backslash Constructs in Regular Expressions
....................................................

For the most part, ‘\’ followed by any character matches only that
character.  However, there are several exceptions: certain sequences
starting with ‘\’ that have special meanings.  Here is a table of the
special ‘\’ constructs.

‘\|’
     specifies an alternative.  Two regular expressions A and B with
     ‘\|’ in between form an expression that matches anything that
     either A or B matches.

     Thus, ‘foo\|bar’ matches either ‘foo’ or ‘bar’ but no other string.

     ‘\|’ applies to the largest possible surrounding expressions.  Only
     a surrounding ‘\( ... \)’ grouping can limit the grouping power of
     ‘\|’.

     If you need full backtracking capability to handle multiple uses of
     ‘\|’, use the POSIX regular expression functions (*note POSIX
     Regexps::).

‘\{M\}’
     is a postfix operator that repeats the previous pattern exactly M
     times.  Thus, ‘x\{5\}’ matches the string ‘xxxxx’ and nothing else.
     ‘c[ad]\{3\}r’ matches string such as ‘caaar’, ‘cdddr’, ‘cadar’, and
     so on.

‘\{M,N\}’
     is a more general postfix operator that specifies repetition with a
     minimum of M repeats and a maximum of N repeats.  If M is omitted,
     the minimum is 0; if N is omitted, there is no maximum.  For both
     forms, M and N, if specified, may be no larger than 2**15 − 1 .

     For example, ‘c[ad]\{1,2\}r’ matches the strings ‘car’, ‘cdr’,
     ‘caar’, ‘cadr’, ‘cdar’, and ‘cddr’, and nothing else.
     ‘\{0,1\}’ or ‘\{,1\}’ is equivalent to ‘?’.
     ‘\{0,\}’ or ‘\{,\}’ is equivalent to ‘*’.
     ‘\{1,\}’ is equivalent to ‘+’.

‘\( ... \)’
     is a grouping construct that serves three purposes:

       1. To enclose a set of ‘\|’ alternatives for other operations.
          Thus, the regular expression ‘\(foo\|bar\)x’ matches either
          ‘foox’ or ‘barx’.

       2. To enclose a complicated expression for the postfix operators
          ‘*’, ‘+’ and ‘?’ to operate on.  Thus, ‘ba\(na\)*’ matches
          ‘ba’, ‘bana’, ‘banana’, ‘bananana’, etc., with any number
          (zero or more) of ‘na’ strings.

       3. To record a matched substring for future reference with
          ‘\DIGIT’ (see below).

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature that was assigned
     as a second meaning to the same ‘\( ... \)’ construct because, in
     practice, there was usually no conflict between the two meanings.
     But occasionally there is a conflict, and that led to the
     introduction of shy groups.

‘\(?: ... \)’
     is the “shy group” construct.  A shy group serves the first two
     purposes of an ordinary group (controlling the nesting of other
     operators), but it does not get a number, so you cannot refer back
     to its value with ‘\DIGIT’.  Shy groups are particularly useful for
     mechanically-constructed regular expressions, because they can be
     added automatically without altering the numbering of ordinary,
     non-shy groups.

     Shy groups are also called “non-capturing” or “unnumbered groups”.

‘\(?NUM: ... \)’
     is the “explicitly numbered group” construct.  Normal groups get
     their number implicitly, based on their position, which can be
     inconvenient.  This construct allows you to force a particular
     group number.  There is no particular restriction on the numbering,
     e.g., you can have several groups with the same number in which
     case the last one to match (i.e., the rightmost match) will win.
     Implicitly numbered groups always get the smallest integer larger
     than the one of any previous group.

‘\DIGIT’
     matches the same text that matched the DIGITth occurrence of a
     grouping (‘\( ... \)’) construct.

     In other words, after the end of a group, the matcher remembers the
     beginning and end of the text matched by that group.  Later on in
     the regular expression you can use ‘\’ followed by DIGIT to match
     that same text, whatever it may have been.

     The strings matching the first nine grouping constructs appearing
     in the entire regular expression passed to a search or matching
     function are assigned numbers 1 through 9 in the order that the
     open parentheses appear in the regular expression.  So you can use
     ‘\1’ through ‘\9’ to refer to the text matched by the corresponding
     grouping constructs.

     For example, ‘\(.*\)\1’ matches any newline-free string that is
     composed of two identical halves.  The ‘\(.*\)’ matches the first
     half, which may be anything, but the ‘\1’ that follows must match
     the same exact text.

     If a ‘\( ... \)’ construct matches more than once (which can
     happen, for instance, if it is followed by ‘*’), only the last
     match is recorded.

     If a particular grouping construct in the regular expression was
     never matched—for instance, if it appears inside of an alternative
     that wasn’t used, or inside of a repetition that repeated zero
     times—then the corresponding ‘\DIGIT’ construct never matches
     anything.  To use an artificial example, ‘\(foo\(b*\)\|lose\)\2’
     cannot match ‘lose’: the second alternative inside the larger group
     matches it, but then ‘\2’ is undefined and can’t match anything.
     But it can match ‘foobb’, because the first alternative matches
     ‘foob’ and ‘\2’ matches ‘b’.

‘\w’
     matches any word-constituent character.  The editor syntax table
     determines which characters these are.  *Note Syntax Tables::.

‘\W’
     matches any character that is not a word constituent.

‘\sCODE’
     matches any character whose syntax is CODE.  Here CODE is a
     character that represents a syntax code: thus, ‘w’ for word
     constituent, ‘-’ for whitespace, ‘(’ for open parenthesis, etc.  To
     represent whitespace syntax, use either ‘-’ or a space character.
     *Note Syntax Class Table::, for a list of syntax codes and the
     characters that stand for them.

‘\SCODE’
     matches any character whose syntax is not CODE.

‘\cC’
     matches any character whose category is C.  Here C is a character
     that represents a category: thus, ‘c’ for Chinese characters or ‘g’
     for Greek characters in the standard category table.  You can see
     the list of all the currently defined categories with ‘M-x
     describe-categories <RET>’.  You can also define your own
     categories in addition to the standard ones using the
     ‘define-category’ function (*note Categories::).

‘\CC’
     matches any character whose category is not C.

   The following regular expression constructs match the empty
string—that is, they don’t use up any characters—but whether they match
depends on the context.  For all, the beginning and end of the
accessible portion of the buffer are treated as if they were the actual
beginning and end of the buffer.

‘\`’
     matches the empty string, but only at the beginning of the buffer
     or string being matched against.

‘\'’
     matches the empty string, but only at the end of the buffer or
     string being matched against.

‘\=’
     matches the empty string, but only at point.  (This construct is
     not defined when matching against a string.)

‘\b’
     matches the empty string, but only at the beginning or end of a
     word.  Thus, ‘\bfoo\b’ matches any occurrence of ‘foo’ as a
     separate word.  ‘\bballs?\b’ matches ‘ball’ or ‘balls’ as a
     separate word.

     ‘\b’ matches at the beginning or end of the buffer (or string)
     regardless of what text appears next to it.

‘\B’
     matches the empty string, but _not_ at the beginning or end of a
     word, nor at the beginning or end of the buffer (or string).

‘\<’
     matches the empty string, but only at the beginning of a word.
     ‘\<’ matches at the beginning of the buffer (or string) only if a
     word-constituent character follows.

‘\>’
     matches the empty string, but only at the end of a word.  ‘\>’
     matches at the end of the buffer (or string) only if the contents
     end with a word-constituent character.

‘\_<’
     matches the empty string, but only at the beginning of a symbol.  A
     symbol is a sequence of one or more word or symbol constituent
     characters.  ‘\_<’ matches at the beginning of the buffer (or
     string) only if a symbol-constituent character follows.

‘\_>’
     matches the empty string, but only at the end of a symbol.  ‘\_>’
     matches at the end of the buffer (or string) only if the contents
     end with a symbol-constituent character.

   Not every string is a valid regular expression.  For example, a
string that ends inside a character alternative without a terminating
‘]’ is invalid, and so is a string that ends with a single ‘\’.  If an
invalid regular expression is passed to any of the search functions, an
‘invalid-regexp’ error is signaled.


File: elisp.info,  Node: Regexp Example,  Next: Regexp Functions,  Prev: Syntax of Regexps,  Up: Regular Expressions

34.3.2 Complex Regexp Example
-----------------------------

Here is a complicated regexp which was formerly used by Emacs to
recognize the end of a sentence together with any whitespace that
follows.  (Nowadays Emacs uses a similar but more complex default regexp
constructed by the function ‘sentence-end’.  *Note Standard Regexps::.)

   Below, we show first the regexp as a string in Lisp syntax (to
distinguish spaces from tab characters), and then the result of
evaluating it.  The string constant begins and ends with a double-quote.
‘\"’ stands for a double-quote as part of the string, ‘\\’ for a
backslash as part of the string, ‘\t’ for a tab and ‘\n’ for a newline.

     "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
          ⇒ "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
     ]*"

In the output, tab and newline appear as themselves.

   This regular expression contains four parts in succession and can be
deciphered as follows:

‘[.?!]’
     The first part of the pattern is a character alternative that
     matches any one of three characters: period, question mark, and
     exclamation mark.  The match must begin with one of these three
     characters.  (This is one point where the new default regexp used
     by Emacs differs from the old.  The new value also allows some
     non-ASCII characters that end a sentence without any following
     whitespace.)

‘[]\"')}]*’
     The second part of the pattern matches any closing braces and
     quotation marks, zero or more of them, that may follow the period,
     question mark or exclamation mark.  The ‘\"’ is Lisp syntax for a
     double-quote in a string.  The ‘*’ at the end indicates that the
     immediately preceding regular expression (a character alternative,
     in this case) may be repeated zero or more times.

‘\\($\\| $\\|\t\\|  \\)’
     The third part of the pattern matches the whitespace that follows
     the end of a sentence: the end of a line (optionally with a space),
     or a tab, or two spaces.  The double backslashes mark the
     parentheses and vertical bars as regular expression syntax; the
     parentheses delimit a group and the vertical bars separate
     alternatives.  The dollar sign is used to match the end of a line.

‘[ \t\n]*’
     Finally, the last part of the pattern matches any additional
     whitespace beyond the minimum needed to end a sentence.


File: elisp.info,  Node: Regexp Functions,  Prev: Regexp Example,  Up: Regular Expressions

34.3.3 Regular Expression Functions
-----------------------------------

These functions operate on regular expressions.

 -- Function: regexp-quote string
     This function returns a regular expression whose only exact match
     is STRING.  Using this regular expression in ‘looking-at’ will
     succeed only if the next characters in the buffer are STRING; using
     it in a search function will succeed if the text being searched
     contains STRING.  *Note Regexp Search::.

     This allows you to request an exact string match or search when
     calling a function that wants a regular expression.

          (regexp-quote "^The cat$")
               ⇒ "\\^The cat\\$"

     One use of ‘regexp-quote’ is to combine an exact string match with
     context described as a regular expression.  For example, this
     searches for the string that is the value of STRING, surrounded by
     whitespace:

          (re-search-forward
           (concat "\\s-" (regexp-quote string) "\\s-"))

 -- Function: regexp-opt strings &optional paren
     This function returns an efficient regular expression that will
     match any of the strings in the list STRINGS.  This is useful when
     you need to make matching or searching as fast as possible—for
     example, for Font Lock mode(1).

     The optional argument PAREN can be any of the following:

     a string
          The resulting regexp is preceded by PAREN and followed by
          ‘\)’, e.g.  use ‘"\\(?1:"’ to produce an explicitly numbered
          group.

     ‘words’
          The resulting regexp is surrounded by ‘\<\(’ and ‘\)\>’.

     ‘symbols’
          The resulting regexp is surrounded by ‘\_<\(’ and ‘\)\_>’
          (this is often appropriate when matching programming-language
          keywords and the like).

     non-‘nil’
          The resulting regexp is surrounded by ‘\(’ and ‘\)’.

     ‘nil’
          The resulting regexp is surrounded by ‘\(?:’ and ‘\)’, if it
          is necessary to ensure that a postfix operator appended to it
          will apply to the whole expression.

     The resulting regexp of ‘regexp-opt’ is equivalent to but usually
     more efficient than that of a simplified version:

          (defun simplified-regexp-opt (strings &optional paren)
           (let ((parens
                  (cond
                   ((stringp paren)       (cons paren "\\)"))
                   ((eq paren 'words)    '("\\<\\(" . "\\)\\>"))
                   ((eq paren 'symbols) '("\\_<\\(" . "\\)\\_>"))
                   ((null paren)          '("\\(?:" . "\\)"))
                   (t                       '("\\(" . "\\)")))))
             (concat (car paren)
                     (mapconcat 'regexp-quote strings "\\|")
                     (cdr paren))))

 -- Function: regexp-opt-depth regexp
     This function returns the total number of grouping constructs
     (parenthesized expressions) in REGEXP.  This does not include shy
     groups (*note Regexp Backslash::).

 -- Function: regexp-opt-charset chars
     This function returns a regular expression matching a character in
     the list of characters CHARS.

          (regexp-opt-charset '(?a ?b ?c ?d ?e))
               ⇒ "[a-e]"

   ---------- Footnotes ----------

   (1) Note that ‘regexp-opt’ does not guarantee that its result is
absolutely the most efficient form possible.  A hand-tuned regular
expression can sometimes be slightly more efficient, but is almost never
worth the effort.


File: elisp.info,  Node: Regexp Search,  Next: POSIX Regexps,  Prev: Regular Expressions,  Up: Searching and Matching

34.4 Regular Expression Searching
=================================

In GNU Emacs, you can search for the next match for a regular expression
(*note Syntax of Regexps::) either incrementally or not.  For
incremental search commands, see *note Regular Expression Search:
(emacs)Regexp Search.  Here we describe only the search functions useful
in programs.  The principal one is ‘re-search-forward’.

   These search functions convert the regular expression to multibyte if
the buffer is multibyte; they convert the regular expression to unibyte
if the buffer is unibyte.  *Note Text Representations::.

 -- Command: re-search-forward regexp &optional limit noerror count
     This function searches forward in the current buffer for a string
     of text that is matched by the regular expression REGEXP.  The
     function skips over any amount of text that is not matched by
     REGEXP, and leaves point at the end of the first match found.  It
     returns the new value of point.

     If LIMIT is non-‘nil’, it must be a position in the current buffer.
     It specifies the upper bound to the search.  No match extending
     after that position is accepted.  If LIMIT is omitted or ‘nil’, it
     defaults to the end of the accessible portion of the buffer.

     What ‘re-search-forward’ does when the search fails depends on the
     value of NOERROR:

     ‘nil’
          Signal a ‘search-failed’ error.
     ‘t’
          Do nothing and return ‘nil’.
     anything else
          Move point to LIMIT (or the end of the accessible portion of
          the buffer) and return ‘nil’.

     The argument NOERROR only affects valid searches which fail to find
     a match.  Invalid arguments cause errors regardless of NOERROR.

     If COUNT is a positive number N, the search is done N times; each
     successive search starts at the end of the previous match.  If all
     these successive searches succeed, the function call succeeds,
     moving point and returning its new value.  Otherwise the function
     call fails, with results depending on the value of NOERROR, as
     described above.  If COUNT is a negative number -N, the search is
     done N times in the opposite (backward) direction.

     In the following example, point is initially before the ‘T’.
     Evaluating the search call moves point to the end of that line
     (between the ‘t’ of ‘hat’ and the newline).

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (re-search-forward "[a-z]+" nil t 5)
               ⇒ 27

          ---------- Buffer: foo ----------
          I read "The cat in the hat★
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Command: re-search-backward regexp &optional limit noerror count
     This function searches backward in the current buffer for a string
     of text that is matched by the regular expression REGEXP, leaving
     point at the beginning of the first text found.

     This function is analogous to ‘re-search-forward’, but they are not
     simple mirror images.  ‘re-search-forward’ finds the match whose
     beginning is as close as possible to the starting point.  If
     ‘re-search-backward’ were a perfect mirror image, it would find the
     match whose end is as close as possible.  However, in fact it finds
     the match whose beginning is as close as possible (and yet ends
     before the starting point).  The reason for this is that matching a
     regular expression at a given spot always works from beginning to
     end, and starts at a specified beginning position.

     A true mirror-image of ‘re-search-forward’ would require a special
     feature for matching regular expressions from end to beginning.
     It’s not worth the trouble of implementing that.

 -- Function: string-match regexp string &optional start
     This function returns the index of the start of the first match for
     the regular expression REGEXP in STRING, or ‘nil’ if there is no
     match.  If START is non-‘nil’, the search starts at that index in
     STRING.

     For example,

          (string-match
           "quick" "The quick brown fox jumped quickly.")
               ⇒ 4
          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               ⇒ 27

     The index of the first character of the string is 0, the index of
     the second character is 1, and so on.

     If this function finds a match, the index of the first character
     beyond the match is available as ‘(match-end 0)’.  *Note Match
     Data::.

          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               ⇒ 27

          (match-end 0)
               ⇒ 32

 -- Function: string-match-p regexp string &optional start
     This predicate function does what ‘string-match’ does, but it
     avoids modifying the match data.

 -- Function: looking-at regexp
     This function determines whether the text in the current buffer
     directly following point matches the regular expression REGEXP.
     “Directly following” means precisely that: the search is “anchored”
     and it can succeed only starting with the first character following
     point.  The result is ‘t’ if so, ‘nil’ otherwise.

     This function does not move point, but it does update the match
     data.  *Note Match Data::.  If you need to test for a match without
     modifying the match data, use ‘looking-at-p’, described below.

     In this example, point is located directly before the ‘T’.  If it
     were anywhere else, the result would be ‘nil’.

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-at "The cat in the hat$")
               ⇒ t

 -- Function: looking-back regexp limit &optional greedy
     This function returns ‘t’ if REGEXP matches the text immediately
     before point (i.e., ending at point), and ‘nil’ otherwise.

     Because regular expression matching works only going forward, this
     is implemented by searching backwards from point for a match that
     ends at point.  That can be quite slow if it has to search a long
     distance.  You can bound the time required by specifying a
     non-‘nil’ value for LIMIT, which says not to search before LIMIT.
     In this case, the match that is found must begin at or after LIMIT.
     Here’s an example:

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-back "read \"" 3)
               ⇒ t
          (looking-back "read \"" 4)
               ⇒ nil

     If GREEDY is non-‘nil’, this function extends the match backwards
     as far as possible, stopping when a single additional previous
     character cannot be part of a match for REGEXP.  When the match is
     extended, its starting position is allowed to occur before LIMIT.

     As a general recommendation, try to avoid using ‘looking-back’
     wherever possible, since it is slow.  For this reason, there are no
     plans to add a ‘looking-back-p’ function.

 -- Function: looking-at-p regexp
     This predicate function works like ‘looking-at’, but without
     updating the match data.

 -- Variable: search-spaces-regexp
     If this variable is non-‘nil’, it should be a regular expression
     that says how to search for whitespace.  In that case, any group of
     spaces in a regular expression being searched for stands for use of
     this regular expression.  However, spaces inside of constructs such
     as ‘[...]’ and ‘*’, ‘+’, ‘?’ are not affected by
     ‘search-spaces-regexp’.

     Since this variable affects all regular expression search and match
     constructs, you should bind it temporarily for as small as possible
     a part of the code.


File: elisp.info,  Node: POSIX Regexps,  Next: Match Data,  Prev: Regexp Search,  Up: Searching and Matching

34.5 POSIX Regular Expression Searching
=======================================

The usual regular expression functions do backtracking when necessary to
handle the ‘\|’ and repetition constructs, but they continue this only
until they find _some_ match.  Then they succeed and report the first
match found.

   This section describes alternative search functions which perform the
full backtracking specified by the POSIX standard for regular expression
matching.  They continue backtracking until they have tried all
possibilities and found all matches, so they can report the longest
match, as required by POSIX.  This is much slower, so use these
functions only when you really need the longest match.

   The POSIX search and match functions do not properly support the
non-greedy repetition operators (*note non-greedy: Regexp Special.).
This is because POSIX backtracking conflicts with the semantics of
non-greedy repetition.

 -- Command: posix-search-forward regexp &optional limit noerror count
     This is like ‘re-search-forward’ except that it performs the full
     backtracking specified by the POSIX standard for regular expression
     matching.

 -- Command: posix-search-backward regexp &optional limit noerror count
     This is like ‘re-search-backward’ except that it performs the full
     backtracking specified by the POSIX standard for regular expression
     matching.

 -- Function: posix-looking-at regexp
     This is like ‘looking-at’ except that it performs the full
     backtracking specified by the POSIX standard for regular expression
     matching.

 -- Function: posix-string-match regexp string &optional start
     This is like ‘string-match’ except that it performs the full
     backtracking specified by the POSIX standard for regular expression
     matching.


File: elisp.info,  Node: Match Data,  Next: Search and Replace,  Prev: POSIX Regexps,  Up: Searching and Matching

34.6 The Match Data
===================

Emacs keeps track of the start and end positions of the segments of text
found during a search; this is called the “match data”.  Thanks to the
match data, you can search for a complex pattern, such as a date in a
mail message, and then extract parts of the match under control of the
pattern.

   Because the match data normally describe the most recent search only,
you must be careful not to do another search inadvertently between the
search you wish to refer back to and the use of the match data.  If you
can’t avoid another intervening search, you must save and restore the
match data around it, to prevent it from being overwritten.

   Notice that all functions are allowed to overwrite the match data
unless they’re explicitly documented not to do so.  A consequence is
that functions that are run implicitly in the background (*note
Timers::, and *note Idle Timers::) should likely save and restore the
match data explicitly.

* Menu:

* Replacing Match::       Replacing a substring that was matched.
* Simple Match Data::     Accessing single items of match data,
                            such as where a particular subexpression started.
* Entire Match Data::     Accessing the entire match data at once, as a list.
* Saving Match Data::     Saving and restoring the match data.


File: elisp.info,  Node: Replacing Match,  Next: Simple Match Data,  Up: Match Data

34.6.1 Replacing the Text that Matched
--------------------------------------

This function replaces all or part of the text matched by the last
search.  It works by means of the match data.

 -- Function: replace-match replacement &optional fixedcase literal
          string subexp
     This function performs a replacement operation on a buffer or
     string.

     If you did the last search in a buffer, you should omit the STRING
     argument or specify ‘nil’ for it, and make sure that the current
     buffer is the one in which you performed the last search.  Then
     this function edits the buffer, replacing the matched text with
     REPLACEMENT.  It leaves point at the end of the replacement text.

     If you performed the last search on a string, pass the same string
     as STRING.  Then this function returns a new string, in which the
     matched text is replaced by REPLACEMENT.

     If FIXEDCASE is non-‘nil’, then ‘replace-match’ uses the
     replacement text without case conversion; otherwise, it converts
     the replacement text depending upon the capitalization of the text
     to be replaced.  If the original text is all upper case, this
     converts the replacement text to upper case.  If all words of the
     original text are capitalized, this capitalizes all the words of
     the replacement text.  If all the words are one-letter and they are
     all upper case, they are treated as capitalized words rather than
     all-upper-case words.

     If LITERAL is non-‘nil’, then REPLACEMENT is inserted exactly as it
     is, the only alterations being case changes as needed.  If it is
     ‘nil’ (the default), then the character ‘\’ is treated specially.
     If a ‘\’ appears in REPLACEMENT, then it must be part of one of the
     following sequences:

     ‘\&’
          This stands for the entire text being replaced.

     ‘\N’, where N is a digit
          This stands for the text that matched the Nth subexpression in
          the original regexp.  Subexpressions are those expressions
          grouped inside ‘\(...\)’.  If the Nth subexpression never
          matched, an empty string is substituted.

     ‘\\’
          This stands for a single ‘\’ in the replacement text.

     ‘\?’
          This stands for itself (for compatibility with
          ‘replace-regexp’ and related commands; *note (emacs)Regexp
          Replace::).

     Any other character following ‘\’ signals an error.

     The substitutions performed by ‘\&’ and ‘\N’ occur after case
     conversion, if any.  Therefore, the strings they substitute are
     never case-converted.

     If SUBEXP is non-‘nil’, that says to replace just subexpression
     number SUBEXP of the regexp that was matched, not the entire match.
     For example, after matching ‘foo \(ba*r\)’, calling ‘replace-match’
     with 1 as SUBEXP means to replace just the text that matched
     ‘\(ba*r\)’.

 -- Function: match-substitute-replacement replacement &optional
          fixedcase literal string subexp
     This function returns the text that would be inserted into the
     buffer by ‘replace-match’, but without modifying the buffer.  It is
     useful if you want to present the user with actual replacement
     result, with constructs like ‘\N’ or ‘\&’ substituted with matched
     groups.  Arguments REPLACEMENT and optional FIXEDCASE, LITERAL,
     STRING and SUBEXP have the same meaning as for ‘replace-match’.


File: elisp.info,  Node: Simple Match Data,  Next: Entire Match Data,  Prev: Replacing Match,  Up: Match Data

34.6.2 Simple Match Data Access
-------------------------------

This section explains how to use the match data to find out what was
matched by the last search or match operation, if it succeeded.

   You can ask about the entire matching text, or about a particular
parenthetical subexpression of a regular expression.  The COUNT argument
in the functions below specifies which.  If COUNT is zero, you are
asking about the entire match.  If COUNT is positive, it specifies which
subexpression you want.

   Recall that the subexpressions of a regular expression are those
expressions grouped with escaped parentheses, ‘\(...\)’.  The COUNTth
subexpression is found by counting occurrences of ‘\(’ from the
beginning of the whole regular expression.  The first subexpression is
numbered 1, the second 2, and so on.  Only regular expressions can have
subexpressions—after a simple string search, the only information
available is about the entire match.

   Every successful search sets the match data.  Therefore, you should
query the match data immediately after searching, before calling any
other function that might perform another search.  Alternatively, you
may save and restore the match data (*note Saving Match Data::) around
the call to functions that could perform another search.  Or use the
functions that explicitly do not modify the match data; e.g.,
‘string-match-p’.

   A search which fails may or may not alter the match data.  In the
current implementation, it does not, but we may change it in the future.
Don’t try to rely on the value of the match data after a failing search.

 -- Function: match-string count &optional in-string
     This function returns, as a string, the text matched in the last
     search or match operation.  It returns the entire text if COUNT is
     zero, or just the portion corresponding to the COUNTth
     parenthetical subexpression, if COUNT is positive.

     If the last such operation was done against a string with
     ‘string-match’, then you should pass the same string as the
     argument IN-STRING.  After a buffer search or match, you should
     omit IN-STRING or pass ‘nil’ for it; but you should make sure that
     the current buffer when you call ‘match-string’ is the one in which
     you did the searching or matching.  Failure to follow this advice
     will lead to incorrect results.

     The value is ‘nil’ if COUNT is out of range, or for a subexpression
     inside a ‘\|’ alternative that wasn’t used or a repetition that
     repeated zero times.

 -- Function: match-string-no-properties count &optional in-string
     This function is like ‘match-string’ except that the result has no
     text properties.

 -- Function: match-beginning count
     If the last regular expression search found a match, this function
     returns the position of the start of the matching text or of a
     subexpression of it.

     If COUNT is zero, then the value is the position of the start of
     the entire match.  Otherwise, COUNT specifies a subexpression in
     the regular expression, and the value of the function is the
     starting position of the match for that subexpression.

     The value is ‘nil’ for a subexpression inside a ‘\|’ alternative
     that wasn’t used or a repetition that repeated zero times.

 -- Function: match-end count
     This function is like ‘match-beginning’ except that it returns the
     position of the end of the match, rather than the position of the
     beginning.

   Here is an example of using the match data, with a comment showing
the positions within the text:

     (string-match "\\(qu\\)\\(ick\\)"
                   "The quick fox jumped quickly.")
                   ;0123456789
          ⇒ 4

     (match-string 0 "The quick fox jumped quickly.")
          ⇒ "quick"
     (match-string 1 "The quick fox jumped quickly.")
          ⇒ "qu"
     (match-string 2 "The quick fox jumped quickly.")
          ⇒ "ick"

     (match-beginning 1)       ; The beginning of the match
          ⇒ 4                 ;   with ‘qu’ is at index 4.

     (match-beginning 2)       ; The beginning of the match
          ⇒ 6                 ;   with ‘ick’ is at index 6.

     (match-end 1)             ; The end of the match
          ⇒ 6                 ;   with ‘qu’ is at index 6.

     (match-end 2)             ; The end of the match
          ⇒ 9                 ;   with ‘ick’ is at index 9.

   Here is another example.  Point is initially located at the beginning
of the line.  Searching moves point to between the space and the word
‘in’.  The beginning of the entire match is at the 9th character of the
buffer (‘T’), and the beginning of the match for the first subexpression
is at the 13th character (‘c’).

     (list
       (re-search-forward "The \\(cat \\)")
       (match-beginning 0)
       (match-beginning 1))
         ⇒ (17 9 13)

     ---------- Buffer: foo ----------
     I read "The cat ★in the hat comes back" twice.
             ^   ^
             9  13
     ---------- Buffer: foo ----------

(In this case, the index returned is a buffer position; the first
character of the buffer counts as 1.)


File: elisp.info,  Node: Entire Match Data,  Next: Saving Match Data,  Prev: Simple Match Data,  Up: Match Data

34.6.3 Accessing the Entire Match Data
--------------------------------------

The functions ‘match-data’ and ‘set-match-data’ read or write the entire
match data, all at once.

 -- Function: match-data &optional integers reuse reseat
     This function returns a list of positions (markers or integers)
     that record all the information on the text that the last search
     matched.  Element zero is the position of the beginning of the
     match for the whole expression; element one is the position of the
     end of the match for the expression.  The next two elements are the
     positions of the beginning and end of the match for the first
     subexpression, and so on.  In general, element number 2N
     corresponds to ‘(match-beginning N)’; and element number 2N + 1
     corresponds to ‘(match-end N)’.

     Normally all the elements are markers or ‘nil’, but if INTEGERS is
     non-‘nil’, that means to use integers instead of markers.  (In that
     case, the buffer itself is appended as an additional element at the
     end of the list, to facilitate complete restoration of the match
     data.)  If the last match was done on a string with ‘string-match’,
     then integers are always used, since markers can’t point into a
     string.

     If REUSE is non-‘nil’, it should be a list.  In that case,
     ‘match-data’ stores the match data in REUSE.  That is, REUSE is
     destructively modified.  REUSE does not need to have the right
     length.  If it is not long enough to contain the match data, it is
     extended.  If it is too long, the length of REUSE stays the same,
     but the elements that were not used are set to ‘nil’.  The purpose
     of this feature is to reduce the need for garbage collection.

     If RESEAT is non-‘nil’, all markers on the REUSE list are reseated
     to point to nowhere.

     As always, there must be no possibility of intervening searches
     between the call to a search function and the call to ‘match-data’
     that is intended to access the match data for that search.

          (match-data)
               ⇒  (#<marker at 9 in foo>
                    #<marker at 17 in foo>
                    #<marker at 13 in foo>
                    #<marker at 17 in foo>)

 -- Function: set-match-data match-list &optional reseat
     This function sets the match data from the elements of MATCH-LIST,
     which should be a list that was the value of a previous call to
     ‘match-data’.  (More precisely, anything that has the same format
     will work.)

     If MATCH-LIST refers to a buffer that doesn’t exist, you don’t get
     an error; that sets the match data in a meaningless but harmless
     way.

     If RESEAT is non-‘nil’, all markers on the MATCH-LIST list are
     reseated to point to nowhere.

     ‘store-match-data’ is a semi-obsolete alias for ‘set-match-data’.


File: elisp.info,  Node: Saving Match Data,  Prev: Entire Match Data,  Up: Match Data

34.6.4 Saving and Restoring the Match Data
------------------------------------------

When you call a function that may search, you may need to save and
restore the match data around that call, if you want to preserve the
match data from an earlier search for later use.  Here is an example
that shows the problem that arises if you fail to save the match data:

     (re-search-forward "The \\(cat \\)")
          ⇒ 48
     (foo)                   ; ‘foo’ does more searching.
     (match-end 0)
          ⇒ 61              ; Unexpected result—not 48!

   You can save and restore the match data with ‘save-match-data’:

 -- Macro: save-match-data body...
     This macro executes BODY, saving and restoring the match data
     around it.  The return value is the value of the last form in BODY.

   You could use ‘set-match-data’ together with ‘match-data’ to imitate
the effect of the special form ‘save-match-data’.  Here is how:

     (let ((data (match-data)))
       (unwind-protect
           ...   ; Ok to change the original match data.
         (set-match-data data)))

   Emacs automatically saves and restores the match data when it runs
process filter functions (*note Filter Functions::) and process
sentinels (*note Sentinels::).


File: elisp.info,  Node: Search and Replace,  Next: Standard Regexps,  Prev: Match Data,  Up: Searching and Matching

34.7 Search and Replace
=======================

If you want to find all matches for a regexp in part of the buffer, and
replace them, the best way is to write an explicit loop using
‘re-search-forward’ and ‘replace-match’, like this:

     (while (re-search-forward "foo[ \t]+bar" nil t)
       (replace-match "foobar"))

*Note Replacing the Text that Matched: Replacing Match, for a
description of ‘replace-match’.

   However, replacing matches in a string is more complex, especially if
you want to do it efficiently.  So Emacs provides a function to do this.

 -- Function: replace-regexp-in-string regexp rep string &optional
          fixedcase literal subexp start
     This function copies STRING and searches it for matches for REGEXP,
     and replaces them with REP.  It returns the modified copy.  If
     START is non-‘nil’, the search for matches starts at that index in
     STRING, so matches starting before that index are not changed.

     This function uses ‘replace-match’ to do the replacement, and it
     passes the optional arguments FIXEDCASE, LITERAL and SUBEXP along
     to ‘replace-match’.

     Instead of a string, REP can be a function.  In that case,
     ‘replace-regexp-in-string’ calls REP for each match, passing the
     text of the match as its sole argument.  It collects the value REP
     returns and passes that to ‘replace-match’ as the replacement
     string.  The match data at this point are the result of matching
     REGEXP against a substring of STRING.

   If you want to write a command along the lines of ‘query-replace’,
you can use ‘perform-replace’ to do the work.

 -- Function: perform-replace from-string replacements query-flag
          regexp-flag delimited-flag &optional repeat-count map start
          end backward region-noncontiguous-p
     This function is the guts of ‘query-replace’ and related commands.
     It searches for occurrences of FROM-STRING in the text between
     positions START and END and replaces some or all of them.  If START
     is ‘nil’ (or omitted), point is used instead, and the end of the
     buffer’s accessible portion is used for END.  (If the optional
     argument BACKWARD is non-‘nil’, the search starts at END and goes
     backward.)

     If QUERY-FLAG is ‘nil’, it replaces all occurrences; otherwise, it
     asks the user what to do about each one.

     If REGEXP-FLAG is non-‘nil’, then FROM-STRING is considered a
     regular expression; otherwise, it must match literally.  If
     DELIMITED-FLAG is non-‘nil’, then only replacements surrounded by
     word boundaries are considered.

     The argument REPLACEMENTS specifies what to replace occurrences
     with.  If it is a string, that string is used.  It can also be a
     list of strings, to be used in cyclic order.

     If REPLACEMENTS is a cons cell, ‘(FUNCTION . DATA)’, this means to
     call FUNCTION after each match to get the replacement text.  This
     function is called with two arguments: DATA, and the number of
     replacements already made.

     If REPEAT-COUNT is non-‘nil’, it should be an integer.  Then it
     specifies how many times to use each of the strings in the
     REPLACEMENTS list before advancing cyclically to the next one.

     If FROM-STRING contains upper-case letters, then ‘perform-replace’
     binds ‘case-fold-search’ to ‘nil’, and it uses the REPLACEMENTS
     without altering their case.

     Normally, the keymap ‘query-replace-map’ defines the possible user
     responses for queries.  The argument MAP, if non-‘nil’, specifies a
     keymap to use instead of ‘query-replace-map’.

     Non-‘nil’ REGION-NONCONTIGUOUS-P means that the region between
     START and END is composed of noncontiguous pieces.  The most common
     example of this is a rectangular region, where the pieces are
     separated by newline characters.

     This function uses one of two functions to search for the next
     occurrence of FROM-STRING.  These functions are specified by the
     values of two variables: ‘replace-re-search-function’ and
     ‘replace-search-function’.  The former is called when the argument
     REGEXP-FLAG is non-‘nil’, the latter when it is ‘nil’.

 -- Variable: query-replace-map
     This variable holds a special keymap that defines the valid user
     responses for ‘perform-replace’ and the commands that use it, as
     well as ‘y-or-n-p’ and ‘map-y-or-n-p’.  This map is unusual in two
     ways:

        • The key bindings are not commands, just symbols that are
          meaningful to the functions that use this map.

        • Prefix keys are not supported; each key binding must be for a
          single-event key sequence.  This is because the functions
          don’t use ‘read-key-sequence’ to get the input; instead, they
          read a single event and look it up “by hand”.

   Here are the meaningful bindings for ‘query-replace-map’.  Several of
them are meaningful only for ‘query-replace’ and friends.

‘act’
     Do take the action being considered—in other words, “yes”.

‘skip’
     Do not take action for this question—in other words, “no”.

‘exit’
     Answer this question “no”, and give up on the entire series of
     questions, assuming that the answers will be “no”.

‘exit-prefix’
     Like ‘exit’, but add the key that was pressed to
     ‘unread-command-events’ (*note Event Input Misc::).

‘act-and-exit’
     Answer this question “yes”, and give up on the entire series of
     questions, assuming that subsequent answers will be “no”.

‘act-and-show’
     Answer this question “yes”, but show the results—don’t advance yet
     to the next question.

‘automatic’
     Answer this question and all subsequent questions in the series
     with “yes”, without further user interaction.

‘backup’
     Move back to the previous place that a question was asked about.

‘undo’
     Undo last replacement and move back to the place where that
     replacement was performed.

‘undo-all’
     Undo all replacements and move back to the place where the first
     replacement was performed.

‘edit’
     Enter a recursive edit to deal with this question—instead of any
     other action that would normally be taken.

‘edit-replacement’
     Edit the replacement for this question in the minibuffer.

‘delete-and-edit’
     Delete the text being considered, then enter a recursive edit to
     replace it.

‘recenter’
‘scroll-up’
‘scroll-down’
‘scroll-other-window’
‘scroll-other-window-down’
     Perform the specified window scroll operation, then ask the same
     question again.  Only ‘y-or-n-p’ and related functions use this
     answer.

‘quit’
     Perform a quit right away.  Only ‘y-or-n-p’ and related functions
     use this answer.

‘help’
     Display some help, then ask again.

 -- Variable: multi-query-replace-map
     This variable holds a keymap that extends ‘query-replace-map’ by
     providing additional keybindings that are useful in multi-buffer
     replacements.  The additional bindings are:

     ‘automatic-all’
          Answer this question and all subsequent questions in the
          series with “yes”, without further user interaction, for all
          remaining buffers.

     ‘exit-current’
          Answer this question “no”, and give up on the entire series of
          questions for the current buffer.  Continue to the next buffer
          in the sequence.

 -- Variable: replace-search-function
     This variable specifies a function that ‘perform-replace’ calls to
     search for the next string to replace.  Its default value is
     ‘search-forward’.  Any other value should name a function of 3
     arguments: the first 3 arguments of ‘search-forward’ (*note String
     Search::).

 -- Variable: replace-re-search-function
     This variable specifies a function that ‘perform-replace’ calls to
     search for the next regexp to replace.  Its default value is
     ‘re-search-forward’.  Any other value should name a function of 3
     arguments: the first 3 arguments of ‘re-search-forward’ (*note
     Regexp Search::).


File: elisp.info,  Node: Standard Regexps,  Prev: Search and Replace,  Up: Searching and Matching

34.8 Standard Regular Expressions Used in Editing
=================================================

This section describes some variables that hold regular expressions used
for certain purposes in editing:

 -- User Option: page-delimiter
     This is the regular expression describing line-beginnings that
     separate pages.  The default value is ‘"^\014"’ (i.e., ‘"^^L"’ or
     ‘"^\C-l"’); this matches a line that starts with a formfeed
     character.

   The following two regular expressions should _not_ assume the match
always starts at the beginning of a line; they should not use ‘^’ to
anchor the match.  Most often, the paragraph commands do check for a
match only at the beginning of a line, which means that ‘^’ would be
superfluous.  When there is a nonzero left margin, they accept matches
that start after the left margin.  In that case, a ‘^’ would be
incorrect.  However, a ‘^’ is harmless in modes where a left margin is
never used.

 -- User Option: paragraph-separate
     This is the regular expression for recognizing the beginning of a
     line that separates paragraphs.  (If you change this, you may have
     to change ‘paragraph-start’ also.)  The default value is
     ‘"[ \t\f]*$"’, which matches a line that consists entirely of
     spaces, tabs, and form feeds (after its left margin).

 -- User Option: paragraph-start
     This is the regular expression for recognizing the beginning of a
     line that starts _or_ separates paragraphs.  The default value is
     ‘"\f\\|[ \t]*$"’, which matches a line containing only whitespace
     or starting with a form feed (after its left margin).

 -- User Option: sentence-end
     If non-‘nil’, the value should be a regular expression describing
     the end of a sentence, including the whitespace following the
     sentence.  (All paragraph boundaries also end sentences,
     regardless.)

     If the value is ‘nil’, as it is by default, then the function
     ‘sentence-end’ constructs the regexp.  That is why you should
     always call the function ‘sentence-end’ to obtain the regexp to be
     used to recognize the end of a sentence.

 -- Function: sentence-end
     This function returns the value of the variable ‘sentence-end’, if
     non-‘nil’.  Otherwise it returns a default value based on the
     values of the variables ‘sentence-end-double-space’ (*note
     Definition of sentence-end-double-space::),
     ‘sentence-end-without-period’, and ‘sentence-end-without-space’.


File: elisp.info,  Node: Syntax Tables,  Next: Abbrevs,  Prev: Searching and Matching,  Up: Top

35 Syntax Tables
****************

A “syntax table” specifies the syntactic role of each character in a
buffer.  It can be used to determine where words, symbols, and other
syntactic constructs begin and end.  This information is used by many
Emacs facilities, including Font Lock mode (*note Font Lock Mode::) and
the various complex movement commands (*note Motion::).

* Menu:

* Basics: Syntax Basics.     Basic concepts of syntax tables.
* Syntax Descriptors::       How characters are classified.
* Syntax Table Functions::   How to create, examine and alter syntax tables.
* Syntax Properties::        Overriding syntax with text properties.
* Motion and Syntax::        Moving over characters with certain syntaxes.
* Parsing Expressions::      Parsing balanced expressions
                                using the syntax table.
* Syntax Table Internals::   How syntax table information is stored.
* Categories::               Another way of classifying character syntax.


File: elisp.info,  Node: Syntax Basics,  Next: Syntax Descriptors,  Up: Syntax Tables

35.1 Syntax Table Concepts
==========================

A syntax table is a data structure which can be used to look up the
“syntax class” and other syntactic properties of each character.  Syntax
tables are used by Lisp programs for scanning and moving across text.

   Internally, a syntax table is a char-table (*note Char-Tables::).
The element at index C describes the character with code C; its value is
a cons cell which specifies the syntax of the character in question.
*Note Syntax Table Internals::, for details.  However, instead of using
‘aset’ and ‘aref’ to modify and inspect syntax table contents, you
should usually use the higher-level functions ‘char-syntax’ and
‘modify-syntax-entry’, which are described in *note Syntax Table
Functions::.

 -- Function: syntax-table-p object
     This function returns ‘t’ if OBJECT is a syntax table.

   Each buffer has its own major mode, and each major mode has its own
idea of the syntax class of various characters.  For example, in Lisp
mode, the character ‘;’ begins a comment, but in C mode, it terminates a
statement.  To support these variations, the syntax table is local to
each buffer.  Typically, each major mode has its own syntax table, which
it installs in all buffers that use that mode.  For example, the
variable ‘emacs-lisp-mode-syntax-table’ holds the syntax table used by
Emacs Lisp mode, and ‘c-mode-syntax-table’ holds the syntax table used
by C mode.  Changing a major mode’s syntax table alters the syntax in
all of that mode’s buffers, as well as in any buffers subsequently put
in that mode.  Occasionally, several similar modes share one syntax
table.  *Note Example Major Modes::, for an example of how to set up a
syntax table.

   A syntax table can “inherit” from another syntax table, which is
called its “parent syntax table”.  A syntax table can leave the syntax
class of some characters unspecified, by giving them the “inherit”
syntax class; such a character then acquires the syntax class specified
by the parent syntax table (*note Syntax Class Table::).  Emacs defines
a “standard syntax table”, which is the default parent syntax table, and
is also the syntax table used by Fundamental mode.

 -- Function: standard-syntax-table
     This function returns the standard syntax table, which is the
     syntax table used in Fundamental mode.

   Syntax tables are not used by the Emacs Lisp reader, which has its
own built-in syntactic rules which cannot be changed.  (Some Lisp
systems provide ways to redefine the read syntax, but we decided to
leave this feature out of Emacs Lisp for simplicity.)


File: elisp.info,  Node: Syntax Descriptors,  Next: Syntax Table Functions,  Prev: Syntax Basics,  Up: Syntax Tables

35.2 Syntax Descriptors
=======================

The “syntax class” of a character describes its syntactic role.  Each
syntax table specifies the syntax class of each character.  There is no
necessary relationship between the class of a character in one syntax
table and its class in any other table.

   Each syntax class is designated by a mnemonic character, which serves
as the name of the class when you need to specify a class.  Usually,
this designator character is one that is often assigned that class;
however, its meaning as a designator is unvarying and independent of
what syntax that character currently has.  Thus, ‘\’ as a designator
character always stands for escape character syntax, regardless of
whether the ‘\’ character actually has that syntax in the current syntax
table.  *Note Syntax Class Table::, for a list of syntax classes and
their designator characters.

   A “syntax descriptor” is a Lisp string that describes the syntax
class and other syntactic properties of a character.  When you want to
modify the syntax of a character, that is done by calling the function
‘modify-syntax-entry’ and passing a syntax descriptor as one of its
arguments (*note Syntax Table Functions::).

   The first character in a syntax descriptor must be a syntax class
designator character.  The second character, if present, specifies a
matching character (e.g., in Lisp, the matching character for ‘(’ is
‘)’); a space specifies that there is no matching character.  Then come
characters specifying additional syntax properties (*note Syntax
Flags::).

   If no matching character or flags are needed, only one character
(specifying the syntax class) is sufficient.

   For example, the syntax descriptor for the character ‘*’ in C mode is
‘". 23"’ (i.e., punctuation, matching character slot unused, second
character of a comment-starter, first character of a comment-ender), and
the entry for ‘/’ is ‘. 14’ (i.e., punctuation, matching character slot
unused, first character of a comment-starter, second character of a
comment-ender).

   Emacs also defines “raw syntax descriptors”, which are used to
describe syntax classes at a lower level.  *Note Syntax Table
Internals::.

* Menu:

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.


File: elisp.info,  Node: Syntax Class Table,  Next: Syntax Flags,  Up: Syntax Descriptors

35.2.1 Table of Syntax Classes
------------------------------

Here is a table of syntax classes, the characters that designate them,
their meanings, and examples of their use.

Whitespace characters: ‘ ’ or ‘-’
     Characters that separate symbols and words from each other.
     Typically, whitespace characters have no other syntactic
     significance, and multiple whitespace characters are syntactically
     equivalent to a single one.  Space, tab, and formfeed are
     classified as whitespace in almost all major modes.

     This syntax class can be designated by either ‘ ’ or ‘-’.  Both
     designators are equivalent.

Word constituents: ‘w’
     Parts of words in human languages.  These are typically used in
     variable and command names in programs.  All upper- and lower-case
     letters, and the digits, are typically word constituents.

Symbol constituents: ‘_’
     Extra characters used in variable and command names along with word
     constituents.  Examples include the characters ‘$&*+-_<>’ in Lisp
     mode, which may be part of a symbol name even though they are not
     part of English words.  In standard C, the only
     non-word-constituent character that is valid in symbols is
     underscore (‘_’).

Punctuation characters: ‘.’
     Characters used as punctuation in a human language, or used in a
     programming language to separate symbols from one another.  Some
     programming language modes, such as Emacs Lisp mode, have no
     characters in this class since the few characters that are not
     symbol or word constituents all have other uses.  Other programming
     language modes, such as C mode, use punctuation syntax for
     operators.

Open parenthesis characters: ‘(’
Close parenthesis characters: ‘)’
     Characters used in dissimilar pairs to surround sentences or
     expressions.  Such a grouping is begun with an open parenthesis
     character and terminated with a close.  Each open parenthesis
     character matches a particular close parenthesis character, and
     vice versa.  Normally, Emacs indicates momentarily the matching
     open parenthesis when you insert a close parenthesis.  *Note
     Blinking::.

     In human languages, and in C code, the parenthesis pairs are ‘()’,
     ‘[]’, and ‘{}’.  In Emacs Lisp, the delimiters for lists and
     vectors (‘()’ and ‘[]’) are classified as parenthesis characters.

String quotes: ‘"’
     Characters used to delimit string constants.  The same string quote
     character appears at the beginning and the end of a string.  Such
     quoted strings do not nest.

     The parsing facilities of Emacs consider a string as a single
     token.  The usual syntactic meanings of the characters in the
     string are suppressed.

     The Lisp modes have two string quote characters: double-quote (‘"’)
     and vertical bar (‘|’).  ‘|’ is not used in Emacs Lisp, but it is
     used in Common Lisp.  C also has two string quote characters:
     double-quote for strings, and apostrophe (‘'’) for character
     constants.

     Human text has no string quote characters.  We do not want
     quotation marks to turn off the usual syntactic properties of other
     characters in the quotation.

Escape-syntax characters: ‘\’
     Characters that start an escape sequence, such as is used in string
     and character constants.  The character ‘\’ belongs to this class
     in both C and Lisp.  (In C, it is used thus only inside strings,
     but it turns out to cause no trouble to treat it this way
     throughout C code.)

     Characters in this class count as part of words if
     ‘words-include-escapes’ is non-‘nil’.  *Note Word Motion::.

Character quotes: ‘/’
     Characters used to quote the following character so that it loses
     its normal syntactic meaning.  This differs from an escape
     character in that only the character immediately following is ever
     affected.

     Characters in this class count as part of words if
     ‘words-include-escapes’ is non-‘nil’.  *Note Word Motion::.

     This class is used for backslash in TeX mode.

Paired delimiters: ‘$’
     Similar to string quote characters, except that the syntactic
     properties of the characters between the delimiters are not
     suppressed.  Only TeX mode uses a paired delimiter presently—the
     ‘$’ that both enters and leaves math mode.

Expression prefixes: ‘'’
     Characters used for syntactic operators that are considered as part
     of an expression if they appear next to one.  In Lisp modes, these
     characters include the apostrophe, ‘'’ (used for quoting), the
     comma, ‘,’ (used in macros), and ‘#’ (used in the read syntax for
     certain data types).

Comment starters: ‘<’
Comment enders: ‘>’
     Characters used in various languages to delimit comments.  Human
     text has no comment characters.  In Lisp, the semicolon (‘;’)
     starts a comment and a newline or formfeed ends one.

Inherit standard syntax: ‘@’
     This syntax class does not specify a particular syntax.  It says to
     look in the standard syntax table to find the syntax of this
     character.

Generic comment delimiters: ‘!’
     Characters that start or end a special kind of comment.  _Any_
     generic comment delimiter matches _any_ generic comment delimiter,
     but they cannot match a comment starter or comment ender; generic
     comment delimiters can only match each other.

     This syntax class is primarily meant for use with the
     ‘syntax-table’ text property (*note Syntax Properties::).  You can
     mark any range of characters as forming a comment, by giving the
     first and last characters of the range ‘syntax-table’ properties
     identifying them as generic comment delimiters.

Generic string delimiters: ‘|’
     Characters that start or end a string.  This class differs from the
     string quote class in that _any_ generic string delimiter can match
     any other generic string delimiter; but they do not match ordinary
     string quote characters.

     This syntax class is primarily meant for use with the
     ‘syntax-table’ text property (*note Syntax Properties::).  You can
     mark any range of characters as forming a string constant, by
     giving the first and last characters of the range ‘syntax-table’
     properties identifying them as generic string delimiters.


File: elisp.info,  Node: Syntax Flags,  Prev: Syntax Class Table,  Up: Syntax Descriptors

35.2.2 Syntax Flags
-------------------

In addition to the classes, entries for characters in a syntax table can
specify flags.  There are eight possible flags, represented by the
characters ‘1’, ‘2’, ‘3’, ‘4’, ‘b’, ‘c’, ‘n’, and ‘p’.

   All the flags except ‘p’ are used to describe comment delimiters.
The digit flags are used for comment delimiters made up of 2 characters.
They indicate that a character can _also_ be part of a comment sequence,
in addition to the syntactic properties associated with its character
class.  The flags are independent of the class and each other for the
sake of characters such as ‘*’ in C mode, which is a punctuation
character, _and_ the second character of a start-of-comment sequence
(‘/*’), _and_ the first character of an end-of-comment sequence (‘*/’).
The flags ‘b’, ‘c’, and ‘n’ are used to qualify the corresponding
comment delimiter.

   Here is a table of the possible flags for a character C, and what
they mean:

   • ‘1’ means C is the start of a two-character comment-start sequence.

   • ‘2’ means C is the second character of such a sequence.

   • ‘3’ means C is the start of a two-character comment-end sequence.

   • ‘4’ means C is the second character of such a sequence.

   • ‘b’ means that C as a comment delimiter belongs to the alternative
     “b” comment style.  For a two-character comment starter, this flag
     is only significant on the second char, and for a 2-character
     comment ender it is only significant on the first char.

   • ‘c’ means that C as a comment delimiter belongs to the alternative
     “c” comment style.  For a two-character comment delimiter, ‘c’ on
     either character makes it of style “c”.

   • ‘n’ on a comment delimiter character specifies that this kind of
     comment can be nested.  Inside such a comment, only comments of the
     same style will be recognized.  For a two-character comment
     delimiter, ‘n’ on either character makes it nestable.

     Emacs supports several comment styles simultaneously in any one
     syntax table.  A comment style is a set of flags ‘b’, ‘c’, and ‘n’,
     so there can be up to 8 different comment styles.  Each comment
     delimiter has a style and only matches comment delimiters of the
     same style.  Thus if a comment starts with the comment-start
     sequence of style “bn”, it will extend until the next matching
     comment-end sequence of style “bn”.

     The appropriate comment syntax settings for C++ can be as follows:

     ‘/’
          ‘124’
     ‘*’
          ‘23b’
     newline
          ‘>’

     This defines four comment-delimiting sequences:

     ‘/*’
          This is a comment-start sequence for “b” style because the
          second character, ‘*’, has the ‘b’ flag.

     ‘//’
          This is a comment-start sequence for “a” style because the
          second character, ‘/’, does not have the ‘b’ flag.

     ‘*/’
          This is a comment-end sequence for “b” style because the first
          character, ‘*’, has the ‘b’ flag.

     newline
          This is a comment-end sequence for “a” style, because the
          newline character does not have the ‘b’ flag.

   • ‘p’ identifies an additional prefix character for Lisp syntax.
     These characters are treated as whitespace when they appear between
     expressions.  When they appear within an expression, they are
     handled according to their usual syntax classes.

     The function ‘backward-prefix-chars’ moves back over these
     characters, as well as over characters whose primary syntax class
     is prefix (‘'’).  *Note Motion and Syntax::.


File: elisp.info,  Node: Syntax Table Functions,  Next: Syntax Properties,  Prev: Syntax Descriptors,  Up: Syntax Tables

35.3 Syntax Table Functions
===========================

In this section we describe functions for creating, accessing and
altering syntax tables.

 -- Function: make-syntax-table &optional table
     This function creates a new syntax table.  If TABLE is non-‘nil’,
     the parent of the new syntax table is TABLE; otherwise, the parent
     is the standard syntax table.

     In the new syntax table, all characters are initially given the
     “inherit” (‘@’) syntax class, i.e., their syntax is inherited from
     the parent table (*note Syntax Class Table::).

 -- Function: copy-syntax-table &optional table
     This function constructs a copy of TABLE and returns it.  If TABLE
     is omitted or ‘nil’, it returns a copy of the standard syntax
     table.  Otherwise, an error is signaled if TABLE is not a syntax
     table.

 -- Command: modify-syntax-entry char syntax-descriptor &optional table
     This function sets the syntax entry for CHAR according to
     SYNTAX-DESCRIPTOR.  CHAR must be a character, or a cons cell of the
     form ‘(MIN . MAX)’; in the latter case, the function sets the
     syntax entries for all characters in the range between MIN and MAX,
     inclusive.

     The syntax is changed only for TABLE, which defaults to the current
     buffer’s syntax table, and not in any other syntax table.

     The argument SYNTAX-DESCRIPTOR is a syntax descriptor, i.e., a
     string whose first character is a syntax class designator and whose
     second and subsequent characters optionally specify a matching
     character and syntax flags.  *Note Syntax Descriptors::.  An error
     is signaled if SYNTAX-DESCRIPTOR is not a valid syntax descriptor.

     This function always returns ‘nil’.  The old syntax information in
     the table for this character is discarded.

     Examples:

          ;; Put the space character in class whitespace.
          (modify-syntax-entry ?\s " ")
               ⇒ nil

          ;; Make ‘$’ an open parenthesis character,
          ;;   with ‘^’ as its matching close.
          (modify-syntax-entry ?$ "(^")
               ⇒ nil

          ;; Make ‘^’ a close parenthesis character,
          ;;   with ‘$’ as its matching open.
          (modify-syntax-entry ?^ ")$")
               ⇒ nil

          ;; Make ‘/’ a punctuation character,
          ;;   the first character of a start-comment sequence,
          ;;   and the second character of an end-comment sequence.
          ;;   This is used in C mode.
          (modify-syntax-entry ?/ ". 14")
               ⇒ nil

 -- Function: char-syntax character
     This function returns the syntax class of CHARACTER, represented by
     its designator character (*note Syntax Class Table::).  This
     returns _only_ the class, not its matching character or syntax
     flags.

     The following examples apply to C mode.  (We use ‘string’ to make
     it easier to see the character returned by ‘char-syntax’.)

          ;; Space characters have whitespace syntax class.
          (string (char-syntax ?\s))
               ⇒ " "

          ;; Forward slash characters have punctuation syntax.
          ;; Note that this char-syntax call does not reveal
          ;; that it is also part of comment-start and -end sequences.
          (string (char-syntax ?/))
               ⇒ "."

          ;; Open parenthesis characters have open parenthesis syntax.
          ;; Note that this char-syntax call does not reveal that
          ;; it has a matching character, ‘)’.
          (string (char-syntax ?\())
               ⇒ "("

 -- Function: set-syntax-table table
     This function makes TABLE the syntax table for the current buffer.
     It returns TABLE.

 -- Function: syntax-table
     This function returns the current syntax table, which is the table
     for the current buffer.

 -- Command: describe-syntax &optional buffer
     This command displays the contents of the syntax table of BUFFER
     (by default, the current buffer) in a help buffer.

 -- Macro: with-syntax-table table body...
     This macro executes BODY using TABLE as the current syntax table.
     It returns the value of the last form in BODY, after restoring the
     old current syntax table.

     Since each buffer has its own current syntax table, we should make
     that more precise: ‘with-syntax-table’ temporarily alters the
     current syntax table of whichever buffer is current at the time the
     macro execution starts.  Other buffers are not affected.


File: elisp.info,  Node: Syntax Properties,  Next: Motion and Syntax,  Prev: Syntax Table Functions,  Up: Syntax Tables

35.4 Syntax Properties
======================

When the syntax table is not flexible enough to specify the syntax of a
language, you can override the syntax table for specific character
occurrences in the buffer, by applying a ‘syntax-table’ text property.
*Note Text Properties::, for how to apply text properties.

   The valid values of ‘syntax-table’ text property are:

SYNTAX-TABLE
     If the property value is a syntax table, that table is used instead
     of the current buffer’s syntax table to determine the syntax for
     the underlying text character.

‘(SYNTAX-CODE . MATCHING-CHAR)’
     A cons cell of this format is a raw syntax descriptor (*note Syntax
     Table Internals::), which directly specifies a syntax class for the
     underlying text character.

‘nil’
     If the property is ‘nil’, the character’s syntax is determined from
     the current syntax table in the usual way.

 -- Variable: parse-sexp-lookup-properties
     If this is non-‘nil’, the syntax scanning functions, like
     ‘forward-sexp’, pay attention to syntax text properties.  Otherwise
     they use only the current syntax table.

 -- Variable: syntax-propertize-function
     This variable, if non-‘nil’, should store a function for applying
     ‘syntax-table’ properties to a specified stretch of text.  It is
     intended to be used by major modes to install a function which
     applies ‘syntax-table’ properties in some mode-appropriate way.

     The function is called by ‘syntax-ppss’ (*note Position Parse::),
     and by Font Lock mode during syntactic fontification (*note
     Syntactic Font Lock::).  It is called with two arguments, START and
     END, which are the starting and ending positions of the text on
     which it should act.  It is allowed to call ‘syntax-ppss’ on any
     position before END.  However, it should not call
     ‘syntax-ppss-flush-cache’; so, it is not allowed to call
     ‘syntax-ppss’ on some position and later modify the buffer at an
     earlier position.

 -- Variable: syntax-propertize-extend-region-functions
     This abnormal hook is run by the syntax parsing code prior to
     calling ‘syntax-propertize-function’.  Its role is to help locate
     safe starting and ending buffer positions for passing to
     ‘syntax-propertize-function’.  For example, a major mode can add a
     function to this hook to identify multi-line syntactic constructs,
     and ensure that the boundaries do not fall in the middle of one.

     Each function in this hook should accept two arguments, START and
     END.  It should return either a cons cell of two adjusted buffer
     positions, ‘(NEW-START . NEW-END)’, or ‘nil’ if no adjustment is
     necessary.  The hook functions are run in turn, repeatedly, until
     they all return ‘nil’.


File: elisp.info,  Node: Motion and Syntax,  Next: Parsing Expressions,  Prev: Syntax Properties,  Up: Syntax Tables

35.5 Motion and Syntax
======================

This section describes functions for moving across characters that have
certain syntax classes.

 -- Function: skip-syntax-forward syntaxes &optional limit
     This function moves point forward across characters having syntax
     classes mentioned in SYNTAXES (a string of syntax class
     characters).  It stops when it encounters the end of the buffer, or
     position LIMIT (if specified), or a character it is not supposed to
     skip.

     If SYNTAXES starts with ‘^’, then the function skips characters
     whose syntax is _not_ in SYNTAXES.

     The return value is the distance traveled, which is a nonnegative
     integer.

 -- Function: skip-syntax-backward syntaxes &optional limit
     This function moves point backward across characters whose syntax
     classes are mentioned in SYNTAXES.  It stops when it encounters the
     beginning of the buffer, or position LIMIT (if specified), or a
     character it is not supposed to skip.

     If SYNTAXES starts with ‘^’, then the function skips characters
     whose syntax is _not_ in SYNTAXES.

     The return value indicates the distance traveled.  It is an integer
     that is zero or less.

 -- Function: backward-prefix-chars
     This function moves point backward over any number of characters
     with expression prefix syntax.  This includes both characters in
     the expression prefix syntax class, and characters with the ‘p’
     flag.


File: elisp.info,  Node: Parsing Expressions,  Next: Syntax Table Internals,  Prev: Motion and Syntax,  Up: Syntax Tables

35.6 Parsing Expressions
========================

This section describes functions for parsing and scanning balanced
expressions.  We will refer to such expressions as “sexps”, following
the terminology of Lisp, even though these functions can act on
languages other than Lisp.  Basically, a sexp is either a balanced
parenthetical grouping, a string, or a symbol (i.e., a sequence of
characters whose syntax is either word constituent or symbol
constituent).  However, characters in the expression prefix syntax class
(*note Syntax Class Table::) are treated as part of the sexp if they
appear next to it.

   The syntax table controls the interpretation of characters, so these
functions can be used for Lisp expressions when in Lisp mode and for C
expressions when in C mode.  *Note List Motion::, for convenient
higher-level functions for moving over balanced expressions.

   A character’s syntax controls how it changes the state of the parser,
rather than describing the state itself.  For example, a string
delimiter character toggles the parser state between in-string and
in-code, but the syntax of characters does not directly say whether they
are inside a string.  For example (note that 15 is the syntax code for
generic string delimiters),

     (put-text-property 1 9 'syntax-table '(15 . nil))

does not tell Emacs that the first eight chars of the current buffer are
a string, but rather that they are all string delimiters.  As a result,
Emacs treats them as four consecutive empty string constants.

* Menu:

* Motion via Parsing::       Motion functions that work by parsing.
* Position Parse::           Determining the syntactic state of a position.
* Parser State::             How Emacs represents a syntactic state.
* Low-Level Parsing::        Parsing across a specified region.
* Control Parsing::          Parameters that affect parsing.


File: elisp.info,  Node: Motion via Parsing,  Next: Position Parse,  Up: Parsing Expressions

35.6.1 Motion Commands Based on Parsing
---------------------------------------

This section describes simple point-motion functions that operate based
on parsing expressions.

 -- Function: scan-lists from count depth
     This function scans forward COUNT balanced parenthetical groupings
     from position FROM.  It returns the position where the scan stops.
     If COUNT is negative, the scan moves backwards.

     If DEPTH is nonzero, treat the starting position as being DEPTH
     parentheses deep.  The scanner moves forward or backward through
     the buffer until the depth changes to zero COUNT times.  Hence, a
     positive value for DEPTH has the effect of moving out DEPTH levels
     of parenthesis from the starting position, while a negative DEPTH
     has the effect of moving deeper by -DEPTH levels of parenthesis.

     Scanning ignores comments if ‘parse-sexp-ignore-comments’ is
     non-‘nil’.

     If the scan reaches the beginning or end of the accessible part of
     the buffer before it has scanned over COUNT parenthetical
     groupings, the return value is ‘nil’ if the depth at that point is
     zero; if the depth is non-zero, a ‘scan-error’ error is signaled.

 -- Function: scan-sexps from count
     This function scans forward COUNT sexps from position FROM.  It
     returns the position where the scan stops.  If COUNT is negative,
     the scan moves backwards.

     Scanning ignores comments if ‘parse-sexp-ignore-comments’ is
     non-‘nil’.

     If the scan reaches the beginning or end of (the accessible part
     of) the buffer while in the middle of a parenthetical grouping, an
     error is signaled.  If it reaches the beginning or end between
     groupings but before count is used up, ‘nil’ is returned.

 -- Function: forward-comment count
     This function moves point forward across COUNT complete comments
     (that is, including the starting delimiter and the terminating
     delimiter if any), plus any whitespace encountered on the way.  It
     moves backward if COUNT is negative.  If it encounters anything
     other than a comment or whitespace, it stops, leaving point at the
     place where it stopped.  This includes (for instance) finding the
     end of a comment when moving forward and expecting the beginning of
     one.  The function also stops immediately after moving over the
     specified number of complete comments.  If COUNT comments are found
     as expected, with nothing except whitespace between them, it
     returns ‘t’; otherwise it returns ‘nil’.

     This function cannot tell whether the comments it traverses are
     embedded within a string.  If they look like comments, it treats
     them as comments.

     To move forward over all comments and whitespace following point,
     use ‘(forward-comment (buffer-size))’.  ‘(buffer-size)’ is a good
     argument to use, because the number of comments in the buffer
     cannot exceed that many.


File: elisp.info,  Node: Position Parse,  Next: Parser State,  Prev: Motion via Parsing,  Up: Parsing Expressions

35.6.2 Finding the Parse State for a Position
---------------------------------------------

For syntactic analysis, such as in indentation, often the useful thing
is to compute the syntactic state corresponding to a given buffer
position.  This function does that conveniently.

 -- Function: syntax-ppss &optional pos
     This function returns the parser state that the parser would reach
     at position POS starting from the beginning of the visible portion
     of the buffer.  *Note Parser State::, for a description of the
     parser state.

     The return value is the same as if you call the low-level parsing
     function ‘parse-partial-sexp’ to parse from the beginning of the
     visible portion of the buffer to POS (*note Low-Level Parsing::).
     However, ‘syntax-ppss’ uses caches to speed up the computation.
     Due to this optimization, the second value (previous complete
     subexpression) and sixth value (minimum parenthesis depth) in the
     returned parser state are not meaningful.

     This function has a side effect: it adds a buffer-local entry to
     ‘before-change-functions’ (*note Change Hooks::) for
     ‘syntax-ppss-flush-cache’ (see below).  This entry keeps the cache
     consistent as the buffer is modified.  However, the cache might not
     be updated if ‘syntax-ppss’ is called while
     ‘before-change-functions’ is temporarily let-bound, or if the
     buffer is modified without running the hook, such as when using
     ‘inhibit-modification-hooks’.  In those cases, it is necessary to
     call ‘syntax-ppss-flush-cache’ explicitly.

 -- Function: syntax-ppss-flush-cache beg &rest ignored-args
     This function flushes the cache used by ‘syntax-ppss’, starting at
     position BEG.  The remaining arguments, IGNORED-ARGS, are ignored;
     this function accepts them so that it can be directly used on hooks
     such as ‘before-change-functions’ (*note Change Hooks::).


File: elisp.info,  Node: Parser State,  Next: Low-Level Parsing,  Prev: Position Parse,  Up: Parsing Expressions

35.6.3 Parser State
-------------------

A “parser state” is a list of (currently) eleven elements describing the
state of the syntactic parser, after it parses the text between a
specified starting point and a specified end point in the buffer.
Parsing functions such as ‘syntax-ppss’ (*note Position Parse::) return
a parser state as the value.  Some parsing functions accept a parser
state as an argument, for resuming parsing.

   Here are the meanings of the elements of the parser state:

  0. The depth in parentheses, counting from 0.  *Warning:* this can be
     negative if there are more close parens than open parens between
     the parser’s starting point and end point.

  1. The character position of the start of the innermost parenthetical
     grouping containing the stopping point; ‘nil’ if none.

  2. The character position of the start of the last complete
     subexpression terminated; ‘nil’ if none.

  3. Non-‘nil’ if inside a string.  More precisely, this is the
     character that will terminate the string, or ‘t’ if a generic
     string delimiter character should terminate it.

  4. ‘t’ if inside a non-nestable comment (of any comment style; *note
     Syntax Flags::); or the comment nesting level if inside a comment
     that can be nested.

  5. ‘t’ if the end point is just after a quote character.

  6. The minimum parenthesis depth encountered during this scan.

  7. What kind of comment is active: ‘nil’ if not in a comment or in a
     comment of style ‘a’; 1 for a comment of style ‘b’; 2 for a comment
     of style ‘c’; and ‘syntax-table’ for a comment that should be ended
     by a generic comment delimiter character.

  8. The string or comment start position.  While inside a comment, this
     is the position where the comment began; while inside a string,
     this is the position where the string began.  When outside of
     strings and comments, this element is ‘nil’.

  9. The list of the positions of the currently open parentheses,
     starting with the outermost.

  10. When the last buffer position scanned was the (potential) first
     character of a two character construct (comment delimiter or
     escaped/char-quoted character pair), the SYNTAX-CODE (*note Syntax
     Table Internals::) of that position.  Otherwise ‘nil’.

   Elements 1, 2, and 6 are ignored in a state which you pass as an
argument to continue parsing.  Elements 9 and 10 are mainly used
internally by the parser code.

   One additional piece of useful information is available from a parser
state using this function:

 -- Function: syntax-ppss-toplevel-pos state
     This function extracts, from parser state STATE, the last position
     scanned in the parse which was at top level in grammatical
     structure.  “At top level” means outside of any parentheses,
     comments, or strings.

     The value is ‘nil’ if STATE represents a parse which has arrived at
     a top level position.


File: elisp.info,  Node: Low-Level Parsing,  Next: Control Parsing,  Prev: Parser State,  Up: Parsing Expressions

35.6.4 Low-Level Parsing
------------------------

The most basic way to use the expression parser is to tell it to start
at a given position with a certain state, and parse up to a specified
end position.

 -- Function: parse-partial-sexp start limit &optional target-depth
          stop-before state stop-comment
     This function parses a sexp in the current buffer starting at
     START, not scanning past LIMIT.  It stops at position LIMIT or when
     certain criteria described below are met, and sets point to the
     location where parsing stops.  It returns a parser state (*note
     Parser State::) describing the status of the parse at the point
     where it stops.

     If the third argument TARGET-DEPTH is non-‘nil’, parsing stops if
     the depth in parentheses becomes equal to TARGET-DEPTH.  The depth
     starts at 0, or at whatever is given in STATE.

     If the fourth argument STOP-BEFORE is non-‘nil’, parsing stops when
     it comes to any character that starts a sexp.  If STOP-COMMENT is
     non-‘nil’, parsing stops after the start of an unnested comment.
     If STOP-COMMENT is the symbol ‘syntax-table’, parsing stops after
     the start of an unnested comment or a string, or after the end of
     an unnested comment or a string, whichever comes first.

     If STATE is ‘nil’, START is assumed to be at the top level of
     parenthesis structure, such as the beginning of a function
     definition.  Alternatively, you might wish to resume parsing in the
     middle of the structure.  To do this, you must provide a STATE
     argument that describes the initial status of parsing.  The value
     returned by a previous call to ‘parse-partial-sexp’ will do nicely.


File: elisp.info,  Node: Control Parsing,  Prev: Low-Level Parsing,  Up: Parsing Expressions

35.6.5 Parameters to Control Parsing
------------------------------------

 -- Variable: multibyte-syntax-as-symbol
     If this variable is non-‘nil’, ‘scan-sexps’ treats all non-ASCII
     characters as symbol constituents regardless of what the syntax
     table says about them.  (However, text properties can still
     override the syntax.)

 -- User Option: parse-sexp-ignore-comments
     If the value is non-‘nil’, then comments are treated as whitespace
     by the functions in this section and by ‘forward-sexp’,
     ‘scan-lists’ and ‘scan-sexps’.

   The behavior of ‘parse-partial-sexp’ is also affected by
‘parse-sexp-lookup-properties’ (*note Syntax Properties::).

 -- Variable: comment-end-can-be-escaped
     If this buffer local variable is non-‘nil’, a single character
     which usually terminates a comment doesn’t do so when that
     character is escaped.  This is used in C and C++ Modes, where line
     comments starting with ‘//’ can be continued onto the next line by
     escaping the newline with ‘\’.

   You can use ‘forward-comment’ to move forward or backward over one
comment or several comments.


File: elisp.info,  Node: Syntax Table Internals,  Next: Categories,  Prev: Parsing Expressions,  Up: Syntax Tables

35.7 Syntax Table Internals
===========================

Syntax tables are implemented as char-tables (*note Char-Tables::), but
most Lisp programs don’t work directly with their elements.  Syntax
tables do not store syntax data as syntax descriptors (*note Syntax
Descriptors::); they use an internal format, which is documented in this
section.  This internal format can also be assigned as syntax properties
(*note Syntax Properties::).

   Each entry in a syntax table is a “raw syntax descriptor”: a cons
cell of the form ‘(SYNTAX-CODE . MATCHING-CHAR)’.  SYNTAX-CODE is an
integer which encodes the syntax class and syntax flags, according to
the table below.  MATCHING-CHAR, if non-‘nil’, specifies a matching
character (similar to the second character in a syntax descriptor).

   Use ‘aref’ (*note Array Functions::) to get the raw syntax descriptor
of a character, e.g. ‘(aref (syntax-table) ch)’.

   Here are the syntax codes corresponding to the various syntax
classes:

Code           Class                  Code           Class
0              whitespace             8              paired delimiter
1              punctuation            9              escape
2              word                   10             character quote
3              symbol                 11             comment-start
4              open parenthesis       12             comment-end
5              close parenthesis      13             inherit
6              expression prefix      14             generic comment
7              string quote           15             generic string

For example, in the standard syntax table, the entry for ‘(’ is ‘(4 .
41)’.  41 is the character code for ‘)’.

   Syntax flags are encoded in higher order bits, starting 16 bits from
the least significant bit.  This table gives the power of two which
corresponds to each syntax flag.

Prefix      Flag                   Prefix      Flag
‘1’         ‘(lsh 1 16)’           ‘p’         ‘(lsh 1 20)’
‘2’         ‘(lsh 1 17)’           ‘b’         ‘(lsh 1 21)’
‘3’         ‘(lsh 1 18)’           ‘n’         ‘(lsh 1 22)’
‘4’         ‘(lsh 1 19)’           ‘c’         ‘(lsh 1 23)’

 -- Function: string-to-syntax desc
     Given a syntax descriptor DESC (a string), this function returns
     the corresponding raw syntax descriptor.

 -- Function: syntax-after pos
     This function returns the raw syntax descriptor for the character
     in the buffer after position POS, taking account of syntax
     properties as well as the syntax table.  If POS is outside the
     buffer’s accessible portion (*note accessible portion: Narrowing.),
     the return value is ‘nil’.

 -- Function: syntax-class syntax
     This function returns the syntax code for the raw syntax descriptor
     SYNTAX.  More precisely, it takes the raw syntax descriptor’s
     SYNTAX-CODE component, masks off the high 16 bits which record the
     syntax flags, and returns the resulting integer.

     If SYNTAX is ‘nil’, the return value is returns ‘nil’.  This is so
     that the expression

          (syntax-class (syntax-after pos))

     evaluates to ‘nil’ if ‘pos’ is outside the buffer’s accessible
     portion, without throwing errors or returning an incorrect code.


File: elisp.info,  Node: Categories,  Prev: Syntax Table Internals,  Up: Syntax Tables

35.8 Categories
===============

“Categories” provide an alternate way of classifying characters
syntactically.  You can define several categories as needed, then
independently assign each character to one or more categories.  Unlike
syntax classes, categories are not mutually exclusive; it is normal for
one character to belong to several categories.

   Each buffer has a “category table” which records which categories are
defined and also which characters belong to each category.  Each
category table defines its own categories, but normally these are
initialized by copying from the standard categories table, so that the
standard categories are available in all modes.

   Each category has a name, which is an ASCII printing character in the
range ‘ ’ to ‘~’.  You specify the name of a category when you define it
with ‘define-category’.

   The category table is actually a char-table (*note Char-Tables::).
The element of the category table at index C is a “category set”—a
bool-vector—that indicates which categories character C belongs to.  In
this category set, if the element at index CAT is ‘t’, that means
category CAT is a member of the set, and that character C belongs to
category CAT.

   For the next three functions, the optional argument TABLE defaults to
the current buffer’s category table.

 -- Function: define-category char docstring &optional table
     This function defines a new category, with name CHAR and
     documentation DOCSTRING, for the category table TABLE.

     Here’s an example of defining a new category for characters that
     have strong right-to-left directionality (*note Bidirectional
     Display::) and using it in a special category table.  To obtain the
     information about the directionality of characters, the example
     code uses the ‘bidi-class’ Unicode property (*note bidi-class:
     Character Properties.).

          (defvar special-category-table-for-bidi
            ;;     Make an empty category-table.
            (let ((category-table (make-category-table))
                  ;; Create a char-table which gives the 'bidi-class' Unicode
                  ;; property for each character.
                  (uniprop-table
                   (unicode-property-table-internal 'bidi-class)))
              (define-category ?R "Characters of bidi-class R, AL, or RLO"
                               category-table)
              ;; Modify the category entry of each character whose
              ;; 'bidi-class' Unicode property is R, AL, or RLO --
              ;; these have a right-to-left directionality.
              (map-char-table
               #'(lambda (key val)
                   (if (memq val '(R AL RLO))
                       (modify-category-entry key ?R category-table)))
               uniprop-table)
              category-table))

 -- Function: category-docstring category &optional table
     This function returns the documentation string of category CATEGORY
     in category table TABLE.

          (category-docstring ?a)
               ⇒ "ASCII"
          (category-docstring ?l)
               ⇒ "Latin"

 -- Function: get-unused-category &optional table
     This function returns a category name (a character) which is not
     currently defined in TABLE.  If all possible categories are in use
     in TABLE, it returns ‘nil’.

 -- Function: category-table
     This function returns the current buffer’s category table.

 -- Function: category-table-p object
     This function returns ‘t’ if OBJECT is a category table, otherwise
     ‘nil’.

 -- Function: standard-category-table
     This function returns the standard category table.

 -- Function: copy-category-table &optional table
     This function constructs a copy of TABLE and returns it.  If TABLE
     is not supplied (or is ‘nil’), it returns a copy of the standard
     category table.  Otherwise, an error is signaled if TABLE is not a
     category table.

 -- Function: set-category-table table
     This function makes TABLE the category table for the current
     buffer.  It returns TABLE.

 -- Function: make-category-table
     This creates and returns an empty category table.  In an empty
     category table, no categories have been allocated, and no
     characters belong to any categories.

 -- Function: make-category-set categories
     This function returns a new category set—a bool-vector—whose
     initial contents are the categories listed in the string
     CATEGORIES.  The elements of CATEGORIES should be category names;
     the new category set has ‘t’ for each of those categories, and
     ‘nil’ for all other categories.

          (make-category-set "al")
               ⇒ #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: char-category-set char
     This function returns the category set for character CHAR in the
     current buffer’s category table.  This is the bool-vector which
     records which categories the character CHAR belongs to.  The
     function ‘char-category-set’ does not allocate storage, because it
     returns the same bool-vector that exists in the category table.

          (char-category-set ?a)
               ⇒ #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: category-set-mnemonics category-set
     This function converts the category set CATEGORY-SET into a string
     containing the characters that designate the categories that are
     members of the set.

          (category-set-mnemonics (char-category-set ?a))
               ⇒ "al"

 -- Function: modify-category-entry char category &optional table reset
     This function modifies the category set of CHAR in category table
     TABLE (which defaults to the current buffer’s category table).
     CHAR can be a character, or a cons cell of the form ‘(MIN . MAX)’;
     in the latter case, the function modifies the category sets of all
     characters in the range between MIN and MAX, inclusive.

     Normally, it modifies a category set by adding CATEGORY to it.  But
     if RESET is non-‘nil’, then it deletes CATEGORY instead.

 -- Command: describe-categories &optional buffer-or-name
     This function describes the category specifications in the current
     category table.  It inserts the descriptions in a buffer, and then
     displays that buffer.  If BUFFER-OR-NAME is non-‘nil’, it describes
     the category table of that buffer instead.


File: elisp.info,  Node: Abbrevs,  Next: Threads,  Prev: Syntax Tables,  Up: Top

36 Abbrevs and Abbrev Expansion
*******************************

An abbreviation or “abbrev” is a string of characters that may be
expanded to a longer string.  The user can insert the abbrev string and
find it replaced automatically with the expansion of the abbrev.  This
saves typing.

   The set of abbrevs currently in effect is recorded in an “abbrev
table”.  Each buffer has a local abbrev table, but normally all buffers
in the same major mode share one abbrev table.  There is also a global
abbrev table.  Normally both are used.

   An abbrev table is represented as an obarray.  *Note Creating
Symbols::, for information about obarrays.  Each abbreviation is
represented by a symbol in the obarray.  The symbol’s name is the
abbreviation; its value is the expansion; its function definition is the
hook function for performing the expansion (*note Defining Abbrevs::);
and its property list cell contains various additional properties,
including the use count and the number of times the abbreviation has
been expanded (*note Abbrev Properties::).

   Certain abbrevs, called “system abbrevs”, are defined by a major mode
instead of the user.  A system abbrev is identified by its non-‘nil’
‘:system’ property (*note Abbrev Properties::).  When abbrevs are saved
to an abbrev file, system abbrevs are omitted.  *Note Abbrev Files::.

   Because the symbols used for abbrevs are not interned in the usual
obarray, they will never appear as the result of reading a Lisp
expression; in fact, normally they are never used except by the code
that handles abbrevs.  Therefore, it is safe to use them in a
nonstandard way.

   If the minor mode Abbrev mode is enabled, the buffer-local variable
‘abbrev-mode’ is non-‘nil’, and abbrevs are automatically expanded in
the buffer.  For the user-level commands for abbrevs, see *note Abbrev
Mode: (emacs)Abbrevs.

* Menu:

* Tables: Abbrev Tables.        Creating and working with abbrev tables.
* Defining Abbrevs::            Specifying abbreviations and their expansions.
* Files: Abbrev Files.          Saving abbrevs in files.
* Expansion: Abbrev Expansion.  Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::      Abbrev tables used by various major modes.
* Abbrev Properties::           How to read and set abbrev properties.
                                Which properties have which effect.
* Abbrev Table Properties::     How to read and set abbrev table properties.
                                Which properties have which effect.


File: elisp.info,  Node: Abbrev Tables,  Next: Defining Abbrevs,  Up: Abbrevs

36.1 Abbrev Tables
==================

This section describes how to create and manipulate abbrev tables.

 -- Function: make-abbrev-table &optional props
     This function creates and returns a new, empty abbrev table—an
     obarray containing no symbols.  It is a vector filled with zeros.
     PROPS is a property list that is applied to the new table (*note
     Abbrev Table Properties::).

 -- Function: abbrev-table-p object
     This function returns a non-‘nil’ value if OBJECT is an abbrev
     table.

 -- Function: clear-abbrev-table abbrev-table
     This function undefines all the abbrevs in ABBREV-TABLE, leaving it
     empty.

 -- Function: copy-abbrev-table abbrev-table
     This function returns a copy of ABBREV-TABLE—a new abbrev table
     containing the same abbrev definitions.  It does _not_ copy any
     property lists; only the names, values, and functions.

 -- Function: define-abbrev-table tabname definitions &optional
          docstring &rest props
     This function defines TABNAME (a symbol) as an abbrev table name,
     i.e., as a variable whose value is an abbrev table.  It defines
     abbrevs in the table according to DEFINITIONS, a list of elements
     of the form ‘(ABBREVNAME EXPANSION [HOOK] [PROPS...])’.  These
     elements are passed as arguments to ‘define-abbrev’.

     The optional string DOCSTRING is the documentation string of the
     variable TABNAME.  The property list PROPS is applied to the abbrev
     table (*note Abbrev Table Properties::).

     If this function is called more than once for the same TABNAME,
     subsequent calls add the definitions in DEFINITIONS to TABNAME,
     rather than overwriting the entire original contents.  (A
     subsequent call only overrides abbrevs explicitly redefined or
     undefined in DEFINITIONS.)

 -- Variable: abbrev-table-name-list
     This is a list of symbols whose values are abbrev tables.
     ‘define-abbrev-table’ adds the new abbrev table name to this list.

 -- Function: insert-abbrev-table-description name &optional human
     This function inserts before point a description of the abbrev
     table named NAME.  The argument NAME is a symbol whose value is an
     abbrev table.

     If HUMAN is non-‘nil’, the description is human-oriented.  System
     abbrevs are listed and identified as such.  Otherwise the
     description is a Lisp expression—a call to ‘define-abbrev-table’
     that would define NAME as it is currently defined, but without the
     system abbrevs.  (The mode or package using NAME is supposed to add
     these to NAME separately.)


File: elisp.info,  Node: Defining Abbrevs,  Next: Abbrev Files,  Prev: Abbrev Tables,  Up: Abbrevs

36.2 Defining Abbrevs
=====================

‘define-abbrev’ is the low-level basic function for defining an abbrev
in an abbrev table.

   When a major mode defines a system abbrev, it should call
‘define-abbrev’ and specify ‘t’ for the ‘:system’ property.  Be aware
that any saved non-system abbrevs are restored at startup, i.e., before
some major modes are loaded.  Therefore, major modes should not assume
that their abbrev tables are empty when they are first loaded.

 -- Function: define-abbrev abbrev-table name expansion &optional hook
          &rest props
     This function defines an abbrev named NAME, in ABBREV-TABLE, to
     expand to EXPANSION and call HOOK, with properties PROPS (*note
     Abbrev Properties::).  The return value is NAME.  The ‘:system’
     property in PROPS is treated specially here: if it has the value
     ‘force’, then it will overwrite an existing definition even for a
     non-system abbrev of the same name.

     NAME should be a string.  The argument EXPANSION is normally the
     desired expansion (a string), or ‘nil’ to undefine the abbrev.  If
     it is anything but a string or ‘nil’, then the abbreviation expands
     solely by running HOOK.

     The argument HOOK is a function or ‘nil’.  If HOOK is non-‘nil’,
     then it is called with no arguments after the abbrev is replaced
     with EXPANSION; point is located at the end of EXPANSION when HOOK
     is called.

     If HOOK is a non-‘nil’ symbol whose ‘no-self-insert’ property is
     non-‘nil’, HOOK can explicitly control whether to insert the
     self-inserting input character that triggered the expansion.  If
     HOOK returns non-‘nil’ in this case, that inhibits insertion of the
     character.  By contrast, if HOOK returns ‘nil’, ‘expand-abbrev’ (or
     ‘abbrev-insert’) also returns ‘nil’, as if expansion had not really
     occurred.

     Normally, ‘define-abbrev’ sets the variable ‘abbrevs-changed’ to
     ‘t’, if it actually changes the abbrev.  This is so that some
     commands will offer to save the abbrevs.  It does not do this for a
     system abbrev, since those aren’t saved anyway.

 -- User Option: only-global-abbrevs
     If this variable is non-‘nil’, it means that the user plans to use
     global abbrevs only.  This tells the commands that define
     mode-specific abbrevs to define global ones instead.  This variable
     does not alter the behavior of the functions in this section; it is
     examined by their callers.


File: elisp.info,  Node: Abbrev Files,  Next: Abbrev Expansion,  Prev: Defining Abbrevs,  Up: Abbrevs

36.3 Saving Abbrevs in Files
============================

A file of saved abbrev definitions is actually a file of Lisp code.  The
abbrevs are saved in the form of a Lisp program to define the same
abbrev tables with the same contents.  Therefore, you can load the file
with ‘load’ (*note How Programs Do Loading::).  However, the function
‘quietly-read-abbrev-file’ is provided as a more convenient interface.
Emacs automatically calls this function at startup.

   User-level facilities such as ‘save-some-buffers’ can save abbrevs in
a file automatically, under the control of variables described here.

 -- User Option: abbrev-file-name
     This is the default file name for reading and saving abbrevs.  By
     default, Emacs will look for ‘~/.emacs.d/abbrev_defs’, and, if not
     found, for ‘~/.abbrev_defs’; if neither file exists, Emacs will
     create ‘~/.emacs.d/abbrev_defs’.

 -- Function: quietly-read-abbrev-file &optional filename
     This function reads abbrev definitions from a file named FILENAME,
     previously written with ‘write-abbrev-file’.  If FILENAME is
     omitted or ‘nil’, the file specified in ‘abbrev-file-name’ is used.

     As the name implies, this function does not display any messages.

 -- User Option: save-abbrevs
     A non-‘nil’ value for ‘save-abbrevs’ means that Emacs should offer
     to save abbrevs (if any have changed) when files are saved.  If the
     value is ‘silently’, Emacs saves the abbrevs without asking the
     user.  ‘abbrev-file-name’ specifies the file to save the abbrevs
     in.  The default value is ‘t’.

 -- Variable: abbrevs-changed
     This variable is set non-‘nil’ by defining or altering any abbrevs
     (except system abbrevs).  This serves as a flag for various Emacs
     commands to offer to save your abbrevs.

 -- Command: write-abbrev-file &optional filename
     Save all abbrev definitions (except system abbrevs), for all abbrev
     tables listed in ‘abbrev-table-name-list’, in the file FILENAME, in
     the form of a Lisp program that when loaded will define the same
     abbrevs.  If FILENAME is ‘nil’ or omitted, ‘abbrev-file-name’ is
     used.  This function returns ‘nil’.


File: elisp.info,  Node: Abbrev Expansion,  Next: Standard Abbrev Tables,  Prev: Abbrev Files,  Up: Abbrevs

36.4 Looking Up and Expanding Abbreviations
===========================================

Abbrevs are usually expanded by certain interactive commands, including
‘self-insert-command’.  This section describes the subroutines used in
writing such commands, as well as the variables they use for
communication.

 -- Function: abbrev-symbol abbrev &optional table
     This function returns the symbol representing the abbrev named
     ABBREV.  It returns ‘nil’ if that abbrev is not defined.  The
     optional second argument TABLE is the abbrev table in which to look
     it up.  If TABLE is ‘nil’, this function tries first the current
     buffer’s local abbrev table, and second the global abbrev table.

 -- Function: abbrev-expansion abbrev &optional table
     This function returns the string that ABBREV would expand into (as
     defined by the abbrev tables used for the current buffer).  It
     returns ‘nil’ if ABBREV is not a valid abbrev.  The optional
     argument TABLE specifies the abbrev table to use, as in
     ‘abbrev-symbol’.

 -- Command: expand-abbrev
     This command expands the abbrev before point, if any.  If point
     does not follow an abbrev, this command does nothing.  To do the
     expansion, it calls the function that is the value of the
     ‘abbrev-expand-function’ variable, with no arguments, and returns
     whatever that function does.

     The default expansion function returns the abbrev symbol if it did
     expansion, and ‘nil’ otherwise.  If the abbrev symbol has a hook
     function that is a symbol whose ‘no-self-insert’ property is
     non-‘nil’, and if the hook function returns ‘nil’ as its value,
     then the default expansion function returns ‘nil’, even though
     expansion did occur.

 -- Function: abbrev-insert abbrev &optional name start end
     This function inserts the abbrev expansion of ‘abbrev’, replacing
     the text between ‘start’ and ‘end’.  If ‘start’ is omitted, it
     defaults to point.  ‘name’, if non-‘nil’, should be the name by
     which this abbrev was found (a string); it is used to figure out
     whether to adjust the capitalization of the expansion.  The
     function returns ‘abbrev’ if the abbrev was successfully inserted,
     otherwise it returns ‘nil’.

 -- Command: abbrev-prefix-mark &optional arg
     This command marks the current location of point as the beginning
     of an abbrev.  The next call to ‘expand-abbrev’ will use the text
     from here to point (where it is then) as the abbrev to expand,
     rather than using the previous word as usual.

     First, this command expands any abbrev before point, unless ARG is
     non-‘nil’.  (Interactively, ARG is the prefix argument.)  Then it
     inserts a hyphen before point, to indicate the start of the next
     abbrev to be expanded.  The actual expansion removes the hyphen.

 -- User Option: abbrev-all-caps
     When this is set non-‘nil’, an abbrev entered entirely in upper
     case is expanded using all upper case.  Otherwise, an abbrev
     entered entirely in upper case is expanded by capitalizing each
     word of the expansion.

 -- Variable: abbrev-start-location
     The value of this variable is a buffer position (an integer or a
     marker) for ‘expand-abbrev’ to use as the start of the next abbrev
     to be expanded.  The value can also be ‘nil’, which means to use
     the word before point instead.  ‘abbrev-start-location’ is set to
     ‘nil’ each time ‘expand-abbrev’ is called.  This variable is also
     set by ‘abbrev-prefix-mark’.

 -- Variable: abbrev-start-location-buffer
     The value of this variable is the buffer for which
     ‘abbrev-start-location’ has been set.  Trying to expand an abbrev
     in any other buffer clears ‘abbrev-start-location’.  This variable
     is set by ‘abbrev-prefix-mark’.

 -- Variable: last-abbrev
     This is the ‘abbrev-symbol’ of the most recent abbrev expanded.
     This information is left by ‘expand-abbrev’ for the sake of the
     ‘unexpand-abbrev’ command (*note Expanding Abbrevs:
     (emacs)Expanding Abbrevs.).

 -- Variable: last-abbrev-location
     This is the location of the most recent abbrev expanded.  This
     contains information left by ‘expand-abbrev’ for the sake of the
     ‘unexpand-abbrev’ command.

 -- Variable: last-abbrev-text
     This is the exact expansion text of the most recent abbrev
     expanded, after case conversion (if any).  Its value is ‘nil’ if
     the abbrev has already been unexpanded.  This contains information
     left by ‘expand-abbrev’ for the sake of the ‘unexpand-abbrev’
     command.

 -- Variable: abbrev-expand-function
     The value of this variable is a function that ‘expand-abbrev’ will
     call with no arguments to do the expansion.  The function can do
     anything it wants before and after performing the expansion.  It
     should return the abbrev symbol if expansion took place.

   The following sample code shows a simple use of
‘abbrev-expand-function’.  It assumes that ‘foo-mode’ is a mode for
editing certain files in which lines that start with ‘#’ are comments.
You want to use Text mode abbrevs for those lines.  The regular local
abbrev table, ‘foo-mode-abbrev-table’ is appropriate for all other
lines.  *Note Standard Abbrev Tables::, for the definitions of
‘local-abbrev-table’ and ‘text-mode-abbrev-table’.  *Note Advising
Functions::, for details of ‘add-function’.

     (defun foo-mode-abbrev-expand-function (expand)
       (if (not (save-excursion (forward-line 0) (eq (char-after) ?#)))
           ;; Performs normal expansion.
           (funcall expand)
         ;; We're inside a comment: use the text-mode abbrevs.
         (let ((local-abbrev-table text-mode-abbrev-table))
           (funcall expand))))

     (add-hook 'foo-mode-hook
               #'(lambda ()
                   (add-function :around (local 'abbrev-expand-function)
                                 #'foo-mode-abbrev-expand-function)))


File: elisp.info,  Node: Standard Abbrev Tables,  Next: Abbrev Properties,  Prev: Abbrev Expansion,  Up: Abbrevs

36.5 Standard Abbrev Tables
===========================

Here we list the variables that hold the abbrev tables for the preloaded
major modes of Emacs.

 -- Variable: global-abbrev-table
     This is the abbrev table for mode-independent abbrevs.  The abbrevs
     defined in it apply to all buffers.  Each buffer may also have a
     local abbrev table, whose abbrev definitions take precedence over
     those in the global table.

 -- Variable: local-abbrev-table
     The value of this buffer-local variable is the (mode-specific)
     abbreviation table of the current buffer.  It can also be a list of
     such tables.

 -- Variable: abbrev-minor-mode-table-alist
     The value of this variable is a list of elements of the form ‘(MODE
     . ABBREV-TABLE)’ where MODE is the name of a variable: if the
     variable is bound to a non-‘nil’ value, then the ABBREV-TABLE is
     active, otherwise it is ignored.  ABBREV-TABLE can also be a list
     of abbrev tables.

 -- Variable: fundamental-mode-abbrev-table
     This is the local abbrev table used in Fundamental mode; in other
     words, it is the local abbrev table in all buffers in Fundamental
     mode.

 -- Variable: text-mode-abbrev-table
     This is the local abbrev table used in Text mode.

 -- Variable: lisp-mode-abbrev-table
     This is the local abbrev table used in Lisp mode.  It is the parent
     of the local abbrev table used in Emacs Lisp mode.  *Note Abbrev
     Table Properties::.


File: elisp.info,  Node: Abbrev Properties,  Next: Abbrev Table Properties,  Prev: Standard Abbrev Tables,  Up: Abbrevs

36.6 Abbrev Properties
======================

Abbrevs have properties, some of which influence the way they work.  You
can provide them as arguments to ‘define-abbrev’, and manipulate them
with the following functions:

 -- Function: abbrev-put abbrev prop val
     Set the property PROP of ABBREV to value VAL.

 -- Function: abbrev-get abbrev prop
     Return the property PROP of ABBREV, or ‘nil’ if the abbrev has no
     such property.

   The following properties have special meanings:

‘:count’
     This property counts the number of times the abbrev has been
     expanded.  If not explicitly set, it is initialized to 0 by
     ‘define-abbrev’.

‘:system’
     If non-‘nil’, this property marks the abbrev as a system abbrev.
     Such abbrevs are not saved (*note Abbrev Files::).

‘:enable-function’
     If non-‘nil’, this property should be a function of no arguments
     which returns ‘nil’ if the abbrev should not be used and ‘t’
     otherwise.

‘:case-fixed’
     If non-‘nil’, this property indicates that the case of the abbrev’s
     name is significant and should only match a text with the same
     pattern of capitalization.  It also disables the code that modifies
     the capitalization of the expansion.


File: elisp.info,  Node: Abbrev Table Properties,  Prev: Abbrev Properties,  Up: Abbrevs

36.7 Abbrev Table Properties
============================

Like abbrevs, abbrev tables have properties, some of which influence the
way they work.  You can provide them as arguments to
‘define-abbrev-table’, and manipulate them with the functions:

 -- Function: abbrev-table-put table prop val
     Set the property PROP of abbrev table TABLE to value VAL.

 -- Function: abbrev-table-get table prop
     Return the property PROP of abbrev table TABLE, or ‘nil’ if the
     abbrev has no such property.

   The following properties have special meaning:

‘:enable-function’
     This is like the ‘:enable-function’ abbrev property except that it
     applies to all abbrevs in the table.  It is used before even trying
     to find the abbrev before point, so it can dynamically modify the
     abbrev table.

‘:case-fixed’
     This is like the ‘:case-fixed’ abbrev property except that it
     applies to all abbrevs in the table.

‘:regexp’
     If non-‘nil’, this property is a regular expression that indicates
     how to extract the name of the abbrev before point, before looking
     it up in the table.  When the regular expression matches before
     point, the abbrev name is expected to be in submatch 1.  If this
     property is ‘nil’, the default is to use ‘backward-word’ and
     ‘forward-word’ to find the name.  This property allows the use of
     abbrevs whose name contains characters of non-word syntax.

‘:parents’
     This property holds a list of tables from which to inherit other
     abbrevs.

‘:abbrev-table-modiff’
     This property holds a counter incremented each time a new abbrev is
     added to the table.


File: elisp.info,  Node: Threads,  Next: Processes,  Prev: Abbrevs,  Up: Top

37 Threads
**********

Emacs Lisp provides a limited form of concurrency, called “threads”.
All the threads in a given instance of Emacs share the same memory.
Concurrency in Emacs Lisp is “mostly cooperative”, meaning that Emacs
will only switch execution between threads at well-defined times.
However, the Emacs thread support has been designed in a way to later
allow more fine-grained concurrency, and correct programs should not
rely on cooperative threading.

   Currently, thread switching will occur upon explicit request via
‘thread-yield’, when waiting for keyboard input or for process output
(e.g., during ‘accept-process-output’), or during blocking operations
relating to threads, such as mutex locking or ‘thread-join’.

   Emacs Lisp provides primitives to create and control threads, and
also to create and control mutexes and condition variables, useful for
thread synchronization.

   While global variables are shared among all Emacs Lisp threads, local
variables are not—a dynamic ‘let’ binding is local.  Each thread also
has its own current buffer (*note Current Buffer::) and its own match
data (*note Match Data::).

   Note that ‘let’ bindings are treated specially by the Emacs Lisp
implementation.  There is no way to duplicate this unwinding and
rewinding behavior other than by using ‘let’.  For example, a manual
implementation of ‘let’ written using ‘unwind-protect’ cannot arrange
for variable values to be thread-specific.

   In the case of lexical bindings (*note Variable Scoping::), a closure
is an object like any other in Emacs Lisp, and bindings in a closure are
shared by any threads invoking the closure.

* Menu:

* Basic Thread Functions::      Basic thread functions.
* Mutexes::                     Mutexes allow exclusive access to data.
* Condition Variables::         Inter-thread events.


File: elisp.info,  Node: Basic Thread Functions,  Next: Mutexes,  Up: Threads

37.1 Basic Thread Functions
===========================

Threads can be created and waited for.  A thread cannot be exited
directly, but the current thread can be exited implicitly, and other
threads can be signaled.

 -- Function: make-thread function &optional name
     Create a new thread of execution which invokes FUNCTION.  When
     FUNCTION returns, the thread exits.

     The new thread is created with no local variable bindings in
     effect.  The new thread’s current buffer is inherited from the
     current thread.

     NAME can be supplied to give a name to the thread.  The name is
     used for debugging and informational purposes only; it has no
     meaning to Emacs.  If NAME is provided, it must be a string.

     This function returns the new thread.

 -- Function: threadp object
     This function returns ‘t’ if OBJECT represents an Emacs thread,
     ‘nil’ otherwise.

 -- Function: thread-join thread
     Block until THREAD exits, or until the current thread is signaled.
     If THREAD has already exited, this returns immediately.

 -- Function: thread-signal thread error-symbol data
     Like ‘signal’ (*note Signaling Errors::), but the signal is
     delivered in the thread THREAD.  If THREAD is the current thread,
     then this just calls ‘signal’ immediately.  Otherwise, THREAD will
     receive the signal as soon as it becomes current.  If THREAD was
     blocked by a call to ‘mutex-lock’, ‘condition-wait’, or
     ‘thread-join’; ‘thread-signal’ will unblock it.

 -- Function: thread-yield
     Yield execution to the next runnable thread.

 -- Function: thread-name thread
     Return the name of THREAD, as specified to ‘make-thread’.

 -- Function: thread-alive-p thread
     Return ‘t’ if THREAD is alive, or ‘nil’ if it is not.  A thread is
     alive as long as its function is still executing.

 -- Function: thread--blocker thread
     Return the object that THREAD is waiting on.  This function is
     primarily intended for debugging, and is given a “double hyphen”
     name to indicate that.

     If THREAD is blocked in ‘thread-join’, this returns the thread for
     which it is waiting.

     If THREAD is blocked in ‘mutex-lock’, this returns the mutex.

     If THREAD is blocked in ‘condition-wait’, this returns the
     condition variable.

     Otherwise, this returns ‘nil’.

 -- Function: current-thread
     Return the current thread.

 -- Function: all-threads
     Return a list of all the live thread objects.  A new list is
     returned by each invocation.

   When code run by a thread signals an error that is unhandled, the
thread exits.  Other threads can access the error form which caused the
thread to exit using the following function.

 -- Function: thread-last-error
     This function returns the last error form recorded when a thread
     exited due to an error.  Each thread that exits abnormally
     overwrites the form stored by the previous thread’s error with a
     new value, so only the last one can be accessed.


File: elisp.info,  Node: Mutexes,  Next: Condition Variables,  Prev: Basic Thread Functions,  Up: Threads

37.2 Mutexes
============

A “mutex” is an exclusive lock.  At any moment, zero or one threads may
own a mutex.  If a thread attempts to acquire a mutex, and the mutex is
already owned by some other thread, then the acquiring thread will block
until the mutex becomes available.

   Emacs Lisp mutexes are of a type called “recursive”, which means that
a thread can re-acquire a mutex it owns any number of times.  A mutex
keeps a count of how many times it has been acquired, and each
acquisition of a mutex must be paired with a release.  The last release
by a thread of a mutex reverts it to the unowned state, potentially
allowing another thread to acquire the mutex.

 -- Function: mutexp object
     This function returns ‘t’ if OBJECT represents an Emacs mutex,
     ‘nil’ otherwise.

 -- Function: make-mutex &optional name
     Create a new mutex and return it.  If NAME is specified, it is a
     name given to the mutex.  It must be a string.  The name is for
     debugging purposes only; it has no meaning to Emacs.

 -- Function: mutex-name mutex
     Return the name of MUTEX, as specified to ‘make-mutex’.

 -- Function: mutex-lock mutex
     This will block until this thread acquires MUTEX, or until this
     thread is signaled using ‘thread-signal’.  If MUTEX is already
     owned by this thread, this simply returns.

 -- Function: mutex-unlock mutex
     Release MUTEX.  If MUTEX is not owned by this thread, this will
     signal an error.

 -- Macro: with-mutex mutex body...
     This macro is the simplest and safest way to evaluate forms while
     holding a mutex.  It acquires MUTEX, invokes BODY, and then
     releases MUTEX.  It returns the result of BODY.


File: elisp.info,  Node: Condition Variables,  Prev: Mutexes,  Up: Threads

37.3 Condition Variables
========================

A “condition variable” is a way for a thread to block until some event
occurs.  A thread can wait on a condition variable, to be woken up when
some other thread notifies the condition.

   A condition variable is associated with a mutex and, conceptually,
with some condition.  For proper operation, the mutex must be acquired,
and then a waiting thread must loop, testing the condition and waiting
on the condition variable.  For example:

     (with-mutex mutex
       (while (not global-variable)
         (condition-wait cond-var)))

   The mutex ensures atomicity, and the loop is for robustness—there may
be spurious notifications.

   Similarly, the mutex must be held before notifying the condition.
The typical, and best, approach is to acquire the mutex, make the
changes associated with this condition, and then notify it:

     (with-mutex mutex
       (setq global-variable (some-computation))
       (condition-notify cond-var))

 -- Function: make-condition-variable mutex &optional name
     Make a new condition variable associated with MUTEX.  If NAME is
     specified, it is a name given to the condition variable.  It must
     be a string.  The name is for debugging purposes only; it has no
     meaning to Emacs.

 -- Function: condition-variable-p object
     This function returns ‘t’ if OBJECT represents a condition
     variable, ‘nil’ otherwise.

 -- Function: condition-wait cond
     Wait for another thread to notify COND, a condition variable.  This
     function will block until the condition is notified, or until a
     signal is delivered to this thread using ‘thread-signal’.

     It is an error to call ‘condition-wait’ without holding the
     condition’s associated mutex.

     ‘condition-wait’ releases the associated mutex while waiting.  This
     allows other threads to acquire the mutex in order to notify the
     condition.

 -- Function: condition-notify cond &optional all
     Notify COND.  The mutex with COND must be held before calling this.
     Ordinarily a single waiting thread is woken by ‘condition-notify’;
     but if ALL is not ‘nil’, then all threads waiting on COND are
     notified.

     ‘condition-notify’ releases the associated mutex while waiting.
     This allows other threads to acquire the mutex in order to wait on
     the condition.

 -- Function: condition-name cond
     Return the name of COND, as passed to ‘make-condition-variable’.

 -- Function: condition-mutex cond
     Return the mutex associated with COND.  Note that the associated
     mutex cannot be changed.


File: elisp.info,  Node: Processes,  Next: Display,  Prev: Threads,  Up: Top

38 Processes
************

In the terminology of operating systems, a “process” is a space in which
a program can execute.  Emacs runs in a process.  Emacs Lisp programs
can invoke other programs in processes of their own.  These are called
“subprocesses” or “child processes” of the Emacs process, which is their
“parent process”.

   A subprocess of Emacs may be “synchronous” or “asynchronous”,
depending on how it is created.  When you create a synchronous
subprocess, the Lisp program waits for the subprocess to terminate
before continuing execution.  When you create an asynchronous
subprocess, it can run in parallel with the Lisp program.  This kind of
subprocess is represented within Emacs by a Lisp object which is also
called a “process”.  Lisp programs can use this object to communicate
with the subprocess or to control it.  For example, you can send
signals, obtain status information, receive output from the process, or
send input to it.

   In addition to processes that run programs, Lisp programs can open
connections of several types to devices or processes running on the same
machine or on other machines.  The supported connection types are: TCP
and UDP network connections, serial port connections, and pipe
connections.  Each such connection is also represented by a process
object.

 -- Function: processp object
     This function returns ‘t’ if OBJECT represents an Emacs process
     object, ‘nil’ otherwise.  The process object can represent a
     subprocess running a program or a connection of any supported type.

   In addition to subprocesses of the current Emacs session, you can
also access other processes running on your machine.  *Note System
Processes::.

* Menu:

* Subprocess Creation::      Functions that start subprocesses.
* Shell Arguments::          Quoting an argument to pass it to a shell.
* Synchronous Processes::    Details of using synchronous subprocesses.
* Asynchronous Processes::   Starting up an asynchronous subprocess.
* Deleting Processes::       Eliminating an asynchronous subprocess.
* Process Information::      Accessing run-status and other attributes.
* Input to Processes::       Sending input to an asynchronous subprocess.
* Signals to Processes::     Stopping, continuing or interrupting
                               an asynchronous subprocess.
* Output from Processes::    Collecting output from an asynchronous subprocess.
* Sentinels::                Sentinels run when process run-status changes.
* Query Before Exit::        Whether to query if exiting will kill a process.
* System Processes::         Accessing other processes running on your system.
* Transaction Queues::       Transaction-based communication with subprocesses.
* Network::                  Opening network connections.
* Network Servers::          Network servers let Emacs accept net connections.
* Datagrams::                UDP network connections.
* Low-Level Network::        Lower-level but more general function
                               to create connections and servers.
* Misc Network::             Additional relevant functions for net connections.
* Serial Ports::             Communicating with serial ports.
* Byte Packing::             Using bindat to pack and unpack binary data.


File: elisp.info,  Node: Subprocess Creation,  Next: Shell Arguments,  Up: Processes

38.1 Functions that Create Subprocesses
=======================================

There are three primitives that create a new subprocess in which to run
a program.  One of them, ‘make-process’, creates an asynchronous process
and returns a process object (*note Asynchronous Processes::).  The
other two, ‘call-process’ and ‘call-process-region’, create a
synchronous process and do not return a process object (*note
Synchronous Processes::).  There are various higher-level functions that
make use of these primitives to run particular types of process.

   Synchronous and asynchronous processes are explained in the following
sections.  Since the three functions are all called in a similar
fashion, their common arguments are described here.

   In all cases, the functions specify the program to be run.  An error
is signaled if the file is not found or cannot be executed.  If the file
name is relative, the variable ‘exec-path’ contains a list of
directories to search.  Emacs initializes ‘exec-path’ when it starts up,
based on the value of the environment variable ‘PATH’.  The standard
file name constructs, ‘~’, ‘.’, and ‘..’, are interpreted as usual in
‘exec-path’, but environment variable substitutions (‘$HOME’, etc.) are
not recognized; use ‘substitute-in-file-name’ to perform them (*note
File Name Expansion::).  ‘nil’ in this list refers to
‘default-directory’.

   Executing a program can also try adding suffixes to the specified
name:

 -- User Option: exec-suffixes
     This variable is a list of suffixes (strings) to try adding to the
     specified program file name.  The list should include ‘""’ if you
     want the name to be tried exactly as specified.  The default value
     is system-dependent.

   *Please note:* The argument PROGRAM contains only the name of the
program file; it may not contain any command-line arguments.  You must
use a separate argument, ARGS, to provide those, as described below.

   Each of the subprocess-creating functions has a BUFFER-OR-NAME
argument that specifies where the output from the program will go.  It
should be a buffer or a buffer name; if it is a buffer name, that will
create the buffer if it does not already exist.  It can also be ‘nil’,
which says to discard the output, unless a custom filter function
handles it.  (*Note Filter Functions::, and *note Read and Print::.)
Normally, you should avoid having multiple processes send output to the
same buffer because their output would be intermixed randomly.  For
synchronous processes, you can send the output to a file instead of a
buffer (and the corresponding argument is therefore more appropriately
called DESTINATION).  By default, both standard output and standard
error streams go to the same destination, but all the 3 primitives allow
optionally to direct the standard error stream to a different
destination.

   All three of the subprocess-creating functions allow to specify
command-line arguments for the process to run.  For ‘call-process’ and
‘call-process-region’, these come in the form of a ‘&rest’ argument,
ARGS.  For ‘make-process’, both the program to run and its command-line
arguments are specified as a list of strings.  The command-line
arguments must all be strings, and they are supplied to the program as
separate argument strings.  Wildcard characters and other shell
constructs have no special meanings in these strings, since the strings
are passed directly to the specified program.

   The subprocess inherits its environment from Emacs, but you can
specify overrides for it with ‘process-environment’.  *Note System
Environment::.  The subprocess gets its current directory from the value
of ‘default-directory’.

 -- Variable: exec-directory
     The value of this variable is a string, the name of a directory
     that contains programs that come with GNU Emacs and are intended
     for Emacs to invoke.  The program ‘movemail’ is an example of such
     a program; Rmail uses it to fetch new mail from an inbox.

 -- User Option: exec-path
     The value of this variable is a list of directories to search for
     programs to run in subprocesses.  Each element is either the name
     of a directory (i.e., a string), or ‘nil’, which stands for the
     default directory (which is the value of ‘default-directory’).
     *Note executable-find: Locating Files, for the details of this
     search.

     The value of ‘exec-path’ is used by ‘call-process’ and
     ‘start-process’ when the PROGRAM argument is not an absolute file
     name.

     Generally, you should not modify ‘exec-path’ directly.  Instead,
     ensure that your ‘PATH’ environment variable is set appropriately
     before starting Emacs.  Trying to modify ‘exec-path’ independently
     of ‘PATH’ can lead to confusing results.


File: elisp.info,  Node: Shell Arguments,  Next: Synchronous Processes,  Prev: Subprocess Creation,  Up: Processes

38.2 Shell Arguments
====================

Lisp programs sometimes need to run a shell and give it a command that
contains file names that were specified by the user.  These programs
ought to be able to support any valid file name.  But the shell gives
special treatment to certain characters, and if these characters occur
in the file name, they will confuse the shell.  To handle these
characters, use the function ‘shell-quote-argument’:

 -- Function: shell-quote-argument argument
     This function returns a string that represents, in shell syntax, an
     argument whose actual contents are ARGUMENT.  It should work
     reliably to concatenate the return value into a shell command and
     then pass it to a shell for execution.

     Precisely what this function does depends on your operating system.
     The function is designed to work with the syntax of your system’s
     standard shell; if you use an unusual shell, you will need to
     redefine this function.  *Note Security Considerations::.

          ;; This example shows the behavior on GNU and Unix systems.
          (shell-quote-argument "foo > bar")
               ⇒ "foo\\ \\>\\ bar"

          ;; This example shows the behavior on MS-DOS and MS-Windows.
          (shell-quote-argument "foo > bar")
               ⇒ "\"foo > bar\""

     Here’s an example of using ‘shell-quote-argument’ to construct a
     shell command:

          (concat "diff -u "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))

   The following two functions are useful for combining a list of
individual command-line argument strings into a single string, and
taking a string apart into a list of individual command-line arguments.
These functions are mainly intended for converting user input in the
minibuffer, a Lisp string, into a list of string arguments to be passed
to ‘make-process’, ‘call-process’ or ‘start-process’, or for converting
such lists of arguments into a single Lisp string to be presented in the
minibuffer or echo area.  Note that if a shell is involved (e.g., if
using ‘call-process-shell-command’), arguments should still be protected
by ‘shell-quote-argument’; ‘combine-and-quote-strings’ is _not_ intended
to protect special characters from shell evaluation.

 -- Function: split-string-and-unquote string &optional separators
     This function splits STRING into substrings at matches for the
     regular expression SEPARATORS, like ‘split-string’ does (*note
     Creating Strings::); in addition, it removes quoting from the
     substrings.  It then makes a list of the substrings and returns it.

     If SEPARATORS is omitted or ‘nil’, it defaults to ‘"\\s-+"’, which
     is a regular expression that matches one or more characters with
     whitespace syntax (*note Syntax Class Table::).

     This function supports two types of quoting: enclosing a whole
     string in double quotes ‘"..."’, and quoting individual characters
     with a backslash escape ‘\’.  The latter is also used in Lisp
     strings, so this function can handle those as well.

 -- Function: combine-and-quote-strings list-of-strings &optional
          separator
     This function concatenates LIST-OF-STRINGS into a single string,
     quoting each string as necessary.  It also sticks the SEPARATOR
     string between each pair of strings; if SEPARATOR is omitted or
     ‘nil’, it defaults to ‘" "’.  The return value is the resulting
     string.

     The strings in LIST-OF-STRINGS that need quoting are those that
     include SEPARATOR as their substring.  Quoting a string encloses it
     in double quotes ‘"..."’.  In the simplest case, if you are consing
     a command from the individual command-line arguments, every
     argument that includes embedded blanks will be quoted.


File: elisp.info,  Node: Synchronous Processes,  Next: Asynchronous Processes,  Prev: Shell Arguments,  Up: Processes

38.3 Creating a Synchronous Process
===================================

After a “synchronous process” is created, Emacs waits for the process to
terminate before continuing.  Starting Dired on GNU or Unix(1) is an
example of this: it runs ‘ls’ in a synchronous process, then modifies
the output slightly.  Because the process is synchronous, the entire
directory listing arrives in the buffer before Emacs tries to do
anything with it.

   While Emacs waits for the synchronous subprocess to terminate, the
user can quit by typing ‘C-g’.  The first ‘C-g’ tries to kill the
subprocess with a ‘SIGINT’ signal; but it waits until the subprocess
actually terminates before quitting.  If during that time the user types
another ‘C-g’, that kills the subprocess instantly with ‘SIGKILL’ and
quits immediately (except on MS-DOS, where killing other processes
doesn’t work).  *Note Quitting::.

   The synchronous subprocess functions return an indication of how the
process terminated.

   The output from a synchronous subprocess is generally decoded using a
coding system, much like text read from a file.  The input sent to a
subprocess by ‘call-process-region’ is encoded using a coding system,
much like text written into a file.  *Note Coding Systems::.

 -- Function: call-process program &optional infile destination display
          &rest args
     This function calls PROGRAM and waits for it to finish.

     The current working directory of the subprocess is set to the
     current buffer’s value of ‘default-directory’ if that is local (as
     determined by ‘unhandled-file-name-directory’), or "~" otherwise.
     If you want to run a process in a remote directory use
     ‘process-file’.

     The standard input for the new process comes from file INFILE if
     INFILE is not ‘nil’, and from the null device otherwise.  The
     argument DESTINATION says where to put the process output.  Here
     are the possibilities:

     a buffer
          Insert the output in that buffer, before point.  This includes
          both the standard output stream and the standard error stream
          of the process.

     a buffer name (a string)
          Insert the output in a buffer with that name, before point.

     ‘t’
          Insert the output in the current buffer, before point.

     ‘nil’
          Discard the output.

     0
          Discard the output, and return ‘nil’ immediately without
          waiting for the subprocess to finish.

          In this case, the process is not truly synchronous, since it
          can run in parallel with Emacs; but you can think of it as
          synchronous in that Emacs is essentially finished with the
          subprocess as soon as this function returns.

          MS-DOS doesn’t support asynchronous subprocesses, so this
          option doesn’t work there.

     ‘(:file FILE-NAME)’
          Send the output to the file name specified, overwriting it if
          it already exists.

     ‘(REAL-DESTINATION ERROR-DESTINATION)’
          Keep the standard output stream separate from the standard
          error stream; deal with the ordinary output as specified by
          REAL-DESTINATION, and dispose of the error output according to
          ERROR-DESTINATION.  If ERROR-DESTINATION is ‘nil’, that means
          to discard the error output, ‘t’ means mix it with the
          ordinary output, and a string specifies a file name to
          redirect error output into.

          You can’t directly specify a buffer to put the error output
          in; that is too difficult to implement.  But you can achieve
          this result by sending the error output to a temporary file
          and then inserting the file into a buffer when the subprocess
          finishes.

     If DISPLAY is non-‘nil’, then ‘call-process’ redisplays the buffer
     as output is inserted.  (However, if the coding system chosen for
     decoding output is ‘undecided’, meaning deduce the encoding from
     the actual data, then redisplay sometimes cannot continue once
     non-ASCII characters are encountered.  There are fundamental
     reasons why it is hard to fix this; see *note Output from
     Processes::.)

     Otherwise the function ‘call-process’ does no redisplay, and the
     results become visible on the screen only when Emacs redisplays
     that buffer in the normal course of events.

     The remaining arguments, ARGS, are strings that specify command
     line arguments for the program.  Each string is passed to PROGRAM
     as a separate argument.

     The value returned by ‘call-process’ (unless you told it not to
     wait) indicates the reason for process termination.  A number gives
     the exit status of the subprocess; 0 means success, and any other
     value means failure.  If the process terminated with a signal,
     ‘call-process’ returns a string describing the signal.  If you told
     ‘call-process’ not to wait, it returns ‘nil’.

     In the examples below, the buffer ‘foo’ is current.

          (call-process "pwd" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          /home/lewis/manual
          ---------- Buffer: foo ----------

          (call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
               ⇒ 0

          ---------- Buffer: bar ----------
          lewis:x:1001:1001:Bil Lewis,,,,:/home/lewis:/bin/bash

          ---------- Buffer: bar ----------

     Here is an example of the use of ‘call-process’, as used to be
     found in the definition of the ‘insert-directory’ function:

          (call-process insert-directory-program nil t nil switches
                        (if full-directory-p
                            (concat (file-name-as-directory file) ".")
                          file))

 -- Function: process-file program &optional infile buffer display &rest
          args
     This function processes files synchronously in a separate process.
     It is similar to ‘call-process’, but may invoke a file handler
     based on the value of the variable ‘default-directory’, which
     specifies the current working directory of the subprocess.

     The arguments are handled in almost the same way as for
     ‘call-process’, with the following differences:

     Some file handlers may not support all combinations and forms of
     the arguments INFILE, BUFFER, and DISPLAY.  For example, some file
     handlers might behave as if DISPLAY were ‘nil’, regardless of the
     value actually passed.  As another example, some file handlers
     might not support separating standard output and error output by
     way of the BUFFER argument.

     If a file handler is invoked, it determines the program to run
     based on the first argument PROGRAM.  For instance, suppose that a
     handler for remote files is invoked.  Then the path that is used
     for searching for the program might be different from ‘exec-path’.

     The second argument INFILE may invoke a file handler.  The file
     handler could be different from the handler chosen for the
     ‘process-file’ function itself.  (For example, ‘default-directory’
     could be on one remote host, and INFILE on a different remote host.
     Or ‘default-directory’ could be non-special, whereas INFILE is on a
     remote host.)

     If BUFFER is a list of the form ‘(REAL-DESTINATION
     ERROR-DESTINATION)’, and ERROR-DESTINATION names a file, then the
     same remarks as for INFILE apply.

     The remaining arguments (ARGS) will be passed to the process
     verbatim.  Emacs is not involved in processing file names that are
     present in ARGS.  To avoid confusion, it may be best to avoid
     absolute file names in ARGS, but rather to specify all file names
     as relative to ‘default-directory’.  The function
     ‘file-relative-name’ is useful for constructing such relative file
     names.

 -- Variable: process-file-side-effects
     This variable indicates whether a call of ‘process-file’ changes
     remote files.

     By default, this variable is always set to ‘t’, meaning that a call
     of ‘process-file’ could potentially change any file on a remote
     host.  When set to ‘nil’, a file handler could optimize its
     behavior with respect to remote file attribute caching.

     You should only ever change this variable with a let-binding; never
     with ‘setq’.

 -- Function: call-process-region start end program &optional delete
          destination display &rest args
     This function sends the text from START to END as standard input to
     a process running PROGRAM.  It deletes the text sent if DELETE is
     non-‘nil’; this is useful when DESTINATION is ‘t’, to insert the
     output in the current buffer in place of the input.

     The arguments DESTINATION and DISPLAY control what to do with the
     output from the subprocess, and whether to update the display as it
     comes in.  For details, see the description of ‘call-process’,
     above.  If DESTINATION is the integer 0, ‘call-process-region’
     discards the output and returns ‘nil’ immediately, without waiting
     for the subprocess to finish (this only works if asynchronous
     subprocesses are supported; i.e., not on MS-DOS).

     The remaining arguments, ARGS, are strings that specify command
     line arguments for the program.

     The return value of ‘call-process-region’ is just like that of
     ‘call-process’: ‘nil’ if you told it to return without waiting;
     otherwise, a number or string which indicates how the subprocess
     terminated.

     In the following example, we use ‘call-process-region’ to run the
     ‘cat’ utility, with standard input being the first five characters
     in buffer ‘foo’ (the word ‘input’).  ‘cat’ copies its standard
     input into its standard output.  Since the argument DESTINATION is
     ‘t’, this output is inserted in the current buffer.

          ---------- Buffer: foo ----------
          input★
          ---------- Buffer: foo ----------

          (call-process-region 1 6 "cat" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          inputinput★
          ---------- Buffer: foo ----------

     For example, the ‘shell-command-on-region’ command uses
     ‘call-shell-region’ in a manner similar to this:

          (call-shell-region
           start end
           command              ; shell command
           nil                  ; do not delete region
           buffer)              ; send output to ‘buffer’

 -- Function: call-process-shell-command command &optional infile
          destination display
     This function executes the shell command COMMAND synchronously.
     The other arguments are handled as in ‘call-process’.  An old
     calling convention allowed passing any number of additional
     arguments after DISPLAY, which were concatenated to COMMAND; this
     is still supported, but strongly discouraged.

 -- Function: process-file-shell-command command &optional infile
          destination display
     This function is like ‘call-process-shell-command’, but uses
     ‘process-file’ internally.  Depending on ‘default-directory’,
     COMMAND can be executed also on remote hosts.  An old calling
     convention allowed passing any number of additional arguments after
     DISPLAY, which were concatenated to COMMAND; this is still
     supported, but strongly discouraged.

 -- Function: call-shell-region start end command &optional delete
          destination
     This function sends the text from START to END as standard input to
     an inferior shell running COMMAND.  This function is similar than
     ‘call-process-region’, with process being a shell.  The arguments
     ‘delete’, ‘destination’ and the return value are like in
     ‘call-process-region’.  Note that this function doesn’t accept
     additional arguments.

 -- Function: shell-command-to-string command
     This function executes COMMAND (a string) as a shell command, then
     returns the command’s output as a string.

 -- Function: process-lines program &rest args
     This function runs PROGRAM, waits for it to finish, and returns its
     output as a list of strings.  Each string in the list holds a
     single line of text output by the program; the end-of-line
     characters are stripped from each line.  The arguments beyond
     PROGRAM, ARGS, are strings that specify command-line arguments with
     which to run the program.

     If PROGRAM exits with a non-zero exit status, this function signals
     an error.

     This function works by calling ‘call-process’, so program output is
     decoded in the same way as for ‘call-process’.

   ---------- Footnotes ----------

   (1) On other systems, Emacs uses a Lisp emulation of ‘ls’; see *note
Contents of Directories::.


File: elisp.info,  Node: Asynchronous Processes,  Next: Deleting Processes,  Prev: Synchronous Processes,  Up: Processes

38.4 Creating an Asynchronous Process
=====================================

In this section, we describe how to create an “asynchronous process”.
After an asynchronous process is created, it runs in parallel with
Emacs, and Emacs can communicate with it using the functions described
in the following sections (*note Input to Processes::, and *note Output
from Processes::).  Note that process communication is only partially
asynchronous: Emacs sends data to the process only when certain
functions are called, and Emacs accepts data from the process only while
waiting for input or for a time delay.

   An asynchronous process is controlled either via a “pty”
(pseudo-terminal) or a “pipe”.  The choice of pty or pipe is made when
creating the process, by default based on the value of the variable
‘process-connection-type’ (see below).  If available, ptys are usually
preferable for processes visible to the user, as in Shell mode, because
they allow for job control (‘C-c’, ‘C-z’, etc.) between the process and
its children, and because interactive programs treat ptys as terminal
devices, whereas pipes don’t support these features.  However, for
subprocesses used by Lisp programs for internal purposes, it is often
better to use a pipe, because pipes are more efficient, and because they
are immune to stray character injections that ptys introduce for large
(around 500 byte) messages.  Also, the total number of ptys is limited
on many systems and it is good not to waste them.

 -- Function: make-process &rest args
     This function is the basic low-level primitive for starting
     asynchronous subprocesses.  It returns a process object
     representing the subprocess.  Compared to the more high-level
     ‘start-process’, described below, it takes keyword arguments, is
     more flexible, and allows to specify process filters and sentinels
     in a single call.

     The arguments ARGS are a list of keyword/argument pairs.  Omitting
     a keyword is always equivalent to specifying it with value ‘nil’.
     Here are the meaningful keywords:

     :name NAME
          Use the string NAME as the process name; if a process with
          this name already exists, then NAME is modified (by appending
          ‘<1>’, etc.) to be unique.

     :buffer BUFFER
          Use BUFFER as the process buffer.  If the value is ‘nil’, the
          subprocess is not associated with any buffer.

     :command COMMAND
          Use COMMAND as the command line of the process.  The value
          should be a list starting with the program’s executable file
          name, followed by strings to give to the program as its
          arguments.  If the first element of the list is ‘nil’, Emacs
          opens a new pseudoterminal (pty) and associates its input and
          output with BUFFER, without actually running any program; the
          rest of the list elements are ignored in that case.

     :coding CODING
          If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.  The coding system used for encoding the data written
          to the program is also used for encoding the command-line
          arguments (but not the program itself, whose file name is
          encoded as any other file name; *note file-name-coding-system:
          Encoding and I/O.).

          If CODING is ‘nil’, the default rules for finding the coding
          system will apply.  *Note Default Coding Systems::.

     :connection-type TYPE
          Initialize the type of device used to communicate with the
          subprocess.  Possible values are ‘pty’ to use a pty, ‘pipe’ to
          use a pipe, or ‘nil’ to use the default derived from the value
          of the ‘process-connection-type’ variable.  This parameter and
          the value of ‘process-connection-type’ are ignored if a
          non-‘nil’ value is specified for the ‘:stderr’ parameter; in
          that case, the type will always be ‘pipe’.

     :noquery QUERY-FLAG
          Initialize the process query flag to QUERY-FLAG.  *Note Query
          Before Exit::.

     :stop STOPPED
          If STOPPED is non-‘nil’, start the process in the stopped
          state.

     :filter FILTER
          Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be overridden
          later.  *Note Filter Functions::.

     :sentinel SENTINEL
          Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          overridden later.  *Note Sentinels::.

     :stderr STDERR
          Associate STDERR with the standard error of the process.  A
          non-‘nil’ value should be either a buffer or a pipe process
          created with ‘make-pipe-process’, described below.

     The original argument list, modified with the actual connection
     information, is available via the ‘process-contact’ function.

     The current working directory of the subprocess is set to the
     current buffer’s value of ‘default-directory’ if that is local (as
     determined by ‘unhandled-file-name-directory’), or "~" otherwise.
     If you want to run a process in a remote directory use
     ‘start-file-process’.

 -- Function: make-pipe-process &rest args
     This function creates a bidirectional pipe which can be attached to
     a child process.  This is useful with the ‘:stderr’ keyword of
     ‘make-process’.  The function returns a process object.

     The arguments ARGS are a list of keyword/argument pairs.  Omitting
     a keyword is always equivalent to specifying it with value ‘nil’.

     Here are the meaningful keywords:

     :name NAME
          Use the string NAME as the process name.  As with
          ‘make-process’, it is modified if necessary to make it unique.

     :buffer BUFFER
          Use BUFFER as the process buffer.

     :coding CODING
          If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.

          If CODING is ‘nil’, the default rules for finding the coding
          system will apply.  *Note Default Coding Systems::.

     :noquery QUERY-FLAG
          Initialize the process query flag to QUERY-FLAG.  *Note Query
          Before Exit::.

     :stop STOPPED
          If STOPPED is non-‘nil’, start the process in the stopped
          state.  In the stopped state, a pipe process does not accept
          incoming data, but you can send outgoing data.  The stopped
          state is set by ‘stop-process’ and cleared by
          ‘continue-process’ (*note Signals to Processes::).

     :filter FILTER
          Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be changed later.
          *Note Filter Functions::.

     :sentinel SENTINEL
          Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          changed later.  *Note Sentinels::.

     The original argument list, modified with the actual connection
     information, is available via the ‘process-contact’ function.

 -- Function: start-process name buffer-or-name program &rest args
     This function is a higher-level wrapper around ‘make-process’,
     exposing an interface that is similar to ‘call-process’.  It
     creates a new asynchronous subprocess and starts the specified
     PROGRAM running in it.  It returns a process object that stands for
     the new subprocess in Lisp.  The argument NAME specifies the name
     for the process object; as with ‘make-process’, it is modified if
     necessary to make it unique.  The buffer BUFFER-OR-NAME is the
     buffer to associate with the process.

     If PROGRAM is ‘nil’, Emacs opens a new pseudoterminal (pty) and
     associates its input and output with BUFFER-OR-NAME, without
     creating a subprocess.  In that case, the remaining arguments ARGS
     are ignored.

     The rest of ARGS are strings that specify command line arguments
     for the subprocess.

     In the example below, the first process is started and runs
     (rather, sleeps) for 100 seconds (the output buffer ‘foo’ is
     created immediately).  Meanwhile, the second process is started,
     and given the name ‘my-process<1>’ for the sake of uniqueness.  It
     inserts the directory listing at the end of the buffer ‘foo’,
     before the first process finishes.  Then it finishes, and a message
     to that effect is inserted in the buffer.  Much later, the first
     process finishes, and another message is inserted in the buffer for
     it.

          (start-process "my-process" "foo" "sleep" "100")
               ⇒ #<process my-process>

          (start-process "my-process" "foo" "ls" "-l" "/bin")
               ⇒ #<process my-process<1>>

          ---------- Buffer: foo ----------
          total 8336
          -rwxr-xr-x 1 root root 971384 Mar 30 10:14 bash
          -rwxr-xr-x 1 root root 146920 Jul  5  2011 bsd-csh
          ...
          -rwxr-xr-x 1 root root 696880 Feb 28 15:55 zsh4

          Process my-process<1> finished

          Process my-process finished
          ---------- Buffer: foo ----------

 -- Function: start-file-process name buffer-or-name program &rest args
     Like ‘start-process’, this function starts a new asynchronous
     subprocess running PROGRAM in it, and returns its process object.

     The difference from ‘start-process’ is that this function may
     invoke a file handler based on the value of ‘default-directory’.
     This handler ought to run PROGRAM, perhaps on the local host,
     perhaps on a remote host that corresponds to ‘default-directory’.
     In the latter case, the local part of ‘default-directory’ becomes
     the working directory of the process.

     This function does not try to invoke file name handlers for PROGRAM
     or for the rest of ARGS.

     Depending on the implementation of the file handler, it might not
     be possible to apply ‘process-filter’ or ‘process-sentinel’ to the
     resulting process object.  *Note Filter Functions::, and *note
     Sentinels::.

     Some file handlers may not support ‘start-file-process’ (for
     example the function ‘ange-ftp-hook-function’).  In such cases,
     this function does nothing and returns ‘nil’.

 -- Function: start-process-shell-command name buffer-or-name command
     This function is like ‘start-process’, except that it uses a shell
     to execute the specified COMMAND.  The argument COMMAND is a shell
     command string.  The variable ‘shell-file-name’ specifies which
     shell to use.

     The point of running a program through the shell, rather than
     directly with ‘make-process’ or ‘start-process’, is so that you can
     employ shell features such as wildcards in the arguments.  It
     follows that if you include any arbitrary user-specified arguments
     in the command, you should quote them with ‘shell-quote-argument’
     first, so that any special shell characters do _not_ have their
     special shell meanings.  *Note Shell Arguments::.  Of course, when
     executing commands based on user input you should also consider the
     security implications.

 -- Function: start-file-process-shell-command name buffer-or-name
          command
     This function is like ‘start-process-shell-command’, but uses
     ‘start-file-process’ internally.  Because of this, COMMAND can also
     be executed on remote hosts, depending on ‘default-directory’.

 -- Variable: process-connection-type
     This variable controls the type of device used to communicate with
     asynchronous subprocesses.  If it is non-‘nil’, then ptys are used,
     when available.  Otherwise, pipes are used.

     The value of ‘process-connection-type’ takes effect when
     ‘make-process’ or ‘start-process’ is called.  So you can specify
     how to communicate with one subprocess by binding the variable
     around the call to these functions.

     Note that the value of this variable is ignored when ‘make-process’
     is called with a non-‘nil’ value of the ‘:stderr’ parameter; in
     that case, Emacs will communicate with the process using pipes.

          (let ((process-connection-type nil))  ; use a pipe
            (start-process ...))

     To determine whether a given subprocess actually got a pipe or a
     pty, use the function ‘process-tty-name’ (*note Process
     Information::).


File: elisp.info,  Node: Deleting Processes,  Next: Process Information,  Prev: Asynchronous Processes,  Up: Processes

38.5 Deleting Processes
=======================

“Deleting a process” disconnects Emacs immediately from the subprocess.
Processes are deleted automatically after they terminate, but not
necessarily right away.  You can delete a process explicitly at any
time.  If you explicitly delete a terminated process before it is
deleted automatically, no harm results.  Deleting a running process
sends a signal to terminate it (and its child processes, if any), and
calls the process sentinel.  *Note Sentinels::.

   When a process is deleted, the process object itself continues to
exist as long as other Lisp objects point to it.  All the Lisp
primitives that work on process objects accept deleted processes, but
those that do I/O or send signals will report an error.  The process
mark continues to point to the same place as before, usually into a
buffer where output from the process was being inserted.

 -- User Option: delete-exited-processes
     This variable controls automatic deletion of processes that have
     terminated (due to calling ‘exit’ or to a signal).  If it is ‘nil’,
     then they continue to exist until the user runs ‘list-processes’.
     Otherwise, they are deleted immediately after they exit.

 -- Function: delete-process process
     This function deletes a process, killing it with a ‘SIGKILL’ signal
     if the process was running a program.  The argument may be a
     process, the name of a process, a buffer, or the name of a buffer.
     (A buffer or buffer-name stands for the process that
     ‘get-buffer-process’ returns.)  Calling ‘delete-process’ on a
     running process terminates it, updates the process status, and runs
     the sentinel immediately.  If the process has already terminated,
     calling ‘delete-process’ has no effect on its status, or on the
     running of its sentinel (which will happen sooner or later).

     If the process object represents a network, serial, or pipe
     connection, its status changes to ‘closed’; otherwise, it changes
     to ‘signal’, unless the process already exited.  *Note
     process-status: Process Information.

          (delete-process "*shell*")
               ⇒ nil


File: elisp.info,  Node: Process Information,  Next: Input to Processes,  Prev: Deleting Processes,  Up: Processes

38.6 Process Information
========================

Several functions return information about processes.

 -- Command: list-processes &optional query-only buffer
     This command displays a listing of all living processes.  In
     addition, it finally deletes any process whose status was ‘Exited’
     or ‘Signaled’.  It returns ‘nil’.

     The processes are shown in a buffer named ‘*Process List*’ (unless
     you specify otherwise using the optional argument BUFFER), whose
     major mode is Process Menu mode.

     If QUERY-ONLY is non-‘nil’, it only lists processes whose query
     flag is non-‘nil’.  *Note Query Before Exit::.

 -- Function: process-list
     This function returns a list of all processes that have not been
     deleted.

          (process-list)
               ⇒ (#<process display-time> #<process shell>)

 -- Function: get-process name
     This function returns the process named NAME (a string), or ‘nil’
     if there is none.  The argument NAME can also be a process object,
     in which case it is returned.

          (get-process "shell")
               ⇒ #<process shell>

 -- Function: process-command process
     This function returns the command that was executed to start
     PROCESS.  This is a list of strings, the first string being the
     program executed and the rest of the strings being the arguments
     that were given to the program.  For a network, serial, or pipe
     connection, this is either ‘nil’, which means the process is
     running or ‘t’ (process is stopped).

          (process-command (get-process "shell"))
               ⇒ ("bash" "-i")

 -- Function: process-contact process &optional key
     This function returns information about how a network, a serial, or
     a pipe connection was set up.  When KEY is ‘nil’, it returns
     ‘(HOSTNAME SERVICE)’ for a network connection, ‘(PORT SPEED)’ for a
     serial connection, and ‘t’ for a pipe connection.  For an ordinary
     child process, this function always returns ‘t’ when called with a
     ‘nil’ KEY.

     If KEY is ‘t’, the value is the complete status information for the
     connection, server, serial port, or pipe; that is, the list of
     keywords and values specified in ‘make-network-process’,
     ‘make-serial-process’, or ‘make-pipe-process’, except that some of
     the values represent the current status instead of what you
     specified.

     For a network process, the values include (see
     ‘make-network-process’ for a complete list):

     ‘:buffer’
          The associated value is the process buffer.
     ‘:filter’
          The associated value is the process filter function.  *Note
          Filter Functions::.
     ‘:sentinel’
          The associated value is the process sentinel function.  *Note
          Sentinels::.
     ‘:remote’
          In a connection, the address in internal format of the remote
          peer.
     ‘:local’
          The local address, in internal format.
     ‘:service’
          In a server, if you specified ‘t’ for SERVICE, this value is
          the actual port number.

     ‘:local’ and ‘:remote’ are included even if they were not specified
     explicitly in ‘make-network-process’.

     For a serial connection, see ‘make-serial-process’ and
     ‘serial-process-configure’ for the list of keys.  For a pipe
     connection, see ‘make-pipe-process’ for the list of keys.

     If KEY is a keyword, the function returns the value corresponding
     to that keyword.

 -- Function: process-id process
     This function returns the PID of PROCESS.  This is an integral
     number that distinguishes the process PROCESS from all other
     processes running on the same computer at the current time.  The
     PID of a process is chosen by the operating system kernel when the
     process is started and remains constant as long as the process
     exists.  For network, serial, and pipe connections, this function
     returns ‘nil’.

 -- Function: process-name process
     This function returns the name of PROCESS, as a string.

 -- Function: process-status process-name
     This function returns the status of PROCESS-NAME as a symbol.  The
     argument PROCESS-NAME must be a process, a buffer, or a process
     name (a string).

     The possible values for an actual subprocess are:

     ‘run’
          for a process that is running.
     ‘stop’
          for a process that is stopped but continuable.
     ‘exit’
          for a process that has exited.
     ‘signal’
          for a process that has received a fatal signal.
     ‘open’
          for a network, serial, or pipe connection that is open.
     ‘closed’
          for a network, serial, or pipe connection that is closed.
          Once a connection is closed, you cannot reopen it, though you
          might be able to open a new connection to the same place.
     ‘connect’
          for a non-blocking connection that is waiting to complete.
     ‘failed’
          for a non-blocking connection that has failed to complete.
     ‘listen’
          for a network server that is listening.
     ‘nil’
          if PROCESS-NAME is not the name of an existing process.

          (process-status (get-buffer "*shell*"))
               ⇒ run

     For a network, serial, or pipe connection, ‘process-status’ returns
     one of the symbols ‘open’, ‘stop’, or ‘closed’.  The latter means
     that the other side closed the connection, or Emacs did
     ‘delete-process’.  The value ‘stop’ means that ‘stop-process’ was
     called on the connection.

 -- Function: process-live-p process
     This function returns non-‘nil’ if PROCESS is alive.  A process is
     considered alive if its status is ‘run’, ‘open’, ‘listen’,
     ‘connect’ or ‘stop’.

 -- Function: process-type process
     This function returns the symbol ‘network’ for a network connection
     or server, ‘serial’ for a serial port connection, ‘pipe’ for a pipe
     connection, or ‘real’ for a subprocess created for running a
     program.

 -- Function: process-exit-status process
     This function returns the exit status of PROCESS or the signal
     number that killed it.  (Use the result of ‘process-status’ to
     determine which of those it is.)  If PROCESS has not yet
     terminated, the value is 0.  For network, serial, and pipe
     connections that are already closed, the value is either 0 or 256,
     depending on whether the connection was closed normally or
     abnormally.

 -- Function: process-tty-name process
     This function returns the terminal name that PROCESS is using for
     its communication with Emacs—or ‘nil’ if it is using pipes instead
     of a pty (see ‘process-connection-type’ in *note Asynchronous
     Processes::).  If PROCESS represents a program running on a remote
     host, the terminal name used by that program on the remote host is
     provided as process property ‘remote-tty’.  If PROCESS represents a
     network, serial, or pipe connection, the value is ‘nil’.

 -- Function: process-coding-system process
     This function returns a cons cell ‘(DECODE . ENCODE)’, describing
     the coding systems in use for decoding output from, and encoding
     input to, PROCESS (*note Coding Systems::).

 -- Function: set-process-coding-system process &optional
          decoding-system encoding-system
     This function specifies the coding systems to use for subsequent
     output from and input to PROCESS.  It will use DECODING-SYSTEM to
     decode subprocess output, and ENCODING-SYSTEM to encode subprocess
     input.

   Every process also has a property list that you can use to store
miscellaneous values associated with the process.

 -- Function: process-get process propname
     This function returns the value of the PROPNAME property of
     PROCESS.

 -- Function: process-put process propname value
     This function sets the value of the PROPNAME property of PROCESS to
     VALUE.

 -- Function: process-plist process
     This function returns the process plist of PROCESS.

 -- Function: set-process-plist process plist
     This function sets the process plist of PROCESS to PLIST.


File: elisp.info,  Node: Input to Processes,  Next: Signals to Processes,  Prev: Process Information,  Up: Processes

38.7 Sending Input to Processes
===============================

Asynchronous subprocesses receive input when it is sent to them by
Emacs, which is done with the functions in this section.  You must
specify the process to send input to, and the input data to send.  If
the subprocess runs a program, the data appears on the standard input of
that program; for connections, the data is sent to the connected device
or program.

   Some operating systems have limited space for buffered input in a
pty.  On these systems, Emacs sends an EOF periodically amidst the other
characters, to force them through.  For most programs, these EOFs do no
harm.

   Subprocess input is normally encoded using a coding system before the
subprocess receives it, much like text written into a file.  You can use
‘set-process-coding-system’ to specify which coding system to use (*note
Process Information::).  Otherwise, the coding system comes from
‘coding-system-for-write’, if that is non-‘nil’; or else from the
defaulting mechanism (*note Default Coding Systems::).

   Sometimes the system is unable to accept input for that process,
because the input buffer is full.  When this happens, the send functions
wait a short while, accepting output from subprocesses, and then try
again.  This gives the subprocess a chance to read more of its pending
input and make space in the buffer.  It also allows filters, sentinels
and timers to run—so take account of that in writing your code.

   In these functions, the PROCESS argument can be a process or the name
of a process, or a buffer or buffer name (which stands for a process via
‘get-buffer-process’).  ‘nil’ means the current buffer’s process.

 -- Function: process-send-string process string
     This function sends PROCESS the contents of STRING as standard
     input.  It returns ‘nil’.  For example, to make a Shell buffer list
     files:

          (process-send-string "shell<1>" "ls\n")
               ⇒ nil

 -- Function: process-send-region process start end
     This function sends the text in the region defined by START and END
     as standard input to PROCESS.

     An error is signaled unless both START and END are integers or
     markers that indicate positions in the current buffer.  (It is
     unimportant which number is larger.)

 -- Function: process-send-eof &optional process
     This function makes PROCESS see an end-of-file in its input.  The
     EOF comes after any text already sent to it.  The function returns
     PROCESS.

          (process-send-eof "shell")
               ⇒ "shell"

 -- Function: process-running-child-p &optional process
     This function will tell you whether a PROCESS, which must not be a
     connection but a real subprocess, has given control of its terminal
     to a child process of its own.  If this is true, the function
     returns the numeric ID of the foreground process group of PROCESS;
     it returns ‘nil’ if Emacs can be certain that this is not so.  The
     value is ‘t’ if Emacs cannot tell whether this is true.  This
     function signals an error if PROCESS is a network, serial, or pipe
     connection, or is the subprocess is not active.


File: elisp.info,  Node: Signals to Processes,  Next: Output from Processes,  Prev: Input to Processes,  Up: Processes

38.8 Sending Signals to Processes
=================================

“Sending a signal” to a subprocess is a way of interrupting its
activities.  There are several different signals, each with its own
meaning.  The set of signals and their names is defined by the operating
system.  For example, the signal ‘SIGINT’ means that the user has typed
‘C-c’, or that some analogous thing has happened.

   Each signal has a standard effect on the subprocess.  Most signals
kill the subprocess, but some stop (or resume) execution instead.  Most
signals can optionally be handled by programs; if the program handles
the signal, then we can say nothing in general about its effects.

   You can send signals explicitly by calling the functions in this
section.  Emacs also sends signals automatically at certain times:
killing a buffer sends a ‘SIGHUP’ signal to all its associated
processes; killing Emacs sends a ‘SIGHUP’ signal to all remaining
processes.  (‘SIGHUP’ is a signal that usually indicates that the user
“hung up the phone”, i.e., disconnected.)

   Each of the signal-sending functions takes two optional arguments:
PROCESS and CURRENT-GROUP.

   The argument PROCESS must be either a process, a process name, a
buffer, a buffer name, or ‘nil’.  A buffer or buffer name stands for a
process through ‘get-buffer-process’.  ‘nil’ stands for the process
associated with the current buffer.  Except with ‘stop-process’ and
‘continue-process’, an error is signaled if PROCESS does not identify an
active process, or if it represents a network, serial, or pipe
connection.

   The argument CURRENT-GROUP is a flag that makes a difference when you
are running a job-control shell as an Emacs subprocess.  If it is
non-‘nil’, then the signal is sent to the current process-group of the
terminal that Emacs uses to communicate with the subprocess.  If the
process is a job-control shell, this means the shell’s current subjob.
If CURRENT-GROUP is ‘nil’, the signal is sent to the process group of
the immediate subprocess of Emacs.  If the subprocess is a job-control
shell, this is the shell itself.  If CURRENT-GROUP is ‘lambda’, the
signal is sent to the process-group that owns the terminal, but only if
it is not the shell itself.

   The flag CURRENT-GROUP has no effect when a pipe is used to
communicate with the subprocess, because the operating system does not
support the distinction in the case of pipes.  For the same reason,
job-control shells won’t work when a pipe is used.  See
‘process-connection-type’ in *note Asynchronous Processes::.

 -- Function: interrupt-process &optional process current-group
     This function interrupts the process PROCESS by sending the signal
     ‘SIGINT’.  Outside of Emacs, typing the interrupt character
     (normally ‘C-c’ on some systems, and <DEL> on others) sends this
     signal.  When the argument CURRENT-GROUP is non-‘nil’, you can
     think of this function as typing ‘C-c’ on the terminal by which
     Emacs talks to the subprocess.

 -- Function: kill-process &optional process current-group
     This function kills the process PROCESS by sending the signal
     ‘SIGKILL’.  This signal kills the subprocess immediately, and
     cannot be handled by the subprocess.

 -- Function: quit-process &optional process current-group
     This function sends the signal ‘SIGQUIT’ to the process PROCESS.
     This signal is the one sent by the quit character (usually ‘C-\’)
     when you are not inside Emacs.

 -- Function: stop-process &optional process current-group
     This function stops the specified PROCESS.  If it is a real
     subprocess running a program, it sends the signal ‘SIGTSTP’ to that
     subprocess.  If PROCESS represents a network, serial, or pipe
     connection, this function inhibits handling of the incoming data
     from the connection; for a network server, this means not accepting
     new connections.  Use ‘continue-process’ to resume normal
     execution.

     Outside of Emacs, on systems with job control, the stop character
     (usually ‘C-z’) normally sends the ‘SIGTSTP’ signal to a
     subprocess.  When CURRENT-GROUP is non-‘nil’, you can think of this
     function as typing ‘C-z’ on the terminal Emacs uses to communicate
     with the subprocess.

 -- Function: continue-process &optional process current-group
     This function resumes execution of the process PROCESS.  If it is a
     real subprocess running a program, it sends the signal ‘SIGCONT’ to
     that subprocess; this presumes that PROCESS was stopped previously.
     If PROCESS represents a network, serial, or pipe connection, this
     function resumes handling of the incoming data from the connection.
     For serial connections, data that arrived during the time the
     process was stopped might be lost.

 -- Command: signal-process process signal
     This function sends a signal to process PROCESS.  The argument
     SIGNAL specifies which signal to send; it should be an integer, or
     a symbol whose name is a signal.

     The PROCESS argument can be a system process ID (an integer); that
     allows you to send signals to processes that are not children of
     Emacs.  *Note System Processes::.

   Sometimes, it is necessary to send a signal to a non-local
asynchronous process.  This is possible by writing an own
‘interrupt-process’ implementation.  This function must be added then to
‘interrupt-process-functions’.

 -- Variable: interrupt-process-functions
     This variable is a list of functions to be called for
     ‘interrupt-process’.  The arguments of the functions are the same
     as for ‘interrupt-process’.  These functions are called in the
     order of the list, until one of them returns non-‘nil’.  The
     default function, which shall always be the last in this list, is
     ‘internal-default-interrupt-process’.

     This is the mechanism, how Tramp implements ‘interrupt-process’.


File: elisp.info,  Node: Output from Processes,  Next: Sentinels,  Prev: Signals to Processes,  Up: Processes

38.9 Receiving Output from Processes
====================================

The output that an asynchronous subprocess writes to its standard output
stream is passed to a function called the “filter function”.  The
default filter function simply inserts the output into a buffer, which
is called the associated buffer of the process (*note Process
Buffers::).  If the process has no buffer then the default filter
discards the output.

   If the subprocess writes to its standard error stream, by default the
error output is also passed to the process filter function.  If Emacs
uses a pseudo-TTY (pty) for communication with the subprocess, then it
is impossible to separate the standard output and standard error streams
of the subprocess, because a pseudo-TTY has only one output channel.  In
that case, if you want to keep the output to those streams separate, you
should redirect one of them to a file—for example, by using an
appropriate shell command via ‘start-process-shell-command’ or a similar
function.

   Alternatively, you could use the ‘:stderr’ parameter with a non-‘nil’
value in a call to ‘make-process’ (*note make-process: Asynchronous
Processes.) to make the destination of the error output separate from
the standard output; in that case, Emacs will use pipes for
communicating with the subprocess.

   When a subprocess terminates, Emacs reads any pending output, then
stops reading output from that subprocess.  Therefore, if the subprocess
has children that are still live and still producing output, Emacs won’t
receive that output.

   Output from a subprocess can arrive only while Emacs is waiting: when
reading terminal input (see the function ‘waiting-for-user-input-p’), in
‘sit-for’ and ‘sleep-for’ (*note Waiting::), and in
‘accept-process-output’ (*note Accepting Output::).  This minimizes the
problem of timing errors that usually plague parallel programming.  For
example, you can safely create a process and only then specify its
buffer or filter function; no output can arrive before you finish, if
the code in between does not call any primitive that waits.

 -- Variable: process-adaptive-read-buffering
     On some systems, when Emacs reads the output from a subprocess, the
     output data is read in very small blocks, potentially resulting in
     very poor performance.  This behavior can be remedied to some
     extent by setting the variable ‘process-adaptive-read-buffering’ to
     a non-‘nil’ value (the default), as it will automatically delay
     reading from such processes, thus allowing them to produce more
     output before Emacs tries to read it.

* Menu:

* Process Buffers::         By default, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Decoding Output::         Filters can get unibyte or multibyte strings.
* Accepting Output::        How to wait until process output arrives.
* Processes and Threads::   How processes and threads interact.


File: elisp.info,  Node: Process Buffers,  Next: Filter Functions,  Up: Output from Processes

38.9.1 Process Buffers
----------------------

A process can (and usually does) have an “associated buffer”, which is
an ordinary Emacs buffer that is used for two purposes: storing the
output from the process, and deciding when to kill the process.  You can
also use the buffer to identify a process to operate on, since in normal
practice only one process is associated with any given buffer.  Many
applications of processes also use the buffer for editing input to be
sent to the process, but this is not built into Emacs Lisp.

   By default, process output is inserted in the associated buffer.
(You can change this by defining a custom filter function, *note Filter
Functions::.)  The position to insert the output is determined by the
‘process-mark’, which is then updated to point to the end of the text
just inserted.  Usually, but not always, the ‘process-mark’ is at the
end of the buffer.

   Killing the associated buffer of a process also kills the process.
Emacs asks for confirmation first, if the process’s
‘process-query-on-exit-flag’ is non-‘nil’ (*note Query Before Exit::).
This confirmation is done by the function
‘process-kill-buffer-query-function’, which is run from
‘kill-buffer-query-functions’ (*note Killing Buffers::).

 -- Function: process-buffer process
     This function returns the associated buffer of the specified
     PROCESS.

          (process-buffer (get-process "shell"))
               ⇒ #<buffer *shell*>

 -- Function: process-mark process
     This function returns the process marker for PROCESS, which is the
     marker that says where to insert output from the process.

     If PROCESS does not have a buffer, ‘process-mark’ returns a marker
     that points nowhere.

     The default filter function uses this marker to decide where to
     insert process output, and updates it to point after the inserted
     text.  That is why successive batches of output are inserted
     consecutively.

     Custom filter functions normally should use this marker in the same
     fashion.  For an example of a filter function that uses
     ‘process-mark’, *note Process Filter Example::.

     When the user is expected to enter input in the process buffer for
     transmission to the process, the process marker separates the new
     input from previous output.

 -- Function: set-process-buffer process buffer
     This function sets the buffer associated with PROCESS to BUFFER.
     If BUFFER is ‘nil’, the process becomes associated with no buffer.

 -- Function: get-buffer-process buffer-or-name
     This function returns a nondeleted process associated with the
     buffer specified by BUFFER-OR-NAME.  If there are several processes
     associated with it, this function chooses one (currently, the one
     most recently created, but don’t count on that).  Deletion of a
     process (see ‘delete-process’) makes it ineligible for this
     function to return.

     It is usually a bad idea to have more than one process associated
     with the same buffer.

          (get-buffer-process "*shell*")
               ⇒ #<process shell>

     Killing the process’s buffer deletes the process, which kills the
     subprocess with a ‘SIGHUP’ signal (*note Signals to Processes::).

   If the process’s buffer is displayed in a window, your Lisp program
may wish to tell the process the dimensions of that window, so that the
process could adapt its output to those dimensions, much as it adapts to
the screen dimensions.  The following functions allow communicating this
kind of information to processes; however, not all systems support the
underlying functionality, so it is best to provide fallbacks, e.g., via
command-line arguments or environment variables.

 -- Function: set-process-window-size process height width
     Tell PROCESS that its logical window size has dimensions WIDTH by
     HEIGHT, in character units.  If this function succeeds in
     communicating this information to the process, it returns ‘t’;
     otherwise it returns ‘nil’.

   When windows that display buffers associated with process change
their dimensions, the affected processes should be told about these
changes.  By default, when the window configuration changes, Emacs will
automatically call ‘set-process-window-size’ on behalf of every process
whose buffer is displayed in a window, passing it the smallest
dimensions of all the windows displaying the process’s buffer.  This
works via ‘window-configuration-change-hook’ (*note Window Hooks::),
which is told to invoke the function that is the value of the variable
‘window-adjust-process-window-size-function’ for each process whose
buffer is displayed in at least one window.  You can customize this
behavior by setting the value of that variable.

 -- User Option: window-adjust-process-window-size-function
     The value of this variable should be a function of two arguments: a
     process and the list of windows displaying the process’s buffer.
     When the function is called, the process’s buffer is the current
     buffer.  The function should return a cons cell ‘(WIDTH . HEIGHT)’
     that describes the dimensions of the logical process window to be
     passed via a call to ‘set-process-window-size’.  The function can
     also return ‘nil’, in which case Emacs will not call
     ‘set-process-window-size’ for this process.

     Emacs supplies two predefined values for this variable:
     ‘window-adjust-process-window-size-smallest’, which returns the
     smallest of all the dimensions of the windows that display a
     process’s buffer; and ‘window-adjust-process-window-size-largest’,
     which returns the largest dimensions.  For more complex strategies,
     write your own function.

     This variable can be buffer-local.

   If the process has the ‘adjust-window-size-function’ property (*note
Process Information::), its value overrides the global and buffer-local
values of ‘window-adjust-process-window-size-function’.


File: elisp.info,  Node: Filter Functions,  Next: Decoding Output,  Prev: Process Buffers,  Up: Output from Processes

38.9.2 Process Filter Functions
-------------------------------

A process “filter function” is a function that receives the standard
output from the associated process.  _All_ output from that process is
passed to the filter.  The default filter simply outputs directly to the
process buffer.

   By default, the error output from the process, if any, is also passed
to the filter function, unless the destination for the standard error
stream of the process was separated from the standard output when the
process was created (*note Output from Processes::).

   The filter function can only be called when Emacs is waiting for
something, because process output arrives only at such times.  Emacs
waits when reading terminal input (see the function
‘waiting-for-user-input-p’), in ‘sit-for’ and ‘sleep-for’ (*note
Waiting::), and in ‘accept-process-output’ (*note Accepting Output::).

   A filter function must accept two arguments: the associated process
and a string, which is output just received from it.  The function is
then free to do whatever it chooses with the output.

   Quitting is normally inhibited within a filter function—otherwise,
the effect of typing ‘C-g’ at command level or to quit a user command
would be unpredictable.  If you want to permit quitting inside a filter
function, bind ‘inhibit-quit’ to ‘nil’.  In most cases, the right way to
do this is with the macro ‘with-local-quit’.  *Note Quitting::.

   If an error happens during execution of a filter function, it is
caught automatically, so that it doesn’t stop the execution of whatever
program was running when the filter function was started.  However, if
‘debug-on-error’ is non-‘nil’, errors are not caught.  This makes it
possible to use the Lisp debugger to debug filter functions.  *Note
Debugger::.

   Many filter functions sometimes (or always) insert the output in the
process’s buffer, mimicking the actions of the default filter.  Such
filter functions need to make sure that they save the current buffer,
select the correct buffer (if different) before inserting output, and
then restore the original buffer.  They should also check whether the
buffer is still alive, update the process marker, and in some cases
update the value of point.  Here is how to do these things:

     (defun ordinary-insertion-filter (proc string)
       (when (buffer-live-p (process-buffer proc))
         (with-current-buffer (process-buffer proc)
           (let ((moving (= (point) (process-mark proc))))
             (save-excursion
               ;; Insert the text, advancing the process marker.
               (goto-char (process-mark proc))
               (insert string)
               (set-marker (process-mark proc) (point)))
             (if moving (goto-char (process-mark proc)))))))

   To make the filter force the process buffer to be visible whenever
new text arrives, you could insert a line like the following just before
the ‘with-current-buffer’ construct:

     (display-buffer (process-buffer proc))

   To force point to the end of the new output, no matter where it was
previously, eliminate the variable ‘moving’ from the example and call
‘goto-char’ unconditionally.

   Note that Emacs automatically saves and restores the match data while
executing filter functions.  *Note Match Data::.

   The output to the filter may come in chunks of any size.  A program
that produces the same output twice in a row may send it as one batch of
200 characters one time, and five batches of 40 characters the next.  If
the filter looks for certain text strings in the subprocess output, make
sure to handle the case where one of these strings is split across two
or more batches of output; one way to do this is to insert the received
text into a temporary buffer, which can then be searched.

 -- Function: set-process-filter process filter
     This function gives PROCESS the filter function FILTER.  If FILTER
     is ‘nil’, it gives the process the default filter, which inserts
     the process output into the process buffer.

 -- Function: process-filter process
     This function returns the filter function of PROCESS.

   In case the process’s output needs to be passed to several filters,
you can use ‘add-function’ to combine an existing filter with a new one.
*Note Advising Functions::.

   Here is an example of the use of a filter function:

     (defun keep-output (process output)
        (setq kept (cons output kept)))
          ⇒ keep-output
     (setq kept nil)
          ⇒ nil
     (set-process-filter (get-process "shell") 'keep-output)
          ⇒ keep-output
     (process-send-string "shell" "ls ~/other\n")
          ⇒ nil
     kept
          ⇒ ("lewis@slug:$ "
     "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
     address.txt             backup.psf              kolstad.psf
     backup.bib~             david.mss               resume-Dec-86.mss~
     backup.err              david.psf               resume-Dec.psf
     backup.mss              dland                   syllabus.mss
     "
     "#backups.mss#          backup.mss~             kolstad.mss
     ")


File: elisp.info,  Node: Decoding Output,  Next: Accepting Output,  Prev: Filter Functions,  Up: Output from Processes

38.9.3 Decoding Process Output
------------------------------

When Emacs writes process output directly into a multibyte buffer, it
decodes the output according to the process output coding system.  If
the coding system is ‘raw-text’ or ‘no-conversion’, Emacs converts the
unibyte output to multibyte using ‘string-to-multibyte’, and inserts the
resulting multibyte text.

   You can use ‘set-process-coding-system’ to specify which coding
system to use (*note Process Information::).  Otherwise, the coding
system comes from ‘coding-system-for-read’, if that is non-‘nil’; or
else from the defaulting mechanism (*note Default Coding Systems::).  If
the text output by a process contains null bytes, Emacs by default uses
‘no-conversion’ for it; see *note inhibit-null-byte-detection: Lisp and
Coding Systems, for how to control this behavior.

   *Warning:* Coding systems such as ‘undecided’, which determine the
coding system from the data, do not work entirely reliably with
asynchronous subprocess output.  This is because Emacs has to process
asynchronous subprocess output in batches, as it arrives.  Emacs must
try to detect the proper coding system from one batch at a time, and
this does not always work.  Therefore, if at all possible, specify a
coding system that determines both the character code conversion and the
end of line conversion—that is, one like ‘latin-1-unix’, rather than
‘undecided’ or ‘latin-1’.

   When Emacs calls a process filter function, it provides the process
output as a multibyte string or as a unibyte string according to the
process’s filter coding system.  Emacs decodes the output according to
the process output coding system, which usually produces a multibyte
string, except for coding systems such as ‘binary’ and ‘raw-text’.


File: elisp.info,  Node: Accepting Output,  Next: Processes and Threads,  Prev: Decoding Output,  Up: Output from Processes

38.9.4 Accepting Output from Processes
--------------------------------------

Output from asynchronous subprocesses normally arrives only while Emacs
is waiting for some sort of external event, such as elapsed time or
terminal input.  Occasionally it is useful in a Lisp program to
explicitly permit output to arrive at a specific point, or even to wait
until output arrives from a process.

 -- Function: accept-process-output &optional process seconds millisec
          just-this-one
     This function allows Emacs to read pending output from processes.
     The output is given to their filter functions.  If PROCESS is
     non-‘nil’ then this function does not return until some output has
     been received from PROCESS.

     The arguments SECONDS and MILLISEC let you specify timeout periods.
     The former specifies a period measured in seconds and the latter
     specifies one measured in milliseconds.  The two time periods thus
     specified are added together, and ‘accept-process-output’ returns
     after that much time, even if there is no subprocess output.

     The argument MILLISEC is obsolete (and should not be used), because
     SECONDS can be floating point to specify waiting a fractional
     number of seconds.  If SECONDS is 0, the function accepts whatever
     output is pending but does not wait.

     If PROCESS is a process, and the argument JUST-THIS-ONE is
     non-‘nil’, only output from that process is handled, suspending
     output from other processes until some output has been received
     from that process or the timeout expires.  If JUST-THIS-ONE is an
     integer, also inhibit running timers.  This feature is generally
     not recommended, but may be necessary for specific applications,
     such as speech synthesis.

     The function ‘accept-process-output’ returns non-‘nil’ if it got
     output from PROCESS, or from any process if PROCESS is ‘nil’.  It
     returns ‘nil’ if the timeout expired before output arrived.


File: elisp.info,  Node: Processes and Threads,  Prev: Accepting Output,  Up: Output from Processes

38.9.5 Processes and Threads
----------------------------

Because threads were a relatively late addition to Emacs Lisp, and due
to the way dynamic binding was sometimes used in conjunction with
‘accept-process-output’, by default a process is locked to the thread
that created it.  When a process is locked to a thread, output from the
process can only be accepted by that thread.

   A Lisp program can specify to which thread a process is to be locked,
or instruct Emacs to unlock a process, in which case its output can be
processed by any thread.  Only a single thread will wait for output from
a given process at one time—once one thread begins waiting for output,
the process is temporarily locked until ‘accept-process-output’ or
‘sit-for’ returns.

   If the thread exits, all the processes locked to it are unlocked.

 -- Function: process-thread process
     Return the thread to which PROCESS is locked.  If PROCESS is
     unlocked, return ‘nil’.

 -- Function: set-process-thread process thread
     Set the locking thread of PROCESS to THREAD.  THREAD may be ‘nil’,
     in which case the process is unlocked.


File: elisp.info,  Node: Sentinels,  Next: Query Before Exit,  Prev: Output from Processes,  Up: Processes

38.10 Sentinels: Detecting Process Status Changes
=================================================

A “process sentinel” is a function that is called whenever the
associated process changes status for any reason, including signals
(whether sent by Emacs or caused by the process’s own actions) that
terminate, stop, or continue the process.  The process sentinel is also
called if the process exits.  The sentinel receives two arguments: the
process for which the event occurred, and a string describing the type
of event.

   If no sentinel function was specified for a process, it will use the
default sentinel function, which inserts a message in the process’s
buffer with the process name and the string describing the event.

   The string describing the event looks like one of the following:

   • ‘"finished\n"’.

   • ‘"deleted\n"’.

   • ‘"exited abnormally with code EXITCODE (core dumped)\n"’.  The
     “core dumped” part is optional, and only appears if the process
     dumped core.

   • ‘"failed with code FAIL-CODE\n"’.

   • ‘"SIGNAL-DESCRIPTION (core dumped)\n"’.  The SIGNAL-DESCRIPTION is
     a system-dependent textual description of a signal, e.g.,
     ‘"killed"’ for ‘SIGKILL’.  The “core dumped” part is optional, and
     only appears if the process dumped core.

   • ‘"open from HOST-NAME\n"’.

   • ‘"open\n"’.

   • ‘"connection broken by remote peer\n"’.

   A sentinel runs only while Emacs is waiting (e.g., for terminal
input, or for time to elapse, or for process output).  This avoids the
timing errors that could result from running sentinels at random places
in the middle of other Lisp programs.  A program can wait, so that
sentinels will run, by calling ‘sit-for’ or ‘sleep-for’ (*note
Waiting::), or ‘accept-process-output’ (*note Accepting Output::).
Emacs also allows sentinels to run when the command loop is reading
input.  ‘delete-process’ calls the sentinel when it terminates a running
process.

   Emacs does not keep a queue of multiple reasons to call the sentinel
of one process; it records just the current status and the fact that
there has been a change.  Therefore two changes in status, coming in
quick succession, can call the sentinel just once.  However, process
termination will always run the sentinel exactly once.  This is because
the process status can’t change again after termination.

   Emacs explicitly checks for output from the process before running
the process sentinel.  Once the sentinel runs due to process
termination, no further output can arrive from the process.

   A sentinel that writes the output into the buffer of the process
should check whether the buffer is still alive.  If it tries to insert
into a dead buffer, it will get an error.  If the buffer is dead,
‘(buffer-name (process-buffer PROCESS))’ returns ‘nil’.

   Quitting is normally inhibited within a sentinel—otherwise, the
effect of typing ‘C-g’ at command level or to quit a user command would
be unpredictable.  If you want to permit quitting inside a sentinel,
bind ‘inhibit-quit’ to ‘nil’.  In most cases, the right way to do this
is with the macro ‘with-local-quit’.  *Note Quitting::.

   If an error happens during execution of a sentinel, it is caught
automatically, so that it doesn’t stop the execution of whatever
programs was running when the sentinel was started.  However, if
‘debug-on-error’ is non-‘nil’, errors are not caught.  This makes it
possible to use the Lisp debugger to debug the sentinel.  *Note
Debugger::.

   While a sentinel is running, the process sentinel is temporarily set
to ‘nil’ so that the sentinel won’t run recursively.  For this reason it
is not possible for a sentinel to specify a new sentinel.

   Note that Emacs automatically saves and restores the match data while
executing sentinels.  *Note Match Data::.

 -- Function: set-process-sentinel process sentinel
     This function associates SENTINEL with PROCESS.  If SENTINEL is
     ‘nil’, then the process will have the default sentinel, which
     inserts a message in the process’s buffer when the process status
     changes.

     Changes in process sentinels take effect immediately—if the
     sentinel is slated to be run but has not been called yet, and you
     specify a new sentinel, the eventual call to the sentinel will use
     the new one.

          (defun msg-me (process event)
             (princ
               (format "Process: %s had the event '%s'" process event)))
          (set-process-sentinel (get-process "shell") 'msg-me)
               ⇒ msg-me
          (kill-process (get-process "shell"))
               ⊣ Process: #<process shell> had the event 'killed'
               ⇒ #<process shell>

 -- Function: process-sentinel process
     This function returns the sentinel of PROCESS.

   In case a process status changes need to be passed to several
sentinels, you can use ‘add-function’ to combine an existing sentinel
with a new one.  *Note Advising Functions::.

 -- Function: waiting-for-user-input-p
     While a sentinel or filter function is running, this function
     returns non-‘nil’ if Emacs was waiting for keyboard input from the
     user at the time the sentinel or filter function was called, or
     ‘nil’ if it was not.


File: elisp.info,  Node: Query Before Exit,  Next: System Processes,  Prev: Sentinels,  Up: Processes

38.11 Querying Before Exit
==========================

When Emacs exits, it terminates all its subprocesses.  For subprocesses
that run a program, it sends them the ‘SIGHUP’ signal; connections are
simply closed.  Because subprocesses may be doing valuable work, Emacs
normally asks the user to confirm that it is ok to terminate them.  Each
process has a query flag, which, if non-‘nil’, says that Emacs should
ask for confirmation before exiting and thus killing that process.  The
default for the query flag is ‘t’, meaning _do_ query.

 -- Function: process-query-on-exit-flag process
     This returns the query flag of PROCESS.

 -- Function: set-process-query-on-exit-flag process flag
     This function sets the query flag of PROCESS to FLAG.  It returns
     FLAG.

     Here is an example of using ‘set-process-query-on-exit-flag’ on a
     shell process to avoid querying:

          (set-process-query-on-exit-flag (get-process "shell") nil)
               ⇒ nil

 -- User Option: confirm-kill-processes
     If this user option is set to ‘t’ (the default), then Emacs asks
     for confirmation before killing processes on exit.  If it is ‘nil’,
     Emacs kills processes without confirmation, i.e., the query flag of
     all processes is ignored.


File: elisp.info,  Node: System Processes,  Next: Transaction Queues,  Prev: Query Before Exit,  Up: Processes

38.12 Accessing Other Processes
===============================

In addition to accessing and manipulating processes that are
subprocesses of the current Emacs session, Emacs Lisp programs can also
access other processes running on the same machine.  We call these
“system processes”, to distinguish them from Emacs subprocesses.

   Emacs provides several primitives for accessing system processes.
Not all platforms support these primitives; on those which don’t, these
primitives return ‘nil’.

 -- Function: list-system-processes
     This function returns a list of all the processes running on the
     system.  Each process is identified by its PID, a numerical process
     ID that is assigned by the OS and distinguishes the process from
     all the other processes running on the same machine at the same
     time.

 -- Function: process-attributes pid
     This function returns an alist of attributes for the process
     specified by its process ID PID.  Each association in the alist is
     of the form ‘(KEY . VALUE)’, where KEY designates the attribute and
     VALUE is the value of that attribute.  The various attribute KEYs
     that this function can return are listed below.  Not all platforms
     support all of these attributes; if an attribute is not supported,
     its association will not appear in the returned alist.  Values that
     are numbers can be either integer or floating point, depending on
     the magnitude of the value.

     ‘euid’
          The effective user ID of the user who invoked the process.
          The corresponding VALUE is a number.  If the process was
          invoked by the same user who runs the current Emacs session,
          the value is identical to what ‘user-uid’ returns (*note User
          Identification::).

     ‘user’
          User name corresponding to the process’s effective user ID, a
          string.

     ‘egid’
          The group ID of the effective user ID, a number.

     ‘group’
          Group name corresponding to the effective user’s group ID, a
          string.

     ‘comm’
          The name of the command that runs in the process.  This is a
          string that usually specifies the name of the executable file
          of the process, without the leading directories.  However,
          some special system processes can report strings that do not
          correspond to an executable file of a program.

     ‘state’
          The state code of the process.  This is a short string that
          encodes the scheduling state of the process.  Here’s a list of
          the most frequently seen codes:

          ‘"D"’
               uninterruptible sleep (usually I/O)
          ‘"R"’
               running
          ‘"S"’
               interruptible sleep (waiting for some event)
          ‘"T"’
               stopped, e.g., by a job control signal
          ‘"Z"’
               zombie: a process that terminated, but was not reaped by
               its parent

          For the full list of the possible states, see the manual page
          of the ‘ps’ command.

     ‘ppid’
          The process ID of the parent process, a number.

     ‘pgrp’
          The process group ID of the process, a number.

     ‘sess’
          The session ID of the process.  This is a number that is the
          process ID of the process’s “session leader”.

     ‘ttname’
          A string that is the name of the process’s controlling
          terminal.  On Unix and GNU systems, this is normally the file
          name of the corresponding terminal device, such as
          ‘/dev/pts65’.

     ‘tpgid’
          The numerical process group ID of the foreground process group
          that uses the process’s terminal.

     ‘minflt’
          The number of minor page faults caused by the process since
          its beginning.  (Minor page faults are those that don’t
          involve reading from disk.)

     ‘majflt’
          The number of major page faults caused by the process since
          its beginning.  (Major page faults require a disk to be read,
          and are thus more expensive than minor page faults.)

     ‘cminflt’
     ‘cmajflt’
          Like ‘minflt’ and ‘majflt’, but include the number of page
          faults for all the child processes of the given process.

     ‘utime’
          Time spent by the process in the user context, for running the
          application’s code.  The corresponding VALUE is in the
          ‘(HIGH LOW MICROSEC PICOSEC)’ format, the same format used by
          functions ‘current-time’ (*note current-time: Time of Day.)
          and ‘file-attributes’ (*note File Attributes::).

     ‘stime’
          Time spent by the process in the system (kernel) context, for
          processing system calls.  The corresponding VALUE is in the
          same format as for ‘utime’.

     ‘time’
          The sum of ‘utime’ and ‘stime’.  The corresponding VALUE is in
          the same format as for ‘utime’.

     ‘cutime’
     ‘cstime’
     ‘ctime’
          Like ‘utime’, ‘stime’, and ‘time’, but include the times of
          all the child processes of the given process.

     ‘pri’
          The numerical priority of the process.

     ‘nice’
          The “nice value” of the process, a number.  (Processes with
          smaller nice values get scheduled more favorably.)

     ‘thcount’
          The number of threads in the process.

     ‘start’
          The time when the process was started, in the same ‘(HIGH LOW
          MICROSEC PICOSEC)’ format used by ‘file-attributes’ and
          ‘current-time’.

     ‘etime’
          The time elapsed since the process started, in the format
          ‘(HIGH LOW MICROSEC PICOSEC)’.

     ‘vsize’
          The virtual memory size of the process, measured in kilobytes.

     ‘rss’
          The size of the process’s “resident set”, the number of
          kilobytes occupied by the process in the machine’s physical
          memory.

     ‘pcpu’
          The percentage of the CPU time used by the process since it
          started.  The corresponding VALUE is a floating-point number
          between 0 and 100.

     ‘pmem’
          The percentage of the total physical memory installed on the
          machine used by the process’s resident set.  The value is a
          floating-point number between 0 and 100.

     ‘args’
          The command-line with which the process was invoked.  This is
          a string in which individual command-line arguments are
          separated by blanks; whitespace characters that are embedded
          in the arguments are quoted as appropriate for the system’s
          shell: escaped by backslash characters on GNU and Unix, and
          enclosed in double quote characters on Windows.  Thus, this
          command-line string can be directly used in primitives such as
          ‘shell-command’.


File: elisp.info,  Node: Transaction Queues,  Next: Network,  Prev: System Processes,  Up: Processes

38.13 Transaction Queues
========================

You can use a “transaction queue” to communicate with a subprocess using
transactions.  First use ‘tq-create’ to create a transaction queue
communicating with a specified process.  Then you can call ‘tq-enqueue’
to send a transaction.

 -- Function: tq-create process
     This function creates and returns a transaction queue communicating
     with PROCESS.  The argument PROCESS should be a subprocess capable
     of sending and receiving streams of bytes.  It may be a child
     process, or it may be a TCP connection to a server, possibly on
     another machine.

 -- Function: tq-enqueue queue question regexp closure fn &optional
          delay-question
     This function sends a transaction to queue QUEUE.  Specifying the
     queue has the effect of specifying the subprocess to talk to.

     The argument QUESTION is the outgoing message that starts the
     transaction.  The argument FN is the function to call when the
     corresponding answer comes back; it is called with two arguments:
     CLOSURE, and the answer received.

     The argument REGEXP is a regular expression that should match text
     at the end of the entire answer, but nothing before; that’s how
     ‘tq-enqueue’ determines where the answer ends.

     If the argument DELAY-QUESTION is non-‘nil’, delay sending this
     question until the process has finished replying to any previous
     questions.  This produces more reliable results with some
     processes.

 -- Function: tq-close queue
     Shut down transaction queue QUEUE, waiting for all pending
     transactions to complete, and then terminate the connection or
     child process.

   Transaction queues are implemented by means of a filter function.
*Note Filter Functions::.


File: elisp.info,  Node: Network,  Next: Network Servers,  Prev: Transaction Queues,  Up: Processes

38.14 Network Connections
=========================

Emacs Lisp programs can open stream (TCP) and datagram (UDP) network
connections (*note Datagrams::) to other processes on the same machine
or other machines.  A network connection is handled by Lisp much like a
subprocess, and is represented by a process object.  However, the
process you are communicating with is not a child of the Emacs process,
has no process ID, and you can’t kill it or send it signals.  All you
can do is send and receive data.  ‘delete-process’ closes the
connection, but does not kill the program at the other end; that program
must decide what to do about closure of the connection.

   Lisp programs can listen for connections by creating network servers.
A network server is also represented by a kind of process object, but
unlike a network connection, the network server never transfers data
itself.  When it receives a connection request, it creates a new network
connection to represent the connection just made.  (The network
connection inherits certain information, including the process plist,
from the server.)  The network server then goes back to listening for
more connection requests.

   Network connections and servers are created by calling
‘make-network-process’ with an argument list consisting of
keyword/argument pairs, for example ‘:server t’ to create a server
process, or ‘:type 'datagram’ to create a datagram connection.  *Note
Low-Level Network::, for details.  You can also use the
‘open-network-stream’ function described below.

   To distinguish the different types of processes, the ‘process-type’
function returns the symbol ‘network’ for a network connection or
server, ‘serial’ for a serial port connection, ‘pipe’ for a pipe
connection, or ‘real’ for a real subprocess.

   The ‘process-status’ function returns ‘open’, ‘closed’, ‘connect’,
‘stop’, or ‘failed’ for network connections.  For a network server, the
status is always ‘listen’.  Except for ‘stop’, none of those values is
possible for a real subprocess.  *Note Process Information::.

   You can stop and resume operation of a network process by calling
‘stop-process’ and ‘continue-process’.  For a server process, being
stopped means not accepting new connections.  (Up to 5 connection
requests will be queued for when you resume the server; you can increase
this limit, unless it is imposed by the operating system—see the
‘:server’ keyword of ‘make-network-process’, *note Network Processes::.)
For a network stream connection, being stopped means not processing
input (any arriving input waits until you resume the connection).  For a
datagram connection, some number of packets may be queued but input may
be lost.  You can use the function ‘process-command’ to determine
whether a network connection or server is stopped; a non-‘nil’ value
means yes.

   Emacs can create encrypted network connections, using either built-in
or external support.  The built-in support uses the GnuTLS Transport
Layer Security Library; see the GnuTLS project page
(https://www.gnu.org/software/gnutls/).  If your Emacs was compiled with
GnuTLS support, the function ‘gnutls-available-p’ is defined and returns
non-‘nil’.  For more details, *note Overview: (emacs-gnutls)Top.  The
external support uses the ‘starttls.el’ library, which requires a helper
utility such as ‘gnutls-cli’ to be installed on the system.  The
‘open-network-stream’ function can transparently handle the details of
creating encrypted connections for you, using whatever support is
available.

 -- Function: open-network-stream name buffer host service &rest
          parameters
     This function opens a TCP connection, with optional encryption, and
     returns a process object that represents the connection.

     The NAME argument specifies the name for the process object.  It is
     modified as necessary to make it unique.

     The BUFFER argument is the buffer to associate with the connection.
     Output from the connection is inserted in the buffer, unless you
     specify your own filter function to handle the output.  If BUFFER
     is ‘nil’, it means that the connection is not associated with any
     buffer.

     The arguments HOST and SERVICE specify where to connect to; HOST is
     the host name (a string), and SERVICE is the name of a defined
     network service (a string) or a port number (an integer like ‘80’
     or an integer string like ‘"80"’).

     The remaining arguments PARAMETERS are keyword/argument pairs that
     are mainly relevant to encrypted connections:

     ‘:nowait BOOLEAN’
          If non-‘nil’, try to make an asynchronous connection.

     ‘:type TYPE’
          The type of connection.  Options are:

          ‘plain’
               An ordinary, unencrypted connection.
          ‘tls’
          ‘ssl’
               A TLS (Transport Layer Security) connection.
          ‘nil’
          ‘network’
               Start with a plain connection, and if parameters
               ‘:success’ and ‘:capability-command’ are supplied, try to
               upgrade to an encrypted connection via STARTTLS.  If that
               fails, retain the unencrypted connection.
          ‘starttls’
               As for ‘nil’, but if STARTTLS fails drop the connection.
          ‘shell’
               A shell connection.

     ‘:always-query-capabilities BOOLEAN’
          If non-‘nil’, always ask for the server’s capabilities, even
          when doing a ‘plain’ connection.

     ‘:capability-command CAPABILITY-COMMAND’
          Command string to query the host capabilities.

     ‘:end-of-command REGEXP’
     ‘:end-of-capability REGEXP’
          Regular expression matching the end of a command, or the end
          of the command CAPABILITY-COMMAND.  The latter defaults to the
          former.

     ‘:starttls-function FUNCTION’
          Function of one argument (the response to CAPABILITY-COMMAND),
          which returns either ‘nil’, or the command to activate
          STARTTLS if supported.

     ‘:success REGEXP’
          Regular expression matching a successful STARTTLS negotiation.

     ‘:use-starttls-if-possible BOOLEAN’
          If non-‘nil’, do opportunistic STARTTLS upgrades even if Emacs
          doesn’t have built-in TLS support.

     ‘:warn-unless-encrypted BOOLEAN’
          If non-‘nil’, and ‘:return-value’ is also non-‘nil’, Emacs
          will warn if the connection isn’t encrypted.  This is useful
          for protocols like IMAP and the like, where most users would
          expect the network traffic to be encrypted.

     ‘:client-certificate LIST-OR-T’
          Either a list of the form ‘(KEY-FILE CERT-FILE)’, naming the
          certificate key file and certificate file itself, or ‘t’,
          meaning to query ‘auth-source’ for this information (*note
          Overview: (auth)Top.).  Only used for TLS or STARTTLS.

     ‘:return-list CONS-OR-NIL’
          The return value of this function.  If omitted or ‘nil’,
          return a process object.  Otherwise, a cons of the form
          ‘(PROCESS-OBJECT . PLIST)’, where PLIST has keywords:

          ‘:greeting STRING-OR-NIL’
               If non-‘nil’, the greeting string returned by the host.
          ‘:capabilities STRING-OR-NIL’
               If non-‘nil’, the host’s capability string.
          ‘:type SYMBOL’
               The connection type: ‘plain’ or ‘tls’.

     ‘:shell-command STRING-OR-NIL’
          If the connection ‘type’ is ‘shell’, this parameter will be
          interpreted as a format-spec string that will be executed to
          make the connection.  The specs available are ‘%s’ for the
          host name and ‘%p’ for the port number.  For instance, if you
          want to first ssh to ‘gateway’ before making a plain
          connection, then this parameter could be something like ‘ssh
          gateway nc %s %p’.


File: elisp.info,  Node: Network Servers,  Next: Datagrams,  Prev: Network,  Up: Processes

38.15 Network Servers
=====================

You create a server by calling ‘make-network-process’ (*note Network
Processes::) with ‘:server t’.  The server will listen for connection
requests from clients.  When it accepts a client connection request,
that creates a new network connection, itself a process object, with the
following parameters:

   • The connection’s process name is constructed by concatenating the
     server process’s NAME with a client identification string.  The
     client identification string for an IPv4 connection looks like
     ‘<A.B.C.D:P>’, which represents an address and port number.
     Otherwise, it is a unique number in brackets, as in ‘<NNN>’.  The
     number is unique for each connection in the Emacs session.

   • If the server has a non-default filter, the connection process does
     not get a separate process buffer; otherwise, Emacs creates a new
     buffer for the purpose.  The buffer name is the server’s buffer
     name or process name, concatenated with the client identification
     string.

     The server’s process buffer value is never used directly, but the
     log function can retrieve it and use it to log connections by
     inserting text there.

   • The communication type and the process filter and sentinel are
     inherited from those of the server.  The server never directly uses
     its filter and sentinel; their sole purpose is to initialize
     connections made to the server.

   • The connection’s process contact information is set according to
     the client’s addressing information (typically an IP address and a
     port number).  This information is associated with the
     ‘process-contact’ keywords ‘:host’, ‘:service’, ‘:remote’.

   • The connection’s local address is set up according to the port
     number used for the connection.

   • The client process’s plist is initialized from the server’s plist.


File: elisp.info,  Node: Datagrams,  Next: Low-Level Network,  Prev: Network Servers,  Up: Processes

38.16 Datagrams
===============

A “datagram” connection communicates with individual packets rather than
streams of data.  Each call to ‘process-send’ sends one datagram packet
(*note Input to Processes::), and each datagram received results in one
call to the filter function.

   The datagram connection doesn’t have to talk with the same remote
peer all the time.  It has a “remote peer address” which specifies where
to send datagrams to.  Each time an incoming datagram is passed to the
filter function, the peer address is set to the address that datagram
came from; that way, if the filter function sends a datagram, it will go
back to that place.  You can specify the remote peer address when you
create the datagram connection using the ‘:remote’ keyword.  You can
change it later on by calling ‘set-process-datagram-address’.

 -- Function: process-datagram-address process
     If PROCESS is a datagram connection or server, this function
     returns its remote peer address.

 -- Function: set-process-datagram-address process address
     If PROCESS is a datagram connection or server, this function sets
     its remote peer address to ADDRESS.


File: elisp.info,  Node: Low-Level Network,  Next: Misc Network,  Prev: Datagrams,  Up: Processes

38.17 Low-Level Network Access
==============================

You can also create network connections by operating at a lower level
than that of ‘open-network-stream’, using ‘make-network-process’.

* Menu:

* Proc: Network Processes.   Using ‘make-network-process’.
* Options: Network Options.  Further control over network connections.
* Features: Network Feature Testing.
                             Determining which network features work on
                               the machine you are using.


File: elisp.info,  Node: Network Processes,  Next: Network Options,  Up: Low-Level Network

38.17.1 ‘make-network-process’
------------------------------

The basic function for creating network connections and network servers
is ‘make-network-process’.  It can do either of those jobs, depending on
the arguments you give it.

 -- Function: make-network-process &rest args
     This function creates a network connection or server and returns
     the process object that represents it.  The arguments ARGS are a
     list of keyword/argument pairs.  Omitting a keyword is always
     equivalent to specifying it with value ‘nil’, except for ‘:coding’,
     ‘:filter-multibyte’, and ‘:reuseaddr’.  Here are the meaningful
     keywords (those corresponding to network options are listed in the
     following section):

     :name NAME
          Use the string NAME as the process name.  It is modified if
          necessary to make it unique.

     :type TYPE
          Specify the communication type.  A value of ‘nil’ specifies a
          stream connection (the default); ‘datagram’ specifies a
          datagram connection; ‘seqpacket’ specifies a sequenced packet
          stream connection.  Both connections and servers can be of
          these types.

     :server SERVER-FLAG
          If SERVER-FLAG is non-‘nil’, create a server.  Otherwise,
          create a connection.  For a stream type server, SERVER-FLAG
          may be an integer, which then specifies the length of the
          queue of pending connections to the server.  The default queue
          length is 5.

     :host HOST
          Specify the host to connect to.  HOST should be a host name or
          Internet address, as a string, or the symbol ‘local’ to
          specify the local host.  If you specify HOST for a server, it
          must specify a valid address for the local host, and only
          clients connecting to that address will be accepted.

     :service SERVICE
          SERVICE specifies a port number to connect to; or, for a
          server, the port number to listen on.  It should be a service
          name like ‘"http"’ that translates to a port number, or an
          integer like ‘80’ or an integer string like ‘"80"’ that
          specifies the port number directly.  For a server, it can also
          be ‘t’, which means to let the system select an unused port
          number.

     :family FAMILY
          FAMILY specifies the address (and protocol) family for
          communication.  ‘nil’ means determine the proper address
          family automatically for the given HOST and SERVICE.  ‘local’
          specifies a Unix socket, in which case HOST is ignored.
          ‘ipv4’ and ‘ipv6’ specify to use IPv4 and IPv6, respectively.

     :use-external-socket USE-EXTERNAL-SOCKET
          If USE-EXTERNAL-SOCKET is non-‘nil’ use any sockets passed to
          Emacs on invocation instead of allocating one.  This is used
          by the Emacs server code to allow on-demand socket activation.
          If Emacs wasn’t passed a socket, this option is silently
          ignored.

     :local LOCAL-ADDRESS
          For a server process, LOCAL-ADDRESS is the address to listen
          on.  It overrides FAMILY, HOST and SERVICE, so you might as
          well not specify them.

     :remote REMOTE-ADDRESS
          For a connection, REMOTE-ADDRESS is the address to connect to.
          It overrides FAMILY, HOST and SERVICE, so you might as well
          not specify them.

          For a datagram server, REMOTE-ADDRESS specifies the initial
          setting of the remote datagram address.

          The format of LOCAL-ADDRESS or REMOTE-ADDRESS depends on the
          address family:

             - An IPv4 address is represented as a five-element vector
               of four 8-bit integers and one 16-bit integer ‘[A B C D
               P]’ corresponding to numeric IPv4 address A.B.C.D and
               port number P.

             - An IPv6 address is represented as a nine-element vector
               of 16-bit integers ‘[A B C D E F G H P]’ corresponding to
               numeric IPv6 address A:B:C:D:E:F:G:H and port number P.

             - A local address is represented as a string, which
               specifies the address in the local address space.

             - An unsupported-family address is represented by a cons
               ‘(F . AV)’, where F is the family number and AV is a
               vector specifying the socket address using one element
               per address data byte.  Do not rely on this format in
               portable code, as it may depend on implementation defined
               constants, data sizes, and data structure alignment.

     :nowait BOOL
          If BOOL is non-‘nil’ for a stream connection, return without
          waiting for the connection to complete.  When the connection
          succeeds or fails, Emacs will call the sentinel function, with
          a second argument matching ‘"open"’ (if successful) or
          ‘"failed"’.  The default is to block, so that
          ‘make-network-process’ does not return until the connection
          has succeeded or failed.

          If you’re setting up an asynchronous TLS connection, you have
          to also provide the ‘:tls-parameters’ parameter (see below).

          Depending on the capabilities of Emacs, how asynchronous
          ‘:nowait’ is may vary.  The three elements that may (or may
          not) be done asynchronously are domain name resolution, socket
          setup, and (for TLS connections) TLS negotiation.

          Many functions that interact with process objects, (for
          instance, ‘process-datagram-address’) rely on them at least
          having a socket before they can return a useful value.  These
          functions will block until the socket has achieved the desired
          status.  The recommended way of interacting with asynchronous
          sockets is to place a sentinel on the process, and not try to
          interact with it before it has changed status to ‘"run"’.
          That way, none of these functions will block.

     :tls-parameters
          When opening a TLS connection, this should be where the first
          element is the TLS type (which should either be
          ‘gnutls-x509pki’ or ‘gnutls-anon’, and the remaining elements
          should form a keyword list acceptable for ‘gnutls-boot’.
          (This keyword list can be obtained from the
          ‘gnutls-boot-parameters’ function.)  The TLS connection will
          then be negotiated after completing the connection to the
          host.

     :stop STOPPED
          If STOPPED is non-‘nil’, start the network connection or
          server in the stopped state.

     :buffer BUFFER
          Use BUFFER as the process buffer.

     :coding CODING
          Use CODING as the coding system for this process.  To specify
          different coding systems for decoding data from the connection
          and for encoding data sent to it, specify ‘(DECODING .
          ENCODING)’ for CODING.

          If you don’t specify this keyword at all, the default is to
          determine the coding systems from the data.

     :noquery QUERY-FLAG
          Initialize the process query flag to QUERY-FLAG.  *Note Query
          Before Exit::.

     :filter FILTER
          Initialize the process filter to FILTER.

     :filter-multibyte MULTIBYTE
          If MULTIBYTE is non-‘nil’, strings given to the process filter
          are multibyte, otherwise they are unibyte.  The default is the
          default value of ‘enable-multibyte-characters’.

     :sentinel SENTINEL
          Initialize the process sentinel to SENTINEL.

     :log LOG
          Initialize the log function of a server process to LOG.  The
          log function is called each time the server accepts a network
          connection from a client.  The arguments passed to the log
          function are SERVER, CONNECTION, and MESSAGE; where SERVER is
          the server process, CONNECTION is the new process for the
          connection, and MESSAGE is a string describing what has
          happened.

     :plist PLIST
          Initialize the process plist to PLIST.

     The original argument list, modified with the actual connection
     information, is available via the ‘process-contact’ function.


File: elisp.info,  Node: Network Options,  Next: Network Feature Testing,  Prev: Network Processes,  Up: Low-Level Network

38.17.2 Network Options
-----------------------

The following network options can be specified when you create a network
process.  Except for ‘:reuseaddr’, you can also set or modify these
options later, using ‘set-network-process-option’.

   For a server process, the options specified with
‘make-network-process’ are not inherited by the client connections, so
you will need to set the necessary options for each child connection as
it is created.

:bindtodevice DEVICE-NAME
     If DEVICE-NAME is a non-empty string identifying a network
     interface name (see ‘network-interface-list’), only handle packets
     received on that interface.  If DEVICE-NAME is ‘nil’ (the default),
     handle packets received on any interface.

     Using this option may require special privileges on some systems.

:broadcast BROADCAST-FLAG
     If BROADCAST-FLAG is non-‘nil’ for a datagram process, the process
     will receive datagram packet sent to a broadcast address, and be
     able to send packets to a broadcast address.  This is ignored for a
     stream connection.

:dontroute DONTROUTE-FLAG
     If DONTROUTE-FLAG is non-‘nil’, the process can only send to hosts
     on the same network as the local host.

:keepalive KEEPALIVE-FLAG
     If KEEPALIVE-FLAG is non-‘nil’ for a stream connection, enable
     exchange of low-level keep-alive messages.

:linger LINGER-ARG
     If LINGER-ARG is non-‘nil’, wait for successful transmission of all
     queued packets on the connection before it is deleted (see
     ‘delete-process’).  If LINGER-ARG is an integer, it specifies the
     maximum time in seconds to wait for queued packets to be sent
     before closing the connection.  The default is ‘nil’, which means
     to discard unsent queued packets when the process is deleted.

:oobinline OOBINLINE-FLAG
     If OOBINLINE-FLAG is non-‘nil’ for a stream connection, receive
     out-of-band data in the normal data stream.  Otherwise, ignore
     out-of-band data.

:priority PRIORITY
     Set the priority for packets sent on this connection to the integer
     PRIORITY.  The interpretation of this number is protocol specific;
     such as setting the TOS (type of service) field on IP packets sent
     on this connection.  It may also have system dependent effects,
     such as selecting a specific output queue on the network interface.

:reuseaddr REUSEADDR-FLAG
     If REUSEADDR-FLAG is non-‘nil’ (the default) for a stream server
     process, allow this server to reuse a specific port number (see
     ‘:service’), unless another process on this host is already
     listening on that port.  If REUSEADDR-FLAG is ‘nil’, there may be a
     period of time after the last use of that port (by any process on
     the host) where it is not possible to make a new server on that
     port.

 -- Function: set-network-process-option process option value &optional
          no-error
     This function sets or modifies a network option for network process
     PROCESS.  The accepted options and values are as for
     ‘make-network-process’.  If NO-ERROR is non-‘nil’, this function
     returns ‘nil’ instead of signaling an error if OPTION is not a
     supported option.  If the function successfully completes, it
     returns ‘t’.

     The current setting of an option is available via the
     ‘process-contact’ function.


File: elisp.info,  Node: Network Feature Testing,  Prev: Network Options,  Up: Low-Level Network

38.17.3 Testing Availability of Network Features
------------------------------------------------

To test for the availability of a given network feature, use ‘featurep’
like this:

     (featurep 'make-network-process '(KEYWORD VALUE))

The result of this form is ‘t’ if it works to specify KEYWORD with value
VALUE in ‘make-network-process’.  Here are some of the KEYWORD—VALUE
pairs you can test in this way.

‘(:nowait t)’
     Non-‘nil’ if non-blocking connect is supported.
‘(:type datagram)’
     Non-‘nil’ if datagrams are supported.
‘(:family local)’
     Non-‘nil’ if local (a.k.a. “UNIX domain”) sockets are supported.
‘(:family ipv6)’
     Non-‘nil’ if IPv6 is supported.
‘(:service t)’
     Non-‘nil’ if the system can select the port for a server.

   To test for the availability of a given network option, use
‘featurep’ like this:

     (featurep 'make-network-process 'KEYWORD)

The accepted KEYWORD values are ‘:bindtodevice’, etc.  For the complete
list, *note Network Options::.  This form returns non-‘nil’ if that
particular network option is supported by ‘make-network-process’ (or
‘set-network-process-option’).


File: elisp.info,  Node: Misc Network,  Next: Serial Ports,  Prev: Low-Level Network,  Up: Processes

38.18 Misc Network Facilities
=============================

These additional functions are useful for creating and operating on
network connections.  Note that they are supported only on some systems.

 -- Function: network-interface-list
     This function returns a list describing the network interfaces of
     the machine you are using.  The value is an alist whose elements
     have the form ‘(NAME . ADDRESS)’.  ADDRESS has the same form as the
     LOCAL-ADDRESS and REMOTE-ADDRESS arguments to
     ‘make-network-process’.

 -- Function: network-interface-info ifname
     This function returns information about the network interface named
     IFNAME.  The value is a list of the form ‘(ADDR BCAST NETMASK
     HWADDR FLAGS)’.

     ADDR
          The Internet protocol address.
     BCAST
          The broadcast address.
     NETMASK
          The network mask.
     HWADDR
          The layer 2 address (Ethernet MAC address, for instance).
     FLAGS
          The current flags of the interface.

 -- Function: format-network-address address &optional omit-port
     This function converts the Lisp representation of a network address
     to a string.

     A five-element vector ‘[A B C D P]’ represents an IPv4 address
     A.B.C.D and port number P.  ‘format-network-address’ converts that
     to the string ‘"A.B.C.D:P"’.

     A nine-element vector ‘[A B C D E F G H P]’ represents an IPv6
     address along with a port number.  ‘format-network-address’
     converts that to the string ‘"[A:B:C:D:E:F:G:H]:P"’.

     If the vector does not include the port number, P, or if OMIT-PORT
     is non-‘nil’, the result does not include the ‘:P’ suffix.


File: elisp.info,  Node: Serial Ports,  Next: Byte Packing,  Prev: Misc Network,  Up: Processes

38.19 Communicating with Serial Ports
=====================================

Emacs can communicate with serial ports.  For interactive use, ‘M-x
serial-term’ opens a terminal window.  In a Lisp program,
‘make-serial-process’ creates a process object.

   The serial port can be configured at run-time, without having to
close and re-open it.  The function ‘serial-process-configure’ lets you
change the speed, bytesize, and other parameters.  In a terminal window
created by ‘serial-term’, you can click on the mode line for
configuration.

   A serial connection is represented by a process object, which can be
used in a similar way to a subprocess or network process.  You can send
and receive data, and configure the serial port.  A serial process
object has no process ID, however, and you can’t send signals to it, and
the status codes are different from other types of processes.
‘delete-process’ on the process object or ‘kill-buffer’ on the process
buffer close the connection, but this does not affect the device
connected to the serial port.

   The function ‘process-type’ returns the symbol ‘serial’ for a process
object representing a serial port connection.

   Serial ports are available on GNU/Linux, Unix, and MS Windows
systems.

 -- Command: serial-term port speed
     Start a terminal-emulator for a serial port in a new buffer.  PORT
     is the name of the serial port to connect to.  For example, this
     could be ‘/dev/ttyS0’ on Unix.  On MS Windows, this could be
     ‘COM1’, or ‘\\.\COM10’ (double the backslashes in Lisp strings).

     SPEED is the speed of the serial port in bits per second.  9600 is
     a common value.  The buffer is in Term mode; see *note (emacs)Term
     Mode::, for the commands to use in that buffer.  You can change the
     speed and the configuration in the mode line menu.

 -- Function: make-serial-process &rest args
     This function creates a process and a buffer.  Arguments are
     specified as keyword/argument pairs.  Here’s the list of the
     meaningful keywords, with the first two (PORT and SPEED) being
     mandatory:

     ‘:port PORT’
          This is the name of the serial port.  On Unix and GNU systems,
          this is a file name such as ‘/dev/ttyS0’.  On Windows, this
          could be ‘COM1’, or ‘\\.\COM10’ for ports higher than ‘COM9’
          (double the backslashes in Lisp strings).

     ‘:speed SPEED’
          The speed of the serial port in bits per second.  This
          function calls ‘serial-process-configure’ to handle the speed;
          see the following documentation of that function for more
          details.

     ‘:name NAME’
          The name of the process.  If NAME is not given, PORT will
          serve as the process name as well.

     ‘:buffer BUFFER’
          The buffer to associate with the process.  The value can be
          either a buffer or a string that names a buffer.  Process
          output goes at the end of that buffer, unless you specify an
          output stream or filter function to handle the output.  If
          BUFFER is not given, the process buffer’s name is taken from
          the value of the ‘:name’ keyword.

     ‘:coding CODING’
          If CODING is a symbol, it specifies the coding system used for
          both reading and writing for this process.  If CODING is a
          cons ‘(DECODING . ENCODING)’, DECODING is used for reading,
          and ENCODING is used for writing.  If not specified, the
          default is to determine the coding systems from the data
          itself.

     ‘:noquery QUERY-FLAG’
          Initialize the process query flag to QUERY-FLAG.  *Note Query
          Before Exit::.  The flags defaults to ‘nil’ if unspecified.

     ‘:stop BOOL’
          Start process in the stopped state if BOOL is non-‘nil’.  In
          the stopped state, a serial process does not accept incoming
          data, but you can send outgoing data.  The stopped state is
          cleared by ‘continue-process’ and set by ‘stop-process’.

     ‘:filter FILTER’
          Install FILTER as the process filter.

     ‘:sentinel SENTINEL’
          Install SENTINEL as the process sentinel.

     ‘:plist PLIST’
          Install PLIST as the initial plist of the process.

     ‘:bytesize’
     ‘:parity’
     ‘:stopbits’
     ‘:flowcontrol’
          These are handled by ‘serial-process-configure’, which is
          called by ‘make-serial-process’.

     The original argument list, possibly modified by later
     configuration, is available via the function ‘process-contact’.

     Here is an example:

          (make-serial-process :port "/dev/ttyS0" :speed 9600)

 -- Function: serial-process-configure &rest args

     This function configures a serial port connection.  Arguments are
     specified as keyword/argument pairs.  Attributes that are not given
     are re-initialized from the process’s current configuration
     (available via the function ‘process-contact’), or set to
     reasonable default values.  The following arguments are defined:

     ‘:process PROCESS’
     ‘:name NAME’
     ‘:buffer BUFFER’
     ‘:port PORT’
          Any of these arguments can be given to identify the process
          that is to be configured.  If none of these arguments is
          given, the current buffer’s process is used.

     ‘:speed SPEED’
          The speed of the serial port in bits per second, a.k.a. “baud
          rate”.  The value can be any number, but most serial ports
          work only at a few defined values between 1200 and 115200,
          with 9600 being the most common value.  If SPEED is ‘nil’, the
          function ignores all other arguments and does not configure
          the port.  This may be useful for special serial ports such as
          Bluetooth-to-serial converters, which can only be configured
          through ‘AT’ commands sent through the connection.  The value
          of ‘nil’ for SPEED is valid only for connections that were
          already opened by a previous call to ‘make-serial-process’ or
          ‘serial-term’.

     ‘:bytesize BYTESIZE’
          The number of bits per byte, which can be 7 or 8.  If BYTESIZE
          is not given or ‘nil’, it defaults to 8.

     ‘:parity PARITY’
          The value can be ‘nil’ (don’t use parity), the symbol ‘odd’
          (use odd parity), or the symbol ‘even’ (use even parity).  If
          PARITY is not given, it defaults to no parity.

     ‘:stopbits STOPBITS’
          The number of stopbits used to terminate a transmission of
          each byte.  STOPBITS can be 1 or 2.  If STOPBITS is not given
          or ‘nil’, it defaults to 1.

     ‘:flowcontrol FLOWCONTROL’
          The type of flow control to use for this connection, which is
          either ‘nil’ (don’t use flow control), the symbol ‘hw’ (use
          RTS/CTS hardware flow control), or the symbol ‘sw’ (use
          XON/XOFF software flow control).  If FLOWCONTROL is not given,
          it defaults to no flow control.

     Internally, ‘make-serial-process’ calls ‘serial-process-configure’
     for the initial configuration of the serial port.


File: elisp.info,  Node: Byte Packing,  Prev: Serial Ports,  Up: Processes

38.20 Packing and Unpacking Byte Arrays
=======================================

This section describes how to pack and unpack arrays of bytes, usually
for binary network protocols.  These functions convert byte arrays to
alists, and vice versa.  The byte array can be represented as a unibyte
string or as a vector of integers, while the alist associates symbols
either with fixed-size objects or with recursive sub-alists.  To use the
functions referred to in this section, load the ‘bindat’ library.

   Conversion from byte arrays to nested alists is also known as
“deserializing” or “unpacking”, while going in the opposite direction is
also known as “serializing” or “packing”.

* Menu:

* Bindat Spec::         Describing data layout.
* Bindat Functions::    Doing the unpacking and packing.
* Bindat Examples::     Samples of what bindat.el can do for you!


File: elisp.info,  Node: Bindat Spec,  Next: Bindat Functions,  Up: Byte Packing

38.20.1 Describing Data Layout
------------------------------

To control unpacking and packing, you write a “data layout
specification”, a special nested list describing named and typed
“fields”.  This specification controls the length of each field to be
processed, and how to pack or unpack it.  We normally keep bindat specs
in variables whose names end in ‘-bindat-spec’; that kind of name is
automatically recognized as risky.

   A field’s “type” describes the size (in bytes) of the object that the
field represents and, in the case of multibyte fields, how the bytes are
ordered within the field.  The two possible orderings are “big endian”
(also known as “network byte ordering”) and “little endian”.  For
instance, the number ‘#x23cd’ (decimal 9165) in big endian would be the
two bytes ‘#x23’ ‘#xcd’; and in little endian, ‘#xcd’ ‘#x23’.  Here are
the possible type values:

‘u8’
‘byte’
     Unsigned byte, with length 1.

‘u16’
‘word’
‘short’
     Unsigned integer in network byte order, with length 2.

‘u24’
     Unsigned integer in network byte order, with length 3.

‘u32’
‘dword’
‘long’
     Unsigned integer in network byte order, with length 4.  Note: These
     values may be limited by Emacs’s integer implementation limits.

‘u16r’
‘u24r’
‘u32r’
     Unsigned integer in little endian order, with length 2, 3 and 4,
     respectively.

‘str LEN’
     String of length LEN.

‘strz LEN’
     Zero-terminated string, in a fixed-size field with length LEN.

‘vec LEN [TYPE]’
     Vector of LEN elements of type TYPE, defaulting to bytes.  The TYPE
     is any of the simple types above, or another vector specified as a
     list of the form ‘(vec LEN [TYPE])’.

‘ip’
     Four-byte vector representing an Internet address.  For example:
     ‘[127 0 0 1]’ for localhost.

‘bits LEN’
     List of set bits in LEN bytes.  The bytes are taken in big endian
     order and the bits are numbered starting with ‘8 * LEN − 1’ and
     ending with zero.  For example: ‘bits 2’ unpacks ‘#x28’ ‘#x1c’ to
     ‘(2 3 4 11 13)’ and ‘#x1c’ ‘#x28’ to ‘(3 5 10 11 12)’.

‘(eval FORM)’
     FORM is a Lisp expression evaluated at the moment the field is
     unpacked or packed.  The result of the evaluation should be one of
     the above-listed type specifications.

   For a fixed-size field, the length LEN is given as an integer
specifying the number of bytes in the field.

   When the length of a field is not fixed, it typically depends on the
value of a preceding field.  In this case, the length LEN can be given
either as a list ‘(NAME ...)’ identifying a “field name” in the format
specified for ‘bindat-get-field’ below, or by an expression ‘(eval
FORM)’ where FORM should evaluate to an integer, specifying the field
length.

   A field specification generally has the form ‘([NAME] HANDLER)’,
where NAME is optional.  Don’t use names that are symbols meaningful as
type specifications (above) or handler specifications (below), since
that would be ambiguous.  NAME can be a symbol or an expression ‘(eval
FORM)’, in which case FORM should evaluate to a symbol.

   HANDLER describes how to unpack or pack the field and can be one of
the following:

‘TYPE’
     Unpack/pack this field according to the type specification TYPE.

‘eval FORM’
     Evaluate FORM, a Lisp expression, for side-effect only.  If the
     field name is specified, the value is bound to that field name.

‘fill LEN’
     Skip LEN bytes.  In packing, this leaves them unchanged, which
     normally means they remain zero.  In unpacking, this means they are
     ignored.

‘align LEN’
     Skip to the next multiple of LEN bytes.

‘struct SPEC-NAME’
     Process SPEC-NAME as a sub-specification.  This describes a
     structure nested within another structure.

‘union FORM (TAG SPEC)...’
     Evaluate FORM, a Lisp expression, find the first TAG that matches
     it, and process its associated data layout specification SPEC.
     Matching can occur in one of three ways:

        • If a TAG has the form ‘(eval EXPR)’, evaluate EXPR with the
          variable ‘tag’ dynamically bound to the value of FORM.  A
          non-‘nil’ result indicates a match.

        • TAG matches if it is ‘equal’ to the value of FORM.

        • TAG matches unconditionally if it is ‘t’.

‘repeat COUNT FIELD-SPECS...’
     Process the FIELD-SPECS recursively, in order, then repeat starting
     from the first one, processing all the specifications COUNT times
     overall.  The COUNT is given using the same formats as a field
     length—if an ‘eval’ form is used, it is evaluated just once.  For
     correct operation, each specification in FIELD-SPECS must include a
     name.

   For the ‘(eval FORM)’ forms used in a bindat specification, the FORM
can access and update these dynamically bound variables during
evaluation:

‘last’
     Value of the last field processed.

‘bindat-raw’
     The data as a byte array.

‘bindat-idx’
     Current index (within ‘bindat-raw’) for unpacking or packing.

‘struct’
     The alist containing the structured data that have been unpacked so
     far, or the entire structure being packed.  You can use
     ‘bindat-get-field’ to access specific fields of this structure.

‘count’
‘index’
     Inside a ‘repeat’ block, these contain the maximum number of
     repetitions (as specified by the COUNT parameter), and the current
     repetition number (counting from 0).  Setting ‘count’ to zero will
     terminate the inner-most repeat block after the current repetition
     has completed.


File: elisp.info,  Node: Bindat Functions,  Next: Bindat Examples,  Prev: Bindat Spec,  Up: Byte Packing

38.20.2 Functions to Unpack and Pack Bytes
------------------------------------------

In the following documentation, SPEC refers to a data layout
specification, ‘bindat-raw’ to a byte array, and STRUCT to an alist
representing unpacked field data.

 -- Function: bindat-unpack spec bindat-raw &optional bindat-idx
     This function unpacks data from the unibyte string or byte array
     ‘bindat-raw’ according to SPEC.  Normally, this starts unpacking at
     the beginning of the byte array, but if BINDAT-IDX is non-‘nil’, it
     specifies a zero-based starting position to use instead.

     The value is an alist or nested alist in which each element
     describes one unpacked field.

 -- Function: bindat-get-field struct &rest name
     This function selects a field’s data from the nested alist STRUCT.
     Usually STRUCT was returned by ‘bindat-unpack’.  If NAME
     corresponds to just one argument, that means to extract a top-level
     field value.  Multiple NAME arguments specify repeated lookup of
     sub-structures.  An integer name acts as an array index.

     For example, if NAME is ‘(a b 2 c)’, that means to find field ‘c’
     in the third element of subfield ‘b’ of field ‘a’.  (This
     corresponds to ‘struct.a.b[2].c’ in C.)

   Although packing and unpacking operations change the organization of
data (in memory), they preserve the data’s “total length”, which is the
sum of all the fields’ lengths, in bytes.  This value is not generally
inherent in either the specification or alist alone; instead, both
pieces of information contribute to its calculation.  Likewise, the
length of a string or array being unpacked may be longer than the data’s
total length as described by the specification.

 -- Function: bindat-length spec struct
     This function returns the total length of the data in STRUCT,
     according to SPEC.

 -- Function: bindat-pack spec struct &optional bindat-raw bindat-idx
     This function returns a byte array packed according to SPEC from
     the data in the alist STRUCT.  It normally creates and fills a new
     byte array starting at the beginning.  However, if BINDAT-RAW is
     non-‘nil’, it specifies a pre-allocated unibyte string or vector to
     pack into.  If BINDAT-IDX is non-‘nil’, it specifies the starting
     offset for packing into ‘bindat-raw’.

     When pre-allocating, you should make sure ‘(length BINDAT-RAW)’
     meets or exceeds the total length to avoid an out-of-range error.

 -- Function: bindat-ip-to-string ip
     Convert the Internet address vector IP to a string in the usual
     dotted notation.

          (bindat-ip-to-string [127 0 0 1])
               ⇒ "127.0.0.1"


File: elisp.info,  Node: Bindat Examples,  Prev: Bindat Functions,  Up: Byte Packing

38.20.3 Examples of Byte Unpacking and Packing
----------------------------------------------

Here are two complete examples that use bindat.el.  The first shows
simple byte packing:

     (require 'bindat)

     (defun rfc868-payload ()
       (bindat-pack
        '((now-hi u16)
          (now-lo u16))
        ;; Emacs uses Unix epoch, while RFC868 epoch
        ;; is 1900-01-01 00:00:00, which is 2208988800
        ;; (or #x83aa7e80) seconds more.
        (let ((now (time-add nil '(#x83aa #x7e80))))
          `((now-hi . ,(car now))
            (now-lo . ,(cadr now))))))

     (let ((s (rfc868-payload)))
       (list (multibyte-string-p s)
             (mapconcat (lambda (byte)
                          (format "%02x" byte))
                        s " ")
             (current-time-string)))
          ⇒ (nil "dc 6d 17 01" "Fri Mar 10 13:13:53 2017")

   The following is an example of defining and unpacking a complex
structure.  Consider the following C structures:

     struct header {
         unsigned long    dest_ip;
         unsigned long    src_ip;
         unsigned short   dest_port;
         unsigned short   src_port;
     };

     struct data {
         unsigned char    type;
         unsigned char    opcode;
         unsigned short   length;  /* in network byte order  */
         unsigned char    id[8];   /* null-terminated string  */
         unsigned char    data[/* (length + 3) & ~3 */];
     };

     struct packet {
         struct header    header;
         unsigned long    counters[2];  /* in little endian order  */
         unsigned char    items;
         unsigned char    filler[3];
         struct data      item[/* items */];

     };

   The corresponding data layout specification is:

     (setq header-spec
           '((dest-ip   ip)
             (src-ip    ip)
             (dest-port u16)
             (src-port  u16)))

     (setq data-spec
           '((type      u8)
             (opcode    u8)
             (length    u16)  ; network byte order
             (id        strz 8)
             (data      vec (length))
             (align     4)))

     (setq packet-spec
           '((header    struct header-spec)
             (counters  vec 2 u32r)   ; little endian order
             (items     u8)
             (fill      3)
             (item      repeat (items)
                        (struct data-spec))))

   A binary data representation is:

     (setq binary-data
           [ 192 168 1 100 192 168 1 101 01 28 21 32
             160 134 1 0 5 1 0 0 2 0 0 0
             2 3 0 5 ?A ?B ?C ?D ?E ?F 0 0 1 2 3 4 5 0 0 0
             1 4 0 7 ?B ?C ?D ?E ?F ?G 0 0 6 7 8 9 10 11 12 0 ])

   The corresponding decoded structure is:

     (setq decoded (bindat-unpack packet-spec binary-data))
          ⇒
     ((header
       (dest-ip   . [192 168 1 100])
       (src-ip    . [192 168 1 101])
       (dest-port . 284)
       (src-port  . 5408))
      (counters . [100000 261])
      (items . 2)
      (item ((data . [1 2 3 4 5])
             (id . "ABCDEF")
             (length . 5)
             (opcode . 3)
             (type . 2))
            ((data . [6 7 8 9 10 11 12])
             (id . "BCDEFG")
             (length . 7)
             (opcode . 4)
             (type . 1))))

   An example of fetching data from this structure:

     (bindat-get-field decoded 'item 1 'id)
          ⇒ "BCDEFG"


File: elisp.info,  Node: Display,  Next: System Interface,  Prev: Processes,  Up: Top

39 Emacs Display
****************

This chapter describes a number of features related to the display that
Emacs presents to the user.

* Menu:

* Refresh Screen::      Clearing the screen and redrawing everything on it.
* Forcing Redisplay::   Forcing redisplay.
* Truncation::          Folding or wrapping long text lines.
* The Echo Area::       Displaying messages at the bottom of the screen.
* Warnings::            Displaying warning messages for the user.
* Invisible Text::      Hiding part of the buffer text.
* Selective Display::   Hiding part of the buffer text (the old way).
* Temporary Displays::  Displays that go away automatically.
* Overlays::            Use overlays to highlight parts of the buffer.
* Size of Displayed Text::  How large displayed text is.
* Line Height::         Controlling the height of lines.
* Faces::               A face defines a graphics style for text characters:
                          font, colors, etc.
* Fringes::             Controlling window fringes.
* Scroll Bars::         Controlling scroll bars.
* Window Dividers::     Separating windows visually.
* Display Property::    Enabling special display features.
* Images::              Displaying images in Emacs buffers.
* Xwidgets::            Displaying native widgets in Emacs buffers.
* Buttons::             Adding clickable buttons to Emacs buffers.
* Abstract Display::    Emacs’s Widget for Object Collections.
* Blinking::            How Emacs shows the matching open parenthesis.
* Character Display::   How Emacs displays individual characters.
* Beeping::             Audible signal to the user.
* Window Systems::      Which window system is being used.
* Tooltips::            Tooltip display in Emacs.
* Bidirectional Display:: Display of bidirectional scripts, such as
                             Arabic and Farsi.


File: elisp.info,  Node: Refresh Screen,  Next: Forcing Redisplay,  Up: Display

39.1 Refreshing the Screen
==========================

The function ‘redraw-frame’ clears and redisplays the entire contents of
a given frame (*note Frames::).  This is useful if the screen is
corrupted.

 -- Function: redraw-frame &optional frame
     This function clears and redisplays frame FRAME.  If FRAME is
     omitted or ‘nil’, it redraws the selected frame.

   Even more powerful is ‘redraw-display’:

 -- Command: redraw-display
     This function clears and redisplays all visible frames.

   In Emacs, processing user input takes priority over redisplay.  If
you call these functions when input is available, they don’t redisplay
immediately, but the requested redisplay does happen eventually—after
all the input has been processed.

   On text terminals, suspending and resuming Emacs normally also
refreshes the screen.  Some terminal emulators record separate contents
for display-oriented programs such as Emacs and for ordinary sequential
display.  If you are using such a terminal, you might want to inhibit
the redisplay on resumption.

 -- User Option: no-redraw-on-reenter
     This variable controls whether Emacs redraws the entire screen
     after it has been suspended and resumed.  Non-‘nil’ means there is
     no need to redraw, ‘nil’ means redrawing is needed.  The default is
     ‘nil’.


File: elisp.info,  Node: Forcing Redisplay,  Next: Truncation,  Prev: Refresh Screen,  Up: Display

39.2 Forcing Redisplay
======================

Emacs normally tries to redisplay the screen whenever it waits for
input.  With the following function, you can request an immediate
attempt to redisplay, in the middle of Lisp code, without actually
waiting for input.

 -- Function: redisplay &optional force
     This function tries immediately to redisplay.  The optional
     argument FORCE, if non-‘nil’, forces the redisplay to be performed,
     instead of being preempted if input is pending.

     The function returns ‘t’ if it actually tried to redisplay, and
     ‘nil’ otherwise.  A value of ‘t’ does not mean that redisplay
     proceeded to completion; it could have been preempted by newly
     arriving input.

   Although ‘redisplay’ tries immediately to redisplay, it does not
change how Emacs decides which parts of its frame(s) to redisplay.  By
contrast, the following function adds certain windows to the pending
redisplay work (as if their contents had completely changed), but does
not immediately try to perform redisplay.

 -- Function: force-window-update &optional object
     This function forces some or all windows to be updated the next
     time Emacs does a redisplay.  If OBJECT is a window, that window is
     to be updated.  If OBJECT is a buffer or buffer name, all windows
     displaying that buffer are to be updated.  If OBJECT is ‘nil’ (or
     omitted), all windows are to be updated.

     This function does not do a redisplay immediately; Emacs does that
     as it waits for input, or when the function ‘redisplay’ is called.

 -- Variable: pre-redisplay-function
     A function run just before redisplay.  It is called with one
     argument, the set of windows to be redisplayed.  The set can be
     ‘nil’, meaning only the selected window, or ‘t’, meaning all the
     windows.

 -- Variable: pre-redisplay-functions
     This hook is run just before redisplay.  It is called once in each
     window that is about to be redisplayed, with ‘current-buffer’ set
     to the buffer displayed in that window.


File: elisp.info,  Node: Truncation,  Next: The Echo Area,  Prev: Forcing Redisplay,  Up: Display

39.3 Truncation
===============

When a line of text extends beyond the right edge of a window, Emacs can
“continue” the line (make it wrap to the next screen line), or
“truncate” the line (limit it to one screen line).  The additional
screen lines used to display a long text line are called “continuation”
lines.  Continuation is not the same as filling; continuation happens on
the screen only, not in the buffer contents, and it breaks a line
precisely at the right margin, not at a word boundary.  *Note Filling::.

   On a graphical display, tiny arrow images in the window fringes
indicate truncated and continued lines (*note Fringes::).  On a text
terminal, a ‘$’ in the rightmost column of the window indicates
truncation; a ‘\’ on the rightmost column indicates a line that wraps.
(The display table can specify alternate characters to use for this;
*note Display Tables::).

 -- User Option: truncate-lines
     If this buffer-local variable is non-‘nil’, lines that extend
     beyond the right edge of the window are truncated; otherwise, they
     are continued.  As a special exception, the variable
     ‘truncate-partial-width-windows’ takes precedence in
     “partial-width” windows (i.e., windows that do not occupy the
     entire frame width).

 -- User Option: truncate-partial-width-windows
     This variable controls line truncation in “partial-width” windows.
     A partial-width window is one that does not occupy the entire frame
     width (*note Splitting Windows::).  If the value is ‘nil’, line
     truncation is determined by the variable ‘truncate-lines’ (see
     above).  If the value is an integer N, lines are truncated if the
     partial-width window has fewer than N columns, regardless of the
     value of ‘truncate-lines’; if the partial-width window has N or
     more columns, line truncation is determined by ‘truncate-lines’.
     For any other non-‘nil’ value, lines are truncated in every
     partial-width window, regardless of the value of ‘truncate-lines’.

   When horizontal scrolling (*note Horizontal Scrolling::) is in use in
a window, that forces truncation.

 -- Variable: wrap-prefix
     If this buffer-local variable is non-‘nil’, it defines a “wrap
     prefix” which Emacs displays at the start of every continuation
     line.  (If lines are truncated, ‘wrap-prefix’ is never used.)  Its
     value may be a string or an image (*note Other Display Specs::), or
     a stretch of whitespace such as specified by the ‘:width’ or
     ‘:align-to’ display properties (*note Specified Space::).  The
     value is interpreted in the same way as a ‘display’ text property.
     *Note Display Property::.

     A wrap prefix may also be specified for regions of text, using the
     ‘wrap-prefix’ text or overlay property.  This takes precedence over
     the ‘wrap-prefix’ variable.  *Note Special Properties::.

 -- Variable: line-prefix
     If this buffer-local variable is non-‘nil’, it defines a “line
     prefix” which Emacs displays at the start of every non-continuation
     line.  Its value may be a string or an image (*note Other Display
     Specs::), or a stretch of whitespace such as specified by the
     ‘:width’ or ‘:align-to’ display properties (*note Specified
     Space::).  The value is interpreted in the same way as a ‘display’
     text property.  *Note Display Property::.

     A line prefix may also be specified for regions of text using the
     ‘line-prefix’ text or overlay property.  This takes precedence over
     the ‘line-prefix’ variable.  *Note Special Properties::.


File: elisp.info,  Node: The Echo Area,  Next: Warnings,  Prev: Truncation,  Up: Display

39.4 The Echo Area
==================

The “echo area” is used for displaying error messages (*note Errors::),
for messages made with the ‘message’ primitive, and for echoing
keystrokes.  It is not the same as the minibuffer, despite the fact that
the minibuffer appears (when active) in the same place on the screen as
the echo area.  *Note The Minibuffer: (emacs)Minibuffer.

   Apart from the functions documented in this section, you can print
Lisp objects to the echo area by specifying ‘t’ as the output stream.
*Note Output Streams::.

* Menu:

* Displaying Messages:: Explicitly displaying text in the echo area.
* Progress::            Informing user about progress of a long operation.
* Logging Messages::    Echo area messages are logged for the user.
* Echo Area Customization:: Controlling the echo area.

