This is elisp.info, produced by makeinfo version 6.1 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp.info,  Node: Format Conversion Piecemeal,  Prev: Format Conversion Round-Trip,  Up: Format Conversion

25.13.3 Piecemeal Specification
-------------------------------

In contrast to the round-trip specification described in the previous
subsection (*note Format Conversion Round-Trip::), you can use the
variables ‘after-insert-file-functions’ and
‘write-region-annotate-functions’ to separately control the respective
reading and writing conversions.

   Conversion starts with one representation and produces another
representation.  When there is only one conversion to do, there is no
conflict about what to start with.  However, when there are multiple
conversions involved, conflict may arise when two conversions need to
start with the same data.

   This situation is best understood in the context of converting text
properties during ‘write-region’.  For example, the character at
position 42 in a buffer is ‘X’ with a text property ‘foo’.  If the
conversion for ‘foo’ is done by inserting into the buffer, say, ‘FOO:’,
then that changes the character at position 42 from ‘X’ to ‘F’.  The
next conversion will start with the wrong data straight away.

   To avoid conflict, cooperative conversions do not modify the buffer,
but instead specify “annotations”, a list of elements of the form
‘(POSITION . STRING)’, sorted in order of increasing POSITION.

   If there is more than one conversion, ‘write-region’ merges their
annotations destructively into one sorted list.  Later, when the text
from the buffer is actually written to the file, it intermixes the
specified annotations at the corresponding positions.  All this takes
place without modifying the buffer.

   In contrast, when reading, the annotations intermixed with the text
are handled immediately.  ‘insert-file-contents’ sets point to the
beginning of some text to be converted, then calls the conversion
functions with the length of that text.  These functions should always
return with point at the beginning of the inserted text.  This approach
makes sense for reading because annotations removed by the first
converter can’t be mistakenly processed by a later converter.  Each
conversion function should scan for the annotations it recognizes,
remove the annotation, modify the buffer text (to set a text property,
for example), and return the updated length of the text, as it stands
after those changes.  The value returned by one function becomes the
argument to the next function.

 -- Variable: write-region-annotate-functions
     A list of functions for ‘write-region’ to call.  Each function in
     the list is called with two arguments: the start and end of the
     region to be written.  These functions should not alter the
     contents of the buffer.  Instead, they should return annotations.

     As a special case, a function may return with a different buffer
     current.  Emacs takes this to mean that the current buffer contains
     altered text to be output.  It therefore changes the START and END
     arguments of the ‘write-region’ call, giving them the values of
     ‘point-min’ and ‘point-max’ in the new buffer, respectively.  It
     also discards all previous annotations, because they should have
     been dealt with by this function.

 -- Variable: write-region-post-annotation-function
     The value of this variable, if non-‘nil’, should be a function.
     This function is called, with no arguments, after ‘write-region’
     has completed.

     If any function in ‘write-region-annotate-functions’ returns with a
     different buffer current, Emacs calls
     ‘write-region-post-annotation-function’ more than once.  Emacs
     calls it with the last buffer that was current, and again with the
     buffer before that, and so on back to the original buffer.

     Thus, a function in ‘write-region-annotate-functions’ can create a
     buffer, give this variable the local value of ‘kill-buffer’ in that
     buffer, set up the buffer with altered text, and make the buffer
     current.  The buffer will be killed after ‘write-region’ is done.

 -- Variable: after-insert-file-functions
     Each function in this list is called by ‘insert-file-contents’ with
     one argument, the number of characters inserted, and with point at
     the beginning of the inserted text.  Each function should leave
     point unchanged, and return the new character count describing the
     inserted text as modified by the function.

   We invite users to write Lisp programs to store and retrieve text
properties in files, using these hooks, and thus to experiment with
various data formats and find good ones.  Eventually we hope users will
produce good, general extensions we can install in Emacs.

   We suggest not trying to handle arbitrary Lisp objects as text
property names or values—because a program that general is probably
difficult to write, and slow.  Instead, choose a set of possible data
types that are reasonably flexible, and not too hard to encode.


File: elisp.info,  Node: Backups and Auto-Saving,  Next: Buffers,  Prev: Files,  Up: Top

26 Backups and Auto-Saving
**************************

Backup files and auto-save files are two methods by which Emacs tries to
protect the user from the consequences of crashes or of the user’s own
errors.  Auto-saving preserves the text from earlier in the current
editing session; backup files preserve file contents prior to the
current session.

* Menu:

* Backup Files::   How backup files are made; how their names are chosen.
* Auto-Saving::    How auto-save files are made; how their names are chosen.
* Reverting::      ‘revert-buffer’, and how to customize what it does.


File: elisp.info,  Node: Backup Files,  Next: Auto-Saving,  Up: Backups and Auto-Saving

26.1 Backup Files
=================

A “backup file” is a copy of the old contents of a file you are editing.
Emacs makes a backup file the first time you save a buffer into its
visited file.  Thus, normally, the backup file contains the contents of
the file as it was before the current editing session.  The contents of
the backup file normally remain unchanged once it exists.

   Backups are usually made by renaming the visited file to a new name.
Optionally, you can specify that backup files should be made by copying
the visited file.  This choice makes a difference for files with
multiple names; it also can affect whether the edited file remains owned
by the original owner or becomes owned by the user editing it.

   By default, Emacs makes a single backup file for each file edited.
You can alternatively request numbered backups; then each new backup
file gets a new name.  You can delete old numbered backups when you
don’t want them any more, or Emacs can delete them automatically.

   For performance, the operating system may not write the backup file’s
contents to secondary storage immediately, or may alias the backup data
with the original until one or the other is later modified.  *Note Files
and Storage::.

* Menu:

* Making Backups::     How Emacs makes backup files, and when.
* Rename or Copy::     Two alternatives: renaming the old file or copying it.
* Numbered Backups::   Keeping multiple backups for each source file.
* Backup Names::       How backup file names are computed; customization.


File: elisp.info,  Node: Making Backups,  Next: Rename or Copy,  Up: Backup Files

26.1.1 Making Backup Files
--------------------------

 -- Function: backup-buffer
     This function makes a backup of the file visited by the current
     buffer, if appropriate.  It is called by ‘save-buffer’ before
     saving the buffer the first time.

     If a backup was made by renaming, the return value is a cons cell
     of the form (MODES EXTRA-ALIST BACKUPNAME), where MODES are the
     mode bits of the original file, as returned by ‘file-modes’ (*note
     Testing Accessibility::), EXTRA-ALIST is an alist describing the
     original file’s extended attributes, as returned by
     ‘file-extended-attributes’ (*note Extended Attributes::), and
     BACKUPNAME is the name of the backup.

     In all other cases (i.e., if a backup was made by copying or if no
     backup was made), this function returns ‘nil’.

 -- Variable: buffer-backed-up
     This buffer-local variable says whether this buffer’s file has been
     backed up on account of this buffer.  If it is non-‘nil’, the
     backup file has been written.  Otherwise, the file should be backed
     up when it is next saved (if backups are enabled).  This is a
     permanent local; ‘kill-all-local-variables’ does not alter it.

 -- User Option: make-backup-files
     This variable determines whether or not to make backup files.  If
     it is non-‘nil’, then Emacs creates a backup of each file when it
     is saved for the first time—provided that ‘backup-inhibited’ is
     ‘nil’ (see below).

     The following example shows how to change the ‘make-backup-files’
     variable only in the Rmail buffers and not elsewhere.  Setting it
     ‘nil’ stops Emacs from making backups of these files, which may
     save disk space.  (You would put this code in your init file.)

          (add-hook 'rmail-mode-hook
                    (lambda () (setq-local make-backup-files nil)))

 -- Variable: backup-enable-predicate
     This variable’s value is a function to be called on certain
     occasions to decide whether a file should have backup files.  The
     function receives one argument, an absolute file name to consider.
     If the function returns ‘nil’, backups are disabled for that file.
     Otherwise, the other variables in this section say whether and how
     to make backups.

     The default value is ‘normal-backup-enable-predicate’, which checks
     for files in ‘temporary-file-directory’ and
     ‘small-temporary-file-directory’.

 -- Variable: backup-inhibited
     If this variable is non-‘nil’, backups are inhibited.  It records
     the result of testing ‘backup-enable-predicate’ on the visited file
     name.  It can also coherently be used by other mechanisms that
     inhibit backups based on which file is visited.  For example, VC
     sets this variable non-‘nil’ to prevent making backups for files
     managed with a version control system.

     This is a permanent local, so that changing the major mode does not
     lose its value.  Major modes should not set this variable—they
     should set ‘make-backup-files’ instead.

 -- User Option: backup-directory-alist
     This variable’s value is an alist of filename patterns and backup
     directories.  Each element looks like
          (REGEXP . DIRECTORY)

     Backups of files with names matching REGEXP will be made in
     DIRECTORY.  DIRECTORY may be relative or absolute.  If it is
     absolute, so that all matching files are backed up into the same
     directory, the file names in this directory will be the full name
     of the file backed up with all directory separators changed to ‘!’
     to prevent clashes.  This will not work correctly if your
     filesystem truncates the resulting name.

     For the common case of all backups going into one directory, the
     alist should contain a single element pairing ‘"."’ with the
     appropriate directory.

     If this variable is ‘nil’ (the default), or it fails to match a
     filename, the backup is made in the original file’s directory.

     On MS-DOS filesystems without long names this variable is always
     ignored.

 -- User Option: make-backup-file-name-function
     This variable’s value is a function to use for making backup file
     names.  The function ‘make-backup-file-name’ calls it.  *Note
     Naming Backup Files: Backup Names.

     This could be buffer-local to do something special for specific
     files.  If you change it, you may need to change
     ‘backup-file-name-p’ and ‘file-name-sans-versions’ too.


File: elisp.info,  Node: Rename or Copy,  Next: Numbered Backups,  Prev: Making Backups,  Up: Backup Files

26.1.2 Backup by Renaming or by Copying?
----------------------------------------

There are two ways that Emacs can make a backup file:

   • Emacs can rename the original file so that it becomes a backup
     file, and then write the buffer being saved into a new file.  After
     this procedure, any other names (i.e., hard links) of the original
     file now refer to the backup file.  The new file is owned by the
     user doing the editing, and its group is the default for new files
     written by the user in that directory.

   • Emacs can copy the original file into a backup file, and then
     overwrite the original file with new contents.  After this
     procedure, any other names (i.e., hard links) of the original file
     continue to refer to the current (updated) version of the file.
     The file’s owner and group will be unchanged.

   The first method, renaming, is the default.

   The variable ‘backup-by-copying’, if non-‘nil’, says to use the
second method, which is to copy the original file and overwrite it with
the new buffer contents.  The variable ‘file-precious-flag’, if
non-‘nil’, also has this effect (as a sideline of its main
significance).  *Note Saving Buffers::.

 -- User Option: backup-by-copying
     If this variable is non-‘nil’, Emacs always makes backup files by
     copying.  The default is ‘nil’.

   The following three variables, when non-‘nil’, cause the second
method to be used in certain special cases.  They have no effect on the
treatment of files that don’t fall into the special cases.

 -- User Option: backup-by-copying-when-linked
     If this variable is non-‘nil’, Emacs makes backups by copying for
     files with multiple names (hard links).  The default is ‘nil’.

     This variable is significant only if ‘backup-by-copying’ is ‘nil’,
     since copying is always used when that variable is non-‘nil’.

 -- User Option: backup-by-copying-when-mismatch
     If this variable is non-‘nil’ (the default), Emacs makes backups by
     copying in cases where renaming would change either the owner or
     the group of the file.

     The value has no effect when renaming would not alter the owner or
     group of the file; that is, for files which are owned by the user
     and whose group matches the default for a new file created there by
     the user.

     This variable is significant only if ‘backup-by-copying’ is ‘nil’,
     since copying is always used when that variable is non-‘nil’.

 -- User Option: backup-by-copying-when-privileged-mismatch
     This variable, if non-‘nil’, specifies the same behavior as
     ‘backup-by-copying-when-mismatch’, but only for certain user-id
     values: namely, those less than or equal to a certain number.  You
     set this variable to that number.

     Thus, if you set ‘backup-by-copying-when-privileged-mismatch’ to 0,
     backup by copying is done for the superuser only, when necessary to
     prevent a change in the owner of the file.

     The default is 200.


File: elisp.info,  Node: Numbered Backups,  Next: Backup Names,  Prev: Rename or Copy,  Up: Backup Files

26.1.3 Making and Deleting Numbered Backup Files
------------------------------------------------

If a file’s name is ‘foo’, the names of its numbered backup versions are
‘foo.~V~’, for various integers V, like this: ‘foo.~1~’, ‘foo.~2~’,
‘foo.~3~’, ..., ‘foo.~259~’, and so on.

 -- User Option: version-control
     This variable controls whether to make a single non-numbered backup
     file or multiple numbered backups.

     ‘nil’
          Make numbered backups if the visited file already has numbered
          backups; otherwise, do not.  This is the default.

     ‘never’
          Do not make numbered backups.

     ANYTHING ELSE
          Make numbered backups.

   The use of numbered backups ultimately leads to a large number of
backup versions, which must then be deleted.  Emacs can do this
automatically or it can ask the user whether to delete them.

 -- User Option: kept-new-versions
     The value of this variable is the number of newest versions to keep
     when a new numbered backup is made.  The newly made backup is
     included in the count.  The default value is 2.

 -- User Option: kept-old-versions
     The value of this variable is the number of oldest versions to keep
     when a new numbered backup is made.  The default value is 2.

   If there are backups numbered 1, 2, 3, 5, and 7, and both of these
variables have the value 2, then the backups numbered 1 and 2 are kept
as old versions and those numbered 5 and 7 are kept as new versions;
backup version 3 is excess.  The function ‘find-backup-file-name’ (*note
Backup Names::) is responsible for determining which backup versions to
delete, but does not delete them itself.

 -- User Option: delete-old-versions
     If this variable is ‘t’, then saving a file deletes excess backup
     versions silently.  If it is ‘nil’, that means to ask for
     confirmation before deleting excess backups.  Otherwise, they are
     not deleted at all.

 -- User Option: dired-kept-versions
     This variable specifies how many of the newest backup versions to
     keep in the Dired command ‘.’ (‘dired-clean-directory’).  That’s
     the same thing ‘kept-new-versions’ specifies when you make a new
     backup file.  The default is 2.


File: elisp.info,  Node: Backup Names,  Prev: Numbered Backups,  Up: Backup Files

26.1.4 Naming Backup Files
--------------------------

The functions in this section are documented mainly because you can
customize the naming conventions for backup files by redefining them.
If you change one, you probably need to change the rest.

 -- Function: backup-file-name-p filename
     This function returns a non-‘nil’ value if FILENAME is a possible
     name for a backup file.  It just checks the name, not whether a
     file with the name FILENAME exists.

          (backup-file-name-p "foo")
               ⇒ nil
          (backup-file-name-p "foo~")
               ⇒ 3

     The standard definition of this function is as follows:

          (defun backup-file-name-p (file)
            "Return non-nil if FILE is a backup file \
          name (numeric or not)..."
            (string-match "~\\'" file))

     Thus, the function returns a non-‘nil’ value if the file name ends
     with a ‘~’.  (We use a backslash to split the documentation
     string’s first line into two lines in the text, but produce just
     one line in the string itself.)

     This simple expression is placed in a separate function to make it
     easy to redefine for customization.

 -- Function: make-backup-file-name filename
     This function returns a string that is the name to use for a
     non-numbered backup file for file FILENAME.  On Unix, this is just
     FILENAME with a tilde appended.

     The standard definition of this function, on most operating
     systems, is as follows:

          (defun make-backup-file-name (file)
            "Create the non-numeric backup file name for FILE..."
            (concat file "~"))

     You can change the backup-file naming convention by redefining this
     function.  The following example redefines ‘make-backup-file-name’
     to prepend a ‘.’ in addition to appending a tilde:

          (defun make-backup-file-name (filename)
            (expand-file-name
              (concat "." (file-name-nondirectory filename) "~")
              (file-name-directory filename)))

          (make-backup-file-name "backups.texi")
               ⇒ ".backups.texi~"

     Some parts of Emacs, including some Dired commands, assume that
     backup file names end with ‘~’.  If you do not follow that
     convention, it will not cause serious problems, but these commands
     may give less-than-desirable results.

 -- Function: find-backup-file-name filename
     This function computes the file name for a new backup file for
     FILENAME.  It may also propose certain existing backup files for
     deletion.  ‘find-backup-file-name’ returns a list whose CAR is the
     name for the new backup file and whose CDR is a list of backup
     files whose deletion is proposed.  The value can also be ‘nil’,
     which means not to make a backup.

     Two variables, ‘kept-old-versions’ and ‘kept-new-versions’,
     determine which backup versions should be kept.  This function
     keeps those versions by excluding them from the CDR of the value.
     *Note Numbered Backups::.

     In this example, the value says that ‘~rms/foo.~5~’ is the name to
     use for the new backup file, and ‘~rms/foo.~3~’ is an excess
     version that the caller should consider deleting now.

          (find-backup-file-name "~rms/foo")
               ⇒ ("~rms/foo.~5~" "~rms/foo.~3~")

 -- Function: file-newest-backup filename
     This function returns the name of the most recent backup file for
     FILENAME, or ‘nil’ if that file has no backup files.

     Some file comparison commands use this function so that they can
     automatically compare a file with its most recent backup.


File: elisp.info,  Node: Auto-Saving,  Next: Reverting,  Prev: Backup Files,  Up: Backups and Auto-Saving

26.2 Auto-Saving
================

Emacs periodically saves all files that you are visiting; this is called
“auto-saving”.  Auto-saving prevents you from losing more than a limited
amount of work if the system crashes.  By default, auto-saves happen
every 300 keystrokes, or after around 30 seconds of idle time.  *Note
Auto Save: (emacs)Auto Save, for information on auto-save for users.
Here we describe the functions used to implement auto-saving and the
variables that control them.

 -- Variable: buffer-auto-save-file-name
     This buffer-local variable is the name of the file used for
     auto-saving the current buffer.  It is ‘nil’ if the buffer should
     not be auto-saved.

          buffer-auto-save-file-name
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"

 -- Command: auto-save-mode arg
     This is the mode command for Auto Save mode, a buffer-local minor
     mode.  When Auto Save mode is enabled, auto-saving is enabled in
     the buffer.  The calling convention is the same as for other minor
     mode commands (*note Minor Mode Conventions::).

     Unlike most minor modes, there is no ‘auto-save-mode’ variable.
     Auto Save mode is enabled if ‘buffer-auto-save-file-name’ is
     non-‘nil’ and ‘buffer-saved-size’ (see below) is non-zero.

 -- Function: auto-save-file-name-p filename
     This function returns a non-‘nil’ value if FILENAME is a string
     that could be the name of an auto-save file.  It assumes the usual
     naming convention for auto-save files: a name that begins and ends
     with hash marks (‘#’) is a possible auto-save file name.  The
     argument FILENAME should not contain a directory part.

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"
          (auto-save-file-name-p "#backups.texi#")
               ⇒ 0
          (auto-save-file-name-p "backups.texi")
               ⇒ nil

     The standard definition of this function is as follows:

          (defun auto-save-file-name-p (filename)
            "Return non-nil if FILENAME can be yielded by..."
            (string-match "^#.*#$" filename))

     This function exists so that you can customize it if you wish to
     change the naming convention for auto-save files.  If you redefine
     it, be sure to redefine the function ‘make-auto-save-file-name’
     correspondingly.

 -- Function: make-auto-save-file-name
     This function returns the file name to use for auto-saving the
     current buffer.  This is just the file name with hash marks (‘#’)
     prepended and appended to it.  This function does not look at the
     variable ‘auto-save-visited-file-name’ (described below); callers
     of this function should check that variable first.

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"

     Here is a simplified version of the standard definition of this
     function:

          (defun make-auto-save-file-name ()
            "Return file name to use for auto-saves \
          of current buffer.."
            (if buffer-file-name
                (concat
                 (file-name-directory buffer-file-name)
                 "#"
                 (file-name-nondirectory buffer-file-name)
                 "#")
              (expand-file-name
               (concat "#%" (buffer-name) "#"))))

     This exists as a separate function so that you can redefine it to
     customize the naming convention for auto-save files.  Be sure to
     change ‘auto-save-file-name-p’ in a corresponding way.

 -- User Option: auto-save-visited-file-name
     If this variable is non-‘nil’, Emacs auto-saves buffers in the
     files they are visiting.  That is, the auto-save is done in the
     same file that you are editing.  Normally, this variable is ‘nil’,
     so auto-save files have distinct names that are created by
     ‘make-auto-save-file-name’.

     When you change the value of this variable, the new value does not
     take effect in an existing buffer until the next time auto-save
     mode is reenabled in it.  If auto-save mode is already enabled,
     auto-saves continue to go in the same file name until
     ‘auto-save-mode’ is called again.

     Note that setting this variable to a non-‘nil’ value does not
     change the fact that auto-saving is different from saving the
     buffer; e.g., the hooks described in *note Saving Buffers:: are
     _not_ run when a buffer is auto-saved.

 -- Function: recent-auto-save-p
     This function returns ‘t’ if the current buffer has been auto-saved
     since the last time it was read in or saved.

 -- Function: set-buffer-auto-saved
     This function marks the current buffer as auto-saved.  The buffer
     will not be auto-saved again until the buffer text is changed
     again.  The function returns ‘nil’.

 -- User Option: auto-save-interval
     The value of this variable specifies how often to do auto-saving,
     in terms of number of input events.  Each time this many additional
     input events are read, Emacs does auto-saving for all buffers in
     which that is enabled.  Setting this to zero disables autosaving
     based on the number of characters typed.

 -- User Option: auto-save-timeout
     The value of this variable is the number of seconds of idle time
     that should cause auto-saving.  Each time the user pauses for this
     long, Emacs does auto-saving for all buffers in which that is
     enabled.  (If the current buffer is large, the specified timeout is
     multiplied by a factor that increases as the size increases; for a
     million-byte buffer, the factor is almost 4.)

     If the value is zero or ‘nil’, then auto-saving is not done as a
     result of idleness, only after a certain number of input events as
     specified by ‘auto-save-interval’.

 -- Variable: auto-save-hook
     This normal hook is run whenever an auto-save is about to happen.

 -- User Option: auto-save-default
     If this variable is non-‘nil’, buffers that are visiting files have
     auto-saving enabled by default.  Otherwise, they do not.

 -- Command: do-auto-save &optional no-message current-only
     This function auto-saves all buffers that need to be auto-saved.
     It saves all buffers for which auto-saving is enabled and that have
     been changed since the previous auto-save.

     If any buffers are auto-saved, ‘do-auto-save’ normally displays a
     message saying ‘Auto-saving...’ in the echo area while auto-saving
     is going on.  However, if NO-MESSAGE is non-‘nil’, the message is
     inhibited.

     If CURRENT-ONLY is non-‘nil’, only the current buffer is
     auto-saved.

 -- Function: delete-auto-save-file-if-necessary &optional force
     This function deletes the current buffer’s auto-save file if
     ‘delete-auto-save-files’ is non-‘nil’.  It is called every time a
     buffer is saved.

     Unless FORCE is non-‘nil’, this function only deletes the file if
     it was written by the current Emacs session since the last true
     save.

 -- User Option: delete-auto-save-files
     This variable is used by the function
     ‘delete-auto-save-file-if-necessary’.  If it is non-‘nil’, Emacs
     deletes auto-save files when a true save is done (in the visited
     file).  This saves disk space and unclutters your directory.

 -- Function: rename-auto-save-file
     This function adjusts the current buffer’s auto-save file name if
     the visited file name has changed.  It also renames an existing
     auto-save file, if it was made in the current Emacs session.  If
     the visited file name has not changed, this function does nothing.

 -- Variable: buffer-saved-size
     The value of this buffer-local variable is the length of the
     current buffer, when it was last read in, saved, or auto-saved.
     This is used to detect a substantial decrease in size, and turn off
     auto-saving in response.

     If it is −1, that means auto-saving is temporarily shut off in this
     buffer due to a substantial decrease in size.  Explicitly saving
     the buffer stores a positive value in this variable, thus
     reenabling auto-saving.  Turning auto-save mode off or on also
     updates this variable, so that the substantial decrease in size is
     forgotten.

     If it is −2, that means this buffer should disregard changes in
     buffer size; in particular, it should not shut off auto-saving
     temporarily due to changes in buffer size.

 -- Variable: auto-save-list-file-name
     This variable (if non-‘nil’) specifies a file for recording the
     names of all the auto-save files.  Each time Emacs does
     auto-saving, it writes two lines into this file for each buffer
     that has auto-saving enabled.  The first line gives the name of the
     visited file (it’s empty if the buffer has none), and the second
     gives the name of the auto-save file.

     When Emacs exits normally, it deletes this file; if Emacs crashes,
     you can look in the file to find all the auto-save files that might
     contain work that was otherwise lost.  The ‘recover-session’
     command uses this file to find them.

     The default name for this file specifies your home directory and
     starts with ‘.saves-’.  It also contains the Emacs process ID and
     the host name.

 -- User Option: auto-save-list-file-prefix
     After Emacs reads your init file, it initializes
     ‘auto-save-list-file-name’ (if you have not already set it
     non-‘nil’) based on this prefix, adding the host name and process
     ID.  If you set this to ‘nil’ in your init file, then Emacs does
     not initialize ‘auto-save-list-file-name’.


File: elisp.info,  Node: Reverting,  Prev: Auto-Saving,  Up: Backups and Auto-Saving

26.3 Reverting
==============

If you have made extensive changes to a file and then change your mind
about them, you can get rid of them by reading in the previous version
of the file with the ‘revert-buffer’ command.  *Note Reverting a Buffer:
(emacs)Reverting.

 -- Command: revert-buffer &optional ignore-auto noconfirm
          preserve-modes
     This command replaces the buffer text with the text of the visited
     file on disk.  This action undoes all changes since the file was
     visited or saved.

     By default, if the latest auto-save file is more recent than the
     visited file, and the argument IGNORE-AUTO is ‘nil’,
     ‘revert-buffer’ asks the user whether to use that auto-save
     instead.  When you invoke this command interactively, IGNORE-AUTO
     is ‘t’ if there is no numeric prefix argument; thus, the
     interactive default is not to check the auto-save file.

     Normally, ‘revert-buffer’ asks for confirmation before it changes
     the buffer; but if the argument NOCONFIRM is non-‘nil’,
     ‘revert-buffer’ does not ask for confirmation.

     Normally, this command reinitializes the buffer’s major and minor
     modes using ‘normal-mode’.  But if PRESERVE-MODES is non-‘nil’, the
     modes remain unchanged.

     Reverting tries to preserve marker positions in the buffer by using
     the replacement feature of ‘insert-file-contents’.  If the buffer
     contents and the file contents are identical before the revert
     operation, reverting preserves all the markers.  If they are not
     identical, reverting does change the buffer; in that case, it
     preserves the markers in the unchanged text (if any) at the
     beginning and end of the buffer.  Preserving any additional markers
     would be problematical.

 -- Variable: revert-buffer-in-progress-p
     ‘revert-buffer’ binds this variable to a non-‘nil’ value while it
     is working.

   You can customize how ‘revert-buffer’ does its work by setting the
variables described in the rest of this section.

 -- User Option: revert-without-query
     This variable holds a list of files that should be reverted without
     query.  The value is a list of regular expressions.  If the visited
     file name matches one of these regular expressions, and the file
     has changed on disk but the buffer is not modified, then
     ‘revert-buffer’ reverts the file without asking the user for
     confirmation.

   Some major modes customize ‘revert-buffer’ by making buffer-local
bindings for these variables:

 -- Variable: revert-buffer-function
     The value of this variable is the function to use to revert this
     buffer.  It should be a function with two optional arguments to do
     the work of reverting.  The two optional arguments, IGNORE-AUTO and
     NOCONFIRM, are the arguments that ‘revert-buffer’ received.

     Modes such as Dired mode, in which the text being edited does not
     consist of a file’s contents but can be regenerated in some other
     fashion, can give this variable a buffer-local value that is a
     special function to regenerate the contents.

 -- Variable: revert-buffer-insert-file-contents-function
     The value of this variable specifies the function to use to insert
     the updated contents when reverting this buffer.  The function
     receives two arguments: first the file name to use; second, ‘t’ if
     the user has asked to read the auto-save file.

     The reason for a mode to change this variable instead of
     ‘revert-buffer-function’ is to avoid duplicating or replacing the
     rest of what ‘revert-buffer’ does: asking for confirmation,
     clearing the undo list, deciding the proper major mode, and running
     the hooks listed below.

 -- Variable: before-revert-hook
     This normal hook is run by the default ‘revert-buffer-function’
     before inserting the modified contents.  A custom
     ‘revert-buffer-function’ may or may not run this hook.

 -- Variable: after-revert-hook
     This normal hook is run by the default ‘revert-buffer-function’
     after inserting the modified contents.  A custom
     ‘revert-buffer-function’ may or may not run this hook.

   Emacs can revert buffers automatically.  It does that by default for
buffers visiting files.  The following describes how to add support for
auto-reverting new types of buffers.

   First, such buffers must have a suitable ‘revert-buffer-function’ and
‘buffer-stale-function’ defined.

 -- Variable: buffer-stale-function
     The value of this variable specifies a function to call to check
     whether a buffer needs reverting.  The default value only handles
     buffers that are visiting files, by checking their modification
     time.  Buffers that are not visiting files require a custom
     function of one optional argument NOCONFIRM.  The function should
     return non-‘nil’ if the buffer should be reverted.  The buffer is
     current when this function is called.

     While this function is mainly intended for use in auto-reverting,
     it could be used for other purposes as well.  For instance, if
     auto-reverting is not enabled, it could be used to warn the user
     that the buffer needs reverting.  The idea behind the NOCONFIRM
     argument is that it should be ‘t’ if the buffer is going to be
     reverted without asking the user and ‘nil’ if the function is just
     going to be used to warn the user that the buffer is out of date.
     In particular, for use in auto-reverting, NOCONFIRM is ‘t’.  If the
     function is only going to be used for auto-reverting, you can
     ignore the NOCONFIRM argument.

     If you just want to automatically auto-revert every
     ‘auto-revert-interval’ seconds (like the Buffer Menu), use:

          (setq-local buffer-stale-function
               #'(lambda (&optional noconfirm) 'fast))

     in the buffer’s mode function.

     The special return value ‘fast’ tells the caller that the need for
     reverting was not checked, but that reverting the buffer is fast.
     It also tells Auto Revert not to print any revert messages, even if
     ‘auto-revert-verbose’ is non-‘nil’.  This is important, as getting
     revert messages every ‘auto-revert-interval’ seconds can be very
     annoying.  The information provided by this return value could also
     be useful if the function is consulted for purposes other than
     auto-reverting.

   Once the buffer has a suitable ‘revert-buffer-function’ and
‘buffer-stale-function’, several problems usually remain.

   The buffer will only auto-revert if it is marked unmodified.  Hence,
you will have to make sure that various functions mark the buffer
modified if and only if either the buffer contains information that
might be lost by reverting, or there is reason to believe that the user
might be inconvenienced by auto-reverting, because he is actively
working on the buffer.  The user can always override this by manually
adjusting the modified status of the buffer.  To support this, calling
the ‘revert-buffer-function’ on a buffer that is marked unmodified
should always keep the buffer marked unmodified.

   It is important to assure that point does not continuously jump
around as a consequence of auto-reverting.  Of course, moving point
might be inevitable if the buffer radically changes.

   You should make sure that the ‘revert-buffer-function’ does not print
messages that unnecessarily duplicate Auto Revert’s own messages,
displayed if ‘auto-revert-verbose’ is ‘t’, and effectively override a
‘nil’ value for ‘auto-revert-verbose’.  Hence, adapting a mode for
auto-reverting often involves getting rid of such messages.  This is
especially important for buffers that automatically revert every
‘auto-revert-interval’ seconds.

   If the new auto-reverting is part of Emacs, you should mention it in
the documentation string of ‘global-auto-revert-non-file-buffers’.

   Similarly, you should document the additions in the Emacs manual.


File: elisp.info,  Node: Buffers,  Next: Windows,  Prev: Backups and Auto-Saving,  Up: Top

27 Buffers
**********

A “buffer” is a Lisp object containing text to be edited.  Buffers are
used to hold the contents of files that are being visited; there may
also be buffers that are not visiting files.  While several buffers may
exist at one time, only one buffer is designated the “current buffer” at
any time.  Most editing commands act on the contents of the current
buffer.  Each buffer, including the current buffer, may or may not be
displayed in any windows.

* Menu:

* Buffer Basics::       What is a buffer?
* Current Buffer::      Designating a buffer as current
                          so that primitives will access its contents.
* Buffer Names::        Accessing and changing buffer names.
* Buffer File Name::    The buffer file name indicates which file is visited.
* Buffer Modification:: A buffer is “modified” if it needs to be saved.
* Modification Time::   Determining whether the visited file was changed
                         behind Emacs’s back.
* Read Only Buffers::   Modifying text is not allowed in a read-only buffer.
* Buffer List::         How to look at all the existing buffers.
* Creating Buffers::    Functions that create buffers.
* Killing Buffers::     Buffers exist until explicitly killed.
* Indirect Buffers::    An indirect buffer shares text with some other buffer.
* Swapping Text::       Swapping text between two buffers.
* Buffer Gap::          The gap in the buffer.


File: elisp.info,  Node: Buffer Basics,  Next: Current Buffer,  Up: Buffers

27.1 Buffer Basics
==================

A “buffer” is a Lisp object containing text to be edited.  Buffers are
used to hold the contents of files that are being visited; there may
also be buffers that are not visiting files.  Although several buffers
normally exist, only one buffer is designated the “current buffer” at
any time.  Most editing commands act on the contents of the current
buffer.  Each buffer, including the current buffer, may or may not be
displayed in any windows.

   Buffers in Emacs editing are objects that have distinct names and
hold text that can be edited.  Buffers appear to Lisp programs as a
special data type.  You can think of the contents of a buffer as a
string that you can extend; insertions and deletions may occur in any
part of the buffer.  *Note Text::.

   A Lisp buffer object contains numerous pieces of information.  Some
of this information is directly accessible to the programmer through
variables, while other information is accessible only through
special-purpose functions.  For example, the visited file name is
directly accessible through a variable, while the value of point is
accessible only through a primitive function.

   Buffer-specific information that is directly accessible is stored in
“buffer-local” variable bindings, which are variable values that are
effective only in a particular buffer.  This feature allows each buffer
to override the values of certain variables.  Most major modes override
variables such as ‘fill-column’ or ‘comment-column’ in this way.  For
more information about buffer-local variables and functions related to
them, see *note Buffer-Local Variables::.

   For functions and variables related to visiting files in buffers, see
*note Visiting Files:: and *note Saving Buffers::.  For functions and
variables related to the display of buffers in windows, see *note
Buffers and Windows::.

 -- Function: bufferp object
     This function returns ‘t’ if OBJECT is a buffer, ‘nil’ otherwise.


File: elisp.info,  Node: Current Buffer,  Next: Buffer Names,  Prev: Buffer Basics,  Up: Buffers

27.2 The Current Buffer
=======================

There are, in general, many buffers in an Emacs session.  At any time,
one of them is designated the “current buffer”—the buffer in which most
editing takes place.  Most of the primitives for examining or changing
text operate implicitly on the current buffer (*note Text::).

   Normally, the buffer displayed in the selected window is the current
buffer, but this is not always so: a Lisp program can temporarily
designate any buffer as current in order to operate on its contents,
without changing what is displayed on the screen.  The most basic
function for designating a current buffer is ‘set-buffer’.

 -- Function: current-buffer
     This function returns the current buffer.

          (current-buffer)
               ⇒ #<buffer buffers.texi>

 -- Function: set-buffer buffer-or-name
     This function makes BUFFER-OR-NAME the current buffer.
     BUFFER-OR-NAME must be an existing buffer or the name of an
     existing buffer.  The return value is the buffer made current.

     This function does not display the buffer in any window, so the
     user cannot necessarily see the buffer.  But Lisp programs will now
     operate on it.

   When an editing command returns to the editor command loop, Emacs
automatically calls ‘set-buffer’ on the buffer shown in the selected
window.  This is to prevent confusion: it ensures that the buffer that
the cursor is in, when Emacs reads a command, is the buffer to which
that command applies (*note Command Loop::).  Thus, you should not use
‘set-buffer’ to switch visibly to a different buffer; for that, use the
functions described in *note Switching Buffers::.

   When writing a Lisp function, do _not_ rely on this behavior of the
command loop to restore the current buffer after an operation.  Editing
commands can also be called as Lisp functions by other programs, not
just from the command loop; it is convenient for the caller if the
subroutine does not change which buffer is current (unless, of course,
that is the subroutine’s purpose).

   To operate temporarily on another buffer, put the ‘set-buffer’ within
a ‘save-current-buffer’ form.  Here, as an example, is a simplified
version of the command ‘append-to-buffer’:

     (defun append-to-buffer (buffer start end)
       "Append the text of the region to BUFFER."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-current-buffer
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

Here, we bind a local variable to record the current buffer, and then
‘save-current-buffer’ arranges to make it current again later.  Next,
‘set-buffer’ makes the specified buffer current, and
‘insert-buffer-substring’ copies the string from the original buffer to
the specified (and now current) buffer.

   Alternatively, we can use the ‘with-current-buffer’ macro:

     (defun append-to-buffer (buffer start end)
       "Append the text of the region to BUFFER."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (with-current-buffer (get-buffer-create buffer)
           (insert-buffer-substring oldbuf start end))))

   In either case, if the buffer appended to happens to be displayed in
some window, the next redisplay will show how its text has changed.  If
it is not displayed in any window, you will not see the change
immediately on the screen.  The command causes the buffer to become
current temporarily, but does not cause it to be displayed.

   If you make local bindings (with ‘let’ or function arguments) for a
variable that may also have buffer-local bindings, make sure that the
same buffer is current at the beginning and at the end of the local
binding’s scope.  Otherwise you might bind it in one buffer and unbind
it in another!

   Do not rely on using ‘set-buffer’ to change the current buffer back,
because that won’t do the job if a quit happens while the wrong buffer
is current.  For instance, in the previous example, it would have been
wrong to do this:

       (let ((oldbuf (current-buffer)))
         (set-buffer (get-buffer-create buffer))
         (insert-buffer-substring oldbuf start end)
         (set-buffer oldbuf))

Using ‘save-current-buffer’ or ‘with-current-buffer’, as we did,
correctly handles quitting, errors, and ‘throw’, as well as ordinary
evaluation.

 -- Special Form: save-current-buffer body...
     The ‘save-current-buffer’ special form saves the identity of the
     current buffer, evaluates the BODY forms, and finally restores that
     buffer as current.  The return value is the value of the last form
     in BODY.  The current buffer is restored even in case of an
     abnormal exit via ‘throw’ or error (*note Nonlocal Exits::).

     If the buffer that used to be current has been killed by the time
     of exit from ‘save-current-buffer’, then it is not made current
     again, of course.  Instead, whichever buffer was current just
     before exit remains current.

 -- Macro: with-current-buffer buffer-or-name body...
     The ‘with-current-buffer’ macro saves the identity of the current
     buffer, makes BUFFER-OR-NAME current, evaluates the BODY forms, and
     finally restores the current buffer.  BUFFER-OR-NAME must specify
     an existing buffer or the name of an existing buffer.

     The return value is the value of the last form in BODY.  The
     current buffer is restored even in case of an abnormal exit via
     ‘throw’ or error (*note Nonlocal Exits::).

 -- Macro: with-temp-buffer body...
     The ‘with-temp-buffer’ macro evaluates the BODY forms with a
     temporary buffer as the current buffer.  It saves the identity of
     the current buffer, creates a temporary buffer and makes it
     current, evaluates the BODY forms, and finally restores the
     previous current buffer while killing the temporary buffer.  By
     default, undo information (*note Undo::) is not recorded in the
     buffer created by this macro (but BODY can enable that, if needed).

     The return value is the value of the last form in BODY.  You can
     return the contents of the temporary buffer by using
     ‘(buffer-string)’ as the last form.

     The current buffer is restored even in case of an abnormal exit via
     ‘throw’ or error (*note Nonlocal Exits::).

     See also ‘with-temp-file’ in *note Writing to Files: Definition of
     with-temp-file.


File: elisp.info,  Node: Buffer Names,  Next: Buffer File Name,  Prev: Current Buffer,  Up: Buffers

27.3 Buffer Names
=================

Each buffer has a unique name, which is a string.  Many of the functions
that work on buffers accept either a buffer or a buffer name as an
argument.  Any argument called BUFFER-OR-NAME is of this sort, and an
error is signaled if it is neither a string nor a buffer.  Any argument
called BUFFER must be an actual buffer object, not a name.

   Buffers that are ephemeral and generally uninteresting to the user
have names starting with a space, so that the ‘list-buffers’ and
‘buffer-menu’ commands don’t mention them (but if such a buffer visits a
file, it *is* mentioned).  A name starting with space also initially
disables recording undo information; see *note Undo::.

 -- Function: buffer-name &optional buffer
     This function returns the name of BUFFER as a string.  BUFFER
     defaults to the current buffer.

     If ‘buffer-name’ returns ‘nil’, it means that BUFFER has been
     killed.  *Note Killing Buffers::.

          (buffer-name)
               ⇒ "buffers.texi"

          (setq foo (get-buffer "temp"))
               ⇒ #<buffer temp>
          (kill-buffer foo)
               ⇒ nil
          (buffer-name foo)
               ⇒ nil
          foo
               ⇒ #<killed buffer>

 -- Command: rename-buffer newname &optional unique
     This function renames the current buffer to NEWNAME.  An error is
     signaled if NEWNAME is not a string.

     Ordinarily, ‘rename-buffer’ signals an error if NEWNAME is already
     in use.  However, if UNIQUE is non-‘nil’, it modifies NEWNAME to
     make a name that is not in use.  Interactively, you can make UNIQUE
     non-‘nil’ with a numeric prefix argument.  (This is how the command
     ‘rename-uniquely’ is implemented.)

     This function returns the name actually given to the buffer.

 -- Function: get-buffer buffer-or-name
     This function returns the buffer specified by BUFFER-OR-NAME.  If
     BUFFER-OR-NAME is a string and there is no buffer with that name,
     the value is ‘nil’.  If BUFFER-OR-NAME is a buffer, it is returned
     as given; that is not very useful, so the argument is usually a
     name.  For example:

          (setq b (get-buffer "lewis"))
               ⇒ #<buffer lewis>
          (get-buffer b)
               ⇒ #<buffer lewis>
          (get-buffer "Frazzle-nots")
               ⇒ nil

     See also the function ‘get-buffer-create’ in *note Creating
     Buffers::.

 -- Function: generate-new-buffer-name starting-name &optional ignore
     This function returns a name that would be unique for a new
     buffer—but does not create the buffer.  It starts with
     STARTING-NAME, and produces a name not currently in use for any
     buffer by appending a number inside of ‘<...>’.  It starts at 2 and
     keeps incrementing the number until it is not the name of an
     existing buffer.

     If the optional second argument IGNORE is non-‘nil’, it should be a
     string, a potential buffer name.  It means to consider that
     potential buffer acceptable, if it is tried, even it is the name of
     an existing buffer (which would normally be rejected).  Thus, if
     buffers named ‘foo’, ‘foo<2>’, ‘foo<3>’ and ‘foo<4>’ exist,

          (generate-new-buffer-name "foo")
               ⇒ "foo<5>"
          (generate-new-buffer-name "foo" "foo<3>")
               ⇒ "foo<3>"
          (generate-new-buffer-name "foo" "foo<6>")
               ⇒ "foo<5>"

     See the related function ‘generate-new-buffer’ in *note Creating
     Buffers::.


File: elisp.info,  Node: Buffer File Name,  Next: Buffer Modification,  Prev: Buffer Names,  Up: Buffers

27.4 Buffer File Name
=====================

The “buffer file name” is the name of the file that is visited in that
buffer.  When a buffer is not visiting a file, its buffer file name is
‘nil’.  Most of the time, the buffer name is the same as the
nondirectory part of the buffer file name, but the buffer file name and
the buffer name are distinct and can be set independently.  *Note
Visiting Files::.

 -- Function: buffer-file-name &optional buffer
     This function returns the absolute file name of the file that
     BUFFER is visiting.  If BUFFER is not visiting any file,
     ‘buffer-file-name’ returns ‘nil’.  If BUFFER is not supplied, it
     defaults to the current buffer.

          (buffer-file-name (other-buffer))
               ⇒ "/usr/user/lewis/manual/files.texi"

 -- Variable: buffer-file-name
     This buffer-local variable contains the name of the file being
     visited in the current buffer, or ‘nil’ if it is not visiting a
     file.  It is a permanent local variable, unaffected by
     ‘kill-all-local-variables’.

          buffer-file-name
               ⇒ "/usr/user/lewis/manual/buffers.texi"

     It is risky to change this variable’s value without doing various
     other things.  Normally it is better to use ‘set-visited-file-name’
     (see below); some of the things done there, such as changing the
     buffer name, are not strictly necessary, but others are essential
     to avoid confusing Emacs.

 -- Variable: buffer-file-truename
     This buffer-local variable holds the abbreviated truename of the
     file visited in the current buffer, or ‘nil’ if no file is visited.
     It is a permanent local, unaffected by ‘kill-all-local-variables’.
     *Note Truenames::, and *note abbreviate-file-name::.

 -- Variable: buffer-file-number
     This buffer-local variable holds the file number and directory
     device number of the file visited in the current buffer, or ‘nil’
     if no file or a nonexistent file is visited.  It is a permanent
     local, unaffected by ‘kill-all-local-variables’.

     The value is normally a list of the form ‘(FILENUM DEVNUM)’.  This
     pair of numbers uniquely identifies the file among all files
     accessible on the system.  See the function ‘file-attributes’, in
     *note File Attributes::, for more information about them.

     If ‘buffer-file-name’ is the name of a symbolic link, then both
     numbers refer to the recursive target.

 -- Function: get-file-buffer filename
     This function returns the buffer visiting file FILENAME.  If there
     is no such buffer, it returns ‘nil’.  The argument FILENAME, which
     must be a string, is expanded (*note File Name Expansion::), then
     compared against the visited file names of all live buffers.  Note
     that the buffer’s ‘buffer-file-name’ must match the expansion of
     FILENAME exactly.  This function will not recognize other names for
     the same file.

          (get-file-buffer "buffers.texi")
              ⇒ #<buffer buffers.texi>

     In unusual circumstances, there can be more than one buffer
     visiting the same file name.  In such cases, this function returns
     the first such buffer in the buffer list.

 -- Function: find-buffer-visiting filename &optional predicate
     This is like ‘get-file-buffer’, except that it can return any
     buffer visiting the file _possibly under a different name_.  That
     is, the buffer’s ‘buffer-file-name’ does not need to match the
     expansion of FILENAME exactly, it only needs to refer to the same
     file.  If PREDICATE is non-‘nil’, it should be a function of one
     argument, a buffer visiting FILENAME.  The buffer is only
     considered a suitable return value if PREDICATE returns non-‘nil’.
     If it can not find a suitable buffer to return,
     ‘find-buffer-visiting’ returns ‘nil’.

 -- Command: set-visited-file-name filename &optional no-query
          along-with-file
     If FILENAME is a non-empty string, this function changes the name
     of the file visited in the current buffer to FILENAME.  (If the
     buffer had no visited file, this gives it one.)  The _next time_
     the buffer is saved it will go in the newly-specified file.

     This command marks the buffer as modified, since it does not (as
     far as Emacs knows) match the contents of FILENAME, even if it
     matched the former visited file.  It also renames the buffer to
     correspond to the new file name, unless the new name is already in
     use.

     If FILENAME is ‘nil’ or the empty string, that stands for “no
     visited file”.  In this case, ‘set-visited-file-name’ marks the
     buffer as having no visited file, without changing the buffer’s
     modified flag.

     Normally, this function asks the user for confirmation if there
     already is a buffer visiting FILENAME.  If NO-QUERY is non-‘nil’,
     that prevents asking this question.  If there already is a buffer
     visiting FILENAME, and the user confirms or NO-QUERY is non-‘nil’,
     this function makes the new buffer name unique by appending a
     number inside of ‘<...>’ to FILENAME.

     If ALONG-WITH-FILE is non-‘nil’, that means to assume that the
     former visited file has been renamed to FILENAME.  In this case,
     the command does not change the buffer’s modified flag, nor the
     buffer’s recorded last file modification time as reported by
     ‘visited-file-modtime’ (*note Modification Time::).  If
     ALONG-WITH-FILE is ‘nil’, this function clears the recorded last
     file modification time, after which ‘visited-file-modtime’ returns
     zero.

     When the function ‘set-visited-file-name’ is called interactively,
     it prompts for FILENAME in the minibuffer.

 -- Variable: list-buffers-directory
     This buffer-local variable specifies a string to display in a
     buffer listing where the visited file name would go, for buffers
     that don’t have a visited file name.  Dired buffers use this
     variable.


File: elisp.info,  Node: Buffer Modification,  Next: Modification Time,  Prev: Buffer File Name,  Up: Buffers

27.5 Buffer Modification
========================

Emacs keeps a flag called the “modified flag” for each buffer, to record
whether you have changed the text of the buffer.  This flag is set to
‘t’ whenever you alter the contents of the buffer, and cleared to ‘nil’
when you save it.  Thus, the flag shows whether there are unsaved
changes.  The flag value is normally shown in the mode line (*note Mode
Line Variables::), and controls saving (*note Saving Buffers::) and
auto-saving (*note Auto-Saving::).

   Some Lisp programs set the flag explicitly.  For example, the
function ‘set-visited-file-name’ sets the flag to ‘t’, because the text
does not match the newly-visited file, even if it is unchanged from the
file formerly visited.

   The functions that modify the contents of buffers are described in
*note Text::.

 -- Function: buffer-modified-p &optional buffer
     This function returns ‘t’ if the buffer BUFFER has been modified
     since it was last read in from a file or saved, or ‘nil’ otherwise.
     If BUFFER is not supplied, the current buffer is tested.

 -- Function: set-buffer-modified-p flag
     This function marks the current buffer as modified if FLAG is
     non-‘nil’, or as unmodified if the flag is ‘nil’.

     Another effect of calling this function is to cause unconditional
     redisplay of the mode line for the current buffer.  In fact, the
     function ‘force-mode-line-update’ works by doing this:

          (set-buffer-modified-p (buffer-modified-p))

 -- Function: restore-buffer-modified-p flag
     Like ‘set-buffer-modified-p’, but does not force redisplay of mode
     lines.

 -- Command: not-modified &optional arg
     This command marks the current buffer as unmodified, and not
     needing to be saved.  If ARG is non-‘nil’, it marks the buffer as
     modified, so that it will be saved at the next suitable occasion.
     Interactively, ARG is the prefix argument.

     Don’t use this function in programs, since it prints a message in
     the echo area; use ‘set-buffer-modified-p’ (above) instead.

 -- Function: buffer-modified-tick &optional buffer
     This function returns BUFFER’s modification-count.  This is a
     counter that increments every time the buffer is modified.  If
     BUFFER is ‘nil’ (or omitted), the current buffer is used.  The
     counter can wrap around occasionally.

 -- Function: buffer-chars-modified-tick &optional buffer
     This function returns BUFFER’s character-change modification-count.
     Changes to text properties leave this counter unchanged; however,
     each time text is inserted or removed from the buffer, the counter
     is reset to the value that would be returned by
     ‘buffer-modified-tick’.  By comparing the values returned by two
     ‘buffer-chars-modified-tick’ calls, you can tell whether a
     character change occurred in that buffer in between the calls.  If
     BUFFER is ‘nil’ (or omitted), the current buffer is used.


File: elisp.info,  Node: Modification Time,  Next: Read Only Buffers,  Prev: Buffer Modification,  Up: Buffers

27.6 Buffer Modification Time
=============================

Suppose that you visit a file and make changes in its buffer, and
meanwhile the file itself is changed on disk.  At this point, saving the
buffer would overwrite the changes in the file.  Occasionally this may
be what you want, but usually it would lose valuable information.  Emacs
therefore checks the file’s modification time using the functions
described below before saving the file.  (*Note File Attributes::, for
how to examine a file’s modification time.)

 -- Function: verify-visited-file-modtime &optional buffer
     This function compares what BUFFER (by default, the current-buffer)
     has recorded for the modification time of its visited file against
     the actual modification time of the file as recorded by the
     operating system.  The two should be the same unless some other
     process has written the file since Emacs visited or saved it.

     The function returns ‘t’ if the last actual modification time and
     Emacs’s recorded modification time are the same, ‘nil’ otherwise.
     It also returns ‘t’ if the buffer has no recorded last modification
     time, that is if ‘visited-file-modtime’ would return zero.

     It always returns ‘t’ for buffers that are not visiting a file,
     even if ‘visited-file-modtime’ returns a non-zero value.  For
     instance, it always returns ‘t’ for dired buffers.  It returns ‘t’
     for buffers that are visiting a file that does not exist and never
     existed, but ‘nil’ for file-visiting buffers whose file has been
     deleted.

 -- Function: clear-visited-file-modtime
     This function clears out the record of the last modification time
     of the file being visited by the current buffer.  As a result, the
     next attempt to save this buffer will not complain of a discrepancy
     in file modification times.

     This function is called in ‘set-visited-file-name’ and other
     exceptional places where the usual test to avoid overwriting a
     changed file should not be done.

 -- Function: visited-file-modtime
     This function returns the current buffer’s recorded last file
     modification time, as a list of the form ‘(HIGH LOW MICROSEC
     PICOSEC)’.  (This is the same format that ‘file-attributes’ uses to
     return time values; *note File Attributes::.)

     If the buffer has no recorded last modification time, this function
     returns zero.  This case occurs, for instance, if the buffer is not
     visiting a file or if the time has been explicitly cleared by
     ‘clear-visited-file-modtime’.  Note, however, that
     ‘visited-file-modtime’ returns a list for some non-file buffers
     too.  For instance, in a Dired buffer listing a directory, it
     returns the last modification time of that directory, as recorded
     by Dired.

     If the buffer is not visiting a file, this function returns −1.

 -- Function: set-visited-file-modtime &optional time
     This function updates the buffer’s record of the last modification
     time of the visited file, to the value specified by TIME if TIME is
     not ‘nil’, and otherwise to the last modification time of the
     visited file.

     If TIME is neither ‘nil’ nor an integer flag returned by
     ‘visited-file-modtime’, it should have the form ‘(HIGH LOW MICROSEC
     PICOSEC)’, the format used by ‘current-time’ (*note Time of Day::).

     This function is useful if the buffer was not read from the file
     normally, or if the file itself has been changed for some known
     benign reason.

 -- Function: ask-user-about-supersession-threat filename
     This function is used to ask a user how to proceed after an attempt
     to modify a buffer visiting file FILENAME when the file is newer
     than the buffer text.  Emacs detects this because the modification
     time of the file on disk is newer than the last save-time and its
     contents have changed.  This means some other program has probably
     altered the file.

     Depending on the user’s answer, the function may return normally,
     in which case the modification of the buffer proceeds, or it may
     signal a ‘file-supersession’ error with data ‘(FILENAME)’, in which
     case the proposed buffer modification is not allowed.

     This function is called automatically by Emacs on the proper
     occasions.  It exists so you can customize Emacs by redefining it.
     See the file ‘userlock.el’ for the standard definition.

     See also the file locking mechanism in *note File Locks::.


File: elisp.info,  Node: Read Only Buffers,  Next: Buffer List,  Prev: Modification Time,  Up: Buffers

27.7 Read-Only Buffers
======================

If a buffer is “read-only”, then you cannot change its contents,
although you may change your view of the contents by scrolling and
narrowing.

   Read-only buffers are used in two kinds of situations:

   • A buffer visiting a write-protected file is normally read-only.

     Here, the purpose is to inform the user that editing the buffer
     with the aim of saving it in the file may be futile or undesirable.
     The user who wants to change the buffer text despite this can do so
     after clearing the read-only flag with ‘C-x C-q’.

   • Modes such as Dired and Rmail make buffers read-only when altering
     the contents with the usual editing commands would probably be a
     mistake.

     The special commands of these modes bind ‘buffer-read-only’ to
     ‘nil’ (with ‘let’) or bind ‘inhibit-read-only’ to ‘t’ around the
     places where they themselves change the text.

 -- Variable: buffer-read-only
     This buffer-local variable specifies whether the buffer is
     read-only.  The buffer is read-only if this variable is non-‘nil’.
     However, characters that have the ‘inhibit-read-only’ text property
     can still be modified.  *Note inhibit-read-only: Special
     Properties.

 -- Variable: inhibit-read-only
     If this variable is non-‘nil’, then read-only buffers and,
     depending on the actual value, some or all read-only characters may
     be modified.  Read-only characters in a buffer are those that have
     a non-‘nil’ ‘read-only’ text property.  *Note Special Properties::,
     for more information about text properties.

     If ‘inhibit-read-only’ is ‘t’, all ‘read-only’ character properties
     have no effect.  If ‘inhibit-read-only’ is a list, then ‘read-only’
     character properties have no effect if they are members of the list
     (comparison is done with ‘eq’).

 -- Command: read-only-mode &optional arg
     This is the mode command for Read Only minor mode, a buffer-local
     minor mode.  When the mode is enabled, ‘buffer-read-only’ is
     non-‘nil’ in the buffer; when disabled, ‘buffer-read-only’ is ‘nil’
     in the buffer.  The calling convention is the same as for other
     minor mode commands (*note Minor Mode Conventions::).

     This minor mode mainly serves as a wrapper for ‘buffer-read-only’;
     unlike most minor modes, there is no separate ‘read-only-mode’
     variable.  Even when Read Only mode is disabled, characters with
     non-‘nil’ ‘read-only’ text properties remain read-only.  To
     temporarily ignore all read-only states, bind ‘inhibit-read-only’,
     as described above.

     When enabling Read Only mode, this mode command also enables View
     mode if the option ‘view-read-only’ is non-‘nil’.  *Note
     Miscellaneous Buffer Operations: (emacs)Misc Buffer.  When
     disabling Read Only mode, it disables View mode if View mode was
     enabled.

 -- Function: barf-if-buffer-read-only &optional position
     This function signals a ‘buffer-read-only’ error if the current
     buffer is read-only.  If the text at POSITION (which defaults to
     point) has the ‘inhibit-read-only’ text property set, the error
     will not be raised.

     *Note Using Interactive::, for another way to signal an error if
     the current buffer is read-only.


File: elisp.info,  Node: Buffer List,  Next: Creating Buffers,  Prev: Read Only Buffers,  Up: Buffers

27.8 The Buffer List
====================

The “buffer list” is a list of all live buffers.  The order of the
buffers in this list is based primarily on how recently each buffer has
been displayed in a window.  Several functions, notably ‘other-buffer’,
use this ordering.  A buffer list displayed for the user also follows
this order.

   Creating a buffer adds it to the end of the buffer list, and killing
a buffer removes it from that list.  A buffer moves to the front of this
list whenever it is chosen for display in a window (*note Switching
Buffers::) or a window displaying it is selected (*note Selecting
Windows::).  A buffer moves to the end of the list when it is buried
(see ‘bury-buffer’, below).  There are no functions available to the
Lisp programmer which directly manipulate the buffer list.

   In addition to the fundamental buffer list just described, Emacs
maintains a local buffer list for each frame, in which the buffers that
have been displayed (or had their windows selected) in that frame come
first.  (This order is recorded in the frame’s ‘buffer-list’ frame
parameter; see *note Buffer Parameters::.)  Buffers never displayed in
that frame come afterward, ordered according to the fundamental buffer
list.

 -- Function: buffer-list &optional frame
     This function returns the buffer list, including all buffers, even
     those whose names begin with a space.  The elements are actual
     buffers, not their names.

     If FRAME is a frame, this returns FRAME’s local buffer list.  If
     FRAME is ‘nil’ or omitted, the fundamental buffer list is used: the
     buffers appear in order of most recent display or selection,
     regardless of which frames they were displayed on.

          (buffer-list)
               ⇒ (#<buffer buffers.texi>
                   #<buffer  *Minibuf-1*> #<buffer buffer.c>
                   #<buffer *Help*> #<buffer TAGS>)

          ;; Note that the name of the minibuffer
          ;;   begins with a space!
          (mapcar (function buffer-name) (buffer-list))
              ⇒ ("buffers.texi" " *Minibuf-1*"
                  "buffer.c" "*Help*" "TAGS")

   The list returned by ‘buffer-list’ is constructed specifically; it is
not an internal Emacs data structure, and modifying it has no effect on
the order of buffers.  If you want to change the order of buffers in the
fundamental buffer list, here is an easy way:

     (defun reorder-buffer-list (new-list)
       (while new-list
         (bury-buffer (car new-list))
         (setq new-list (cdr new-list))))

   With this method, you can specify any order for the list, but there
is no danger of losing a buffer or adding something that is not a valid
live buffer.

   To change the order or value of a specific frame’s buffer list, set
that frame’s ‘buffer-list’ parameter with ‘modify-frame-parameters’
(*note Parameter Access::).

 -- Function: other-buffer &optional buffer visible-ok frame
     This function returns the first buffer in the buffer list other
     than BUFFER.  Usually, this is the buffer appearing in the most
     recently selected window (in frame FRAME or else the selected
     frame, *note Input Focus::), aside from BUFFER.  Buffers whose
     names start with a space are not considered at all.

     If BUFFER is not supplied (or if it is not a live buffer), then
     ‘other-buffer’ returns the first buffer in the selected frame’s
     local buffer list.  (If FRAME is non-‘nil’, it returns the first
     buffer in FRAME’s local buffer list instead.)

     If FRAME has a non-‘nil’ ‘buffer-predicate’ parameter, then
     ‘other-buffer’ uses that predicate to decide which buffers to
     consider.  It calls the predicate once for each buffer, and if the
     value is ‘nil’, that buffer is ignored.  *Note Buffer Parameters::.

     If VISIBLE-OK is ‘nil’, ‘other-buffer’ avoids returning a buffer
     visible in any window on any visible frame, except as a last
     resort.  If VISIBLE-OK is non-‘nil’, then it does not matter
     whether a buffer is displayed somewhere or not.

     If no suitable buffer exists, the buffer ‘*scratch*’ is returned
     (and created, if necessary).

 -- Function: last-buffer &optional buffer visible-ok frame
     This function returns the last buffer in FRAME’s buffer list other
     than BUFFER.  If FRAME is omitted or ‘nil’, it uses the selected
     frame’s buffer list.

     The argument VISIBLE-OK is handled as with ‘other-buffer’, see
     above.  If no suitable buffer can be found, the buffer ‘*scratch*’
     is returned.

 -- Command: bury-buffer &optional buffer-or-name
     This command puts BUFFER-OR-NAME at the end of the buffer list,
     without changing the order of any of the other buffers on the list.
     This buffer therefore becomes the least desirable candidate for
     ‘other-buffer’ to return.  The argument can be either a buffer
     itself or the name of one.

     This function operates on each frame’s ‘buffer-list’ parameter as
     well as the fundamental buffer list; therefore, the buffer that you
     bury will come last in the value of ‘(buffer-list FRAME)’ and in
     the value of ‘(buffer-list)’.  In addition, it also puts the buffer
     at the end of the list of buffers of the selected window (*note
     Window History::) provided it is shown in that window.

     If BUFFER-OR-NAME is ‘nil’ or omitted, this means to bury the
     current buffer.  In addition, if the current buffer is displayed in
     the selected window, this makes sure that the window is either
     deleted or another buffer is shown in it.  More precisely, if the
     selected window is dedicated (*note Dedicated Windows::) and there
     are other windows on its frame, the window is deleted.  If it is
     the only window on its frame and that frame is not the only frame
     on its terminal, the frame is dismissed by calling the function
     specified by ‘frame-auto-hide-function’ (*note Quitting Windows::).
     Otherwise, it calls ‘switch-to-prev-buffer’ (*note Window
     History::) to show another buffer in that window.  If
     BUFFER-OR-NAME is displayed in some other window, it remains
     displayed there.

     To replace a buffer in all the windows that display it, use
     ‘replace-buffer-in-windows’, *Note Buffers and Windows::.

 -- Command: unbury-buffer
     This command switches to the last buffer in the local buffer list
     of the selected frame.  More precisely, it calls the function
     ‘switch-to-buffer’ (*note Switching Buffers::), to display the
     buffer returned by ‘last-buffer’ (see above), in the selected
     window.

 -- Variable: buffer-list-update-hook
     This is a normal hook run whenever the buffer list changes.
     Functions (implicitly) running this hook are ‘get-buffer-create’
     (*note Creating Buffers::), ‘rename-buffer’ (*note Buffer Names::),
     ‘kill-buffer’ (*note Killing Buffers::), ‘bury-buffer’ (see above)
     and ‘select-window’ (*note Selecting Windows::).


File: elisp.info,  Node: Creating Buffers,  Next: Killing Buffers,  Prev: Buffer List,  Up: Buffers

27.9 Creating Buffers
=====================

This section describes the two primitives for creating buffers.
‘get-buffer-create’ creates a buffer if it finds no existing buffer with
the specified name; ‘generate-new-buffer’ always creates a new buffer
and gives it a unique name.

   Other functions you can use to create buffers include
‘with-output-to-temp-buffer’ (*note Temporary Displays::) and
‘create-file-buffer’ (*note Visiting Files::).  Starting a subprocess
can also create a buffer (*note Processes::).

 -- Function: get-buffer-create buffer-or-name
     This function returns a buffer named BUFFER-OR-NAME.  The buffer
     returned does not become the current buffer—this function does not
     change which buffer is current.

     BUFFER-OR-NAME must be either a string or an existing buffer.  If
     it is a string and a live buffer with that name already exists,
     ‘get-buffer-create’ returns that buffer.  If no such buffer exists,
     it creates a new buffer.  If BUFFER-OR-NAME is a buffer instead of
     a string, it is returned as given, even if it is dead.

          (get-buffer-create "foo")
               ⇒ #<buffer foo>

     The major mode for a newly created buffer is set to Fundamental
     mode.  (The default value of the variable ‘major-mode’ is handled
     at a higher level; see *note Auto Major Mode::.)  If the name
     begins with a space, the buffer initially disables undo information
     recording (*note Undo::).

 -- Function: generate-new-buffer name
     This function returns a newly created, empty buffer, but does not
     make it current.  The name of the buffer is generated by passing
     NAME to the function ‘generate-new-buffer-name’ (*note Buffer
     Names::).  Thus, if there is no buffer named NAME, then that is the
     name of the new buffer; if that name is in use, a suffix of the
     form ‘<N>’, where N is an integer, is appended to NAME.

     An error is signaled if NAME is not a string.

          (generate-new-buffer "bar")
               ⇒ #<buffer bar>
          (generate-new-buffer "bar")
               ⇒ #<buffer bar<2>>
          (generate-new-buffer "bar")
               ⇒ #<buffer bar<3>>

     The major mode for the new buffer is set to Fundamental mode.  The
     default value of the variable ‘major-mode’ is handled at a higher
     level.  *Note Auto Major Mode::.


File: elisp.info,  Node: Killing Buffers,  Next: Indirect Buffers,  Prev: Creating Buffers,  Up: Buffers

27.10 Killing Buffers
=====================

“Killing a buffer” makes its name unknown to Emacs and makes the memory
space it occupied available for other use.

   The buffer object for the buffer that has been killed remains in
existence as long as anything refers to it, but it is specially marked
so that you cannot make it current or display it.  Killed buffers retain
their identity, however; if you kill two distinct buffers, they remain
distinct according to ‘eq’ although both are dead.

   If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This means
that killing a buffer can change the current buffer.  Therefore, when
you kill a buffer, you should also take the precautions associated with
changing the current buffer (unless you happen to know that the buffer
being killed isn’t current).  *Note Current Buffer::.

   If you kill a buffer that is the base buffer of one or more indirect
buffers (*note Indirect Buffers::), the indirect buffers are
automatically killed as well.

   The ‘buffer-name’ of a buffer is ‘nil’ if, and only if, the buffer is
killed.  A buffer that has not been killed is called a “live” buffer.
To test whether a buffer is live or killed, use the function
‘buffer-live-p’ (see below).

 -- Command: kill-buffer &optional buffer-or-name
     This function kills the buffer BUFFER-OR-NAME, freeing all its
     memory for other uses or to be returned to the operating system.
     If BUFFER-OR-NAME is ‘nil’ or omitted, it kills the current buffer.

     Any processes that have this buffer as the ‘process-buffer’ are
     sent the ‘SIGHUP’ (hangup) signal, which normally causes them to
     terminate.  *Note Signals to Processes::.

     If the buffer is visiting a file and contains unsaved changes,
     ‘kill-buffer’ asks the user to confirm before the buffer is killed.
     It does this even if not called interactively.  To prevent the
     request for confirmation, clear the modified flag before calling
     ‘kill-buffer’.  *Note Buffer Modification::.

     This function calls ‘replace-buffer-in-windows’ for cleaning up all
     windows currently displaying the buffer to be killed.

     Killing a buffer that is already dead has no effect.

     This function returns ‘t’ if it actually killed the buffer.  It
     returns ‘nil’ if the user refuses to confirm or if BUFFER-OR-NAME
     was already dead.

          (kill-buffer "foo.unchanged")
               ⇒ t
          (kill-buffer "foo.changed")

          ---------- Buffer: Minibuffer ----------
          Buffer foo.changed modified; kill anyway? (yes or no) yes
          ---------- Buffer: Minibuffer ----------

               ⇒ t

 -- Variable: kill-buffer-query-functions
     Before confirming unsaved changes, ‘kill-buffer’ calls the
     functions in the list ‘kill-buffer-query-functions’, in order of
     appearance, with no arguments.  The buffer being killed is the
     current buffer when they are called.  The idea of this feature is
     that these functions will ask for confirmation from the user.  If
     any of them returns ‘nil’, ‘kill-buffer’ spares the buffer’s life.

 -- Variable: kill-buffer-hook
     This is a normal hook run by ‘kill-buffer’ after asking all the
     questions it is going to ask, just before actually killing the
     buffer.  The buffer to be killed is current when the hook functions
     run.  *Note Hooks::.  This variable is a permanent local, so its
     local binding is not cleared by changing major modes.

 -- User Option: buffer-offer-save
     This variable, if non-‘nil’ in a particular buffer, tells
     ‘save-buffers-kill-emacs’ to offer to save that buffer, just as it
     offers to save file-visiting buffers.  If ‘save-some-buffers’ is
     called with the second optional argument set to ‘t’, it will also
     offer to save the buffer.  Lastly, if this variable is set to the
     symbol ‘always’, both ‘save-buffers-kill-emacs’ and
     ‘save-some-buffers’ will always offer to save.  *Note Definition of
     save-some-buffers::.  The variable ‘buffer-offer-save’
     automatically becomes buffer-local when set for any reason.  *Note
     Buffer-Local Variables::.

 -- Variable: buffer-save-without-query
     This variable, if non-‘nil’ in a particular buffer, tells
     ‘save-buffers-kill-emacs’ and ‘save-some-buffers’ to save this
     buffer (if it’s modified) without asking the user.  The variable
     automatically becomes buffer-local when set for any reason.

 -- Function: buffer-live-p object
     This function returns ‘t’ if OBJECT is a live buffer (a buffer
     which has not been killed), ‘nil’ otherwise.


File: elisp.info,  Node: Indirect Buffers,  Next: Swapping Text,  Prev: Killing Buffers,  Up: Buffers

27.11 Indirect Buffers
======================

An “indirect buffer” shares the text of some other buffer, which is
called the “base buffer” of the indirect buffer.  In some ways it is the
analogue, for buffers, of a symbolic link among files.  The base buffer
may not itself be an indirect buffer.

   The text of the indirect buffer is always identical to the text of
its base buffer; changes made by editing either one are visible
immediately in the other.  This includes the text properties as well as
the characters themselves.

   In all other respects, the indirect buffer and its base buffer are
completely separate.  They have different names, independent values of
point, independent narrowing, independent markers and overlays (though
inserting or deleting text in either buffer relocates the markers and
overlays for both), independent major modes, and independent
buffer-local variable bindings.

   An indirect buffer cannot visit a file, but its base buffer can.  If
you try to save the indirect buffer, that actually saves the base
buffer.

   Killing an indirect buffer has no effect on its base buffer.  Killing
the base buffer effectively kills the indirect buffer in that it cannot
ever again be the current buffer.

 -- Command: make-indirect-buffer base-buffer name &optional clone
     This creates and returns an indirect buffer named NAME whose base
     buffer is BASE-BUFFER.  The argument BASE-BUFFER may be a live
     buffer or the name (a string) of an existing buffer.  If NAME is
     the name of an existing buffer, an error is signaled.

     If CLONE is non-‘nil’, then the indirect buffer originally shares
     the state of BASE-BUFFER such as major mode, minor modes, buffer
     local variables and so on.  If CLONE is omitted or ‘nil’ the
     indirect buffer’s state is set to the default state for new
     buffers.

     If BASE-BUFFER is an indirect buffer, its base buffer is used as
     the base for the new buffer.  If, in addition, CLONE is non-‘nil’,
     the initial state is copied from the actual base buffer, not from
     BASE-BUFFER.

 -- Command: clone-indirect-buffer newname display-flag &optional
          norecord
     This function creates and returns a new indirect buffer that shares
     the current buffer’s base buffer and copies the rest of the current
     buffer’s attributes.  (If the current buffer is not indirect, it is
     used as the base buffer.)

     If DISPLAY-FLAG is non-‘nil’, that means to display the new buffer
     by calling ‘pop-to-buffer’.  If NORECORD is non-‘nil’, that means
     not to put the new buffer to the front of the buffer list.

 -- Function: buffer-base-buffer &optional buffer
     This function returns the base buffer of BUFFER, which defaults to
     the current buffer.  If BUFFER is not indirect, the value is ‘nil’.
     Otherwise, the value is another buffer, which is never an indirect
     buffer.


File: elisp.info,  Node: Swapping Text,  Next: Buffer Gap,  Prev: Indirect Buffers,  Up: Buffers

27.12 Swapping Text Between Two Buffers
=======================================

Specialized modes sometimes need to let the user access from the same
buffer several vastly different types of text.  For example, you may
need to display a summary of the buffer text, in addition to letting the
user access the text itself.

   This could be implemented with multiple buffers (kept in sync when
the user edits the text), or with narrowing (*note Narrowing::).  But
these alternatives might sometimes become tedious or prohibitively
expensive, especially if each type of text requires expensive
buffer-global operations in order to provide correct display and editing
commands.

   Emacs provides another facility for such modes: you can quickly swap
buffer text between two buffers with ‘buffer-swap-text’.  This function
is very fast because it doesn’t move any text, it only changes the
internal data structures of the buffer object to point to a different
chunk of text.  Using it, you can pretend that a group of two or more
buffers are actually a single virtual buffer that holds the contents of
all the individual buffers together.

 -- Function: buffer-swap-text buffer
     This function swaps the text of the current buffer and that of its
     argument BUFFER.  It signals an error if one of the two buffers is
     an indirect buffer (*note Indirect Buffers::) or is a base buffer
     of an indirect buffer.

     All the buffer properties that are related to the buffer text are
     swapped as well: the positions of point and mark, all the markers,
     the overlays, the text properties, the undo list, the value of the
     ‘enable-multibyte-characters’ flag (*note
     enable-multibyte-characters: Text Representations.), etc.

     *Warning:* If this function is called from within a
     ‘save-excursion’ form, the current buffer will be set to BUFFER
     upon leaving the form, since the marker used by ‘save-excursion’ to
     save the position and buffer will be swapped as well.

   If you use ‘buffer-swap-text’ on a file-visiting buffer, you should
set up a hook to save the buffer’s original text rather than what it was
swapped with.  ‘write-region-annotate-functions’ works for this purpose.
You should probably set ‘buffer-saved-size’ to −2 in the buffer, so that
changes in the text it is swapped with will not interfere with
auto-saving.


File: elisp.info,  Node: Buffer Gap,  Prev: Swapping Text,  Up: Buffers

27.13 The Buffer Gap
====================

Emacs buffers are implemented using an invisible “gap” to make insertion
and deletion faster.  Insertion works by filling in part of the gap, and
deletion adds to the gap.  Of course, this means that the gap must first
be moved to the locus of the insertion or deletion.  Emacs moves the gap
only when you try to insert or delete.  This is why your first editing
command in one part of a large buffer, after previously editing in
another far-away part, sometimes involves a noticeable delay.

   This mechanism works invisibly, and Lisp code should never be
affected by the gap’s current location, but these functions are
available for getting information about the gap status.

 -- Function: gap-position
     This function returns the current gap position in the current
     buffer.

 -- Function: gap-size
     This function returns the current gap size of the current buffer.


File: elisp.info,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

28 Windows
**********

This chapter describes the functions and variables related to Emacs
windows.  *Note Frames::, for how windows are assigned an area of screen
available for Emacs to use.  *Note Display::, for information on how
text is displayed in windows.

* Menu:

* Basic Windows::           Basic information on using windows.
* Windows and Frames::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window’s size.
* Resizing Windows::        Changing the sizes of windows.
* Preserving Window Sizes:: Preserving the size of windows.
* Splitting Windows::       Creating a new window.
* Deleting Windows::        Removing a window from its frame.
* Recombining Windows::     Preserving the frame layout when splitting and
                              deleting windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer.
* Choosing Window::         How to choose a window for displaying a buffer.
* Display Action Functions:: Subroutines for ‘display-buffer’.
* Choosing Window Options:: Extra options affecting how buffers are displayed.
* Window History::          Each window remembers the buffers displayed in it.
* Dedicated Windows::       How to avoid displaying another buffer in
                              a specific window.
* Quitting Windows::        How to restore the state prior to displaying a
                              buffer.
* Side Windows::            Special windows on a frame’s sides.
* Atomic Windows::          Preserving parts of the window layout.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Converting coordinates to windows.
* Mouse Window Auto-selection:: Automatically selecting windows with the mouse.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.


File: elisp.info,  Node: Basic Windows,  Next: Windows and Frames,  Up: Windows

28.1 Basic Concepts of Emacs Windows
====================================

A “window” is an area of the screen that is used to display a buffer
(*note Buffers::).  In Emacs Lisp, windows are represented by a special
Lisp object type.

   Windows are grouped into frames (*note Frames::).  Each frame
contains at least one window; the user can subdivide it into multiple,
non-overlapping windows to view several buffers at once.  Lisp programs
can use multiple windows for a variety of purposes.  In Rmail, for
example, you can view a summary of message titles in one window, and the
contents of the selected message in another window.

   Emacs uses the word “window” with a different meaning than in
graphical desktop environments and window systems, such as the X Window
System.  When Emacs is run on X, each of its graphical X windows is an
Emacs frame (containing one or more Emacs windows).  When Emacs is run
on a text terminal, the frame fills the entire terminal screen.

   Unlike X windows, Emacs windows are “tiled”; they never overlap
within the area of the frame.  When a window is created, resized, or
deleted, the change in window space is taken from or given to the
adjacent windows, so that the total area of the frame is unchanged.

 -- Function: windowp object
     This function returns ‘t’ if OBJECT is a window (whether or not it
     displays a buffer).  Otherwise, it returns ‘nil’.

   A “live window” is one that is actually displaying a buffer in a
frame.

 -- Function: window-live-p object
     This function returns ‘t’ if OBJECT is a live window and ‘nil’
     otherwise.  A live window is one that displays a buffer.

   The windows in each frame are organized into a “window tree”.  *Note
Windows and Frames::.  The leaf nodes of each window tree are live
windows—the ones actually displaying buffers.  The internal nodes of the
window tree are “internal windows”, which are not live.

   A “valid window” is one that is either live or internal.  A valid
window can be “deleted”, i.e., removed from its frame (*note Deleting
Windows::); then it is no longer valid, but the Lisp object representing
it might be still referenced from other Lisp objects.  A deleted window
may be made valid again by restoring a saved window configuration (*note
Window Configurations::).

   You can distinguish valid windows from deleted windows with
‘window-valid-p’.

 -- Function: window-valid-p object
     This function returns ‘t’ if OBJECT is a live window, or an
     internal window in a window tree.  Otherwise, it returns ‘nil’,
     including for the case where OBJECT is a deleted window.

   In each frame, at any time, exactly one Emacs window is designated as
“selected within the frame”.  For the selected frame, that window is
called the “selected window”—the one in which most editing takes place,
and in which the cursor for selected windows appears (*note Cursor
Parameters::).  Keyboard input that inserts or deletes text is also
normally directed to this window.  The selected window’s buffer is
usually also the current buffer, except when ‘set-buffer’ has been used
(*note Current Buffer::).  As for non-selected frames, the window
selected within the frame becomes the selected window if the frame is
ever selected.  *Note Selecting Windows::.

 -- Function: selected-window
     This function returns the selected window (which is always a live
     window).

   Sometimes several windows collectively and cooperatively display a
buffer, for example, under the management of Follow Mode (*note
(emacs)Follow Mode::), where the windows together display a bigger
portion of the buffer than one window could alone.  It is often useful
to consider such a “window group” as a single entity.  Several functions
such as ‘window-group-start’ (*note Window Start and End::) allow you to
do this by supplying, as an argument, one of the windows as a stand in
for the whole group.

 -- Function: selected-window-group
     When the selected window is a member of a group of windows, this
     function returns a list of the windows in the group, ordered such
     that the first window in the list is displaying the earliest part
     of the buffer, and so on.  Otherwise the function returns a list
     containing just the selected window.

     The selected window is considered part of a group when the buffer
     local variable ‘selected-window-group-function’ is set to a
     function.  In this case, ‘selected-window-group’ calls it with no
     arguments and returns its result (which should be the list of
     windows in the group).


File: elisp.info,  Node: Windows and Frames,  Next: Window Sizes,  Prev: Basic Windows,  Up: Windows

28.2 Windows and Frames
=======================

Each window belongs to exactly one frame (*note Frames::).

 -- Function: window-frame &optional window
     This function returns the frame that the window WINDOW belongs to.
     If WINDOW is ‘nil’, it defaults to the selected window.

 -- Function: window-list &optional frame minibuffer window
     This function returns a list of live windows belonging to the frame
     FRAME.  If FRAME is omitted or ‘nil’, it defaults to the selected
     frame.

     The optional argument MINIBUFFER specifies whether to include the
     minibuffer window in the returned list.  If MINIBUFFER is ‘t’, the
     minibuffer window is included.  If MINIBUFFER is ‘nil’ or omitted,
     the minibuffer window is included only if it is active.  If
     MINIBUFFER is neither ‘nil’ nor ‘t’, the minibuffer window is never
     included.

     The optional argument WINDOW, if non-‘nil’, should be a live window
     on the specified frame; then WINDOW will be the first element in
     the returned list.  If WINDOW is omitted or ‘nil’, the window
     selected within the frame is the first element.

   Windows in the same frame are organized into a “window tree”, whose
leaf nodes are the live windows.  The internal nodes of a window tree
are not live; they exist for the purpose of organizing the relationships
between live windows.  The root node of a window tree is called the
“root window”.  It can be either a live window (if the frame has just
one window), or an internal window.

   A minibuffer window (*note Minibuffer Windows::) is not part of its
frame’s window tree unless the frame is a minibuffer-only frame.
Nonetheless, most of the functions in this section accept the minibuffer
window as an argument.  Also, the function ‘window-tree’ described at
the end of this section lists the minibuffer window alongside the actual
window tree.

 -- Function: frame-root-window &optional frame-or-window
     This function returns the root window for FRAME-OR-WINDOW.  The
     argument FRAME-OR-WINDOW should be either a window or a frame; if
     omitted or ‘nil’, it defaults to the selected frame.  If
     FRAME-OR-WINDOW is a window, the return value is the root window of
     that window’s frame.

   When a window is split, there are two live windows where previously
there was one.  One of these is represented by the same Lisp window
object as the original window, and the other is represented by a
newly-created Lisp window object.  Both of these live windows become
leaf nodes of the window tree, as “child windows” of a single internal
window.  If necessary, Emacs automatically creates this internal window,
which is also called the “parent window”, and assigns it to the
appropriate position in the window tree.  A set of windows that share
the same parent are called “siblings”.

 -- Function: window-parent &optional window
     This function returns the parent window of WINDOW.  If WINDOW is
     omitted or ‘nil’, it defaults to the selected window.  The return
     value is ‘nil’ if WINDOW has no parent (i.e., it is a minibuffer
     window or the root window of its frame).

   Each internal window always has at least two child windows.  If this
number falls to one as a result of window deletion, Emacs automatically
deletes the internal window, and its sole remaining child window takes
its place in the window tree.

   Each child window can be either a live window, or an internal window
(which in turn would have its own child windows).  Therefore, each
internal window can be thought of as occupying a certain rectangular
“screen area”—the union of the areas occupied by the live windows that
are ultimately descended from it.

   For each internal window, the screen areas of the immediate children
are arranged either vertically or horizontally (never both).  If the
child windows are arranged one above the other, they are said to form a
“vertical combination”; if they are arranged side by side, they are said
to form a “horizontal combination”.  Consider the following example:

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|


The root window of this frame is an internal window, W1.  Its child
windows form a horizontal combination, consisting of the live window W2
and the internal window W3.  The child windows of W3 form a vertical
combination, consisting of the live windows W4 and W5.  Hence, the live
windows in this window tree are W2, W4, and W5.

   The following functions can be used to retrieve a child window of an
internal window, and the siblings of a child window.

 -- Function: window-top-child &optional window
     This function returns the topmost child window of WINDOW, if WINDOW
     is an internal window whose children form a vertical combination.
     For any other type of window, the return value is ‘nil’.

 -- Function: window-left-child &optional window
     This function returns the leftmost child window of WINDOW, if
     WINDOW is an internal window whose children form a horizontal
     combination.  For any other type of window, the return value is
     ‘nil’.

 -- Function: window-child window
     This function returns the first child window of the internal window
     WINDOW—the topmost child window for a vertical combination, or the
     leftmost child window for a horizontal combination.  If WINDOW is a
     live window, the return value is ‘nil’.

 -- Function: window-combined-p &optional window horizontal
     This function returns a non-‘nil’ value if and only if WINDOW is
     part of a vertical combination.  If WINDOW is omitted or ‘nil’, it
     defaults to the selected one.

     If the optional argument HORIZONTAL is non-‘nil’, this means to
     return non-‘nil’ if and only if WINDOW is part of a horizontal
     combination.

 -- Function: window-next-sibling &optional window
     This function returns the next sibling of the window WINDOW.  If
     omitted or ‘nil’, WINDOW defaults to the selected window.  The
     return value is ‘nil’ if WINDOW is the last child of its parent.

 -- Function: window-prev-sibling &optional window
     This function returns the previous sibling of the window WINDOW.
     If omitted or ‘nil’, WINDOW defaults to the selected window.  The
     return value is ‘nil’ if WINDOW is the first child of its parent.

   The functions ‘window-next-sibling’ and ‘window-prev-sibling’ should
not be confused with the functions ‘next-window’ and ‘previous-window’,
which return the next and previous window, respectively, in the cyclic
ordering of windows (*note Cyclic Window Ordering::).

   The following functions can be useful to locate a window within its
frame.

 -- Function: frame-first-window &optional frame-or-window
     This function returns the live window at the upper left corner of
     the frame specified by FRAME-OR-WINDOW.  The argument
     FRAME-OR-WINDOW must denote a window or a live frame and defaults
     to the selected frame.  If FRAME-OR-WINDOW specifies a window, this
     function returns the first window on that window’s frame.  Under
     the assumption that the frame from our canonical example is
     selected ‘(frame-first-window)’ returns W2.

 -- Function: window-at-side-p &optional window side
     This function returns ‘t’ if WINDOW is located at SIDE of its
     containing frame.  The argument WINDOW must be a valid window and
     defaults to the selected one.  The argument SIDE can be any of the
     symbols ‘left’, ‘top’, ‘right’ or ‘bottom’.  The default value
     ‘nil’ is handled like ‘bottom’.

     Note that this function disregards the minibuffer window (*note
     Minibuffer Windows::).  Hence, with SIDE equal to ‘bottom’ it may
     return ‘t’ also when the minibuffer window appears right below
     WINDOW.

 -- Function: window-in-direction direction &optional window ignore sign
          wrap mini
     This function returns the nearest live window in direction
     DIRECTION as seen from the position of ‘window-point’ in window
     WINDOW.  The argument DIRECTION must be one of ‘above’, ‘below’,
     ‘left’ or ‘right’.  The optional argument WINDOW must denote a live
     window and defaults to the selected one.

     This function does not return a window whose ‘no-other-window’
     parameter is non-‘nil’ (*note Window Parameters::).  If the nearest
     window’s ‘no-other-window’ parameter is non-‘nil’, this function
     tries to find another window in the indicated direction whose
     ‘no-other-window’ parameter is ‘nil’.  If the optional argument
     IGNORE is non-‘nil’, a window may be returned even if its
     ‘no-other-window’ parameter is non-‘nil’.

     If the optional argument SIGN is a negative number, it means to use
     the right or bottom edge of WINDOW as reference position instead of
     ‘window-point’.  If SIGN is a positive number, it means to use the
     left or top edge of WINDOW as reference position.

     If the optional argument WRAP is non-‘nil’, this means to wrap
     DIRECTION around frame borders.  For example, if WINDOW is at the
     top of the frame and DIRECTION is ‘above’, then this function
     usually returns the frame’s minibuffer window if it’s active and a
     window at the bottom of the frame otherwise.

     If the optional argument MINI is ‘nil’, this means to return the
     minibuffer window if and only if it is currently active.  If MINI
     is non-‘nil’, this function may return the minibuffer window even
     when it’s not active.  However, if WRAP is non-‘nil’, it always
     acts as if MINI were ‘nil’.

     If it doesn’t find a suitable window, this function returns ‘nil’.

     Don’t use this function to check whether there is _no_ window in
     DIRECTION.  Calling ‘window-at-side-p’ described above is a much
     more efficient way to do that.

   The following function allows the entire window tree of a frame to be
retrieved:

 -- Function: window-tree &optional frame
     This function returns a list representing the window tree for frame
     FRAME.  If FRAME is omitted or ‘nil’, it defaults to the selected
     frame.

     The return value is a list of the form ‘(ROOT MINI)’, where ROOT
     represents the window tree of the frame’s root window, and MINI is
     the frame’s minibuffer window.

     If the root window is live, ROOT is that window itself.  Otherwise,
     ROOT is a list ‘(DIR EDGES W1 W2 ...)’ where DIR is ‘nil’ for a
     horizontal combination and ‘t’ for a vertical combination, EDGES
     gives the size and position of the combination, and the remaining
     elements are the child windows.  Each child window may again be a
     window object (for a live window) or a list with the same format as
     above (for an internal window).  The EDGES element is a list ‘(LEFT
     TOP RIGHT BOTTOM)’, similar to the value returned by ‘window-edges’
     (*note Coordinates and Windows::).


File: elisp.info,  Node: Window Sizes,  Next: Resizing Windows,  Prev: Windows and Frames,  Up: Windows

28.3 Window Sizes
=================

The following schematic shows the structure of a live window:

             ____________________________________________
            |______________ Header Line ______________|RD| ^
          ^ |LS|LM|LF|                       |RF|RM|RS|  | |
          | |  |  |  |                       |  |  |  |  | |
     Window |  |  |  |       Text Area       |  |  |  |  | Window
     Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
     Height |  |  |  |                       |  |  |  |  | Height
          | |  |  |  |<- Window Body Width ->|  |  |  |  | |
          v |__|__|__|_______________________|__|__|__|  | |
            |_________ Horizontal Scroll Bar _________|  | |
            |_______________ Mode Line _______________|__| |
            |_____________ Bottom Divider _______________| v
             <---------- Window Total Width ------------>


   At the center of the window is the “text area”, or “body”, where the
buffer text is displayed.  The text area can be surrounded by a series
of optional areas.  On the left and right, from innermost to outermost,
these are the left and right fringes, denoted by LF and RF (*note
Fringes::); the left and right margins, denoted by LM and RM in the
schematic (*note Display Margins::); the left or right vertical scroll
bar, only one of which is present at any time, denoted by LS and RS
(*note Scroll Bars::); and the right divider, denoted by RD (*note
Window Dividers::).  At the top of the window is the header line (*note
Header Lines::).  At the bottom of the window are the horizontal scroll
bar (*note Scroll Bars::); the mode line (*note Mode Line Format::); and
the bottom divider (*note Window Dividers::).

   Emacs provides miscellaneous functions for finding the height and
width of a window.  The return value of many of these functions can be
specified either in units of pixels or in units of lines and columns.
On a graphical display, the latter actually correspond to the height and
width of a default character specified by the frame’s default font as
returned by ‘frame-char-height’ and ‘frame-char-width’ (*note Frame
Font::).  Thus, if a window is displaying text with a different font or
size, the reported line height and column width for that window may
differ from the actual number of text lines or columns displayed within
it.

   The “total height” of a window is the number of lines comprising the
window’s body, the header line, the horizontal scroll bar, the mode line
and the bottom divider (if any).

 -- Function: window-total-height &optional window round
     This function returns the total height, in lines, of the window
     WINDOW.  If WINDOW is omitted or ‘nil’, it defaults to the selected
     window.  If WINDOW is an internal window, the return value is the
     total height occupied by its descendant windows.

     If a window’s pixel height is not an integral multiple of its
     frame’s default character height, the number of lines occupied by
     the window is rounded internally.  This is done in a way such that,
     if the window is a parent window, the sum of the total heights of
     all its child windows internally equals the total height of their
     parent.  This means that although two windows have the same pixel
     height, their internal total heights may differ by one line.  This
     means also, that if window is vertically combined and has a next
     sibling, the topmost row of that sibling can be calculated as the
     sum of this window’s topmost row and total height (*note
     Coordinates and Windows::)

     If the optional argument ROUND is ‘ceiling’, this function returns
     the smallest integer larger than WINDOW’s pixel height divided by
     the character height of its frame; if it is ‘floor’, it returns the
     largest integer smaller than said value; with any other ROUND it
     returns the internal value of WINDOWS’s total height.

   The “total width” of a window is the number of lines comprising the
window’s body, its margins, fringes, scroll bars and a right divider (if
any).

 -- Function: window-total-width &optional window round
     This function returns the total width, in columns, of the window
     WINDOW.  If WINDOW is omitted or ‘nil’, it defaults to the selected
     window.  If WINDOW is internal, the return value is the total width
     occupied by its descendant windows.

     If a window’s pixel width is not an integral multiple of its
     frame’s character width, the number of lines occupied by the window
     is rounded internally.  This is done in a way such that, if the
     window is a parent window, the sum of the total widths of all its
     children internally equals the total width of their parent.  This
     means that although two windows have the same pixel width, their
     internal total widths may differ by one column.  This means also,
     that if this window is horizontally combined and has a next
     sibling, the leftmost column of that sibling can be calculated as
     the sum of this window’s leftmost column and total width (*note
     Coordinates and Windows::).  The optional argument ROUND behaves as
     it does for ‘window-total-height’.

 -- Function: window-total-size &optional window horizontal round
     This function returns either the total height in lines or the total
     width in columns of the window WINDOW.  If HORIZONTAL is omitted or
     ‘nil’, this is equivalent to calling ‘window-total-height’ for
     WINDOW; otherwise it is equivalent to calling ‘window-total-width’
     for WINDOW.  The optional argument ROUND behaves as it does for
     ‘window-total-height’.

   The following two functions can be used to return the total size of a
window in units of pixels.

 -- Function: window-pixel-height &optional window
     This function returns the total height of window WINDOW in pixels.
     WINDOW must be a valid window and defaults to the selected one.

     The return value includes mode and header line, a horizontal scroll
     bar and a bottom divider, if any.  If WINDOW is an internal window,
     its pixel height is the pixel height of the screen areas spanned by
     its children.

 -- Function: window-pixel-height-before-size-change &optional
          Lisp_Object &optional window
     This function returns the height of window WINDOW in pixels at the
     time ‘window-size-change-functions’ was run for the last time on
     WINDOW’s frame (*note Window Hooks::).

 -- Function: window-pixel-width &optional window
     This function returns the width of window WINDOW in pixels.  WINDOW
     must be a valid window and defaults to the selected one.

     The return value includes the fringes and margins of WINDOW as well
     as any vertical dividers or scroll bars belonging to WINDOW.  If
     WINDOW is an internal window, its pixel width is the width of the
     screen areas spanned by its children.

 -- Function: window-pixel-width-before-size-change &optional
          Lisp_Object &optional window
     This function returns the width of window WINDOW in pixels at the
     time ‘window-size-change-functions’ was run for the last time on
     WINDOW’s frame (*note Window Hooks::).

   The following functions can be used to determine whether a given
window has any adjacent windows.

 -- Function: window-full-height-p &optional window
     This function returns non-‘nil’ if WINDOW has no other window above
     or below it in its frame.  More precisely, this means that the
     total height of WINDOW equals the total height of the root window
     on that frame.  The minibuffer window does not count in this
     regard.  If WINDOW is omitted or ‘nil’, it defaults to the selected
     window.

 -- Function: window-full-width-p &optional window
     This function returns non-‘nil’ if WINDOW has no other window to
     the left or right in its frame, i.e., its total width equals that
     of the root window on that frame.  If WINDOW is omitted or ‘nil’,
     it defaults to the selected window.

   The “body height” of a window is the height of its text area, which
does not include a mode or header line, a horizontal scroll bar, or a
bottom divider.

 -- Function: window-body-height &optional window pixelwise
     This function returns the height, in lines, of the body of window
     WINDOW.  If WINDOW is omitted or ‘nil’, it defaults to the selected
     window; otherwise it must be a live window.

     If the optional argument PIXELWISE is non-‘nil’, this function
     returns the body height of WINDOW counted in pixels.

     If PIXELWISE is ‘nil’, the return value is rounded down to the
     nearest integer, if necessary.  This means that if a line at the
     bottom of the text area is only partially visible, that line is not
     counted.  It also means that the height of a window’s body can
     never exceed its total height as returned by ‘window-total-height’.

   The “body width” of a window is the width of its text area, which
does not include the scroll bar, fringes, margins or a right divider.
Note that when one or both fringes are removed (by setting their width
to zero), the display engine reserves two character cells, one on each
side of the window, for displaying the continuation and truncation
glyphs, which leaves 2 columns less for text display.  (The function
‘window-max-chars-per-line’, described below, takes this peculiarity
into account.)

 -- Function: window-body-width &optional window pixelwise
     This function returns the width, in columns, of the body of window
     WINDOW.  If WINDOW is omitted or ‘nil’, it defaults to the selected
     window; otherwise it must be a live window.

     If the optional argument PIXELWISE is non-‘nil’, this function
     returns the body width of WINDOW in units of pixels.

     If PIXELWISE is ‘nil’, the return value is rounded down to the
     nearest integer, if necessary.  This means that if a column on the
     right of the text area is only partially visible, that column is
     not counted.  It also means that the width of a window’s body can
     never exceed its total width as returned by ‘window-total-width’.

 -- Function: window-body-size &optional window horizontal pixelwise
     This function returns the body height or body width of WINDOW.  If
     HORIZONTAL is omitted or ‘nil’, it is equivalent to calling
     ‘window-body-height’ for WINDOW; otherwise it is equivalent to
     calling ‘window-body-width’.  In either case, the optional argument
     PIXELWISE is passed to the function called.

   For compatibility with previous versions of Emacs, ‘window-height’ is
an alias for ‘window-total-height’, and ‘window-width’ is an alias for
‘window-body-width’.  These aliases are considered obsolete and will be
removed in the future.

   The pixel heights of a window’s mode and header line can be retrieved
with the functions given below.  Their return value is usually accurate
unless the window has not been displayed before: In that case, the
return value is based on an estimate of the font used for the window’s
frame.

 -- Function: window-mode-line-height &optional window
     This function returns the height in pixels of WINDOW’s mode line.
     WINDOW must be a live window and defaults to the selected one.  If
     WINDOW has no mode line, the return value is zero.

 -- Function: window-header-line-height &optional window
     This function returns the height in pixels of WINDOW’s header line.
     WINDOW must be a live window and defaults to the selected one.  If
     WINDOW has no header line, the return value is zero.

   Functions for retrieving the height and/or width of window dividers
(*note Window Dividers::), fringes (*note Fringes::), scroll bars (*note
Scroll Bars::), and display margins (*note Display Margins::) are
described in the corresponding sections.

   If your Lisp program needs to make layout decisions, you will find
the following function useful:

 -- Function: window-max-chars-per-line &optional window face
     This function returns the number of characters displayed in the
     specified face FACE in the specified window WINDOW (which must be a
     live window).  If FACE was remapped (*note Face Remapping::), the
     information is returned for the remapped face.  If omitted or
     ‘nil’, FACE defaults to the default face, and WINDOW defaults to
     the selected window.

     Unlike ‘window-body-width’, this function accounts for the actual
     size of FACE’s font, instead of working in units of the canonical
     character width of WINDOW’s frame (*note Frame Font::).  It also
     accounts for space used by the continuation glyph, if WINDOW lacks
     one or both of its fringes.

   Commands that change the size of windows (*note Resizing Windows::),
or split them (*note Splitting Windows::), obey the variables
‘window-min-height’ and ‘window-min-width’, which specify the smallest
allowable window height and width.  They also obey the variable
‘window-size-fixed’, with which a window can be “fixed” in size (*note
Preserving Window Sizes::).

 -- User Option: window-min-height
     This option specifies the minimum total height, in lines, of any
     window.  Its value has to accommodate at least one text line as
     well as a mode and header line, a horizontal scroll bar and a
     bottom divider, if present.

 -- User Option: window-min-width
     This option specifies the minimum total width, in columns, of any
     window.  Its value has to accommodate two text columns as well as
     margins, fringes, a scroll bar and a right divider, if present.

   The following function tells how small a specific window can get
taking into account the sizes of its areas and the values of
‘window-min-height’, ‘window-min-width’ and ‘window-size-fixed’ (*note
Preserving Window Sizes::).

 -- Function: window-min-size &optional window horizontal ignore
          pixelwise
     This function returns the minimum size of WINDOW.  WINDOW must be a
     valid window and defaults to the selected one.  The optional
     argument HORIZONTAL non-‘nil’ means to return the minimum number of
     columns of WINDOW; otherwise return the minimum number of WINDOW’s
     lines.

     The return value makes sure that all components of WINDOW remain
     fully visible if WINDOW’s size were actually set to it.  With
     HORIZONTAL ‘nil’ it includes the mode and header line, the
     horizontal scroll bar and the bottom divider, if present.  With
     HORIZONTAL non-‘nil’ it includes the margins and fringes, the
     vertical scroll bar and the right divider, if present.

     The optional argument IGNORE, if non-‘nil’, means ignore
     restrictions imposed by fixed size windows, ‘window-min-height’ or
     ‘window-min-width’ settings.  If IGNORE equals ‘safe’, live windows
     may get as small as ‘window-safe-min-height’ lines and
     ‘window-safe-min-width’ columns.  If IGNORE is a window, ignore
     restrictions for that window only.  Any other non-‘nil’ value means
     ignore all of the above restrictions for all windows.

     The optional argument PIXELWISE non-‘nil’ means to return the
     minimum size of WINDOW counted in pixels.


File: elisp.info,  Node: Resizing Windows,  Next: Preserving Window Sizes,  Prev: Window Sizes,  Up: Windows

28.4 Resizing Windows
=====================

This section describes functions for resizing a window without changing
the size of its frame.  Because live windows do not overlap, these
functions are meaningful only on frames that contain two or more
windows: resizing a window also changes the size of a neighboring
window.  If there is just one window on a frame, its size cannot be
changed except by resizing the frame (*note Frame Size::).

   Except where noted, these functions also accept internal windows as
arguments.  Resizing an internal window causes its child windows to be
resized to fit the same space.

 -- Function: window-resizable window delta &optional horizontal ignore
          pixelwise
     This function returns DELTA if the size of WINDOW can be changed
     vertically by DELTA lines.  If the optional argument HORIZONTAL is
     non-‘nil’, it instead returns DELTA if WINDOW can be resized
     horizontally by DELTA columns.  It does not actually change the
     window size.

     If WINDOW is ‘nil’, it defaults to the selected window.

     A positive value of DELTA means to check whether the window can be
     enlarged by that number of lines or columns; a negative value of
     DELTA means to check whether the window can be shrunk by that many
     lines or columns.  If DELTA is non-zero, a return value of 0 means
     that the window cannot be resized.

     Normally, the variables ‘window-min-height’ and ‘window-min-width’
     specify the smallest allowable window size (*note Window Sizes::).
     However, if the optional argument IGNORE is non-‘nil’, this
     function ignores ‘window-min-height’ and ‘window-min-width’, as
     well as ‘window-size-fixed’.  Instead, it considers the
     minimum-height window to be one consisting of a header and a mode
     line, a horizontal scrollbar and a bottom divider (if any), plus a
     text area one line tall; and a minimum-width window as one
     consisting of fringes, margins, a scroll bar and a right divider
     (if any), plus a text area two columns wide.

     If the optional argument PIXELWISE is non-‘nil’, DELTA is
     interpreted as pixels.

 -- Function: window-resize window delta &optional horizontal ignore
          pixelwise
     This function resizes WINDOW by DELTA increments.  If HORIZONTAL is
     ‘nil’, it changes the height by DELTA lines; otherwise, it changes
     the width by DELTA columns.  A positive DELTA means to enlarge the
     window, and a negative DELTA means to shrink it.

     If WINDOW is ‘nil’, it defaults to the selected window.  If the
     window cannot be resized as demanded, an error is signaled.

     The optional argument IGNORE has the same meaning as for the
     function ‘window-resizable’ above.

     If the optional argument PIXELWISE is non-‘nil’, DELTA will be
     interpreted as pixels.

     The choice of which window edges this function alters depends on
     the values of the option ‘window-combination-resize’ and the
     combination limits of the involved windows; in some cases, it may
     alter both edges.  *Note Recombining Windows::.  To resize by
     moving only the bottom or right edge of a window, use the function
     ‘adjust-window-trailing-edge’.

 -- Function: adjust-window-trailing-edge window delta &optional
          horizontal pixelwise
     This function moves WINDOW’s bottom edge by DELTA lines.  If
     optional argument HORIZONTAL is non-‘nil’, it instead moves the
     right edge by DELTA columns.  If WINDOW is ‘nil’, it defaults to
     the selected window.

     If the optional argument PIXELWISE is non-‘nil’, DELTA is
     interpreted as pixels.

     A positive DELTA moves the edge downwards or to the right; a
     negative DELTA moves it upwards or to the left.  If the edge cannot
     be moved as far as specified by DELTA, this function moves it as
     far as possible but does not signal an error.

     This function tries to resize windows adjacent to the edge that is
     moved.  If this is not possible for some reason (e.g., if that
     adjacent window is fixed-size), it may resize other windows.

 -- User Option: window-resize-pixelwise
     If the value of this option is non-‘nil’, Emacs resizes windows in
     units of pixels.  This currently affects functions like
     ‘split-window’ (*note Splitting Windows::), ‘maximize-window’,
     ‘minimize-window’, ‘fit-window-to-buffer’, ‘fit-frame-to-buffer’
     and ‘shrink-window-if-larger-than-buffer’ (all listed below).

     Note that when a frame’s pixel size is not a multiple of its
     character size, at least one window may get resized pixelwise even
     if this option is ‘nil’.  The default value is ‘nil’.

   The following commands resize windows in more specific ways.  When
called interactively, they act on the selected window.

 -- Command: fit-window-to-buffer &optional window max-height min-height
          max-width min-width preserve-size
     This command adjusts the height or width of WINDOW to fit the text
     in it.  It returns non-‘nil’ if it was able to resize WINDOW, and
     ‘nil’ otherwise.  If WINDOW is omitted or ‘nil’, it defaults to the
     selected window.  Otherwise, it should be a live window.

     If WINDOW is part of a vertical combination, this function adjusts
     WINDOW’s height.  The new height is calculated from the actual
     height of the accessible portion of its buffer.  The optional
     argument MAX-HEIGHT, if non-‘nil’, specifies the maximum total
     height that this function can give WINDOW.  The optional argument
     MIN-HEIGHT, if non-‘nil’, specifies the minimum total height that
     it can give, which overrides the variable ‘window-min-height’.
     Both MAX-HEIGHT and MIN-HEIGHT are specified in lines and include
     mode and header line and a bottom divider, if any.

     If WINDOW is part of a horizontal combination and the value of the
     option ‘fit-window-to-buffer-horizontally’ (see below) is
     non-‘nil’, this function adjusts WINDOW’s width.  The new width of
     WINDOW is calculated from the maximum length of its buffer’s lines
     that follow the current start position of WINDOW.  The optional
     argument MAX-WIDTH specifies a maximum width and defaults to the
     width of WINDOW’s frame.  The optional argument MIN-WIDTH specifies
     a minimum width and defaults to ‘window-min-width’.  Both MAX-WIDTH
     and MIN-WIDTH are specified in columns and include fringes, margins
     and scrollbars, if any.

     The optional argument PRESERVE-SIZE, if non-‘nil’, will install a
     parameter to preserve the size of WINDOW during future resize
     operations (*note Preserving Window Sizes::).

     If the option ‘fit-frame-to-buffer’ (see below) is non-‘nil’, this
     function will try to resize the frame of WINDOW to fit its contents
     by calling ‘fit-frame-to-buffer’ (see below).

 -- User Option: fit-window-to-buffer-horizontally
     If this is non-‘nil’, ‘fit-window-to-buffer’ can resize windows
     horizontally.  If this is ‘nil’ (the default)
     ‘fit-window-to-buffer’ never resizes windows horizontally.  If this
     is ‘only’, it can resize windows horizontally only.  Any other
     value means ‘fit-window-to-buffer’ can resize windows in both
     dimensions.

 -- User Option: fit-frame-to-buffer
     If this option is non-‘nil’, ‘fit-window-to-buffer’ can fit a frame
     to its buffer.  A frame is fit if and only if its root window is a
     live window and this option is non-‘nil’.  If this is
     ‘horizontally’, frames are fit horizontally only.  If this is
     ‘vertically’, frames are fit vertically only.  Any other non-‘nil’
     value means frames can be resized in both dimensions.

   If you have a frame that displays only one window, you can fit that
frame to its buffer using the command ‘fit-frame-to-buffer’.

 -- Command: fit-frame-to-buffer &optional frame max-height min-height
          max-width min-width only
     This command adjusts the size of FRAME to display the contents of
     its buffer exactly.  FRAME can be any live frame and defaults to
     the selected one.  Fitting is done only if FRAME’s root window is
     live.  The arguments MAX-HEIGHT, MIN-HEIGHT, MAX-WIDTH and
     MIN-WIDTH specify bounds on the new total size of FRAME’s root
     window.  MIN-HEIGHT and MIN-WIDTH default to the values of
     ‘window-min-height’ and ‘window-min-width’ respectively.

     If the optional argument ONLY is ‘vertically’, this function may
     resize the frame vertically only.  If ONLY is ‘horizontally’, it
     may resize the frame horizontally only.

   The behavior of ‘fit-frame-to-buffer’ can be controlled with the help
of the two options listed next.

 -- User Option: fit-frame-to-buffer-margins
     This option can be used to specify margins around frames to be fit
     by ‘fit-frame-to-buffer’.  Such margins can be useful to avoid, for
     example, that the resized frame overlaps the taskbar or parts of
     its parent frame.

     It specifies the numbers of pixels to be left free on the left,
     above, the right, and below a frame that shall be fit.  The default
     specifies ‘nil’ for each which means to use no margins.  The value
     specified here can be overridden for a specific frame by that
     frame’s ‘fit-frame-to-buffer-margins’ parameter, if present.

 -- User Option: fit-frame-to-buffer-sizes
     This option specifies size boundaries for ‘fit-frame-to-buffer’.
     It specifies the total maximum and minimum lines and maximum and
     minimum columns of the root window of any frame that shall be fit
     to its buffer.  If any of these values is non-‘nil’, it overrides
     the corresponding argument of ‘fit-frame-to-buffer’.

 -- Command: shrink-window-if-larger-than-buffer &optional window
     This command attempts to reduce WINDOW’s height as much as possible
     while still showing its full buffer, but no less than
     ‘window-min-height’ lines.  The return value is non-‘nil’ if the
     window was resized, and ‘nil’ otherwise.  If WINDOW is omitted or
     ‘nil’, it defaults to the selected window.  Otherwise, it should be
     a live window.

     This command does nothing if the window is already too short to
     display all of its buffer, or if any of the buffer is scrolled
     off-screen, or if the window is the only live window in its frame.

     This command calls ‘fit-window-to-buffer’ (see above) to do its
     work.

 -- Command: balance-windows &optional window-or-frame
     This function balances windows in a way that gives more space to
     full-width and/or full-height windows.  If WINDOW-OR-FRAME
     specifies a frame, it balances all windows on that frame.  If
     WINDOW-OR-FRAME specifies a window, it balances only that window
     and its siblings (*note Windows and Frames::).

 -- Command: balance-windows-area
     This function attempts to give all windows on the selected frame
     approximately the same share of the screen area.  Full-width or
     full-height windows are not given more space than other windows.

 -- Command: maximize-window &optional window
     This function attempts to make WINDOW as large as possible, in both
     dimensions, without resizing its frame or deleting other windows.
     If WINDOW is omitted or ‘nil’, it defaults to the selected window.

 -- Command: minimize-window &optional window
     This function attempts to make WINDOW as small as possible, in both
     dimensions, without deleting it or resizing its frame.  If WINDOW
     is omitted or ‘nil’, it defaults to the selected window.


File: elisp.info,  Node: Preserving Window Sizes,  Next: Splitting Windows,  Prev: Resizing Windows,  Up: Windows

28.5 Preserving Window Sizes
============================

A window can get resized explicitly by using one of the functions from
the preceding section or implicitly, for example, when resizing an
adjacent window, when splitting or deleting a window (*note Splitting
Windows::, *note Deleting Windows::) or when resizing the window’s frame
(*note Frame Size::).

   It is possible to avoid implicit resizing of a specific window when
there are one or more other resizable windows on the same frame.  For
this purpose, Emacs must be advised to “preserve” the size of that
window.  There are two basic ways to do that.

 -- Variable: window-size-fixed
     If this buffer-local variable is non-‘nil’, the size of any window
     displaying the buffer cannot normally be changed.  Deleting a
     window or changing the frame’s size may still change the window’s
     size, if there is no choice.

     If the value is ‘height’, then only the window’s height is fixed;
     if the value is ‘width’, then only the window’s width is fixed.
     Any other non-‘nil’ value fixes both the width and the height.

     If this variable is ‘nil’, this does not necessarily mean that any
     window showing the buffer can be resized in the desired direction.
     To determine that, use the function ‘window-resizable’.  *Note
     Resizing Windows::.

   Often ‘window-size-fixed’ is overly aggressive because it inhibits
any attempt to explicitly resize or split an affected window as well.
This may even happen after the window has been resized implicitly, for
example, when deleting an adjacent window or resizing the window’s
frame.  The following function tries hard to never disallow resizing
such a window explicitly:

 -- Function: window-preserve-size &optional window horizontal preserve
     This function (un-)marks the height of window WINDOW as preserved
     for future resize operations.  WINDOW must be a live window and
     defaults to the selected one.  If the optional argument HORIZONTAL
     is non-‘nil’, it (un-)marks the width of WINDOW as preserved.

     If the optional argument PRESERVE is ‘t’, this means to preserve
     the current height/width of WINDOW’s body.  The height/width of
     WINDOW will change only if Emacs has no better choice.  Resizing a
     window whose height/width is preserved by this function never
     throws an error.

     If PRESERVE is ‘nil’, this means to stop preserving the
     height/width of WINDOW, lifting any respective restraint induced by
     a previous call of this function for WINDOW.  Calling
     ‘enlarge-window’, ‘shrink-window’ or ‘fit-window-to-buffer’ with
     WINDOW as argument may also remove the respective restraint.

   ‘window-preserve-size’ is currently invoked by the following
functions:

‘fit-window-to-buffer’
     If the optional argument PRESERVE-SIZE of that function (*note
     Resizing Windows::) is non-‘nil’, the size established by that
     function is preserved.

‘display-buffer’
     If the ALIST argument of that function (*note Choosing Window::)
     contains a ‘preserve-size’ entry, the size of the window produced
     by that function is preserved.

   ‘window-preserve-size’ installs a window parameter (*note Window
Parameters::) called ‘window-preserved-size’ which is consulted by the
window resizing functions.  This parameter will not prevent resizing the
window when the window shows another buffer than the one when
‘window-preserve-size’ was invoked or if its size has changed since
then.

   The following function can be used to check whether the height of a
particular window is preserved:

 -- Function: window-preserved-size &optional window horizontal
     This function returns the preserved height of window WINDOW in
     pixels.  WINDOW must be a live window and defaults to the selected
     one.  If the optional argument HORIZONTAL is non-‘nil’, it returns
     the preserved width of WINDOW.  It returns ‘nil’ if the size of
     WINDOW is not preserved.


File: elisp.info,  Node: Splitting Windows,  Next: Deleting Windows,  Prev: Preserving Window Sizes,  Up: Windows

28.6 Splitting Windows
======================

This section describes functions for creating a new window by
“splitting” an existing one.  Note that some windows are special in the
sense that these functions may fail to split them as described here.
Examples of such windows are side windows (*note Side Windows::) and
atomic windows (*note Atomic Windows::).

 -- Function: split-window &optional window size side pixelwise
     This function creates a new live window next to the window WINDOW.
     If WINDOW is omitted or ‘nil’, it defaults to the selected window.
     That window is split, and reduced in size.  The space is taken up
     by the new window, which is returned.

     The optional second argument SIZE determines the sizes of WINDOW
     and/or the new window.  If it is omitted or ‘nil’, both windows are
     given equal sizes; if there is an odd line, it is allocated to the
     new window.  If SIZE is a positive number, WINDOW is given SIZE
     lines (or columns, depending on the value of SIDE).  If SIZE is a
     negative number, the new window is given −SIZE lines (or columns).

     If SIZE is ‘nil’, this function obeys the variables
     ‘window-min-height’ and ‘window-min-width’ (*note Window Sizes::).
     Thus, it signals an error if splitting would result in making a
     window smaller than those variables specify.  However, a non-‘nil’
     value for SIZE causes those variables to be ignored; in that case,
     the smallest allowable window is considered to be one that has
     space for a text area one line tall and/or two columns wide.

     Hence, if SIZE is specified, it’s the caller’s responsibility to
     check whether the emanating windows are large enough to encompass
     all areas like a mode line or a scroll bar.  The function
     ‘window-min-size’ (*note Window Sizes::) can be used to determine
     the minimum requirements of WINDOW in this regard.  Since the new
     window usually inherits areas like the mode line or the scroll bar
     from WINDOW, that function is also a good guess for the minimum
     size of the new window.  The caller should specify a smaller size
     only if it correspondingly removes an inherited area before the
     next redisplay.

     The optional third argument SIDE determines the position of the new
     window relative to WINDOW.  If it is ‘nil’ or ‘below’, the new
     window is placed below WINDOW.  If it is ‘above’, the new window is
     placed above WINDOW.  In both these cases, SIZE specifies a total
     window height, in lines.

     If SIDE is ‘t’ or ‘right’, the new window is placed on the right of
     WINDOW.  If SIDE is ‘left’, the new window is placed on the left of
     WINDOW.  In both these cases, SIZE specifies a total window width,
     in columns.

     The optional fourth argument PIXELWISE, if non-‘nil’, means to
     interpret SIZE in units of pixels, instead of lines and columns.

     If WINDOW is a live window, the new window inherits various
     properties from it, including margins and scroll bars.  If WINDOW
     is an internal window, the new window inherits the properties of
     the window selected within WINDOW’s frame.

     The behavior of this function may be altered by the window
     parameters of WINDOW, so long as the variable
     ‘ignore-window-parameters’ is ‘nil’.  If the value of the
     ‘split-window’ window parameter is ‘t’, this function ignores all
     other window parameters.  Otherwise, if the value of the
     ‘split-window’ window parameter is a function, that function is
     called with the arguments WINDOW, SIZE, and SIDE, in lieu of the
     usual action of ‘split-window’.  Otherwise, this function obeys the
     ‘window-atom’ or ‘window-side’ window parameter, if any.  *Note
     Window Parameters::.

   As an example, here is a sequence of ‘split-window’ calls that yields
the window configuration discussed in *note Windows and Frames::.  This
example demonstrates splitting a live window as well as splitting an
internal window.  We begin with a frame containing a single window (a
live root window), which we denote by W4.  Calling ‘(split-window W4)’
yields this window configuration:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W5_________________||
         |__________________W3__________________|


The ‘split-window’ call has created a new live window, denoted by W5.
It has also created a new internal window, denoted by W3, which becomes
the root window and the parent of both W4 and W5.

   Next, we call ‘(split-window W3 nil 'left)’, passing the internal
window W3 as the argument.  The result:

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|

A new live window W2 is created, to the left of the internal window W3.
A new internal window W1 is created, becoming the new root window.

   For interactive use, Emacs provides two commands which always split
the selected window.  These call ‘split-window’ internally.

 -- Command: split-window-right &optional size
     This function splits the selected window into two side-by-side
     windows, putting the selected window on the left.  If SIZE is
     positive, the left window gets SIZE columns; if SIZE is negative,
     the right window gets −SIZE columns.

 -- Command: split-window-below &optional size
     This function splits the selected window into two windows, one
     above the other, leaving the upper window selected.  If SIZE is
     positive, the upper window gets SIZE lines; if SIZE is negative,
     the lower window gets −SIZE lines.

 -- User Option: split-window-keep-point
     If the value of this variable is non-‘nil’ (the default),
     ‘split-window-below’ behaves as described above.

     If it is ‘nil’, ‘split-window-below’ adjusts point in each of the
     two windows to minimize redisplay.  (This is useful on slow
     terminals.)  It selects whichever window contains the screen line
     that point was previously on.  Note that this only affects
     ‘split-window-below’, not the lower-level ‘split-window’ function.


File: elisp.info,  Node: Deleting Windows,  Next: Recombining Windows,  Prev: Splitting Windows,  Up: Windows

28.7 Deleting Windows
=====================

“Deleting” a window removes it from the frame’s window tree.  If the
window is a live window, it disappears from the screen.  If the window
is an internal window, its child windows are deleted too.

   Even after a window is deleted, it continues to exist as a Lisp
object, until there are no more references to it.  Window deletion can
be reversed, by restoring a saved window configuration (*note Window
Configurations::).

 -- Command: delete-window &optional window
     This function removes WINDOW from display and returns ‘nil’.  If
     WINDOW is omitted or ‘nil’, it defaults to the selected window.

     If deleting the window would leave no more windows in the window
     tree (e.g., if it is the only live window in the frame) or all
     remaining windows on WINDOW’s frame are side windows (*note Side
     Windows::), an error is signaled.

     By default, the space taken up by WINDOW is given to one of its
     adjacent sibling windows, if any.  However, if the variable
     ‘window-combination-resize’ is non-‘nil’, the space is
     proportionally distributed among any remaining windows in the same
     window combination.  *Note Recombining Windows::.

     The behavior of this function may be altered by the window
     parameters of WINDOW, so long as the variable
     ‘ignore-window-parameters’ is ‘nil’.  If the value of the
     ‘delete-window’ window parameter is ‘t’, this function ignores all
     other window parameters.  Otherwise, if the value of the
     ‘delete-window’ window parameter is a function, that function is
     called with the argument WINDOW, in lieu of the usual action of
     ‘delete-window’.  *Note Window Parameters::.

 -- Command: delete-other-windows &optional window
     This function makes WINDOW fill its frame, deleting other windows
     as necessary.  If WINDOW is omitted or ‘nil’, it defaults to the
     selected window.  An error is signaled if WINDOW is a side window
     (*note Side Windows::).  The return value is ‘nil’.

     The behavior of this function may be altered by the window
     parameters of WINDOW, so long as the variable
     ‘ignore-window-parameters’ is ‘nil’.  If the value of the
     ‘delete-other-windows’ window parameter is ‘t’, this function
     ignores all other window parameters.  Otherwise, if the value of
     the ‘delete-other-windows’ window parameter is a function, that
     function is called with the argument WINDOW, in lieu of the usual
     action of ‘delete-other-windows’.  *Note Window Parameters::.

     Also, if ‘ignore-window-parameters’ is ‘nil’, this function does
     not delete any window whose ‘no-delete-other-windows’ parameter is
     non-‘nil’.

 -- Command: delete-windows-on &optional buffer-or-name frame
     This function deletes all windows showing BUFFER-OR-NAME, by
     calling ‘delete-window’ on those windows.  BUFFER-OR-NAME should be
     a buffer, or the name of a buffer; if omitted or ‘nil’, it defaults
     to the current buffer.  If there are no windows showing the
     specified buffer, this function does nothing.  If the specified
     buffer is a minibuffer, an error is signaled.

     If there is a dedicated window showing the buffer, and that window
     is the only one on its frame, this function also deletes that frame
     if it is not the only frame on the terminal.

     The optional argument FRAME specifies which frames to operate on:

        • ‘nil’ means operate on all frames.
        • ‘t’ means operate on the selected frame.
        • ‘visible’ means operate on all visible frames.
        • ‘0’ means operate on all visible or iconified frames.
        • A frame means operate on that frame.

     Note that this argument does not have the same meaning as in other
     functions which scan all live windows (*note Cyclic Window
     Ordering::).  Specifically, the meanings of ‘t’ and ‘nil’ here are
     the opposite of what they are in those other functions.


File: elisp.info,  Node: Recombining Windows,  Next: Selecting Windows,  Prev: Deleting Windows,  Up: Windows

28.8 Recombining Windows
========================

When deleting the last sibling of a window W, its parent window is
deleted too, with W replacing it in the window tree.  This means that W
must be recombined with its parent’s siblings to form a new window
combination (*note Windows and Frames::).  In some occasions, deleting a
live window may even entail the deletion of two internal windows.

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      ||| ___________  ___________ |||
         ||      ||||           ||           ||||
         ||      ||||____W6_____||_____W7____||||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|


Deleting W5 in this configuration normally causes the deletion of W3 and
W4.  The remaining live windows W2, W6 and W7 are recombined to form a
new horizontal combination with parent W1.

   Sometimes, however, it makes sense to not delete a parent window like
W4.  In particular, a parent window should not be removed when it was
used to preserve a combination embedded in a combination of the same
type.  Such embeddings make sense to assure that when you split a window
and subsequently delete the new window, Emacs reestablishes the layout
of the associated frame as it existed before the splitting.

   Consider a scenario starting with two live windows W2 and W3 and
their parent W1.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


Split W2 to make a new window W4 as follows.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


Now, when enlarging a window vertically, Emacs tries to obtain the
corresponding space from its lower sibling, provided such a window
exists.  In our scenario, enlarging W4 will steal space from W3.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||_________________W3_________________||
         |__________________W1__________________|


Deleting W4 will now give its entire space to W2, including the space
earlier stolen from W3.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||_________________W3_________________||
         |__________________W1__________________|


This can be counterintuitive, in particular if W4 were used for
displaying a buffer only temporarily (*note Temporary Displays::), and
you want to continue working with the initial layout.

   The behavior can be fixed by making a new parent window when
splitting W2.  The variable described next allows that to be done.

 -- User Option: window-combination-limit
     This variable controls whether splitting a window shall make a new
     parent window.  The following values are recognized:

     ‘nil’
          This means that the new live window is allowed to share the
          existing parent window, if one exists, provided the split
          occurs in the same direction as the existing window
          combination (otherwise, a new internal window is created
          anyway).

     ‘window-size’
          This means that ‘display-buffer’ makes a new parent window
          when it splits a window and is passed a ‘window-height’ or
          ‘window-width’ entry in the ALIST argument (*note Display
          Action Functions::).  Otherwise, window splitting behaves as
          for a value of ‘nil’.

     ‘temp-buffer-resize’
          In this case ‘with-temp-buffer-window’ makes a new parent
          window when it splits a window and ‘temp-buffer-resize-mode’
          is enabled (*note Temporary Displays::).  Otherwise, window
          splitting behaves as for ‘nil’.

     ‘temp-buffer’
          In this case ‘with-temp-buffer-window’ always makes a new
          parent window when it splits an existing window (*note
          Temporary Displays::).  Otherwise, window splitting behaves as
          for ‘nil’.

     ‘display-buffer’
          This means that when ‘display-buffer’ (*note Choosing
          Window::) splits a window it always makes a new parent window.
          Otherwise, window splitting behaves as for ‘nil’.

     ‘t’
          This means that splitting a window always creates a new parent
          window.  Thus, if the value of this variable is at all times
          ‘t’, then at all times every window tree is a binary tree (a
          tree where each window except the root window has exactly one
          sibling).

     The default is ‘window-size’.  Other values are reserved for future
     use.

     If, as a consequence of this variable’s setting, ‘split-window’
     makes a new parent window, it also calls
     ‘set-window-combination-limit’ (see below) on the newly-created
     internal window.  This affects how the window tree is rearranged
     when the child windows are deleted (see below).

   If ‘window-combination-limit’ is ‘t’, splitting W2 in the initial
configuration of our scenario would have produced this:

          ______________________________________
         | ____________________________________ |
         || __________________________________ ||
         |||                                  |||
         |||________________W2________________|||
         || __________________________________ ||
         |||                                  |||
         |||________________W4________________|||
         ||_________________W5_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


A new internal window W5 has been created; its children are W2 and the
new live window W4.  Now, W2 is the only sibling of W4, so enlarging W4
will try to shrink W2, leaving W3 unaffected.  Observe that W5
represents a vertical combination of two windows embedded in the
vertical combination W1.

 -- Function: set-window-combination-limit window limit
     This function sets the “combination limit” of the window WINDOW to
     LIMIT.  This value can be retrieved via the function
     ‘window-combination-limit’.  See below for its effects; note that
     it is only meaningful for internal windows.  The ‘split-window’
     function automatically calls this function, passing it ‘t’ as
     LIMIT, provided the value of the variable
     ‘window-combination-limit’ is ‘t’ when it is called.

 -- Function: window-combination-limit window
     This function returns the combination limit for WINDOW.

     The combination limit is meaningful only for an internal window.
     If it is ‘nil’, then Emacs is allowed to automatically delete
     WINDOW, in response to a window deletion, in order to group the
     child windows of WINDOW with its sibling windows to form a new
     window combination.  If the combination limit is ‘t’, the child
     windows of WINDOW are never automatically recombined with its
     siblings.

     If, in the configuration shown at the beginning of this section,
     the combination limit of W4 (the parent window of W6 and W7) is
     ‘t’, deleting W5 will not implicitly delete W4 too.

   Alternatively, the problems sketched above can be avoided by always
resizing all windows in the same combination whenever one of its windows
is split or deleted.  This also permits splitting windows that would be
otherwise too small for such an operation.

 -- User Option: window-combination-resize
     If this variable is ‘nil’, ‘split-window’ can only split a window
     (denoted by WINDOW) if WINDOW’s screen area is large enough to
     accommodate both itself and the new window.

     If this variable is ‘t’, ‘split-window’ tries to resize all windows
     that are part of the same combination as WINDOW, in order to
     accommodate the new window.  In particular, this may allow
     ‘split-window’ to succeed even if WINDOW is a fixed-size window or
     too small to ordinarily split.  Furthermore, subsequently resizing
     or deleting WINDOW may resize all other windows in its combination.

     The default is ‘nil’.  Other values are reserved for future use.  A
     specific split operation may ignore the value of this variable if
     it is affected by a non-‘nil’ value of ‘window-combination-limit’.

   To illustrate the effect of ‘window-combination-resize’, consider the
following frame layout.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


If ‘window-combination-resize’ is ‘nil’, splitting window W3 leaves the
size of W2 unchanged:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||_________________W3_________________||
         | ____________________________________ |
         ||                                    ||
         ||_________________W4_________________||
         |__________________W1__________________|


If ‘window-combination-resize’ is ‘t’, splitting W3 instead leaves all
three live windows with approximately the same height:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         |__________________W1__________________|


Deleting any of the live windows W2, W3 or W4 will distribute its space
proportionally among the two remaining live windows.


File: elisp.info,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Recombining Windows,  Up: Windows

28.9 Selecting Windows
======================

 -- Function: select-window window &optional norecord
     This function makes WINDOW the selected window and the window
     selected within its frame (*note Basic Windows::), and selects that
     frame.  It also makes WINDOW’s buffer (*note Buffers and Windows::)
     current and sets that buffer’s value of ‘point’ to the value of
     ‘window-point’ (*note Window Point::) in WINDOW.  WINDOW must be a
     live window.  The return value is WINDOW.

     By default, this function also moves WINDOW’s buffer to the front
     of the buffer list (*note Buffer List::) and makes WINDOW the most
     recently selected window.  If the optional argument NORECORD is
     non-‘nil’, these additional actions are omitted.

     In addition, this function by default also tells the display engine
     to update the display of WINDOW when its frame gets redisplayed the
     next time.  If NORECORD is non-‘nil’, such updates are usually not
     performed.  If, however, NORECORD equals the special symbol
     ‘mark-for-redisplay’, the additional actions mentioned above are
     omitted but WINDOW will be nevertheless updated.

     Note that sometimes selecting a window is not enough to show it, or
     make its frame the top-most frame on display: you may also need to
     raise the frame or make sure input focus is directed to that frame.
     *Note Input Focus::.

   For historical reasons, Emacs does not run a separate hook whenever a
window gets selected.  Applications and internal routines often
temporarily select a window to perform a few actions on it.  They do
that either to simplify coding—because many functions by default operate
on the selected window when no WINDOW argument is specified—or because
some functions did not (and still do not) take a window as argument and
always operate(d) on the selected window instead.  Running a hook every
time a window gets selected for a short time and once more when the
previously selected window gets restored is not useful.

   However, when its NORECORD argument is ‘nil’, ‘select-window’ updates
the buffer list and thus indirectly runs the normal hook
‘buffer-list-update-hook’ (*note Buffer List::).  Consequently, that
hook provides a reasonable way to run a function whenever a window gets
selected more “permanently”.

   Since ‘buffer-list-update-hook’ is also run by functions that are not
related to window management, it will usually make sense to save the
value of the selected window somewhere and compare it with the value of
‘selected-window’ while running that hook.  Also, to avoid false
positives when using ‘buffer-list-update-hook’, it is good practice that
every ‘select-window’ call supposed to select a window only temporarily
passes a non-‘nil’ NORECORD argument.  If possible, the macro
‘with-selected-window’ (see below) should be used in such cases.

   The sequence of calls to ‘select-window’ with a non-‘nil’ NORECORD
argument determines an ordering of windows by their selection time.  The
function ‘get-lru-window’ can be used to retrieve the least recently
selected live window (*note Cyclic Window Ordering::).

 -- Macro: save-selected-window forms...
     This macro records the selected frame, as well as the selected
     window of each frame, executes FORMS in sequence, then restores the
     earlier selected frame and windows.  It also saves and restores the
     current buffer.  It returns the value of the last form in FORMS.

     This macro does not save or restore anything about the sizes,
     arrangement or contents of windows; therefore, if FORMS change
     them, the change persists.  If the previously selected window of
     some frame is no longer live at the time of exit from FORMS, that
     frame’s selected window is left alone.  If the previously selected
     window is no longer live, then whatever window is selected at the
     end of FORMS remains selected.  The current buffer is restored if
     and only if it is still live when exiting FORMS.

     This macro changes neither the ordering of recently selected
     windows nor the buffer list.

 -- Macro: with-selected-window window forms...
     This macro selects WINDOW, executes FORMS in sequence, then
     restores the previously selected window and current buffer.  The
     ordering of recently selected windows and the buffer list remain
     unchanged unless you deliberately change them within FORMS; for
     example, by calling ‘select-window’ with argument NORECORD ‘nil’.
     Hence, this macro is the preferred way to temporarily work with
     WINDOW as the selected window without needlessly running
     ‘buffer-list-update-hook’.

 -- Function: frame-selected-window &optional frame
     This function returns the window on FRAME that is selected within
     that frame.  FRAME should be a live frame; if omitted or ‘nil’, it
     defaults to the selected frame.

 -- Function: set-frame-selected-window frame window &optional norecord
     This function makes WINDOW the window selected within the frame
     FRAME.  FRAME should be a live frame; if ‘nil’, it defaults to the
     selected frame.  WINDOW should be a live window; if ‘nil’, it
     defaults to the selected window.

     If FRAME is the selected frame, this makes WINDOW the selected
     window.

     If the optional argument NORECORD is non-‘nil’, this function does
     not alter the list of most recently selected windows, nor the
     buffer list.

 -- Function: window-use-time &optional window
     This functions returns the use time of window WINDOW.  WINDOW must
     be a live window and defaults to the selected one.

     The “use time” of a window is not really a time value, but an
     integer that does increase monotonically with each call of
     ‘select-window’ with a ‘nil’ NORECORD argument.  The window with
     the lowest use time is usually called the least recently used
     window while the window with the highest use time is called the
     most recently used one (*note Cyclic Window Ordering::).


File: elisp.info,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

28.10 Cyclic Ordering of Windows
================================

When you use the command ‘C-x o’ (‘other-window’) to select some other
window, it moves through live windows in a specific order.  For any
given configuration of windows, this order never varies.  It is called
the “cyclic ordering of windows”.

   The ordering is determined by a depth-first traversal of each frame’s
window tree, retrieving the live windows which are the leaf nodes of the
tree (*note Windows and Frames::).  If the minibuffer is active, the
minibuffer window is included too.  The ordering is cyclic, so the last
window in the sequence is followed by the first one.

 -- Function: next-window &optional window minibuf all-frames
     This function returns a live window, the one following WINDOW in
     the cyclic ordering of windows.  WINDOW should be a live window; if
     omitted or ‘nil’, it defaults to the selected window.

     The optional argument MINIBUF specifies whether minibuffer windows
     should be included in the cyclic ordering.  Normally, when MINIBUF
     is ‘nil’, a minibuffer window is included only if it is currently
     active; this matches the behavior of ‘C-x o’.  (Note that a
     minibuffer window is active as long as its minibuffer is in use;
     see *note Minibuffers::).

     If MINIBUF is ‘t’, the cyclic ordering includes all minibuffer
     windows.  If MINIBUF is neither ‘t’ nor ‘nil’, minibuffer windows
     are not included even if they are active.

     The optional argument ALL-FRAMES specifies which frames to
     consider:

        • ‘nil’ means to consider windows on WINDOW’s frame.  If the
          minibuffer window is considered (as specified by the MINIBUF
          argument), then frames that share the minibuffer window are
          considered too.

        • ‘t’ means to consider windows on all existing frames.

        • ‘visible’ means to consider windows on all visible frames.

        • 0 means to consider windows on all visible or iconified
          frames.

        • A frame means to consider windows on that specific frame.

        • Anything else means to consider windows on WINDOW’s frame, and
          no others.

     If more than one frame is considered, the cyclic ordering is
     obtained by appending the orderings for those frames, in the same
     order as the list of all live frames (*note Finding All Frames::).

 -- Function: previous-window &optional window minibuf all-frames
     This function returns a live window, the one preceding WINDOW in
     the cyclic ordering of windows.  The other arguments are handled
     like in ‘next-window’.

 -- Command: other-window count &optional all-frames
     This function selects a live window, one COUNT places from the
     selected window in the cyclic ordering of windows.  If COUNT is a
     positive number, it skips COUNT windows forwards; if COUNT is
     negative, it skips −COUNT windows backwards; if COUNT is zero, that
     simply re-selects the selected window.  When called interactively,
     COUNT is the numeric prefix argument.

     The optional argument ALL-FRAMES has the same meaning as in
     ‘next-window’, like a ‘nil’ MINIBUF argument to ‘next-window’.

     This function does not select a window that has a non-‘nil’
     ‘no-other-window’ window parameter (*note Window Parameters::).

 -- Function: walk-windows fun &optional minibuf all-frames
     This function calls the function FUN once for each live window,
     with the window as the argument.

     It follows the cyclic ordering of windows.  The optional arguments
     MINIBUF and ALL-FRAMES specify the set of windows included; these
     have the same arguments as in ‘next-window’.  If ALL-FRAMES
     specifies a frame, the first window walked is the first window on
     that frame (the one returned by ‘frame-first-window’), not
     necessarily the selected window.

     If FUN changes the window configuration by splitting or deleting
     windows, that does not alter the set of windows walked, which is
     determined prior to calling FUN for the first time.

 -- Function: one-window-p &optional no-mini all-frames
     This function returns ‘t’ if the selected window is the only live
     window, and ‘nil’ otherwise.

     If the minibuffer window is active, it is normally considered (so
     that this function returns ‘nil’).  However, if the optional
     argument NO-MINI is non-‘nil’, the minibuffer window is ignored
     even if active.  The optional argument ALL-FRAMES has the same
     meaning as for ‘next-window’.

   The following functions return a window which satisfies some
criterion, without selecting it:

 -- Function: get-lru-window &optional all-frames dedicated not-selected
     This function returns a live window which is heuristically the
     least recently used.  The optional argument ALL-FRAMES has the same
     meaning as in ‘next-window’.

     If any full-width windows are present, only those windows are
     considered.  A minibuffer window is never a candidate.  A dedicated
     window (*note Dedicated Windows::) is never a candidate unless the
     optional argument DEDICATED is non-‘nil’.  The selected window is
     never returned, unless it is the only candidate.  However, if the
     optional argument NOT-SELECTED is non-‘nil’, this function returns
     ‘nil’ in that case.

 -- Function: get-mru-window &optional all-frames dedicated not-selected
     This function is like ‘get-lru-window’, but it returns the most
     recently used window instead.  The meaning of the arguments is the
     same as described for ‘get-lru-window’.

 -- Function: get-largest-window &optional all-frames dedicated
          not-selected
     This function returns the window with the largest area (height
     times width).  The optional argument ALL-FRAMES specifies the
     windows to search, and has the same meaning as in ‘next-window’.

     A minibuffer window is never a candidate.  A dedicated window
     (*note Dedicated Windows::) is never a candidate unless the
     optional argument DEDICATED is non-‘nil’.  The selected window is
     not a candidate if the optional argument NOT-SELECTED is non-‘nil’.
     If the optional argument NOT-SELECTED is non-‘nil’ and the selected
     window is the only candidate, this function returns ‘nil’.

     If there are two candidate windows of the same size, this function
     prefers the one that comes first in the cyclic ordering of windows,
     starting from the selected window.

 -- Function: get-window-with-predicate predicate &optional minibuf
          all-frames default
     This function calls the function PREDICATE for each of the windows
     in the cyclic order of windows in turn, passing it the window as an
     argument.  If the predicate returns non-‘nil’ for any window, this
     function stops and returns that window.  If no such window is
     found, the return value is DEFAULT (which defaults to ‘nil’).

     The optional arguments MINIBUF and ALL-FRAMES specify the windows
     to search, and have the same meanings as in ‘next-window’.


File: elisp.info,  Node: Buffers and Windows,  Next: Switching Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

28.11 Buffers and Windows
=========================

This section describes low-level functions for examining and setting the
contents of windows.  *Note Switching Buffers::, for higher-level
functions for displaying a specific buffer in a window.

 -- Function: window-buffer &optional window
     This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted or ‘nil’ it defaults to the selected window.  If
     WINDOW is an internal window, this function returns ‘nil’.

 -- Function: set-window-buffer window buffer-or-name &optional
          keep-margins
     This function makes WINDOW display BUFFER-OR-NAME.  WINDOW should
     be a live window; if ‘nil’, it defaults to the selected window.
     BUFFER-OR-NAME should be a buffer, or the name of an existing
     buffer.  This function does not change which window is selected,
     nor does it directly change which buffer is current (*note Current
     Buffer::).  Its return value is ‘nil’.

     If WINDOW is “strongly dedicated” to a buffer and BUFFER-OR-NAME
     does not specify that buffer, this function signals an error.
     *Note Dedicated Windows::.

     By default, this function resets WINDOW’s position, display
     margins, fringe widths, and scroll bar settings, based on the local
     variables in the specified buffer.  However, if the optional
     argument KEEP-MARGINS is non-‘nil’, it leaves WINDOW’s display
     margins, fringes and scroll bar settings alone.

     When writing an application, you should normally use the
     higher-level functions described in *note Switching Buffers::,
     instead of calling ‘set-window-buffer’ directly.

     This runs ‘window-scroll-functions’, followed by
     ‘window-configuration-change-hook’.  *Note Window Hooks::.

 -- Variable: buffer-display-count
     This buffer-local variable records the number of times a buffer has
     been displayed in a window.  It is incremented each time
     ‘set-window-buffer’ is called for the buffer.

 -- Variable: buffer-display-time
     This buffer-local variable records the time at which a buffer was
     last displayed in a window.  The value is ‘nil’ if the buffer has
     never been displayed.  It is updated each time ‘set-window-buffer’
     is called for the buffer, with the value returned by ‘current-time’
     (*note Time of Day::).

 -- Function: get-buffer-window &optional buffer-or-name all-frames
     This function returns the first window displaying BUFFER-OR-NAME in
     the cyclic ordering of windows, starting from the selected window
     (*note Cyclic Window Ordering::).  If no such window exists, the
     return value is ‘nil’.

     BUFFER-OR-NAME should be a buffer or the name of a buffer; if
     omitted or ‘nil’, it defaults to the current buffer.  The optional
     argument ALL-FRAMES specifies which windows to consider:

        • ‘t’ means consider windows on all existing frames.
        • ‘visible’ means consider windows on all visible frames.
        • 0 means consider windows on all visible or iconified frames.
        • A frame means consider windows on that frame only.
        • Any other value means consider windows on the selected frame.

     Note that these meanings differ slightly from those of the
     ALL-FRAMES argument to ‘next-window’ (*note Cyclic Window
     Ordering::).  This function may be changed in a future version of
     Emacs to eliminate this discrepancy.

 -- Function: get-buffer-window-list &optional buffer-or-name minibuf
          all-frames
     This function returns a list of all windows currently displaying
     BUFFER-OR-NAME.  BUFFER-OR-NAME should be a buffer or the name of
     an existing buffer.  If omitted or ‘nil’, it defaults to the
     current buffer.  If the currently selected window displays
     BUFFER-OR-NAME, it will be the first in the list returned by this
     function.

     The arguments MINIBUF and ALL-FRAMES have the same meanings as in
     the function ‘next-window’ (*note Cyclic Window Ordering::).  Note
     that the ALL-FRAMES argument does _not_ behave exactly like in
     ‘get-buffer-window’.

 -- Command: replace-buffer-in-windows &optional buffer-or-name
     This command replaces BUFFER-OR-NAME with some other buffer, in all
     windows displaying it.  BUFFER-OR-NAME should be a buffer, or the
     name of an existing buffer; if omitted or ‘nil’, it defaults to the
     current buffer.

     The replacement buffer in each window is chosen via
     ‘switch-to-prev-buffer’ (*note Window History::).  Any dedicated
     window displaying BUFFER-OR-NAME is deleted if possible (*note
     Dedicated Windows::).  If such a window is the only window on its
     frame and there are other frames on the same terminal, the frame is
     deleted as well.  If the dedicated window is the only window on the
     only frame on its terminal, the buffer is replaced anyway.


File: elisp.info,  Node: Switching Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

28.12 Switching to a Buffer in a Window
=======================================

This section describes high-level functions for switching to a specified
buffer in some window.  In general, “switching to a buffer” means to (1)
show the buffer in some window, (2) make that window the selected window
(and its frame the selected frame), and (3) make the buffer the current
buffer.

   Do _not_ use these functions to make a buffer temporarily current
just so a Lisp program can access or modify it.  They have side-effects,
such as changing window histories (*note Window History::), which will
surprise the user if used that way.  If you want to make a buffer
current to modify it in Lisp, use ‘with-current-buffer’,
‘save-current-buffer’, or ‘set-buffer’.  *Note Current Buffer::.

 -- Command: switch-to-buffer buffer-or-name &optional norecord
          force-same-window
     This command attempts to display BUFFER-OR-NAME in the selected
     window and make it the current buffer.  It is often used
     interactively (as the binding of ‘C-x b’), as well as in Lisp
     programs.  The return value is the buffer switched to.

     If BUFFER-OR-NAME is ‘nil’, it defaults to the buffer returned by
     ‘other-buffer’ (*note Buffer List::).  If BUFFER-OR-NAME is a
     string that is not the name of any existing buffer, this function
     creates a new buffer with that name; the new buffer’s major mode is
     determined by the variable ‘major-mode’ (*note Major Modes::).

     Normally, the specified buffer is put at the front of the buffer
     list—both the global buffer list and the selected frame’s buffer
     list (*note Buffer List::).  However, this is not done if the
     optional argument NORECORD is non-‘nil’.

     Sometimes, the selected window may not be suitable for displaying
     the buffer.  This happens if the selected window is a minibuffer
     window, or if the selected window is strongly dedicated to its
     buffer (*note Dedicated Windows::).  In such cases, the command
     normally tries to display the buffer in some other window, by
     invoking ‘pop-to-buffer’ (see below).

     If the optional argument FORCE-SAME-WINDOW is non-‘nil’ and the
     selected window is not suitable for displaying the buffer, this
     function always signals an error when called non-interactively.  In
     interactive use, if the selected window is a minibuffer window,
     this function will try to use some other window instead.  If the
     selected window is strongly dedicated to its buffer, the option
     ‘switch-to-buffer-in-dedicated-window’ described next can be used
     to proceed.

 -- User Option: switch-to-buffer-in-dedicated-window
     This option, if non-‘nil’, allows ‘switch-to-buffer’ to proceed
     when called interactively and the selected window is strongly
     dedicated to its buffer.

     The following values are respected:

     ‘nil’
          Disallows switching and signals an error as in non-interactive
          use.

     ‘prompt’
          Prompts the user whether to allow switching.

     ‘pop’
          Invokes ‘pop-to-buffer’ to proceed.

     ‘t’
          Marks the selected window as non-dedicated and proceeds.

     This option does not affect non-interactive calls of
     ‘switch-to-buffer’.

   By default, ‘switch-to-buffer’ tries to preserve ‘window-point’.
This behavior can be tuned using the following option.

 -- User Option: switch-to-buffer-preserve-window-point
     If this variable is ‘nil’, ‘switch-to-buffer’ displays the buffer
     specified by BUFFER-OR-NAME at the position of that buffer’s
     ‘point’.  If this variable is ‘already-displayed’, it tries to
     display the buffer at its previous position in the selected window,
     provided the buffer is currently displayed in some other window on
     any visible or iconified frame.  If this variable is ‘t’,
     ‘switch-to-buffer’ unconditionally tries to display the buffer at
     its previous position in the selected window.

     This variable is ignored if the buffer is already displayed in the
     selected window or never appeared in it before, or if
     ‘switch-to-buffer’ calls ‘pop-to-buffer’ to display the buffer.

   The next two commands are similar to ‘switch-to-buffer’, except for
the described features.

 -- Command: switch-to-buffer-other-window buffer-or-name &optional
          norecord
     This function displays the buffer specified by BUFFER-OR-NAME in
     some window other than the selected window.  It uses the function
     ‘pop-to-buffer’ internally (see below).

     If the selected window already displays the specified buffer, it
     continues to do so, but another window is nonetheless found to
     display it as well.

     The BUFFER-OR-NAME and NORECORD arguments have the same meanings as
     in ‘switch-to-buffer’.

 -- Command: switch-to-buffer-other-frame buffer-or-name &optional
          norecord
     This function displays the buffer specified by BUFFER-OR-NAME in a
     new frame.  It uses the function ‘pop-to-buffer’ internally (see
     below).

     If the specified buffer is already displayed in another window, in
     any frame on the current terminal, this switches to that window
     instead of creating a new frame.  However, the selected window is
     never used for this.

     The BUFFER-OR-NAME and NORECORD arguments have the same meanings as
     in ‘switch-to-buffer’.

   The above commands use the function ‘pop-to-buffer’, which flexibly
displays a buffer in some window and selects that window for editing.
In turn, ‘pop-to-buffer’ uses ‘display-buffer’ for displaying the
buffer.  Hence, all the variables affecting ‘display-buffer’ will affect
it as well.  *Note Choosing Window::, for the documentation of
‘display-buffer’.

 -- Command: pop-to-buffer buffer-or-name &optional action norecord
     This function makes BUFFER-OR-NAME the current buffer and displays
     it in some window, preferably not the window currently selected.
     It then selects the displaying window.  If that window is on a
     different graphical frame, that frame is given input focus if
     possible (*note Input Focus::).

     If BUFFER-OR-NAME is ‘nil’, it defaults to the buffer returned by
     ‘other-buffer’ (*note Buffer List::).  If BUFFER-OR-NAME is a
     string that is not the name of any existing buffer, this function
     creates a new buffer with that name; the new buffer’s major mode is
     determined by the variable ‘major-mode’ (*note Major Modes::).  In
     any case, that buffer is made current and returned, even when no
     suitable window was found to display it.

     If ACTION is non-‘nil’, it should be a display action to pass to
     ‘display-buffer’ (*note Choosing Window::).  Alternatively, a
     non-‘nil’, non-list value means to pop to a window other than the
     selected one—even if the buffer is already displayed in the
     selected window.

     Like ‘switch-to-buffer’, this function updates the buffer list
     unless NORECORD is non-‘nil’.


File: elisp.info,  Node: Choosing Window,  Next: Display Action Functions,  Prev: Switching Buffers,  Up: Windows

28.13 Choosing a Window for Display
===================================

The command ‘display-buffer’ flexibly chooses a window for display, and
displays a specified buffer in that window.  It can be called
interactively, via the key binding ‘C-x 4 C-o’.  It is also used as a
subroutine by many functions and commands, including ‘switch-to-buffer’
and ‘pop-to-buffer’ (*note Switching Buffers::).

   This command performs several complex steps to find a window to
display in.  These steps are described by means of “display actions”,
which have the form ‘(FUNCTION . ALIST)’.  Here, FUNCTION is either a
function or a list of functions, which we refer to as “action
functions”; ALIST is an association list, which we refer to as an
“action alist”.

   An action function accepts two arguments: the buffer to display and
an action alist.  It attempts to display the buffer in some window,
picking or creating a window according to its own criteria.  If
successful, it returns the window; otherwise, it returns ‘nil’.  *Note
Display Action Functions::, for a list of predefined action functions.

   ‘display-buffer’ works by combining display actions from several
sources, and calling the action functions in turn, until one of them
manages to display the buffer and returns a non-‘nil’ value.

 -- Command: display-buffer buffer-or-name &optional action frame
     This command makes BUFFER-OR-NAME appear in some window, without
     selecting the window or making the buffer current.  The argument
     BUFFER-OR-NAME must be a buffer or the name of an existing buffer.
     The return value is the window chosen to display the buffer.

     The optional argument ACTION, if non-‘nil’, should normally be a
     display action (described above).  ‘display-buffer’ builds a list
     of action functions and an action alist, by consolidating display
     actions from the following sources (in order):

        • The variable ‘display-buffer-overriding-action’.

        • The user option ‘display-buffer-alist’.

        • The ACTION argument.

        • The user option ‘display-buffer-base-action’.

        • The constant ‘display-buffer-fallback-action’.

     Each action function is called in turn, passing the buffer as the
     first argument and the combined action alist as the second
     argument, until one of the functions returns non-‘nil’.  The caller
     can pass ‘(allow-no-window . t)’ as an element of the action alist
     to indicate its readiness to handle the case of not displaying the
     buffer in a window.

     The argument ACTION can also have a non-‘nil’, non-list value.
     This has the special meaning that the buffer should be displayed in
     a window other than the selected one, even if the selected window
     is already displaying it.  If called interactively with a prefix
     argument, ACTION is ‘t’.

     The optional argument FRAME, if non-‘nil’, specifies which frames
     to check when deciding whether the buffer is already displayed.  It
     is equivalent to adding an element ‘(reusable-frames . FRAME)’ to
     the action alist of ACTION.  *Note Display Action Functions::.

 -- Variable: display-buffer-overriding-action
     The value of this variable should be a display action, which is
     treated with the highest priority by ‘display-buffer’.  The default
     value is empty, i.e., ‘(nil . nil)’.

 -- User Option: display-buffer-alist
     The value of this option is an alist mapping conditions to display
     actions.  Each condition may be either a regular expression
     matching a buffer name or a function that takes two arguments: a
     buffer name and the ACTION argument passed to ‘display-buffer’.  If
     the name of the buffer passed to ‘display-buffer’ either matches a
     regular expression in this alist or the function specified by a
     condition returns non-‘nil’, then ‘display-buffer’ uses the
     corresponding display action to display the buffer.

 -- User Option: display-buffer-base-action
     The value of this option should be a display action.  This option
     can be used to define a standard display action for calls to
     ‘display-buffer’.

 -- Constant: display-buffer-fallback-action
     This display action specifies the fallback behavior for
     ‘display-buffer’ if no other display actions are given.


File: elisp.info,  Node: Display Action Functions,  Next: Choosing Window Options,  Prev: Choosing Window,  Up: Windows

28.14 Action Functions for ‘display-buffer’
===========================================

The following basic action functions are defined in Emacs.  Each of
these functions takes two arguments: BUFFER, the buffer to display, and
ALIST, an action alist.  Each action function returns the window if it
succeeds, and ‘nil’ if it fails.

 -- Function: display-buffer-same-window buffer alist
     This function tries to display BUFFER in the selected window.  It
     fails if the selected window is a minibuffer window or is dedicated
     to another buffer (*note Dedicated Windows::).  It also fails if
     ALIST has a non-‘nil’ ‘inhibit-same-window’ entry.

 -- Function: display-buffer-reuse-window buffer alist
     This function tries to display BUFFER by finding a window that is
     already displaying it.

     If ALIST has a non-‘nil’ ‘inhibit-same-window’ entry, the selected
     window is not eligible for reuse.  If ALIST contains a
     ‘reusable-frames’ entry, its value determines which frames to
     search for a reusable window:

        • ‘nil’ means consider windows on the selected frame.
          (Actually, the last non-minibuffer frame.)
        • ‘t’ means consider windows on all frames.
        • ‘visible’ means consider windows on all visible frames.
        • 0 means consider windows on all visible or iconified frames.
        • A frame means consider windows on that frame only.

     Note that these meanings differ slightly from those of the
     ALL-FRAMES argument to ‘next-window’ (*note Cyclic Window
     Ordering::).

     If ALIST contains no ‘reusable-frames’ entry, this function
     normally searches just the selected frame; however, if the variable
     ‘pop-up-frames’ is non-‘nil’, it searches all frames on the current
     terminal.  *Note Choosing Window Options::.

     If this function chooses a window on another frame, it makes that
     frame visible and, unless ALIST contains an ‘inhibit-switch-frame’
     entry (*note Choosing Window Options::), raises that frame if
     necessary.

 -- Function: display-buffer-reuse-mode-window buffer alist
     This function tries to display BUFFER by finding a window that is
     displaying a buffer in a given mode.

     If ALIST contains a ‘mode’ entry, its value is a major mode (a
     symbol) or a list of major modes.  If ALIST contains no ‘mode’
     entry, the current major mode of BUFFER is used.  A window is a
     candidate if it displays a buffer that derives from one of the
     given modes.

     The behavior is also controlled by entries for
     ‘inhibit-same-window’, ‘reusable-frames’ and ‘inhibit-switch-frame’
     as is done in the function ‘display-buffer-reuse-window’.

 -- Function: display-buffer-pop-up-frame buffer alist
     This function creates a new frame, and displays the buffer in that
     frame’s window.  It actually performs the frame creation by calling
     the function specified in ‘pop-up-frame-function’ (*note Choosing
     Window Options::).  If ALIST contains a ‘pop-up-frame-parameters’
     entry, the associated value is added to the newly created frame’s
     parameters.

 -- Function: display-buffer-in-child-frame buffer alist
     This function tries to display BUFFER in a child frame (*note Child
     Frames::) of the selected frame, either reusing an existing child
     frame or by making a new one.  If ALIST has a non-‘nil’
     ‘child-frame-parameters’ entry, the corresponding value is an alist
     of frame parameters to give the new frame.  A ‘parent-frame’
     parameter specifying the selected frame is provided by default.  If
     the child frame should be or become the child of another frame, a
     corresponding entry must be added to ALIST.

     The appearance of child frames is largely dependent on the
     parameters provided via ALIST.  It is advisable to use at least
     ratios to specify the size (*note Size Parameters::) and the
     position (*note Position Parameters::) of the child frame and to
     add the ‘keep-ratio’ in order to make sure that the child frame
     remains visible.  For other parameters that should be considered
     see *note Child Frames::.

 -- Function: display-buffer-use-some-frame buffer alist
     This function tries to display BUFFER by trying to find a frame
     that meets a predicate (by default any frame other than the current
     frame).

     If this function chooses a window on another frame, it makes that
     frame visible and, unless ALIST contains an ‘inhibit-switch-frame’
     entry (*note Choosing Window Options::), raises that frame if
     necessary.

     If ALIST has a non-‘nil’ ‘frame-predicate’ entry, its value is a
     function taking one argument (a frame), returning non-‘nil’ if the
     frame is a candidate; this function replaces the default predicate.

     If ALIST has a non-‘nil’ ‘inhibit-same-window’ entry, the selected
     window is used; thus if the selected frame has a single window, it
     is not used.

 -- Function: display-buffer-pop-up-window buffer alist
     This function tries to display BUFFER by splitting the largest or
     least recently-used window (typically one on the selected frame).
     It actually performs the split by calling the function specified in
     ‘split-window-preferred-function’ (*note Choosing Window
     Options::).

     The size of the new window can be adjusted by supplying
     ‘window-height’ and ‘window-width’ entries in ALIST.  To adjust the
     window’s height, use an entry whose CAR is ‘window-height’ and
     whose CDR is one of:

        • ‘nil’ means to leave the height of the new window alone.

        • A number specifies the desired height of the new window.  An
          integer specifies the number of lines of the window.  A
          floating-point number gives the fraction of the window’s
          height with respect to the height of the frame’s root window.

        • If the CDR specifies a function, that function is called with
          one argument: the new window.  The function is supposed to
          adjust the height of the window; its return value is ignored.
          Suitable functions are ‘shrink-window-if-larger-than-buffer’
          and ‘fit-window-to-buffer’, see *note Resizing Windows::.

     To adjust the window’s width, use an entry whose CAR is
     ‘window-width’ and whose CDR is one of:

        • ‘nil’ means to leave the width of the new window alone.

        • A number specifies the desired width of the new window.  An
          integer specifies the number of columns of the window.  A
          floating-point number gives the fraction of the window’s width
          with respect to the width of the frame’s root window.

        • If the CDR specifies a function, that function is called with
          one argument: the new window.  The function is supposed to
          adjust the width of the window; its return value is ignored.

     If ALIST contains a ‘preserve-size’ entry, Emacs will try to
     preserve the size of the new window during future resize operations
     (*note Preserving Window Sizes::).  The CDR of that entry must be a
     cons cell whose CAR, if non-‘nil’, means to preserve the width of
     the window and whose CDR, if non-‘nil’, means to preserve the
     height of the window.

     This function can fail if no window splitting can be performed for
     some reason (e.g., if the selected frame has an ‘unsplittable’
     frame parameter; *note Buffer Parameters::).

 -- Function: display-buffer-below-selected buffer alist
     This function tries to display BUFFER in a window below the
     selected window.  If there is a window below the selected one and
     that window already displays BUFFER, it reuses that window.

     If there is no such window, this function tries to create a new
     window by splitting the selected one and display BUFFER there.  It
     will also adjust that window’s size provided ALIST contains a
     suitable ‘window-height’ or ‘window-width’ entry, see above.

     If splitting the selected window fails and there is a non-dedicated
     window below the selected one showing some other buffer, it uses
     that window for showing BUFFER.

 -- Function: display-buffer-in-previous-window buffer alist
     This function tries to display BUFFER in a window previously
     showing it.  If ALIST has a non-‘nil’ ‘inhibit-same-window’ entry,
     the selected window is not eligible for reuse.  If ALIST contains a
     ‘reusable-frames’ entry, its value determines which frames to
     search for a suitable window as with ‘display-buffer-reuse-window’.

     If ALIST has a ‘previous-window’ entry, the window specified by
     that entry will override any other window found by the methods
     above, even if that window never showed BUFFER before.

 -- Function: display-buffer-at-bottom buffer alist
     This function tries to display BUFFER in a window at the bottom of
     the selected frame.

     This either splits the window at the bottom of the frame or the
     frame’s root window, or reuses an existing window at the bottom of
     the selected frame.

 -- Function: display-buffer-use-some-window buffer alist
     This function tries to display BUFFER by choosing an existing
     window and displaying the buffer in that window.  It can fail if
     all windows are dedicated to another buffer (*note Dedicated
     Windows::).

 -- Function: display-buffer-no-window buffer alist
     If ALIST has a non-‘nil’ ‘allow-no-window’ entry, then this
     function does not display ‘buffer’.  This allows you to override
     the default action and avoid displaying the buffer.  It is assumed
     that when the caller specifies a non-‘nil’ ‘allow-no-window’ value
     it can handle a ‘nil’ value returned from ‘display-buffer’ in this
     case.

   If the ALIST argument of any of these functions contains a
‘window-parameters’ entry, ‘display-buffer’ assigns the elements of the
associated value as window parameters of the chosen window.

   To illustrate the use of action functions, consider the following
example.

     (display-buffer
      (get-buffer-create "*foo*")
      '((display-buffer-reuse-window
         display-buffer-pop-up-window
         display-buffer-pop-up-frame)
        (reusable-frames . 0)
        (window-height . 10) (window-width . 40)))

Evaluating the form above will cause ‘display-buffer’ to proceed as
follows: If a buffer called *foo* already appears on a visible or
iconified frame, it will reuse its window.  Otherwise, it will try to
pop up a new window or, if that is impossible, a new frame and show the
buffer there.  If all these steps fail, it will proceed using whatever
‘display-buffer-base-action’ and ‘display-buffer-fallback-action’
prescribe.

   Furthermore, ‘display-buffer’ will try to adjust a reused window
(provided *foo* was put by ‘display-buffer’ there before) or a popped-up
window as follows: If the window is part of a vertical combination, it
will set its height to ten lines.  Note that if, instead of the number
10, we specified the function ‘fit-window-to-buffer’, ‘display-buffer’
would come up with a one-line window to fit the empty buffer.  If the
window is part of a horizontal combination, it sets its width to 40
columns.  Whether a new window is vertically or horizontally combined
depends on the shape of the window split and the values of
‘split-window-preferred-function’, ‘split-height-threshold’ and
‘split-width-threshold’ (*note Choosing Window Options::).

   Now suppose we combine this call with a preexisting setup for
‘display-buffer-alist’ as follows.

     (let ((display-buffer-alist
            (cons
             '("\\*foo\\*"
               (display-buffer-reuse-window display-buffer-below-selected)
               (reusable-frames)
               (window-height . 5))
             display-buffer-alist)))
       (display-buffer
        (get-buffer-create "*foo*")
        '((display-buffer-reuse-window
           display-buffer-pop-up-window
           display-buffer-pop-up-frame)
          (reusable-frames . 0)
          (window-height . 10) (window-width . 40))))

This form will have ‘display-buffer’ first try reusing a window that
shows *foo* on the selected frame.  If there’s no such window, it will
try to split the selected window or, if that is impossible, use the
window below the selected window.

   If there’s no window below the selected one, or the window below the
selected one is dedicated to its buffer, ‘display-buffer’ will proceed
as described in the previous example.  Note, however, that when it tries
to adjust the height of any reused or popped-up window, it will in any
case try to set its number of lines to 5 since that value overrides the
corresponding specification in the ACTION argument of ‘display-buffer’.


File: elisp.info,  Node: Choosing Window Options,  Next: Window History,  Prev: Display Action Functions,  Up: Windows

28.15 Additional Options for Displaying Buffers
===============================================

The behavior of the standard display actions of ‘display-buffer’ (*note
Choosing Window::) can be modified by a variety of user options.

 -- User Option: pop-up-windows
     If the value of this variable is non-‘nil’, ‘display-buffer’ is
     allowed to split an existing window to make a new window for
     displaying in.  This is the default.

     This variable is provided mainly for backward compatibility.  It is
     obeyed by ‘display-buffer’ via a special mechanism in
     ‘display-buffer-fallback-action’, which only calls the action
     function ‘display-buffer-pop-up-window’ (*note Display Action
     Functions::) when the value is ‘nil’.  It is not consulted by
     ‘display-buffer-pop-up-window’ itself, which the user may specify
     directly in ‘display-buffer-alist’ etc.

 -- User Option: split-window-preferred-function
     This variable specifies a function for splitting a window, in order
     to make a new window for displaying a buffer.  It is used by the
     ‘display-buffer-pop-up-window’ action function to actually split
     the window (*note Display Action Functions::).

     The default value is ‘split-window-sensibly’, which is documented
     below.  The value must be a function that takes one argument, a
     window, and return either a new window (which will be used to
     display the desired buffer) or ‘nil’ (which means the splitting
     failed).

 -- Function: split-window-sensibly &optional window
     This function tries to split WINDOW, and return the newly created
     window.  If WINDOW cannot be split, it returns ‘nil’.  If WINDOW is
     omitted or ‘nil’, it defaults to the selected window.

     This function obeys the usual rules that determine when a window
     may be split (*note Splitting Windows::).  It first tries to split
     by placing the new window below, subject to the restriction imposed
     by ‘split-height-threshold’ (see below), in addition to any other
     restrictions.  If that fails, it tries to split by placing the new
     window to the right, subject to ‘split-width-threshold’ (see
     below).  If that fails, and the window is the only window on its
     frame, this function again tries to split and place the new window
     below, disregarding ‘split-height-threshold’.  If this fails as
     well, this function gives up and returns ‘nil’.

 -- User Option: split-height-threshold
     This variable, used by ‘split-window-sensibly’, specifies whether
     to split the window placing the new window below.  If it is an
     integer, that means to split only if the original window has at
     least that many lines.  If it is ‘nil’, that means not to split
     this way.

 -- User Option: split-width-threshold
     This variable, used by ‘split-window-sensibly’, specifies whether
     to split the window placing the new window to the right.  If the
     value is an integer, that means to split only if the original
     window has at least that many columns.  If the value is ‘nil’, that
     means not to split this way.

 -- User Option: even-window-sizes
     This variable, if non-‘nil’, causes ‘display-buffer’ to even window
     sizes whenever it reuses an existing window and that window is
     adjacent to the selected one.

     If its value is ‘width-only’, sizes are evened only if the reused
     window is on the left or right of the selected one and the selected
     window is wider than the reused one.  If its value is ‘height-only’
     sizes are evened only if the reused window is above or beneath the
     selected window and the selected window is higher than the reused
     one.  Any other non-‘nil’ value means to even sizes in any of these
     cases provided the selected window is larger than the reused one in
     the sense of their combination.

 -- User Option: pop-up-frames
     If the value of this variable is non-‘nil’, that means
     ‘display-buffer’ may display buffers by making new frames.  The
     default is ‘nil’.

     A non-‘nil’ value also means that when ‘display-buffer’ is looking
     for a window already displaying BUFFER-OR-NAME, it can search any
     visible or iconified frame, not just the selected frame.

     This variable is provided mainly for backward compatibility.  It is
     obeyed by ‘display-buffer’ via a special mechanism in
     ‘display-buffer-fallback-action’, which calls the action function
     ‘display-buffer-pop-up-frame’ (*note Display Action Functions::) if
     the value is non-‘nil’.  (This is done before attempting to split a
     window.)  This variable is not consulted by
     ‘display-buffer-pop-up-frame’ itself, which the user may specify
     directly in ‘display-buffer-alist’ etc.

 -- User Option: pop-up-frame-function
     This variable specifies a function for creating a new frame, in
     order to make a new window for displaying a buffer.  It is used by
     the ‘display-buffer-pop-up-frame’ action function (*note Display
     Action Functions::).

     The value should be a function that takes no arguments and returns
     a frame, or ‘nil’ if no frame could be created.  The default value
     is a function that creates a frame using the parameters specified
     by ‘pop-up-frame-alist’ (see below).

 -- User Option: pop-up-frame-alist
     This variable holds an alist of frame parameters (*note Frame
     Parameters::), which is used by the default function in
     ‘pop-up-frame-function’ to make a new frame.  The default is ‘nil’.

 -- User Option: same-window-buffer-names
     A list of buffer names for buffers that should be displayed in the
     selected window.  If a buffer’s name is in this list,
     ‘display-buffer’ handles the buffer by showing it in the selected
     window.

 -- User Option: same-window-regexps
     A list of regular expressions that specify buffers that should be
     displayed in the selected window.  If the buffer’s name matches any
     of the regular expressions in this list, ‘display-buffer’ handles
     the buffer by showing it in the selected window.

 -- Function: same-window-p buffer-name
     This function returns ‘t’ if displaying a buffer named BUFFER-NAME
     with ‘display-buffer’ would put it in the selected window.


File: elisp.info,  Node: Window History,  Next: Dedicated Windows,  Prev: Choosing Window Options,  Up: Windows

28.16 Window History
====================

Each window remembers in a list the buffers it has previously displayed,
and the order in which these buffers were removed from it.  This history
is used, for example, by ‘replace-buffer-in-windows’ (*note Buffers and
Windows::), and when quitting windows (*note Quitting Windows::).  The
list is automatically maintained by Emacs, but you can use the following
functions to explicitly inspect or alter it:

 -- Function: window-prev-buffers &optional window
     This function returns a list specifying the previous contents of
     WINDOW.  The optional argument WINDOW should be a live window and
     defaults to the selected one.

     Each list element has the form ‘(BUFFER WINDOW-START WINDOW-POS)’,
     where BUFFER is a buffer previously shown in the window,
     WINDOW-START is the window start position (*note Window Start and
     End::) when that buffer was last shown, and WINDOW-POS is the point
     position (*note Window Point::) when that buffer was last shown in
     WINDOW.

     The list is ordered so that earlier elements correspond to more
     recently-shown buffers, and the first element usually corresponds
     to the buffer most recently removed from the window.

 -- Function: set-window-prev-buffers window prev-buffers
     This function sets WINDOW’s previous buffers to the value of
     PREV-BUFFERS.  The argument WINDOW must be a live window and
     defaults to the selected one.  The argument PREV-BUFFERS should be
     a list of the same form as that returned by ‘window-prev-buffers’.

   In addition, each buffer maintains a list of “next buffers”, which is
a list of buffers re-shown by ‘switch-to-prev-buffer’ (see below).  This
list is mainly used by ‘switch-to-prev-buffer’ and
‘switch-to-next-buffer’ for choosing buffers to switch to.

 -- Function: window-next-buffers &optional window
     This function returns the list of buffers recently re-shown in
     WINDOW via ‘switch-to-prev-buffer’.  The WINDOW argument must
     denote a live window or ‘nil’ (meaning the selected window).

 -- Function: set-window-next-buffers window next-buffers
     This function sets the next buffer list of WINDOW to NEXT-BUFFERS.
     The WINDOW argument should be a live window or ‘nil’ (meaning the
     selected window).  The argument NEXT-BUFFERS should be a list of
     buffers.

   The following commands can be used to cycle through the global buffer
list, much like ‘bury-buffer’ and ‘unbury-buffer’.  However, they cycle
according to the specified window’s history list, rather than the global
buffer list.  In addition, they restore window-specific window start and
point positions, and may show a buffer even if it is already shown in
another window.  The ‘switch-to-prev-buffer’ command, in particular, is
used by ‘replace-buffer-in-windows’, ‘bury-buffer’ and ‘quit-window’ to
find a replacement buffer for a window.

 -- Command: switch-to-prev-buffer &optional window bury-or-kill
     This command displays the previous buffer in WINDOW.  The argument
     WINDOW should be a live window or ‘nil’ (meaning the selected
     window).  If the optional argument BURY-OR-KILL is non-‘nil’, this
     means that the buffer currently shown in WINDOW is about to be
     buried or killed and consequently should not be switched to in
     future invocations of this command.

     The previous buffer is usually the buffer shown before the buffer
     currently shown in WINDOW.  However, a buffer that has been buried
     or killed, or has been already shown by a recent invocation of
     ‘switch-to-prev-buffer’, does not qualify as previous buffer.

     If repeated invocations of this command have already shown all
     buffers previously shown in WINDOW, further invocations will show
     buffers from the buffer list of the frame WINDOW appears on (*note
     Buffer List::), trying to skip buffers that are already shown in
     another window on that frame.

 -- Command: switch-to-next-buffer &optional window
     This command switches to the next buffer in WINDOW, thus undoing
     the effect of the last ‘switch-to-prev-buffer’ command in WINDOW.
     The argument WINDOW must be a live window and defaults to the
     selected one.

     If there is no recent invocation of ‘switch-to-prev-buffer’ that
     can be undone, this function tries to show a buffer from the buffer
     list of the frame WINDOW appears on (*note Buffer List::).

   By default ‘switch-to-prev-buffer’ and ‘switch-to-next-buffer’ can
switch to a buffer that is already shown in another window on the same
frame.  The following option can be used to override this behavior.

 -- User Option: switch-to-visible-buffer
     If this variable is non-‘nil’, ‘switch-to-prev-buffer’ and
     ‘switch-to-next-buffer’ may switch to a buffer that is already
     visible on the same frame, provided the buffer was shown in the
     relevant window before.  If it is ‘nil’, ‘switch-to-prev-buffer’
     and ‘switch-to-next-buffer’ always try to avoid switching to a
     buffer that is already visible in another window on the same frame.
     The default is ‘t’.


File: elisp.info,  Node: Dedicated Windows,  Next: Quitting Windows,  Prev: Window History,  Up: Windows

28.17 Dedicated Windows
=======================

Functions for displaying a buffer can be told to not use specific
windows by marking these windows as “dedicated” to their buffers.
‘display-buffer’ (*note Choosing Window::) never uses a dedicated window
for displaying another buffer in it.  ‘get-lru-window’ and
‘get-largest-window’ (*note Cyclic Window Ordering::) do not consider
dedicated windows as candidates when their DEDICATED argument is
non-‘nil’.  The behavior of ‘set-window-buffer’ (*note Buffers and
Windows::) with respect to dedicated windows is slightly different, see
below.

   Functions supposed to remove a buffer from a window or a window from
a frame can behave specially when a window they operate on is dedicated.
We will distinguish three basic cases, namely where (1) the window is
not the only window on its frame, (2) the window is the only window on
its frame but there are other frames on the same terminal left, and (3)
the window is the only window on the only frame on the same terminal.

   In particular, ‘delete-windows-on’ (*note Deleting Windows::) handles
case (2) by deleting the associated frame and case (3) by showing
another buffer in that frame’s only window.  The function
‘replace-buffer-in-windows’ (*note Buffers and Windows::) which is
called when a buffer gets killed, deletes the window in case (1) and
behaves like ‘delete-windows-on’ otherwise.

   When ‘bury-buffer’ (*note Buffer List::) operates on the selected
window (which shows the buffer that shall be buried), it handles case
(2) by calling ‘frame-auto-hide-function’ (*note Quitting Windows::) to
deal with the selected frame.  The other two cases are handled as with
‘replace-buffer-in-windows’.

 -- Function: window-dedicated-p &optional window
     This function returns non-‘nil’ if WINDOW is dedicated to its
     buffer and ‘nil’ otherwise.  More precisely, the return value is
     the value assigned by the last call of ‘set-window-dedicated-p’ for
     WINDOW, or ‘nil’ if that function was never called with WINDOW as
     its argument.  The default for WINDOW is the selected window.

 -- Function: set-window-dedicated-p window flag
     This function marks WINDOW as dedicated to its buffer if FLAG is
     non-‘nil’, and non-dedicated otherwise.

     As a special case, if FLAG is ‘t’, WINDOW becomes “strongly”
     dedicated to its buffer.  ‘set-window-buffer’ signals an error when
     the window it acts upon is strongly dedicated to its buffer and
     does not already display the buffer it is asked to display.  Other
     functions do not treat ‘t’ differently from any non-‘nil’ value.


File: elisp.info,  Node: Quitting Windows,  Next: Side Windows,  Prev: Dedicated Windows,  Up: Windows

28.18 Quitting Windows
======================

When you want to get rid of a window used for displaying a buffer, you
can call ‘delete-window’ or ‘delete-windows-on’ (*note Deleting
Windows::) to remove that window from its frame.  If the buffer is shown
on a separate frame, you might want to call ‘delete-frame’ (*note
Deleting Frames::) instead.  If, on the other hand, a window has been
reused for displaying the buffer, you might prefer showing the buffer
previously shown in that window, by calling the function
‘switch-to-prev-buffer’ (*note Window History::).  Finally, you might
want to either bury (*note Buffer List::) or kill (*note Killing
Buffers::) the window’s buffer.

   The following command uses information on how the window for
displaying the buffer was obtained in the first place, thus attempting
to automate the above decisions for you.

 -- Command: quit-window &optional kill window
     This command quits WINDOW and buries its buffer.  The argument
     WINDOW must be a live window and defaults to the selected one.
     With prefix argument KILL non-‘nil’, it kills the buffer instead of
     burying it.  It calls the function ‘quit-restore-window’ described
     next to deal with the window and its buffer.

 -- Function: quit-restore-window &optional window bury-or-kill
     This function handles WINDOW and its buffer after quitting.  The
     optional argument WINDOW must be a live window and defaults to the
     selected one.  The function’s behavior is determined by the four
     elements of the ‘quit-restore’ window parameter (*note Window
     Parameters::), which is set to ‘nil’ afterwards.

     The window is deleted entirely if: 1) the first element of the
     ‘quit-restore’ parameter is one of ’window or ’frame, 2) the window
     has no history of previously-displayed buffers, and 3) the
     displayed buffer matches the one in the fourth element of the
     ‘quit-restore’ parameter.  If WINDOW is the only window on its
     frame and there are other frames on the frame’s terminal, the value
     of the optional argument BURY-OR-KILL determines how to proceed
     with the window.  If BURY-OR-KILL equals ‘kill’, the frame is
     deleted unconditionally.  Otherwise, the fate of the frame is
     determined by calling ‘frame-auto-hide-function’ (see below) with
     that frame as sole argument.

     If the third element of the ‘quit-restore’ parameter is a list of
     buffer, window start (*note Window Start and End::), and point
     (*note Window Point::), and that buffer is still live, the buffer
     will be displayed, and start and point set accordingly.  If, in
     addition, WINDOW’s buffer was temporarily resized, this function
     will also try to restore the original height of WINDOW.

     Otherwise, if WINDOW was previously used for displaying other
     buffers (*note Window History::), the most recent buffer in that
     history will be displayed.

     The optional argument BURY-OR-KILL specifies how to deal with
     WINDOW’s buffer.  The following values are handled:

     ‘nil’
          This means to not deal with the buffer in any particular way.
          As a consequence, if WINDOW is not deleted, invoking
          ‘switch-to-prev-buffer’ will usually show the buffer again.

     ‘append’
          This means that if WINDOW is not deleted, its buffer is moved
          to the end of WINDOW’s list of previous buffers, so it’s less
          likely that a future invocation of ‘switch-to-prev-buffer’
          will switch to it.  Also, it moves the buffer to the end of
          the frame’s buffer list.

     ‘bury’
          This means that if WINDOW is not deleted, its buffer is
          removed from WINDOW’s list of previous buffers.  Also, it
          moves the buffer to the end of the frame’s buffer list.  This
          value provides the most reliable remedy to not have
          ‘switch-to-prev-buffer’ switch to this buffer again without
          killing the buffer.

     ‘kill’
          This means to kill WINDOW’s buffer.

     Typically, the display routines run by ‘display-buffer’ will set
     the ‘quit-restore’ window parameter correctly.  It’s also possible
     to set it manually, using the following code for displaying BUFFER
     in WINDOW:

          (display-buffer-record-window type window buffer)

          (set-window-buffer window buffer)

          (set-window-prev-buffers window nil)

     Setting the window history to ‘nil’ ensures that a future call to
     ‘quit-window’ can delete the window altogether.

   The following option specifies how to deal with a frame containing
just one window that should be either quit, or whose buffer should be
buried.

 -- User Option: frame-auto-hide-function
     The function specified by this option is called to automatically
     hide frames.  This function is called with one argument—a frame.

     The function specified here is called by ‘bury-buffer’ (*note
     Buffer List::) when the selected window is dedicated and shows the
     buffer to bury.  It is also called by ‘quit-restore-window’ (see
     above) when the frame of the window to quit has been specially
     created for displaying that window’s buffer and the buffer is not
     killed.

     The default is to call ‘iconify-frame’ (*note Visibility of
     Frames::).  Alternatively, you may specify either ‘delete-frame’
     (*note Deleting Frames::) to remove the frame from its display,
     ‘make-frame-invisible’ to make the frame invisible, ‘ignore’ to
     leave the frame unchanged, or any other function that can take a
     frame as its sole argument.

     Note that the function specified by this option is called only if
     the specified frame contains just one live window and there is at
     least one other frame on the same terminal.

     For a particular frame, the value specified here may be overridden
     by that frame’s ‘auto-hide-function’ frame parameter (*note Frame
     Interaction Parameters::).


File: elisp.info,  Node: Side Windows,  Next: Atomic Windows,  Prev: Quitting Windows,  Up: Windows

28.19 Side Windows
==================

Side windows are special windows positioned at any of the four sides of
a frame’s root window (*note Windows and Frames::).  In practice, this
means that the area of the frame’s root window is subdivided into a main
window and a number of side windows surrounding that main window.  The
main window is either a “normal” live window or specifies the area
containing all the normal windows.

   In their most simple form of use, side windows allow to display
specific buffers always in the same area of a frame.  Hence they can be
regarded as a generalization of the concept provided by
‘display-buffer-at-bottom’ (*note Display Action Functions::) to the
remaining sides of a frame.  With suitable customizations, however, side
windows can be also used to provide frame layouts similar to those found
in so-called integrated development environments (IDEs).

* Menu:

* Displaying Buffers in Side Windows:: An action function for displaying
                              buffers in side windows.
* Side Window Options and Functions:: Further tuning of side windows.
* Frame Layouts with Side Windows:: Setting up frame layouts with side
                              windows.


File: elisp.info,  Node: Displaying Buffers in Side Windows,  Next: Side Window Options and Functions,  Up: Side Windows

28.19.1 Displaying Buffers in Side Windows
------------------------------------------

The following action function for ‘display-buffer’ (*note Display Action
Functions::) creates or reuses a side window for displaying the
specified buffer.

 -- Function: display-buffer-in-side-window buffer alist
     This function displays BUFFER in a side window of the selected
     frame.  It returns the window used for displaying BUFFER, ‘nil’ if
     no such window can be found or created.

     ALIST is an association list of symbols and values as for
     ‘display-buffer’.  The following symbols in ALIST are special for
     this function:

     ‘side’
          Denotes the side of the frame where the window shall be
          located.  Valid values are ‘left’, ‘top’, ‘right’ and
          ‘bottom’.  If unspecified, the window is located at the bottom
          of the frame.

     ‘slot’
          Denotes a slot at the specified side where to locate the
          window.  A value of zero means to preferably position the
          window in the middle of the specified side.  A negative value
          means to use a slot preceding (that is, above or on the left
          of) the middle slot.  A positive value means to use a slot
          following (that is, below or on the right of) the middle slot.
          Hence, all windows on a specific side are ordered by their
          ‘slot’ value.  If unspecified, the window is located in the
          middle of the specified side.

     If you specify the same slot on the same side for two or more
     different buffers, the buffer displayed last is shown in the
     corresponding window.  Hence, slots can be used for sharing the
     same side window between buffers.

     This function installs the ‘window-side’ and ‘window-slot’
     parameters (*note Window Parameters::) and makes them persistent.
     It does not install any other window parameters unless they have
     been explicitly provided via a ‘window-parameters’ entry in ALIST.

   By default, side windows cannot be split via ‘split-window’ (*note
Splitting Windows::).  Also, a side window is not reused or split by any
buffer display action (*note Display Action Functions::) unless it is
explicitly specified as target of that action.  Note also that
‘delete-other-windows’ cannot make a side window the only window on its
frame (*note Deleting Windows::).

   Once set up, side windows also change the behavior of the commands
‘switch-to-prev-buffer’ and ‘switch-to-next-buffer’ (*note Window
History::).  In particular, these commands will refrain from showing, in
a side window, buffers that have not been displayed in that window
before.  They will also refrain from having a normal, non-side window
show a buffer that has been already displayed in a side window.  A
notable exception to the latter rule occurs when an application, after
displaying a buffer, resets that buffer’s local variables.


File: elisp.info,  Node: Side Window Options and Functions,  Next: Frame Layouts with Side Windows,  Prev: Displaying Buffers in Side Windows,  Up: Side Windows

28.19.2 Side Window Options and Functions
-----------------------------------------

The following options provide additional control over the placement of
side windows.

 -- User Option: window-sides-vertical
     If non-‘nil’, the side windows on the left and right of a frame
     occupy the frame’s full height.  Otherwise, the side windows on the
     top and bottom of the frame occupy the frame’s full width.

 -- User Option: window-sides-slots
     This option specifies the maximum number of side windows on each
     side of a frame.  The value is a list of four elements specifying
     the number of side window slots on (in this order) the left, top,
     right and bottom of each frame.  If an element is a number, it
     means to display at most that many windows on the corresponding
     side.  If an element is ‘nil’, it means there’s no bound on the
     number of slots on that side.

     If any of the specified values is zero, no window can be created on
     the corresponding side.  ‘display-buffer-in-side-window’ will not
     signal an error in that case, but will return ‘nil’.  If a
     specified value just forbids the creation of an additional side
     window, the most suitable window on that side is reused and may
     have its ‘window-slot’ parameter changed accordingly.

 -- User Option: window-sides-reversed
     This option specifies whether top/bottom side windows should appear
     in reverse order.  When this is ‘nil’, side windows on the top and
     bottom of a frame are always drawn from left to right with
     increasing slot values.  When this is ‘t’, the drawing order is
     reversed and side windows on the top and bottom of a frame are
     drawn from right to left with increasing slot values.

     When this is ‘bidi’, the drawing order is reversed if and only if
     the value of ‘bidi-paragraph-direction’ (*note Bidirectional
     Display::) is ‘right-to-left’ in the buffer displayed in the window
     most recently selected within the main window area of this frame.
     Sometimes that window may be hard to find, so heuristics are used
     to avoid that the drawing order changes inadvertently when another
     window gets selected.

     The layout of side windows on the left or right of a frame is not
     affected by the value of this variable.

   When a frame has side windows, the following function returns the
main window of that frame.

 -- Function: window-main-window &optional frame
     This function returns the main window of the specified FRAME.  The
     optional argument FRAME must be a live frame and defaults to the
     selected one.

     If FRAME has no side windows, it returns FRAME’s root window.
     Otherwise, it returns either an internal non-side window such that
     all other non-side windows on FRAME descend from it, or the single
     live non-side window of FRAME.  Note that the main window of a
     frame cannot be deleted via ‘delete-window’.

   The following command is handy to toggle the appearance of all side
windows on a specified frame.

 -- Command: window-toggle-side-windows &optional frame
     This command toggles side windows on the specified FRAME.  The
     optional argument FRAME must be a live frame and defaults to the
     selected one.

     If FRAME has at least one side window, this command saves the state
     of FRAME’s root window in the FRAME’s ‘window-state’ frame
     parameter and deletes all side windows on FRAME afterwards.

     If FRAME has no side windows, but does have a ‘window-state’
     parameter, this command uses that parameter’s value to restore the
     side windows on FRAME leaving FRAME’s main window alone.

     An error is signaled if FRAME has no side windows and no saved
     state is found for it.


File: elisp.info,  Node: Frame Layouts with Side Windows,  Prev: Side Window Options and Functions,  Up: Side Windows

28.19.3 Frame Layouts with Side Windows
---------------------------------------

Side windows can be used to create more complex frame layouts like those
provided by integrated development environments (IDEs).  In such
layouts, the area of the main window is where the normal editing
activities take place.  Side windows are not conceived for editing in
the usual sense.  Rather, they are supposed to display information
complementary to the current editing activity, like lists of files, tags
or buffers, help information, search or grep results or shell output.

   The layout of such a frame might appear as follows:

          ___________________________________
         |          *Buffer List*            |
         |___________________________________|
         |     |                       |     |
         |  *  |                       |  *  |
         |  d  |                       |  T  |
         |  i  |                       |  a  |
         |  r  |   Main Window Area    |  g  |
         |  e  |                       |  s  |
         |  d  |                       |  *  |
         |  *  |                       |     |
         |_____|_______________________|_____|
         | *help*/*grep*/  |  *shell*/       |
         | *Completions*   |  *compilation*  |
         |_________________|_________________|
         |             Echo Area             |
         |___________________________________|



   The following example illustrates how window parameters (*note Window
Parameters::) can be used with ‘display-buffer-in-side-window’ (*note
Displaying Buffers in Side Windows::) to set up code for producing the
frame layout sketched above.

     (defvar parameters
       '(window-parameters . ((no-other-window . t)
                              (no-delete-other-windows . t))))

     (setq fit-window-to-buffer-horizontally t)
     (setq window-resize-pixelwise t)

     (setq
      display-buffer-alist
      `(("\\*Buffer List\\*" display-buffer-in-side-window
         (side . top) (slot . 0) (window-height . fit-window-to-buffer)
         (preserve-size . (nil . t)) ,parameters)
        ("\\*Tags List\\*" display-buffer-in-side-window
         (side . right) (slot . 0) (window-width . fit-window-to-buffer)
         (preserve-size . (t . nil)) ,parameters)
        ("\\*\\(?:help\\|grep\\|Completions\\)\\*"
         display-buffer-in-side-window
         (side . bottom) (slot . -1) (preserve-size . (nil . t))
         ,parameters)
        ("\\*\\(?:shell\\|compilation\\)\\*" display-buffer-in-side-window
         (side . bottom) (slot . 1) (preserve-size . (nil . t))
         ,parameters)))

   This specifies ‘display-buffer-alist’ entries (*note Choosing
Window::) for buffers with fixed names.  In particular, it asks for
showing ‘*Buffer List*’ with adjustable height at the top of the frame
and ‘*Tags List*’ with adjustable width on the frame’s right.  It also
asks for having the ‘*help*’, ‘*grep*’ and ‘*Completions*’ buffers share
a window on the bottom left side of the frame and the ‘*shell*’ and
‘*compilation*’ buffers appear in a window on the bottom right side of
the frame.

   Note that the option ‘fit-window-to-buffer-horizontally’ must have a
non-‘nil’ value in order to allow horizontal adjustment of windows.
Entries are also added that ask for preserving the height of side
windows at the top and bottom of the frame and the width of side windows
at the left or right of the frame.  To assure that side windows retain
their respective sizes when maximizing the frame, the variable
‘window-resize-pixelwise’ is set to a non-‘nil’ value.  *Note Resizing
Windows::.

   The last form also makes sure that none of the created side windows
are accessible via ‘C-x o’ by installing the ‘no-other-window’ parameter
for each of these windows.  In addition, it makes sure that side windows
are not deleted via ‘C-x 1’ by installing the ‘no-delete-other-windows’
parameter for each of these windows.

   Since ‘dired’ buffers have no fixed names, we use a special function
‘dired-default-directory-on-left’ in order to display a lean directory
buffer on the left side of the frame.

     (defun dired-default-directory-on-left ()
       "Display `default-directory' in side window on left, hiding details."
       (interactive)
       (let ((buffer (dired-noselect default-directory)))
         (with-current-buffer buffer (dired-hide-details-mode t))
         (display-buffer-in-side-window
          buffer `((side . left) (slot . 0)
                   (window-width . fit-window-to-buffer)
                   (preserve-size . (t . nil)) ,parameters))))

   Evaluating the preceding forms and typing, in any order,
‘M-x list-buffers’, ‘C-h f’, ‘M-x shell’, ‘M-x list-tags’, and ‘M-x
dired-default-directory-on-left’ should now reproduce the frame layout
sketched above.


File: elisp.info,  Node: Atomic Windows,  Next: Window Point,  Prev: Side Windows,  Up: Windows

28.20 Atomic Windows
====================

Atomic windows are rectangular compositions of at least two live
windows.  They have the following distinctive characteristics:

   • The function ‘split-window’ (*note Splitting Windows::), when
     applied to a constituent of an atomic window, will try to create
     the new window outside of the atomic window.

   • The function ‘delete-window’ (*note Deleting Windows::), when
     applied to a constituent of an atomic window, will try to delete
     the entire atomic window instead.

   • The function ‘delete-other-windows’ (*note Deleting Windows::),
     when applied to a constituent of an atomic window, will try to make
     the atomic window fill its frame or main window (*note Side
     Windows::).

   This means that the basic groups of functions that alter the window
structure treat an atomic window like a live one, thus preserving the
internal structure of the atomic window.

   Atomic windows are useful to construct and preserve window layouts
that are meaningful only when all involved buffers are shown
simultaneously in a specific manner, such as when showing differences
between file revisions, or the same text in different languages or
markups.  They can also be used to permanently display information
pertinent to a specific window in bars on that window’s sides.

   Atomic windows are implemented with the help of the reserved
‘window-atom’ window parameter (*note Window Parameters::) and an
internal window (*note Basic Windows::) called the root window of the
atomic window.  All windows that are part of the same atomic window have
this root window as their common ancestor and are assigned a non-‘nil’
‘window-atom’ parameter.

   The following function returns the root of the atomic window a
specified window is part of:

 -- Function: window-atom-root &optional window
     This functions returns the root of the atomic window WINDOW is a
     part of.  The specified WINDOW must be a valid window and defaults
     to the selected one.  It returns ‘nil’ if WINDOW is not part of an
     atomic window.

   The most simple approach to make a new atomic window is to take an
existing internal window and apply the following function:

 -- Function: window-make-atom window
     This function converts WINDOW into an atomic window.  The specified
     WINDOW must be an internal window.  All this function does is to
     set the ‘window-atom’ parameter of each descendant of WINDOW to
     ‘t’.

   To create a new atomic window from an existing live window or to add
a new window to an existing atomic window, the following buffer display
action function (*note Display Action Functions::) can be used:

 -- Function: display-buffer-in-atom-window buffer alist
     This function tries to display BUFFER in a new window that will be
     combined with an existing window to form an atomic window.  If the
     existing window is already part of an atomic window, it adds the
     new window to that atomic window.

     The specified ALIST is an association list of symbols and values.
     The following symbols have a special meaning:

     ‘window’
          The value of such an element specifies an existing window the
          new window shall be combined with.  If it specifies an
          internal window, all children of that window become part of
          the atomic window too.  If no window is specified, the new
          window becomes a sibling of the selected window.  The
          ‘window-atom’ parameter of the existing window is set to
          ‘main’ provided that window is live and its ‘window-atom’
          parameter was not already set.

     ‘side’
          The value of such an element denotes the side of the existing
          window where the new window shall be located.  Valid values
          are ‘below’, ‘right’, ‘above’ and ‘left’.  The default is
          ‘below’.  The ‘window-atom’ parameter of the new window is set
          to this value.

     The return value is the new window, ‘nil’ when creating that window
     failed.

   Note that the value of the ‘window-atom’ parameter does not really
matter as long as it is non-‘nil’.  The values assigned by
‘display-buffer-in-atom-window’ just allow for easy retrieval of the
original and the new window after that function has been applied.  Note
also that the ‘window-atom’ parameter is the only window parameter
assigned by ‘display-buffer-in-atom-window’.  Further parameters have to
be set by the application explicitly via a ‘window-parameters’ entry in
ALIST.

   The following code snippet, when applied to a single-window frame,
first splits the selected window and makes the selected and the new
window constituents of an atomic window with their parent as root.  It
then displays the buffer ‘*Messages*’ in a new window at the frame’s
bottom and makes that new window part of the atomic window just created.

     (let ((window (split-window-right)))
       (window-make-atom (window-parent window))
       (display-buffer-in-atom-window
        (get-buffer-create "*Messages*")
        `((window . ,(window-parent window)) (window-height . 5))))

   At this moment typing ‘C-x 2’ in any window of that frame produces a
new window at the bottom of the frame.  Typing ‘C-x 3’ instead will put
the new window at the frame’s right.  In either case, typing now ‘C-x 1’
in any window of the atomic window will remove the new window only.
Typing ‘C-x 0’ in any window of the atomic window will make that new
window fill the frame.


File: elisp.info,  Node: Window Point,  Next: Window Start and End,  Prev: Atomic Windows,  Up: Windows

28.21 Windows and Point
=======================

Each window has its own value of point (*note Point::), independent of
the value of point in other windows displaying the same buffer.  This
makes it useful to have multiple windows showing one buffer.

   • The window point is established when a window is first created; it
     is initialized from the buffer’s point, or from the window point of
     another window opened on the buffer if such a window exists.

   • Selecting a window sets the value of point in its buffer from the
     window’s value of point.  Conversely, deselecting a window sets the
     window’s value of point from that of the buffer.  Thus, when you
     switch between windows that display a given buffer, the point value
     for the selected window is in effect in the buffer, while the point
     values for the other windows are stored in those windows.

   • As long as the selected window displays the current buffer, the
     window’s point and the buffer’s point always move together; they
     remain equal.

   Emacs displays the cursor, by default as a rectangular block, in each
window at the position of that window’s point.  When the user switches
to another buffer in a window, Emacs moves that window’s cursor to where
point is in that buffer.  If the exact position of point is hidden
behind some display element, such as a display string or an image, Emacs
displays the cursor immediately before or after that display element.

 -- Function: window-point &optional window
     This function returns the current position of point in WINDOW.  For
     a nonselected window, this is the value point would have (in that
     window’s buffer) if that window were selected.  The default for
     WINDOW is the selected window.

     When WINDOW is the selected window, the value returned is the value
     of point in that window’s buffer.  Strictly speaking, it would be
     more correct to return the top-level value of point, outside of any
     ‘save-excursion’ forms.  But that value is hard to find.

 -- Function: set-window-point window position
     This function positions point in WINDOW at position POSITION in
     WINDOW’s buffer.  It returns POSITION.

     If WINDOW is selected, this simply does ‘goto-char’ in WINDOW’s
     buffer.

 -- Variable: window-point-insertion-type
     This variable specifies the marker insertion type (*note Marker
     Insertion Types::) of ‘window-point’.  The default is ‘nil’, so
     ‘window-point’ will stay behind text inserted there.


File: elisp.info,  Node: Window Start and End,  Next: Textual Scrolling,  Prev: Window Point,  Up: Windows

28.22 The Window Start and End Positions
========================================

Each window maintains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the “display-start” position of the window (or just the
“start”).  The character after this position is the one that appears at
the upper left corner of the window.  It is usually, but not inevitably,
at the beginning of a text line.

   After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window start
to the start of a line.  This prevents certain operations from leaving
the window start at a meaningless point within a line.  This feature may
interfere with testing some Lisp code by executing it using the commands
of Lisp mode, because they trigger this readjustment.  To test such
code, put it into a command and bind the command to a key.

 -- Function: window-start &optional window
     This function returns the display-start position of window WINDOW.
     If WINDOW is ‘nil’, the selected window is used.

     When you create a window, or display a different buffer in it, the
     display-start position is set to a display-start position recently
     used for the same buffer, or to ‘point-min’ if the buffer doesn’t
     have any.

     Redisplay updates the window-start position (if you have not
     specified it explicitly since the previous redisplay)—to make sure
     point appears on the screen.  Nothing except redisplay
     automatically changes the window-start position; if you move point,
     do not expect the window-start position to change in response until
     after the next redisplay.

 -- Function: window-group-start &optional window
     This function is like ‘window-start’, except that when WINDOW is a
     part of a group of windows (*note Window Group::),
     ‘window-group-start’ returns the start position of the entire
     group.  This condition holds when the buffer local variable
     ‘window-group-start-function’ is set to a function.  In this case,
     ‘window-group-start’ calls the function with the single argument
     WINDOW, then returns its result.

 -- Function: window-end &optional window update
     This function returns the position where display of its buffer ends
     in WINDOW.  The default for WINDOW is the selected window.

     Simply changing the buffer text or moving point does not update the
     value that ‘window-end’ returns.  The value is updated only when
     Emacs redisplays and redisplay completes without being preempted.

     If the last redisplay of WINDOW was preempted, and did not finish,
     Emacs does not know the position of the end of display in that
     window.  In that case, this function returns ‘nil’.

     If UPDATE is non-‘nil’, ‘window-end’ always returns an up-to-date
     value for where display ends, based on the current ‘window-start’
     value.  If a previously saved value of that position is still
     valid, ‘window-end’ returns that value; otherwise it computes the
     correct value by scanning the buffer text.

     Even if UPDATE is non-‘nil’, ‘window-end’ does not attempt to
     scroll the display if point has moved off the screen, the way real
     redisplay would do.  It does not alter the ‘window-start’ value.
     In effect, it reports where the displayed text will end if
     scrolling is not required.

 -- Function: window-group-end &optional window update
     This function is like ‘window-end’, except that when WINDOW is a
     part of a group of windows (*note Window Group::),
     ‘window-group-end’ returns the end position of the entire group.
     This condition holds when the buffer local variable
     ‘window-group-end-function’ is set to a function.  In this case,
     ‘window-group-end’ calls the function with the two arguments WINDOW
     and UPDATE, then returns its result.  The argument UPDATE has the
     same meaning as in ‘window-end’.

 -- Function: set-window-start window position &optional noforce
     This function sets the display-start position of WINDOW to POSITION
     in WINDOW’s buffer.  It returns POSITION.

     The display routines insist that the position of point be visible
     when a buffer is displayed.  Normally, they change the
     display-start position (that is, scroll the window) whenever
     necessary to make point visible.  However, if you specify the start
     position with this function using ‘nil’ for NOFORCE, it means you
     want display to start at POSITION even if that would put the
     location of point off the screen.  If this does place point off
     screen, the display routines move point to the left margin on the
     middle line in the window.

     For example, if point is 1 and you set the start of the window
     to 37, the start of the next line, point will be above the top of
     the window.  The display routines will automatically move point if
     it is still 1 when redisplay occurs.  Here is an example:

          ;; Here is what ‘foo’ looks like before executing
          ;;   the ‘set-window-start’ expression.

          ---------- Buffer: foo ----------
          ★This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------

          (set-window-start
           (selected-window)
           (save-excursion
             (goto-char 1)
             (forward-line 1)
             (point)))
          ⇒ 37

          ;; Here is what ‘foo’ looks like after executing
          ;;   the ‘set-window-start’ expression.
          ---------- Buffer: foo ----------
          2
          3
          ★4
          5
          6
          ---------- Buffer: foo ----------

     If NOFORCE is non-‘nil’, and POSITION would place point off screen
     at the next redisplay, then redisplay computes a new window-start
     position that works well with point, and thus POSITION is not used.

 -- Function: set-window-group-start window position &optional noforce
     This function is like ‘set-window-start’, except that when WINDOW
     is a part of a group of windows (*note Window Group::),
     ‘set-window-group-start’ sets the start position of the entire
     group.  This condition holds when the buffer local variable
     ‘set-window-group-start-function’ is set to a function.  In this
     case, ‘set-window-group-start’ calls the function with the three
     arguments WINDOW, POSITION, and NOFORCE, then returns its result.
     The arguments POSITION and NOFORCE in this function have the same
     meaning as in ‘set-window-start’.

 -- Function: pos-visible-in-window-p &optional position window
          partially
     This function returns non-‘nil’ if POSITION is within the range of
     text currently visible on the screen in WINDOW.  It returns ‘nil’
     if POSITION is scrolled vertically out of view.  Locations that are
     partially obscured are not considered visible unless PARTIALLY is
     non-‘nil’.  The argument POSITION defaults to the current position
     of point in WINDOW; WINDOW defaults to the selected window.  If
     POSITION is ‘t’, that means to check either the first visible
     position of the last screen line in WINDOW, or the end-of-buffer
     position, whichever comes first.

     This function considers only vertical scrolling.  If POSITION is
     out of view only because WINDOW has been scrolled horizontally,
     ‘pos-visible-in-window-p’ returns non-‘nil’ anyway.  *Note
     Horizontal Scrolling::.

     If POSITION is visible, ‘pos-visible-in-window-p’ returns ‘t’ if
     PARTIALLY is ‘nil’; if PARTIALLY is non-‘nil’, and the character
     following POSITION is fully visible, it returns a list of the form
     ‘(X Y)’, where X and Y are the pixel coordinates relative to the
     top left corner of the window; otherwise it returns an extended
     list of the form ‘(X Y RTOP RBOT ROWH VPOS)’, where RTOP and RBOT
     specify the number of off-window pixels at the top and bottom of
     the row at POSITION, ROWH specifies the visible height of that row,
     and VPOS specifies the vertical position (zero-based row number) of
     that row.

     Here is an example:

          ;; If point is off the screen now, recenter it now.
          (or (pos-visible-in-window-p
               (point) (selected-window))
              (recenter 0))

 -- Function: pos-visible-in-window-group-p &optional position window
          partially
     This function is like ‘pos-visible-in-window-p’, except that when
     WINDOW is a part of a group of windows (*note Window Group::),
     ‘pos-visible-in-window-group-p’ tests the visibility of POS in the
     entire group, not just in the single WINDOW.  This condition holds
     when the buffer local variable
     ‘pos-visible-in-window-group-p-function’ is set to a function.  In
     this case ‘pos-visible-in-window-group-p’ calls the function with
     the three arguments POSITION, WINDOW, and PARTIALLY, then returns
     its result.  The arguments POSITION and PARTIALLY have the same
     meaning as in ‘pos-visible-in-window-p’.

 -- Function: window-line-height &optional line window
     This function returns the height of text line LINE in WINDOW.  If
     LINE is one of ‘header-line’ or ‘mode-line’, ‘window-line-height’
     returns information about the corresponding line of the window.
     Otherwise, LINE is a text line number starting from 0.  A negative
     number counts from the end of the window.  The default for LINE is
     the current line in WINDOW; the default for WINDOW is the selected
     window.

     If the display is not up to date, ‘window-line-height’ returns
     ‘nil’.  In that case, ‘pos-visible-in-window-p’ may be used to
     obtain related information.

     If there is no line corresponding to the specified LINE,
     ‘window-line-height’ returns ‘nil’.  Otherwise, it returns a list
     ‘(HEIGHT VPOS YPOS OFFBOT)’, where HEIGHT is the height in pixels
     of the visible part of the line, VPOS and YPOS are the vertical
     position in lines and pixels of the line relative to the top of the
     first text line, and OFFBOT is the number of off-window pixels at
     the bottom of the text line.  If there are off-window pixels at the
     top of the (first) text line, YPOS is negative.


File: elisp.info,  Node: Textual Scrolling,  Next: Vertical Scrolling,  Prev: Window Start and End,  Up: Windows

28.23 Textual Scrolling
=======================

“Textual scrolling” means moving the text up or down through a window.
It works by changing the window’s display-start location.  It may also
change the value of ‘window-point’ to keep point on the screen (*note
Window Point::).

   The basic textual scrolling functions are ‘scroll-up’ (which scrolls
forward) and ‘scroll-down’ (which scrolls backward).  In these function
names, “up” and “down” refer to the direction of motion of the buffer
text relative to the window.  Imagine that the text is written on a long
roll of paper and that the scrolling commands move the paper up and
down.  Thus, if you are looking at the middle of a buffer and repeatedly
call ‘scroll-down’, you will eventually see the beginning of the buffer.

   Unfortunately, this sometimes causes confusion, because some people
tend to think in terms of the opposite convention: they imagine the
window moving over text that remains in place, so that “down” commands
take you to the end of the buffer.  This convention is consistent with
fact that such a command is bound to a key named <PageDown> on modern
keyboards.

   Textual scrolling functions (aside from ‘scroll-other-window’) have
unpredictable results if the current buffer is not the one displayed in
the selected window.  *Note Current Buffer::.

   If the window contains a row taller than the height of the window
(for example in the presence of a large image), the scroll functions
will adjust the window’s vertical scroll position to scroll the
partially visible row.  Lisp callers can disable this feature by binding
the variable ‘auto-window-vscroll’ to ‘nil’ (*note Vertical
Scrolling::).

 -- Command: scroll-up &optional count
     This function scrolls forward by COUNT lines in the selected
     window.

     If COUNT is negative, it scrolls backward instead.  If COUNT is
     ‘nil’ (or omitted), the distance scrolled is
     ‘next-screen-context-lines’ lines less than the height of the
     window’s text area.

     If the selected window cannot be scrolled any further, this
     function signals an error.  Otherwise, it returns ‘nil’.

 -- Command: scroll-down &optional count
     This function scrolls backward by COUNT lines in the selected
     window.

     If COUNT is negative, it scrolls forward instead.  In other
     respects, it behaves the same way as ‘scroll-up’ does.

 -- Command: scroll-up-command &optional count
     This behaves like ‘scroll-up’, except that if the selected window
     cannot be scrolled any further and the value of the variable
     ‘scroll-error-top-bottom’ is ‘t’, it tries to move to the end of
     the buffer instead.  If point is already there, it signals an
     error.

 -- Command: scroll-down-command &optional count
     This behaves like ‘scroll-down’, except that if the selected window
     cannot be scrolled any further and the value of the variable
     ‘scroll-error-top-bottom’ is ‘t’, it tries to move to the beginning
     of the buffer instead.  If point is already there, it signals an
     error.

 -- Command: scroll-other-window &optional count
     This function scrolls the text in another window upward COUNT
     lines.  Negative values of COUNT, or ‘nil’, are handled as in
     ‘scroll-up’.

     You can specify which buffer to scroll by setting the variable
     ‘other-window-scroll-buffer’ to a buffer.  If that buffer isn’t
     already displayed, ‘scroll-other-window’ displays it in some
     window.

     When the selected window is the minibuffer, the next window is
     normally the leftmost one immediately above it.  You can specify a
     different window to scroll, when the minibuffer is selected, by
     setting the variable ‘minibuffer-scroll-window’.  This variable has
     no effect when any other window is selected.  When it is non-‘nil’
     and the minibuffer is selected, it takes precedence over
     ‘other-window-scroll-buffer’.  *Note Definition of
     minibuffer-scroll-window::.

     When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, ‘scroll-other-window’ attempts to scroll the minibuffer.  If
     the minibuffer contains just one line, it has nowhere to scroll to,
     so the line reappears after the echo area momentarily displays the
     message ‘End of buffer’.

 -- Variable: other-window-scroll-buffer
     If this variable is non-‘nil’, it tells ‘scroll-other-window’ which
     buffer’s window to scroll.

 -- User Option: scroll-margin
     This option specifies the size of the scroll margin—a minimum
     number of lines between point and the top or bottom of a window.
     Whenever point gets within this many lines of the top or bottom of
     the window, redisplay scrolls the text automatically (if possible)
     to move point out of the margin, closer to the center of the
     window.

 -- User Option: maximum-scroll-margin
     This variable limits the effective value of ‘scroll-margin’ to a
     fraction of the current window line height.  For example, if the
     current window has 20 lines and ‘maximum-scroll-margin’ is 0.1,
     then the scroll margins will never be larger than 2 lines, no
     matter how big ‘scroll-margin’ is.

     ‘maximum-scroll-margin’ itself has a maximum value of 0.5, which
     allows setting margins large to keep the cursor at the middle line
     of the window (or two middle lines if the window has an even number
     of lines).  If it’s set to a larger value (or any value other than
     a float between 0.0 and 0.5) then the default value of 0.25 will be
     used instead.

 -- User Option: scroll-conservatively
     This variable controls how scrolling is done automatically when
     point moves off the screen (or into the scroll margin).  If the
     value is a positive integer N, then redisplay scrolls the text up
     to N lines in either direction, if that will bring point back into
     proper view.  This behavior is called “conservative scrolling”.
     Otherwise, scrolling happens in the usual way, under the control of
     other variables such as ‘scroll-up-aggressively’ and
     ‘scroll-down-aggressively’.

     The default value is zero, which means that conservative scrolling
     never happens.

 -- User Option: scroll-down-aggressively
     The value of this variable should be either ‘nil’ or a fraction F
     between 0 and 1.  If it is a fraction, that specifies where on the
     screen to put point when scrolling down.  More precisely, when a
     window scrolls down because point is above the window start, the
     new start position is chosen to put point F part of the window
     height from the top.  The larger F, the more aggressive the
     scrolling.

     A value of ‘nil’ is equivalent to .5, since its effect is to center
     point.  This variable automatically becomes buffer-local when set
     in any fashion.

 -- User Option: scroll-up-aggressively
     Likewise, for scrolling up.  The value, F, specifies how far point
     should be placed from the bottom of the window; thus, as with
     ‘scroll-up-aggressively’, a larger value scrolls more aggressively.

 -- User Option: scroll-step
     This variable is an older variant of ‘scroll-conservatively’.  The
     difference is that if its value is N, that permits scrolling only
     by precisely N lines, not a smaller number.  This feature does not
     work with ‘scroll-margin’.  The default value is zero.

 -- User Option: scroll-preserve-screen-position
     If this option is ‘t’, whenever a scrolling command moves point
     off-window, Emacs tries to adjust point to keep the cursor at its
     old vertical position in the window, rather than the window edge.

     If the value is non-‘nil’ and not ‘t’, Emacs adjusts point to keep
     the cursor at the same vertical position, even if the scrolling
     command didn’t move point off-window.

     This option affects all scroll commands that have a non-‘nil’
     ‘scroll-command’ symbol property.

 -- User Option: next-screen-context-lines
     The value of this variable is the number of lines of continuity to
     retain when scrolling by full screens.  For example, ‘scroll-up’
     with an argument of ‘nil’ scrolls so that this many lines at the
     bottom of the window appear instead at the top.  The default value
     is ‘2’.

 -- User Option: scroll-error-top-bottom
     If this option is ‘nil’ (the default), ‘scroll-up-command’ and
     ‘scroll-down-command’ simply signal an error when no more scrolling
     is possible.

     If the value is ‘t’, these commands instead move point to the
     beginning or end of the buffer (depending on scrolling direction);
     only if point is already on that position do they signal an error.

 -- Command: recenter &optional count
     This function scrolls the text in the selected window so that point
     is displayed at a specified vertical position within the window.
     It does not move point with respect to the text.

     If COUNT is a non-negative number, that puts the line containing
     point COUNT lines down from the top of the window.  If COUNT is a
     negative number, then it counts upward from the bottom of the
     window, so that −1 stands for the last usable line in the window.

     If COUNT is ‘nil’ (or a non-‘nil’ list), ‘recenter’ puts the line
     containing point in the middle of the window.  If COUNT is ‘nil’,
     this function may redraw the frame, according to the value of
     ‘recenter-redisplay’.

     When ‘recenter’ is called interactively, COUNT is the raw prefix
     argument.  Thus, typing ‘C-u’ as the prefix sets the COUNT to a
     non-‘nil’ list, while typing ‘C-u 4’ sets COUNT to 4, which
     positions the current line four lines from the top.

     With an argument of zero, ‘recenter’ positions the current line at
     the top of the window.  The command ‘recenter-top-bottom’ offers a
     more convenient way to achieve this.

 -- Function: recenter-window-group &optional count
     This function is like ‘recenter’, except that when the selected
     window is part of a group of windows (*note Window Group::),
     ‘recenter-window-group’ scrolls the entire group.  This condition
     holds when the buffer local variable
     ‘recenter-window-group-function’ is set to a function.  In this
     case, ‘recenter-window-group’ calls the function with the argument
     COUNT, then returns its result.  The argument COUNT has the same
     meaning as in ‘recenter’, but with respect to the entire window
     group.

 -- User Option: recenter-redisplay
     If this variable is non-‘nil’, calling ‘recenter’ with a ‘nil’
     argument redraws the frame.  The default value is ‘tty’, which
     means only redraw the frame if it is a tty frame.

 -- Command: recenter-top-bottom &optional count
     This command, which is the default binding for ‘C-l’, acts like
     ‘recenter’, except if called with no argument.  In that case,
     successive calls place point according to the cycling order defined
     by the variable ‘recenter-positions’.

 -- User Option: recenter-positions
     This variable controls how ‘recenter-top-bottom’ behaves when
     called with no argument.  The default value is ‘(middle top
     bottom)’, which means that successive calls of
     ‘recenter-top-bottom’ with no argument cycle between placing point
     at the middle, top, and bottom of the window.


File: elisp.info,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Textual Scrolling,  Up: Windows

28.24 Vertical Fractional Scrolling
===================================

“Vertical fractional scrolling” means shifting text in a window up or
down by a specified multiple or fraction of a line.  Each window has a
“vertical scroll position”, which is a number, never less than zero.  It
specifies how far to raise the contents of the window.  Raising the
window contents generally makes all or part of some lines disappear off
the top, and all or part of some other lines appear at the bottom.  The
usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents are scrolled up half the normal line
height.  If it is 3.3, that means the window contents are scrolled up
somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

 -- Function: window-vscroll &optional window pixels-p
     This function returns the current vertical scroll position of
     WINDOW.  The default for WINDOW is the selected window.  If
     PIXELS-P is non-‘nil’, the return value is measured in pixels,
     rather than in units of the normal line height.

          (window-vscroll)
               ⇒ 0

 -- Function: set-window-vscroll window lines &optional pixels-p
     This function sets WINDOW’s vertical scroll position to LINES.  If
     WINDOW is ‘nil’, the selected window is used.  The argument LINES
     should be zero or positive; if not, it is taken as zero.

     The actual vertical scroll position must always correspond to an
     integral number of pixels, so the value you specify is rounded
     accordingly.

     The return value is the result of this rounding.

          (set-window-vscroll (selected-window) 1.2)
               ⇒ 1.13

     If PIXELS-P is non-‘nil’, LINES specifies a number of pixels.  In
     this case, the return value is LINES.

 -- Variable: auto-window-vscroll
     If this variable is non-‘nil’, the ‘line-move’, ‘scroll-up’, and
     ‘scroll-down’ functions will automatically modify the vertical
     scroll position to scroll through display rows that are taller than
     the height of the window, for example in the presence of large
     images.


File: elisp.info,  Node: Horizontal Scrolling,  Next: Coordinates and Windows,  Prev: Vertical Scrolling,  Up: Windows

28.25 Horizontal Scrolling
==========================

“Horizontal scrolling” means shifting the image in the window left or
right by a specified multiple of the normal character width.  Each
window has a “horizontal scroll position”, which is a number, never less
than zero.  It specifies how far to shift the contents left.  Shifting
the window contents left generally makes all or part of some characters
disappear off the left, and all or part of some other characters appear
at the right.  The usual value is zero.

   The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

   Because we read from side to side in the inner loop, and from top to
bottom in the outer loop, the effect of horizontal scrolling is not like
that of textual or vertical scrolling.  Textual scrolling involves
selection of a portion of text to display, and vertical scrolling moves
the window contents contiguously; but horizontal scrolling causes part
of _each line_ to go off screen.

   Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

   If ‘auto-hscroll-mode’ is set, redisplay automatically alters the
horizontal scrolling of a window as necessary to ensure that point is
always visible.  However, you can still set the horizontal scrolling
value explicitly.  The value you specify serves as a lower bound for
automatic scrolling, i.e., automatic scrolling will not scroll a window
to a column less than the specified one.

   The default value of ‘auto-hscroll-mode’ is ‘t’; setting it to
‘current-line’ activates a variant of automatic horizontal scrolling
whereby only the line showing the cursor is horizontally scrolled to
make point visible, the rest of the window is left either unscrolled, or
at the minimum scroll amount set by ‘scroll-left’ and ‘scroll-right’,
see below.

 -- Command: scroll-left &optional count set-minimum
     This function scrolls the selected window COUNT columns to the left
     (or to the right if COUNT is negative).  The default for COUNT is
     the window width, minus 2.

     The return value is the total amount of leftward horizontal
     scrolling in effect after the change—just like the value returned
     by ‘window-hscroll’ (below).

     Note that text in paragraphs whose base direction is right-to-left
     (*note Bidirectional Display::) moves in the opposite direction:
     e.g., it moves to the right when ‘scroll-left’ is invoked with a
     positive value of COUNT.

     Once you scroll a window as far right as it can go, back to its
     normal position where the total leftward scrolling is zero,
     attempts to scroll any farther right have no effect.

     If SET-MINIMUM is non-‘nil’, the new scroll amount becomes the
     lower bound for automatic scrolling; that is, automatic scrolling
     will not scroll a window to a column less than the value returned
     by this function.  Interactive calls pass non-‘nil’ for
     SET-MINIMUM.

 -- Command: scroll-right &optional count set-minimum
     This function scrolls the selected window COUNT columns to the
     right (or to the left if COUNT is negative).  The default for COUNT
     is the window width, minus 2.  Aside from the direction of
     scrolling, this works just like ‘scroll-left’.

 -- Function: window-hscroll &optional window
     This function returns the total leftward horizontal scrolling of
     WINDOW—the number of columns by which the text in WINDOW is
     scrolled left past the left margin.  (In right-to-left paragraphs,
     the value is the total amount of the rightward scrolling instead.)
     The default for WINDOW is the selected window.

     The return value is never negative.  It is zero when no horizontal
     scrolling has been done in WINDOW (which is usually the case).

          (window-hscroll)
               ⇒ 0
          (scroll-left 5)
               ⇒ 5
          (window-hscroll)
               ⇒ 5

 -- Function: set-window-hscroll window columns
     This function sets horizontal scrolling of WINDOW.  The value of
     COLUMNS specifies the amount of scrolling, in terms of columns from
     the left margin (right margin in right-to-left paragraphs).  The
     argument COLUMNS should be zero or positive; if not, it is taken as
     zero.  Fractional values of COLUMNS are not supported at present.

     Note that ‘set-window-hscroll’ may appear not to work if you test
     it by evaluating a call with ‘M-:’ in a simple way.  What happens
     is that the function sets the horizontal scroll value and returns,
     but then redisplay adjusts the horizontal scrolling to make point
     visible, and this overrides what the function did.  You can observe
     the function’s effect if you call it while point is sufficiently
     far from the left margin that it will remain visible.

     The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               ⇒ 10

   Here is how you can determine whether a given position POSITION is
off the screen due to horizontal scrolling:

     (defun hscroll-on-screen (window position)
       (save-excursion
         (goto-char position)
         (and
          (>= (- (current-column) (window-hscroll window)) 0)
          (< (- (current-column) (window-hscroll window))
             (window-width window)))))


File: elisp.info,  Node: Coordinates and Windows,  Next: Mouse Window Auto-selection,  Prev: Horizontal Scrolling,  Up: Windows

28.26 Coordinates and Windows
=============================

This section describes functions that report positions of and within a
window.  Most of these functions report positions relative to an origin
at the native position of the window’s frame (*note Frame Geometry::).
Some functions report positions relative to the origin of the display of
the window’s frame.  In any case, the origin has the coordinates (0, 0)
and X and Y coordinates increase rightward and downward respectively.

   For the following functions, X and Y coordinates are reported in
integer character units, i.e., numbers of lines and columns
respectively.  On a graphical display, each “line” and “column”
corresponds to the height and width of the default character specified
by the frame’s default font (*note Frame Font::).

 -- Function: window-edges &optional window body absolute pixelwise
     This function returns a list of the edge coordinates of WINDOW.  If
     WINDOW is omitted or ‘nil’, it defaults to the selected window.

     The return value has the form ‘(LEFT TOP RIGHT BOTTOM)’.  These
     list elements are, respectively, the X coordinate of the leftmost
     column occupied by the window, the Y coordinate of the topmost row,
     the X coordinate one column to the right of the rightmost column,
     and the Y coordinate one row down from the bottommost row.

     Note that these are the actual outer edges of the window, including
     any header line, mode line, scroll bar, fringes, window divider and
     display margins.  On a text terminal, if the window has a neighbor
     on its right, its right edge includes the separator line between
     the window and its neighbor.

     If the optional argument BODY is ‘nil’, this means to return the
     edges corresponding to the total size of WINDOW.  BODY non-‘nil’
     means to return the edges of WINDOW’s body (aka text area).  If
     BODY is non-‘nil’, WINDOW must specify a live window.

     If the optional argument ABSOLUTE is ‘nil’, this means to return
     edges relative to the native position of WINDOW’s frame.  ABSOLUTE
     non-‘nil’ means to return coordinates relative to the origin (0, 0)
     of WINDOW’s display.  On non-graphical systems this argument has no
     effect.

     If the optional argument PIXELWISE is ‘nil’, this means to return
     the coordinates in terms of the default character width and height
     of WINDOW’s frame (*note Frame Font::), rounded if necessary.
     PIXELWISE non-‘nil’ means to return the coordinates in pixels.
     Note that the pixel specified by RIGHT and BOTTOM is immediately
     outside of these edges.  If ABSOLUTE is non-‘nil’, PIXELWISE is
     implicitly non-‘nil’ too.

 -- Function: window-body-edges &optional window
     This function returns the edges of WINDOW’s body (*note Window
     Sizes::).  Calling ‘(window-body-edges window)’ is equivalent to
     calling ‘(window-edges window t)’, see above.

   The following functions can be used to relate a set of frame-relative
coordinates to a window:

 -- Function: window-at x y &optional frame
     This function returns the live window at the coordinates X and Y
     given in default character sizes (*note Frame Font::) relative to
     the native position of FRAME (*note Frame Geometry::).

     If there is no window at that position, the return value is ‘nil’.
     If FRAME is omitted or ‘nil’, it defaults to the selected frame.

 -- Function: coordinates-in-window-p coordinates window
     This function checks whether a window WINDOW occupies the frame
     relative coordinates COORDINATES, and if so, which part of the
     window that is.  WINDOW should be a live window.

     COORDINATES should be a cons cell of the form ‘(X . Y)’, where X
     and Y are given in default character sizes (*note Frame Font::)
     relative to the native position of WINDOW’s frame (*note Frame
     Geometry::).

     If there is no window at the specified position, the return value
     is ‘nil’ .  Otherwise, the return value is one of the following:

     ‘(RELX . RELY)’
          The coordinates are inside WINDOW.  The numbers RELX and RELY
          are the equivalent window-relative coordinates for the
          specified position, counting from 0 at the top left corner of
          the window.

     ‘mode-line’
          The coordinates are in the mode line of WINDOW.

     ‘header-line’
          The coordinates are in the header line of WINDOW.

     ‘right-divider’
          The coordinates are in the divider separating WINDOW from a
          window on the right.

     ‘bottom-divider’
          The coordinates are in the divider separating WINDOW from a
          window beneath.

     ‘vertical-line’
          The coordinates are in the vertical line between WINDOW and
          its neighbor to the right.  This value occurs only if the
          window doesn’t have a scroll bar; positions in a scroll bar
          are considered outside the window for these purposes.

     ‘left-fringe’
     ‘right-fringe’
          The coordinates are in the left or right fringe of the window.

     ‘left-margin’
     ‘right-margin’
          The coordinates are in the left or right margin of the window.

     ‘nil’
          The coordinates are not in any part of WINDOW.

     The function ‘coordinates-in-window-p’ does not require a frame as
     argument because it always uses the frame that WINDOW is on.

   The following functions return window positions in pixels, rather
than character units.  Though mostly useful on graphical displays, they
can also be called on text terminals, where the screen area of each text
character is taken to be one pixel.

 -- Function: window-pixel-edges &optional window
     This function returns a list of pixel coordinates for the edges of
     WINDOW.  Calling ‘(window-pixel-edges window)’ is equivalent to
     calling ‘(window-edges window nil nil t)’, see above.

 -- Function: window-body-pixel-edges &optional window
     This function returns the pixel edges of WINDOW’s body.  Calling
     ‘(window-body-pixel-edges window)’ is equivalent to calling
     ‘(window-edges window t nil t)’, see above.

   The following functions return window positions in pixels, relative
to the origin of the display screen rather than that of the frame:

 -- Function: window-absolute-pixel-edges &optional window
     This function returns the pixel coordinates of WINDOW relative to
     an origin at (0, 0) of the display of WINDOW’s frame.  Calling
     ‘(window-absolute-pixel-edges)’ is equivalent to calling
     ‘(window-edges window nil t t)’, see above.

 -- Function: window-absolute-body-pixel-edges &optional window
     This function returns the pixel coordinates of WINDOW’s body
     relative to an origin at (0, 0) of the display of WINDOW’s frame.
     Calling ‘(window-absolute-body-pixel-edges window)’ is equivalent
     to calling ‘(window-edges window t t t)’, see above.

     Combined with ‘set-mouse-absolute-pixel-position’, this function
     can be used to move the mouse pointer to an arbitrary buffer
     position visible in some window:

          (let ((edges (window-absolute-body-pixel-edges))
                (position (pos-visible-in-window-p nil nil t)))
            (set-mouse-absolute-pixel-position
             (+ (nth 0 edges) (nth 0 position))
             (+ (nth 1 edges) (nth 1 position))))

     On a graphical terminal this form “warps” the mouse cursor to the
     upper left corner of the glyph at the selected window’s point.  A
     position calculated this way can be also used to show a tooltip
     window there.

   The following function returns the screen coordinates of a buffer
position visible in a window:

 -- Function: window-absolute-pixel-position &optional position window
     If the buffer position POSITION is visible in window WINDOW, this
     function returns the display coordinates of the upper/left corner
     of the glyph at POSITION.  The return value is a cons of the X- and
     Y-coordinates of that corner, relative to an origin at (0, 0) of
     WINDOW’s display.  It returns ‘nil’ if POSITION is not visible in
     WINDOW.

     WINDOW must be a live window and defaults to the selected window.
     POSITION defaults to the value of ‘window-point’ of WINDOW.

     This means that in order to move the mouse pointer to the position
     of point in the selected window, it’s sufficient to write:

          (let ((position (window-absolute-pixel-position)))
            (set-mouse-absolute-pixel-position
             (car position) (cdr position)))

   The following function returns the largest rectangle that can be
inscribed in a window without covering text displayed in that window.

 -- Function: window-largest-empty-rectangle &optional window count
          min-width min-height positions left
     This function calculates the dimensions of the largest empty
     rectangle that can be inscribed in the specified WINDOW’s text
     area.  WINDOW must be a live window and defaults to the selected
     one.

     The return value is a triple of the width and the start and end
     y-coordinates of the largest rectangle that can be inscribed into
     the empty space (space not displaying any text) of the text area of
     WINDOW.  No x-coordinates are returned by this function—any such
     rectangle is assumed to end at the right edge of WINDOW’s text
     area.  If no empty space can be found, the return value is ‘nil’.

     The optional argument COUNT, if non-‘nil’, specifies a maximum
     number of rectangles to return.  This means that the return value
     is a list of triples specifying rectangles with the largest
     rectangle first.  COUNT can be also a cons cell whose car specifies
     the number of rectangles to return and whose CDR, if non-‘nil’,
     states that all rectangles returned must be disjoint.

     The optional arguments MIN-WIDTH and MIN-HEIGHT, if non-‘nil’,
     specify the minimum width and height of any rectangle returned.

     The optional argument POSITIONS, if non-‘nil’, is a cons cell whose
     CAR specifies the uppermost and whose CDR specifies the lowermost
     pixel position that must be covered by any rectangle returned.
     These positions measure from the start of the text area of WINDOW.

     The optional argument LEFT, if non-‘nil’, means to return values
     suitable for buffers displaying right to left text.  In that case,
     any rectangle returned is assumed to start at the left edge of
     WINDOW’s text area.

     Note that this function has to retrieve the dimensions of each line
     of WINDOW’s glyph matrix via ‘window-lines-pixel-dimensions’ (*note
     Size of Displayed Text::).  Hence, this function may also return
     ‘nil’ when the current glyph matrix of WINDOW is not up-to-date.

