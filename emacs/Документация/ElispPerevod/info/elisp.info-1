This is elisp.info, produced by makeinfo version 6.1 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp.info,  Node: Top,  Next: Introduction,  Up: (dir)

Emacs Lisp
**********

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 26.1.

   Copyright © 1990–1996, 1998–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”

* Menu:

* Introduction::            Введение и соглашения.

* Lisp Data Types::         Типы данных объектов в Emacs Lisp.
* Numbers::                 Числа и арифметические функции.
* Strings and Characters::  Строки и функции, которые работают над ними.
* Lists::                   Списки, ячейки cons и связанные с ними функции.
* Sequences Arrays Vectors::  Списки, строки и векторы называются
                              последовательностями. Некоторые функции действуют
                              на любую последовательность. Здесь также
                              приводится описание векторов.
* Records::                 Составные объекты с определенными
                            программистами типами.
* Hash Tables::             Очень быстрые таблицы поиска.
* Symbols::                 Символы обозначают имена, уникально.

* Evaluation::              Как оцениваются выражения Lisp.
* Control Structures::      Условные, циклы, нелокальные выходы.
* Variables::               Использование символов в программах для
                            обозначения значений.
* Functions::               Функция - это программа Lisp, которая может
                            быть вызвана из других функций.
* Macros::                  Макросы - это способ расширить язык Lisp.
* Customization::           Настройка переменных и настройка отображения.

* Loading::                 Чтение файлов Lisp-кода в Lisp.
* Byte Compilation::        Компиляция делает программы более быстрыми.
* Debugging::               Инструменты и советы по отладке программ Lisp.

* Read and Print::          Преобразование объектов Lisp в текст и обратно.
* Minibuffers::             Использование минибуфера для чтения ввода.
* Command Loop::            Как работает контур команды редактора и как
                            вы можете вызвать его подпрограммы.
* Keymaps::                 Определение привязок от ключей к командам.
* Modes::                   Определение основных и второстепенных режимов.
* Documentation::           Написание и использование строк документации.

* Files::                   Доступ к файлам.
* Backups and Auto-Saving:: Управление созданием резервных копий и
                            автоматическим сохранением файлов.
* Buffers::                 Создание и использование объектов буфера.
* Windows::                 Манипулирование окнами и отображение буферов.
* Frames::                  Создание нескольких окон на системном уровне.
* Positions::               Позиции буфера и функции движения.
* Markers::                 Маркеры представляют позиции и автоматически
                            обновляются при изменении текста.

* Text::                    Изучение и изменение текста в буферах.
* Non-ASCII Characters::    Текст, не содержащий ASCII в буферах и строках.
* Searching and Matching::  Поиск буферов для строк или регулярных выражений.
* Syntax Tables::           Таблица синтаксиса управляет разбором слов и списков.
* Abbrevs::                 Как работает режим Abbrev и его структуры данных.

* Threads::                 Параллельность в Emacs Lisp.
* Processes::               Запуск и связь с подпроцессами.
* Display::                 Особенности управления экраном.
* System Interface::        Получение идентификатора пользователя, типа
                            системы, переменных среды и т. Д.

* Packaging::               Подготовка кода Lisp для распространения.

Приложенеия

* Antinews::                Информация для пользователей, понижающих рейтинг до Emacs 25.
* GNU Free Documentation License:: Лицензия на эту документацию.
* GPL::                     Условия копирования и изменения GNU Emacs.
* Tips::                    Консультирование и кодирование для Emacs Lisp.
* GNU Emacs Internals::     Запуск и завершение Emacs; внутренние
                            структуры данных.
* Standard Errors::         Список некоторых стандартных символов ошибки.
* Standard Keymaps::        Список некоторых стандартных раскладок.
* Standard Hooks::          Список некоторых стандартных переменных.

* Index::                   Индекс включает понятия, функции, переменные
                            и другие термины.



 — The Detailed Node Listing —
 ———————————

Вот и другие узлы, которые являются подузнями тех, которые уже перечислены,
упомянутые здесь, чтобы вы могли добраться до них за один шаг:

Вступление

* Caveats::                 Недостатки и запрос о помощи.
* Lisp History::            Emacs Lisp происходит от Maclisp.
* Conventions::             Как отформатировано руководство.
* Version Info::            Какая версия Emacs запущена?
* Acknowledgments::         Авторы, редакторы и спонсоры этого руководства.

Условные обозначения

* Some Terms::              Объяснение терминов, которые мы используем в этом
                            руководстве.
* nil and t::               Как используются символы ‘nil’ и ‘t’.
* Evaluation Notation::     Формат, который мы используем для примеров оценки.
* Printing Notation::       Формат, который мы используем, когда примеры
                            печатают текст.
* Error Messages::          Формат, который мы используем для примеров ошибок.
* Buffer Text Notation::    Формат, который мы используем для содержимого
                            буфера в примерах.
* Format of Descriptions::  Обозначение для описания функций, переменных и т.Д.

Формат описания

* A Sample Function Description::  Описание мнимой функции, ‘foo’.
* A Sample Variable Description::  Описание мнимой переменной, ‘electric-future-map’.

Типы данных Lisp

* Printed Representation::  Как объекты Lisp представлены в виде текста.
* Comments::                Комментарии и их соглашения о форматировании.
* Programming Types::       Типы, найденные во всех системах Lisp.
* Editing Types::           Типы, специфичные для Emacs.
* Circular Objects::        Прочитайте синтаксис для круговой структуры.
* Type Predicates::         Тесты, связанные с типами.
* Equality Predicates::     Испытания равенства между любыми двумя объектами.

Типы программирования

* Integer Type::        Числа без дробных частей.
* Floating-Point Type:: Числа с дробными частями и с большим диапазоном.
* Character Type::      Представление букв, цифр и управляющих символов.
* Symbol Type::         Многоцелевой объект, который ссылается на список
                        функций, переменных или свойств и имеет уникальный
                        идентификатор.
* Sequence Type::       Оба списка и массивы классифицируются как
                        последовательности.
* Cons Cell Type::      Минусы и списки (которые сделаны из cons-ячеек).
* Array Type::          Массивы включают строки и векторы.
* String Type::         Массив символов (эффективный).
* Vector Type::         Одномерные массивы.
* Char-Table Type::     Одномерные разреженные массивы, индексированные
                        символами.
* Bool-Vector Type::    Одномерные массивы ‘t’ или ‘nil’.
* Hash Table Type::     Супер-быстрые таблицы поиска.
* Function Type::       Кусок исполняемого кода, который вы можете вызвать
                        из другого места.
* Macro Type::          Метод расширения выражения в другое выражение, более
                        фундаментальный, но менее симпатичный.
* Primitive Function Type::     Функция, написанная на C, вызываемая из Lisp.
* Byte-Code Type::      Функция, написанная в Lisp, затем скомпилирована.
* Record Type::         Составные объекты с определенными программистами типами.
* Type Descriptors::    Объекты, содержащие информацию о типах.
* Autoload Type::       Тип, используемый для автоматической загрузки редко
                        используемых функций.
* Finalizer Type::      Запускает код, когда он больше не доступен.

Символьный Тип

* Basic Char Syntax::       Синтаксис для регулярных символов.
* General Escape Syntax::   Как указать символы по их кодам.
* Ctl-Char Syntax::         Синтаксис для управляющих символов.
* Meta-Char Syntax::        Синтаксис для метасимволов.
* Other Char Bits::         Синтаксис для гипер-, супер- и альт-символов.

Cons Cell and List Types

* Box Diagrams::            Рисование изображений списков.
* Dotted Pair Notation::    Общий синтаксис для cons-ячеек.
* Association List Type::   Специально составленный список.

Строковый Тип

* Syntax for Strings::      Как указать строки Lisp.
* Non-ASCII in Strings::    Международные символы в строках.
* Nonprinting Characters::  Буквенные непечатаемые символы в строках.
* Text Props and Strings::  Строки с текстовыми свойствами.

Типы Редактора

* Buffer Type::             Основной объект редактирования.
* Marker Type::             Позиция в буфере.
* Window Type::             Буферы отображаются в окнах.
* Frame Type::              Окно подразделяет фреймы.
* Terminal Type::           Терминальное устройство отображает фреймы.
* Window Configuration Type::  Запись способа разделения кадра.
* Frame Configuration Type::   Запись состояния всех кадров.
* Process Type::            Подпроцесс Emacs, работающий на базовой ОС.
* Thread Type::             Поток выполнения Emacs Lisp.
* Mutex Type::              Исключительная блокировка синхронизации потоков.
* Condition Variable Type::    Переменная условия для синхронизации потоков.
* Stream Type::             Получать или отправлять символы.
* Keymap Type::             Какую функцию вызывает нажатие клавиши.
* Overlay Type::            Как отображается оверлей.
* Font Type::               Шрифты для отображения текста.

Числа

* Integer Basics::          Представление и диапазон целых чисел.
* Float Basics::            Представление и диапазон значений с плавающей запятой.
* Predicates on Numbers::   Тестирование чисел.
* Comparison of Numbers::   Предикаты равенства и неравенства.
* Numeric Conversions::     Преобразование float в integer и наоборот.
* Arithmetic Operations::   Как добавить, вычесть, умножить и разделить.
* Rounding Operations::     Явное округление чисел с плавающей запятой.
* Bitwise Operations::      Логический и, или, не, сдвиг.
* Math Functions::          Тригонометрические, экспоненциальные и
                            логарифмические функции.
* Random Numbers::          Получение случайных целых чисел, предсказуемых
                            или нет.

Строки и Символы

* String Basics::           Основные свойства строк и символов.
* Predicates for Strings::  Проверка того, является ли объект строкой или
                            символом.
* Creating Strings::        Функции для выделения новых строк.
* Modifying Strings::       Изменение содержимого существующей строки.
* Text Comparison::         Сравнение символов или строк.
* String Conversion::       Преобразование символов в строки и наоборот.
* Formatting Strings::      ‘format’: Аналог Emacs ‘printf’.
* Case Conversion::         Функции преобразования регистра.
* Case Tables::             Настройка преобразования регистра.

Списки

* Cons Cells::              Как списки сделаны из cons-ячеек.
* List-related Predicates:: Является ли этот объект списком? Сравнение двух
                            списков.
* List Elements::           Извлечение фрагментов списка.
* Building Lists::          Создание структуры списка.
* List Variables::          Изменение списков, хранящихся в переменных.
* Modifying Lists::         Хранение новых произведений в существующем списке.
* Sets And Lists::          Список может представлять собой конечный
                            математический набор.
* Association Lists::       Список может представлять собой конечное отношение
                            или отображение.
* Property Lists::          Список парных элементов.

Изменение существующей структуры списка

* Setcar::                  Замена элемента в списке.
* Setcdr::                  Замена части основы списка.
                            Это можно использовать для удаления или добавления
                            элементов.
* Rearrangement::           Переупорядочение элементов в списке;
                            объединение списков.

Списки свойств

* Plists and Alists::       Сравнение преимуществ списков свойств и списков
                            ассоциаций.
* Plist Access::            Доступ к спискам свойств, хранящимся в другом месте.

Последовательности, массивы и векторы

* Sequence Functions::      Функции, которые принимают любую последовательность.
* Arrays::                  Характеристики массивов в Emacs Lisp.
* Array Functions::         Функции специально для массивов.
* Vectors::                 Специальные характеристики векторов Emacs Lisp.
* Vector Functions::        Функции специально для векторов.
* Char-Tables::             Как работать с char-tables.
* Bool-Vectors::            Как работать с bool-векторами.
* Rings::                   Управление кольцом фиксированного размера объектов.

документация

* Record Functions::        Функции для записей.
* Backward Compatibility::  Совместимость для cl-defstruct.

Хэш-таблицы

* Creating Hash::           Функции для создания хеш-таблиц.
* Hash Access::             Чтение и запись содержимого хэш-таблицы.
* Defining Hash::           Определение новых методов сравнения.
* Other Hash::              Разнообразный.

Символы

* Symbol Components::       Символы имеют имена, значения, определения
                            функций и списки свойств.
* Definitions::             В определении говорится, как будет использоваться
                            символ.
* Creating Symbols::        Как символы сохраняются уникальными.
* Symbol Properties::       Каждый символ имеет список свойств для записи
                            различной информации.

Свойства символа

* Symbol Plists::           Доступ к свойствам символа.
* Standard Properties::     Стандартные значения свойств символа.

Оценка

* Intro Eval::              Оценка в схеме вещей.
* Forms::                   Как оцениваются различные типы объектов.
* Quoting::                 Избегать оценки (поставить константы в программу).
* Backquote::               Простое построение структуры списка.
* Eval::                    Как явно вызывать интерпретатор Lisp.

Виды форм

* Self-Evaluating Forms::   Формы, которые оцениваются сами собой.
* Symbol Forms::            Символы оцениваются как переменные.
* Classifying Lists::       Как различать различные виды форм списка.
* Function Indirection::    Когда символ появляется первым списка, мы находим
                            действительную функцию через символ.
* Function Forms::          Формы, вызывающие функции.
* Macro Forms::             Формы, вызывающие макросы.
* Special Forms::           Специальные формы - своеобразные примитивы,
                            большинство из которых чрезвычайно важны.
* Autoloading::             Функции, установленные для загрузки файлов,
                            содержащих их реальные определения.

Контрольные структуры

* Sequencing::              Оценка в текстовом порядке.
* Conditionals::            ‘if’, ‘cond’, ‘when’, ‘unless’.
* Combining Conditions::    ‘and’, ‘or’, ‘not’.
* Iteration::               ‘while’ петли.
* Generators::              Общие последовательности и сопрограммы.
* Nonlocal Exits::          Выпрыгивание из последовательности.

Conditionals

* Pattern matching case statement::  Как пользоваться ‘pcase’.

Нелокальные выходы

* Catch and Throw::         Нелокальные выходы для собственных целей программы.
* Examples of Catch::       Показывается, как можно записать такие нелокальные
                            выходы.
* Errors::                  Как сигнализировать и обрабатывать ошибки.
* Cleanups::                Организация запуска формы очистки при
                            возникновении ошибки.

Ошибки

* Signaling Errors::        Как сообщить об ошибке.
* Processing of Errors::    Что Emacs делает, когда вы сообщаете об ошибке.
* Handling Errors::         Как вы можете уловить ошибки и продолжить
                            выполнение.
* Error Symbols::           Как ошибки классифицируются для их захвата.

переменные

* Global Variables::        Переменные значения, которые существуют постоянно,
                            везде.
* Constant Variables::      Переменные, которые никогда не меняются.
* Local Variables::         Значения переменных, которые существуют только
                            временно.
* Void Variables::          Символы, которые не имеют значений.
* Defining Variables::      Определение говорит, что символ используется как
                            переменная.
* Tips for Defining::       О чем вы должны думать, когда вы определяете
                            переменную.
* Accessing Variables::     Изучение значений переменных, имена которых
                            известны только во время выполнения.
* Setting Variables::       Сохранение новых значений в переменных.
* Watching Variables::      Запуск функции при изменении переменной.
* Variable Scoping::        Как Lisp выбирает среди локальных и глобальных
                            значений.
* Buffer-Local Variables::  Значения переменных действуют только в одном буфере.
* File Local Variables::    Обработка списков локальных переменных в файлах.
* Directory Local Variables:: Локальные переменные, общие для всех файлов в
                              каталоге.
* Connection Local Variables::  Локальные переменные, общие для удаленных
                                подключений.
* Variable Aliases::        Переменные, которые являются псевдонимами для
                            других переменных.
* Variables with Restricted Values::  Непостоянные переменные, значение которых
                                      может быть _not_ произвольным
                                      объектом Lisp.
* Generalized Variables::   Расширение понятия переменных.

Правила для определения переменных привязок

* Dynamic Binding::         Значение по умолчанию для привязки локальных
                            переменных в Emacs.
* Dynamic Binding Tips::    Избегайте проблем с динамической привязкой.
* Lexical Binding::         Другой тип привязки локальной переменной.
* Using Lexical Binding::   Как включить лексическое связывание.

Локальные переменные буфера

* Intro to Buffer-Local::   Введение и концепции.
* Creating Buffer-Local::   Создание и уничтожение буферов-локальных привязок.
* Default Value::           Значение по умолчанию отображается в буферах,
                            которые не имеют собственных локальных значений
                            буфера.

Обобщенные переменные

* Setting Generalized Variables::   Макрос ‘setf’.
* Adding Generalized Variables::    Определение новых форм ‘setf’.

Функции

* What Is a Function::      Функции Лиспа против примитивов; терминология.
* Lambda Expressions::      Как функции выражаются как объекты Lisp.
* Function Names::          Символом может служить имя функции.
* Defining Functions::      Выражения Lisp для определения функций.
* Calling Functions::       Как использовать существующую функцию.
* Mapping Functions::       Применение функции к каждому элементу списка и т.д.
* Anonymous Functions::     Лямбда-выражения - это функции без имен.
* Generic Functions::       Полиморфизм, стиль Emacs.
* Function Cells::          Доступ или определение функции символа.
* Closures::                Функции, которые включают лексическую среду.
* Advising Functions::      Добавление к определению функции.
* Obsolete Functions::      Объявление устаревших функций.
* Inline Functions::        Определение функций, которые компилятор будет
                            расширять inline.
* Declare Form::            Добавление дополнительной информации о функции.
* Declaring Functions::     Сообщение компилятору о том, что функция определена.
* Function Safety::         Определение того, безопасна ли функция для вызова.
* Related Topics::          Перекрестные ссылки на конкретные примитивы Lisp,
                            которые имеют особое значение для работы функций.

Лямбда-выражения

* Lambda Components::       Части лямбда-выражения.
* Simple Lambda::           Простой пример.
* Argument List::           Детали и особенности списков аргументов.
* Function Documentation::  Как разместить документацию в функции.

Консультирование функций Emacs Lisp

* Core Advising Primitives::  Примитивы для управления советами.
* Advising Named Functions::  Консультирование названных функций.
* Advice combinators::        Способы составления совета.
* Porting old advice::        Адаптация кода с использованием старой defadvice.

Макросы

* Simple Macro::            Простой пример.
* Expansion::               Как, когда и почему макросы расширяются.
* Compiling Macros::        Как макросы расширяются компилятором.
* Defining Macros::         Как написать определение макроса.
* Problems with Macros::    Не оценивайте макрокоманды слишком много раз. Не
                            скрывайте переменные пользователя.
* Indenting Macros::        Указание способа вызова макросов с отступом.

Общие проблемы с использованием макросов

* Wrong Time::             Делайте работу в расширении, а не в макросе.
* Argument Evaluation::    Расширение должно оценивать каждый макрос один раз.
* Surprising Local Vars::  Локальные переменные привязки в расширении требуют
                           особого внимания.
* Eval During Expansion::  Не оценивайте их; положить их в расширение.
* Repeated Expansion::     Избегайте зависимости от того, сколько раз было
                           сделано расширение.

Настройки параметров

* Common Keywords::         Общие аргументы ключевых слов для всех видов
                            объявлений настройки.
* Group Definitions::       Написание определений групп настройки.
* Variable Definitions::    Объявление параметров пользователя.
* Customization Types::     Указание типа пользовательской опции.
* Applying Customizations:: Функции для применения настроек настройки.
* Custom Themes::           Написание пользовательских тем.

Типы настроек

* Simple Types::            Простые типы настройки: sexp, integer и т.д.
* Composite Types::         Создавайте новые типы из других типов или данных.
* Splicing into Lists::     Объединение элементов в список с помощью
                            ‘:inline’.
* Type Keywords::           Параметров ключевых слов в типе настройки.
* Defining New Types::      Дайте вашему типу имя.

загрузка

* How Programs Do Loading:: Функция ‘load’ и другие.
* Load Suffixes::           Подробности о суффиксах ‘load’.
* Library Search::          Поиск библиотеки для загрузки.
* Loading Non-ASCII::       Non-ASCII в файлах Emacs Lisp.
* Autoload::                Настройка функции автозагрузки.
* Repeated Loading::        Меры предосторожности при загрузке файла дважды.
* Named Features::          Загрузка библиотеки, если она еще не загружена.
* Where Defined::           Поиск того, какой файл определил определенный
                            символ.
* Unloading::               Как выгрузить загруженную библиотеку.
* Hooks for Loading::       Предоставление кода для запуска при загрузке
                            определенных библиотек.
* Dynamic Modules::         Модули предоставляют дополнительные примитивы Lisp.

Байт-компиляция

* Speed of Byte-Code::      Пример ускорения работы с байтовой компиляцией.
* Compilation Functions::   Функции байт компиляции.
* Docs and Compilation::    Динамическая загрузка строк документации.
* Dynamic Loading::         Динамическая загрузка отдельных функций.
* Eval During Compile::     Код, который будет оцениваться при компиляции.
* Compiler Errors::         Обработка сообщений об ошибках компилятора.
* Byte-Code Objects::       Тип данных, используемый для байт-скомпилированных
                            функций.
* Disassembly::             Дизассемблирование байт-кода; как читать байт-код.

Отладка программ Lisp

* Debugger::                Отладчик для оценщика Emacs Lisp.
* Edebug::                  Исходный уровень Emacs Lisp отладчик.
* Syntax Errors::           Как найти синтаксические ошибки.
* Test Coverage::           Убедитесь, что вы проверили все участки в
                            своем коде.
* Profiling::               Измерение ресурсов, используемых вашим кодом.

Отладчик Lisp

* Error Debugging::         Запуск отладчика при возникновении ошибки.
* Infinite Loops::          Остановка и отладка программы, которая не
                            завершается.
* Function Debugging::      Запуск его при вызове определенной функции.
* Variable Debugging::      Ввод его при изменении переменной.
* Explicit Debug::          Ввод его в определенный момент в программе.
* Using Debugger::          Что делает отладчик; что вы видите во время этого.
* Debugger Commands::       Команды, используемые в отладчике.
* Invoking the Debugger::   Как вызвать функцию ‘debug’.
* Internals of Debugger::   Подпрограммы отладчика и глобальные переменные.

Edebug

* Using Edebug::            Введение в использование Edebug.
* Instrumenting::           Вы должны настроить свой код, чтобы отладить его
                            с помощью Edebug.
* Edebug Execution Modes::  Режимы выполнения, останавкиь более или менее часто.
* Jumping::                 Команды для перехода в указанное место.
* Edebug Misc::             Различные команды.
* Breaks::                  Установка точек останова для остановки программы.
* Trapping Errors::         Ловушка ошибок с Edebug.
* Edebug Views::            Обзор внутри и снаружи Edebug.
* Edebug Eval::             Оценка выражений в Edebug.
* Eval List::               Выражения, значения которых отображаются каждый
                            раз, когда вы вводите Edebug.
* Printing in Edebug::      Настройка вывода.
* Trace Buffer::            Как создать вывод трассировки в буфере.
* Coverage Testing::        Как проверить охват оценки.
* The Outside Context::     Данные, которые Edebug сохраняет и восстанавливает.
* Edebug and Macros::       Указание способа обработки вызовов макросов.
* Edebug Options::          Опционные переменные для настройки Edebug.

Перерывы

* Breakpoints::             Точки останова в точках остановки.
* Global Break Condition::  Разрыв на событии.
* Source Breakpoints::      Встраивание точек останова в исходный код.

Внешний контекст

* Checking Whether to Stop::Когда Эдебуг решает, что делать.
* Edebug Display Update::   Когда Edebug обновляет дисплей.
* Edebug Recursive Edit::   Когда Edebug прекращает выполнение.

Эдебуг и макросы

* Instrumenting Macro Calls::Основная проблема.
* Specification List::      Как определить сложные шаблоны оценки.
* Backtracking::            Что делает Edebug при совпадении.
* Specification Examples::  Чтобы помочь понять спецификации.

Отладка недействительного синтаксиса Lisp

* Excess Open::             Как найти ложный открытый или отсутствующий.
* Excess Close::            Как найти ложный закрытый или отсутствующий открытый.

Чтение и печать объектов Lisp

* Streams Intro::           Обзор потоков, чтение и печать.
* Input Streams::           Различные типы данных, которые могут использоваться в
                            качестве входных потоков.
* Input Functions::         Функции для чтения объектов Lisp из текста.
* Output Streams::          Различные типы данных, которые могут использоваться в
                            качестве выходных потоков.
* Output Functions::        Функции для печати объектов Lisp в виде текста.
* Output Variables::        Переменные, которые управляют функциями печати.

Minibuffers

* Intro to Minibuffers::    Основная информация о минибуферах.
* Text from Minibuffer::    Как читать прямую текстовую строку.
* Object from Minibuffer::  Как читать объект Lisp или выражение.
* Minibuffer History::      Запись предыдущих входов минибуфера, чтобы пользователь мог
                            их повторно использовать.
* Initial Input::           Указание начального содержимого для минибуфера.
* Completion::              Как вызвать и настроить завершение.
* Yes-or-No Queries::       Задавая вопрос простым ответом.
* Multiple Queries::        Задавая ряд подобных вопросов.
* Reading a Password::      Чтение пароля с терминала.
* Minibuffer Commands::     Команды, используемые в качестве привязок клавиш в минибуферах.
* Minibuffer Windows::      Работает на специальных окнах минибуфера.
* Minibuffer Contents::     Как такие команды получают доступ к тексту минибуфера.
* Recursive Mini::          Разрешена ли рекурсивная запись в минибуфер.
* Minibuffer Misc::         Различные крючки и переменные настройки.

Завершение

* Basic Completion::        Низкоуровневые функции для завершения строк.
* Minibuffer Completion::   Вызов минибуфера с завершением.
* Completion Commands::     Команды Minibuffer, которые завершают работу.
* High-Level Completion::   Удобные особые случаи завершения (имена буфера чтения, имена
                            переменных и т.д.).
* Reading File Names::      Использование завершения для чтения имен файлов и команд
                            оболочки.
* Completion Variables::    Переменные, контролирующие поведение завершения.
* Programmed Completion::   Написание собственной функции завершения.
* Completion in Buffers::   Заполнение текста в обычных буферах.

Командный цикл

* Command Overview::    Как командный цикл считывает команды.
* Defining Commands::   Указание того, как функция должна читать аргументы.
* Interactive Call::    Вызов команды, чтобы он читал аргументы.
* Distinguish Interactive::     Выполнение команды отличает интерактивные вызовы.
* Command Loop Info::   Переменные, заданные в командной строке для проверки.
* Adjusting Point::     Настройка точки после команды.
* Input Events::        Какой ввод выглядит, когда вы его читаете.
* Reading Input::       Как читать входные события с клавиатуры или мыши.
* Special Events::      События обрабатываются немедленно и индивидуально.
* Waiting::             Ожидание ввода пользователем или истекшего времени.
* Quitting::            Как работает ‘C-g’. Как поймать или отложить выход.
* Prefix Command Arguments::    Как работают команды для установки префиксов args.
* Recursive Editing::   Ввод рекурсивного редактирования и почему вы обычно не должны.
* Disabling Commands::  Как командный цикл обрабатывает отключенные команды.
* Command History::     Как настраивается история команд и как осуществляется доступ к ней.
* Keyboard Macros::     Как реализованы клавиатурные макросы.

Определение команд

* Using Interactive::       Общие правила для ‘interactive’.
* Interactive Codes::       Стандартные буквенные коды для чтения аргументов различными
                            способами.
* Interactive Examples::    Примеры чтения интерактивных аргументов.
* Generic Commands::        Выберите один из вариантов команды.


Входные события

* Keyboard Events::         Обычные символы - клавиши с символами на них.
* Function Keys::           Функциональные клавиши - клавиши с именами, а не символами.
* Mouse Events::            Обзор событий мыши.
* Click Events::            Нажатие и отпускание кнопки мыши.
* Drag Events::             Перемещение мыши до отпускания кнопки.
* Button-Down Events::      Кнопка была нажата и еще не выпущена.
* Repeat Events::           Двойной и тройной щелчок (или перетаскивание или вниз).
* Motion Events::           Просто двигайте мышь, не нажимая кнопку.
* Focus Events::            Перемещение мыши между кадрами.
* Misc Events::             Другие события, которые система может генерировать.
* Event Examples::          Примеры списков событий мыши.
* Classifying Events::      Поиск ключей модификатора в символе события. Типы событий.
* Accessing Mouse::         Функции для извлечения информации из событий мыши.
* Accessing Scroll::        Функции для получения информации о событиях полосы прокрутки.
* Strings of Events::       Особые соображения для размещения событий символа клавиатуры
                            в строке.

Чтение ввода

* Key Sequence Input::      Как читать одну последовательность клавиш.
* Reading One Event::       Как читать только одно событие.
* Event Mod::               Как Emacs изменяет события по мере их чтения.
* Invoking the Input Method::   Как чтение события использует метод ввода.
* Quoted Character Input::  Попросить пользователя указать символ.
* Event Input Misc::        Как перечитать или выбросить входные события.

Таблицы ключей

* Key Sequences::           Ключевые последовательности как объекты Lisp.
* Keymap Basics::           Основные понятия раскладок.
* Format of Keymaps::       Какая карта клавиатуры выглядит как объект Lisp.
* Creating Keymaps::        Функции для создания и копирования раскладок.
* Inheritance and Keymaps:: Как одна keymap может наследовать привязки другой раскладки.
* Prefix Keys::             Определение ключа с раскладкой в ​​качестве определения.
* Active Keymaps::          Как Emacs ищет активные раскладки клавиатуры для привязки
                            ключей.
* Searching Keymaps::       Псевдо-Lisp резюме поиска активных карт.
* Controlling Active Maps:: Каждый буфер имеет локальную раскладку для переопределения
                            стандартных (глобальных) привязок. Малый режим также
                            может их переопределить.
* Key Lookup::              Поиск привязки ключа в одной ключевой карте.
* Functions for Key Lookup::    Как запросить ключевой поиск.
* Changing Key Bindings::   Переопределение ключа в ключевой карте.
* Remapping Commands::      Клавиатура может переводить одну команду в другую.
* Translation Keymaps::     Ключи для перевода последовательностей событий.
* Key Binding Commands::    Интерактивные интерфейсы для переопределения ключей.
* Scanning Keymaps::        Просмотр всех раскладок, для печати справки.
* Menu Keymaps::            Определение меню в виде раскладки.

Клавиши меню

* Defining Menus::          Как создать раскладку, которая определяет меню.
* Mouse Menus::             Как пользователи приводят в действие меню с помощью мыши.
* Keyboard Menus::          Как пользователи приводят в действие меню с помощью клавиатуры.
* Menu Example::            Создание простого меню.
* Menu Bar::                Как настроить панель меню.
* Tool Bar::                Панель инструментов представляет собой ряд изображений.
* Modifying Menus::         Как добавить новые элементы в меню.
* Easy Menu::               Удобный макрос для определения меню.

Определение меню

* Simple Menu Items::       Простой вид привязки клавиш меню.
* Extended Menu Items::     Более сложные определения пунктов меню.
* Menu Separators::         Рисование горизонтальной линии через меню.
* Alias Menu Items::        Использование псевдонимов команд в пунктах меню.

Основные и второстепенные режимы

* Hooks::              Как использовать крючки; как писать код, который предоставляет
                       крючки.
* Major Modes::        Определение основных режимов.
* Minor Modes::        Определение второстепенных режимов.
* Mode Line Format::   Настройка текста, отображаемого в строке режима.
* Imenu::              Предоставление меню определений, сделанных в буфере.
* Font Lock Mode::     Как режимы могут выделять текст в соответствии с синтаксисом.
* Auto-Indentation::   Как научить Emacs отступов для основного режима.
* Desktop Save Mode::  Как режимы могут сохранять состояние буфера между сеансами Emacs.

Крючки

* Running Hooks::      Как запустить крючок.
* Setting Hooks::      Как поместить функции на крючок или удалить их.

Основные режимы

* Major Mode Conventions::  Соглашения о кодировании для раскладок и т.д.
* Auto Major Mode::         Как Emacs автоматически выбирает основной режим.
* Mode Help::               Определение способа использования режима.
* Derived Modes::           Определение нового основного режима на основе
                            другого основного режима.
* Basic Major Modes::       Режимы, из которых часто происходят другие режимы.
* Mode Hooks::              Крюки запускаются в конце основных функций режима.
* Tabulated List Mode::     Родительский режим для буферов, содержащих табличные данные.
* Generic Modes::           Определение простого основного режима, поддерживающего
                            синтаксис комментариев и режим блокировки шрифтов.
* Example Major Modes::     Текстовый режим и режимы Лиспа.

Дополнительные режимы

* Minor Mode Conventions::  Советы по написанию второстепенного режима.
* Keymaps and Minor Modes:: Как второстепенный режим может иметь свою собственную
                            раскладку.
* Defining Minor Modes::    Удобное средство для определения второстепенных режимов.

Формат режима строки

* Mode Line Basics::        Основные идеи управления линией режима.
* Mode Line Data::          Структура данных, которая управляет линией режима.
* Mode Line Top::           Переменная верхнего уровня, mode-line-format.
* Mode Line Variables::     Переменные, используемые в этой структуре данных.
* %-Constructs::            Ввод информации в линию режима.
* Properties in Mode::      Использование текстовых свойств в строке режима.
* Header Lines::            Как линия режима, но вверху.
* Emulating Mode Line::     Форматирование текста в виде строки режима.

Режим блокировки шрифтов

* Font Lock Basics::        Обзор настройки Font Lock.
* Search-based Fontification::  Обозначение на основе регулярных выражений.
* Customizing Keywords::    Настройка пользовательской настройки.
* Other Font Lock Variables::   Дополнительные возможности настройки.
* Levels of Font Lock::     Каждый режим может определять альтернативные уровни, чтобы
                            пользователь мог выбирать более или менее.
* Precalculated Fontification:: Как программы Lisp, которые создают содержимое буфера,
                                также могут указать, как его размножать.
* Faces for Font Lock::     Специальные лица специально для Font Lock.
* Syntactic Font Lock::     Fontification на основе синтаксических таблиц.
* Multiline Font Lock::     Как заставить Font Lock правильно выделять
                            многострочные конструкции.

Многострочные блокировки шрифтов

* Font Lock Multiline::     Маркировка многострочных фрагментов с текстовым свойством.
* Region to Refontify::     Контроль того, какая область будет изменена после
                            изменения буфера.

Автоматический отступ кода

* SMIE::                    Простой мыслящий движок отступа.

Простой Minded Indentation Engine

* SMIE setup::              Настройка и функции SMIE.
* Operator Precedence Grammars:: Очень простая методика синтаксического анализа.
* SMIE Grammar::            Определение грамматики языка.
* SMIE Lexer::              Определение токенов.
* SMIE Tricks::             Работа над ограничениями парсера.
* SMIE Indentation::        Указание правил отступов.
* SMIE Indentation Helpers:: Вспомогательные функции для правил отступов.
* SMIE Indentation Example:: Примеры правил отступов.
* SMIE Customization::      Настройка отступов.

Документация

* Documentation Basics::    Где doc строки определены и сохранены.
* Accessing Documentation:: Как программы Lisp могут получить доступ к строкам документа.
* Keys in Documentation::   Подстановка текущих привязок клавиш.
* Text Quoting Style::      Котировки в строках и сообщениях.
* Describing Characters::   Создание печатных описаний непечатаемых символов и
                            последовательностей клавиш.
* Help Functions::          Подпрограммы, используемые средствами помощи Emacs.

Файлы

* Visiting Files::          Чтение файлов в буферы Emacs для редактирования.
* Saving Buffers::          Написание измененных буферов обратно в файлы.
* Reading from Files::      Чтение файлов в буферы без посещения.
* Writing to Files::        Написание новых файлов из частей буферов.
* File Locks::              Блокировка и разблокировка файлов, чтобы предотвратить
                            одновременное редактирование двумя людьми.
* Information about Files:: Проверка наличия, доступности, размера файлов.
* Changing Files::          Переименование файлов, изменение разрешений и т.д.
* File Names::              Разложение и расширение имен файлов.
* Contents of Directories:: Получение списка файлов в каталоге.
* Create/Delete Dirs::      Создание и удаление каталогов.
* Magic File Names::        Специальная обработка для определенных имен файлов.
* Format Conversion::       Преобразование в различные форматы файлов и из них.

Просмотр файлов

* Visiting Functions::      Обычные функции интерфейса для посещения.
* Subroutines of Visiting:: Подпрограммы нижнего уровня, которые они используют.

Информация о файлах

* Testing Accessibility::   Является ли данный файл доступным для чтения? Writable?
* Kinds of Files::          Это каталог? Символическая ссылка?
* Truenames::               Устранение символических ссылок из имени файла.
* File Attributes::         Размер файла, время модификации и т.д.
* Extended Attributes::     Расширенные атрибуты файлов для контроля доступа.
* Locating Files::          Как найти файл в стандартных местах.

Имена файлов

* File Name Components::    Часть каталога имени файла, а остальное.
* Relative File Names::     Некоторые имена файлов относятся к текущему каталогу.
* Directory Names::         Имя каталога в качестве каталога отличается от его
                            имени как файла.
* File Name Expansion::     Преобразование относительных имен файлов в абсолютные.
* Unique File Names::       Создание имен для временных файлов.
* File Name Completion::    Поиск завершений для заданного имени файла.
* Standard File Names::     Если ваш пакет использует фиксированное имя файла, как
                            просто обращаться с различными операционными системами.

Преобразование формата файла

* Format Conversion Overview::   ‘insert-file-contents’ и ‘write-region’.
* Format Conversion Round-Trip:: Использование ‘format-alist’.
* Format Conversion Piecemeal::  Указание непарного преобразования.

Резервные копии и автоматическое сохранение

* Backup Files::            Как создаются резервные файлы; как их имена выбраны.
* Auto-Saving::             Как создаются файлы автосохранения; как их имена выбраны.
* Reverting::               ‘revert-buffer’, и как настроить, что он делает.

Резервные файлы

* Making Backups::          Как Emacs создает резервные файлы и когда.
* Rename or Copy::          Две альтернативы: переименование старого
                            файла или его копирование.
* Numbered Backups::        Сохранение нескольких резервных копий для каждого
                            исходного файла.
* Backup Names::            Как вычисляются имена файлов резервных копий; настройки.

Буферы

* Buffer Basics::           Что такое буфер?
* Current Buffer::          Назначение буфера как текущего, чтобы примитивы могли
                            получить доступ к его содержимому.
* Buffer Names::            Доступ и изменение имен буферов.
* Buffer File Name::        Имя файла буфера указывает, какой файл посещен.
* Buffer Modification::     Буфер будет “modified”, если его нужно сохранить.
* Modification Time::       Определение того, был ли изменен посещаемый файл
                            за спиной Emacs.
* Read Only Buffers::       Модификация текста не допускается в буфере
                            только для чтения.
* Buffer List::             Как посмотреть на все существующие буферы.
* Creating Buffers::        Функции, которые создают буферы.
* Killing Buffers::         Буферы существуют до явного уничтожения.
* Indirect Buffers::        Косвенный буфер передает текст с каким-то другим буфером.
* Swapping Text::           Обмен текстом между двумя буферами.
* Buffer Gap::              Зазор в буфере.

Окна

* Basic Windows::           Основная информация об использовании окон.
* Windows and Frames::      Связать окна с рамкой, на которой они отображаются.
* Window Sizes::            Доступ к размеру окна.
* Resizing Windows::        Изменение размеров окон.
* Preserving Window Sizes:: Preserving the size of windows.
* Splitting Windows::       Разделение одного окна на два окна.
* Deleting Windows::        Удаление окна дает пространство для других окон.
* Recombining Windows::     Сохранение макета кадра при расщеплении и удалении окон.
* Selecting Windows::       Выбранное окно - это то, которое вы редактируете.
* Cyclic Window Ordering::  Перемещение по существующим окнам.
* Buffers and Windows::     Каждое окно отображает содержимое буфера.
* Switching Buffers::       Функции более высокого уровня для переключения в буфер.
* Choosing Window::         Как выбрать окно для отображения буфера.
* Display Action Functions:: Подпрограммы для ‘display-buffer’.
* Choosing Window Options:: Дополнительные параметры, влияющие на отображение буферов.
* Window History::          Каждое окно запоминает отображаемые в нем буферы.
* Dedicated Windows::       Как избежать отображения другого буфера в определенном окне.
* Quitting Windows::        Как восстановить состояние перед отображением буфера.
* Side Windows::            Специальные окна со стороны рамы.
* Atomic Windows::          Сохранение частей макета окна.
* Window Point::            Каждое окно имеет свое местоположение точки.
* Window Start and End::    Буферные позиции, указывающие, какой текст находится
                            на экране в окне.
* Textual Scrolling::       Перемещение текста вверх и вниз по окну.
* Vertical Scrolling::      Перемещение содержимого вверх и вниз по окну.
* Horizontal Scrolling::    Перемещение содержимого в сторону в окне.
* Coordinates and Windows:: Преобразование координат в окне.
* Mouse Window Auto-selection:: Автоматический выбор окон с помощью мыши.
* Window Configurations::   Сохранение и восстановление состояния экрана.
* Window Parameters::       Связывание дополнительной информации с окнами.
* Window Hooks::            Крючки для прокрутки, изменения размера окна,
                            повторного отображения пройдут через определенную
                            точку или изменения конфигурации окна.

Боковые окна

* Displaying Buffers in Side Windows:: Функция действия для отображения буферов
                                       в боковых окнах.
* Side Window Options and Functions:: Дальнейшая настройка боковых окон.
* Frame Layouts with Side Windows:: Настройка макетов рамок с боковыми окнами.

Фреймы (кадры, рамки)

* Creating Frames::         Создание дополнительных фреймов.
* Multiple Terminals::      Отображение на нескольких разных устройствах.
* Frame Geometry::          Геометрические свойства фреймов.
* Frame Parameters::        Управление размером, положением, шрифтом и т.д.
* Terminal Parameters::     Параметры, общие для всех кадров на терминале.
* Frame Titles::            Автоматическое обновление названий кадров.
* Deleting Frames::         Кадры сохраняются до явного удаления.
* Finding All Frames::      Как проверить все существующие фреймы.
* Minibuffers and Frames::  Как кадр находит минибуфер для использования.
* Input Focus::             Указание выбранного кадра.
* Visibility of Frames::    Рамки могут быть видимыми или невидимыми, или значками.
* Raising and Lowering::    Подъем, опускание и восстановление рамок.
* Frame Configurations::    Сохранение состояния всех кадров.
* Child Frames::            Создание рамки для потомка другого.
* Mouse Tracking::          Получение событий, при перемещении мыши.
* Mouse Position::          Спросить, где находится мышь, или перемещать ее.
* Pop-Up Menus::            Отображение меню для выбора пользователем.
* Dialog Boxes::            Отображение поля для ответа «да» или «нет».
* Pointer Shape::           Указание формы указателя мыши.
* Window System Selections::Перенос текста в другие клиенты X и обратно.
* Drag and Drop::           Внутренние реализации Drag-and-Drop.
* Color Names::             Получение определений имен цветов.
* Text Terminal Colors::    Определение цветов для текстовых терминалов.
* Resources::               Получение значений ресурсов с сервера.
* Display Feature Testing:: Определение особенностей терминала.

Геометрия Фрейма

* Frame Layout::            Базовая компоновка фреймов.
* Frame Font::              Шрифт по умолчанию для фрейма и как его установить.
* Frame Position::          Положение фрейма на дисплее.
* Frame Size::              Задание и выбор размера фрейма.
* Implied Frame Resizing::  Подразумевается изменение размера фрейма и способы
                            его предотвращения.

Параметры Фрейма

* Parameter Access::        Как изменить параметры фрейма.
* Initial Parameters::      Указание параметров фрейма при его создании.
* Window Frame Parameters:: Список параметров кадра для оконных систем.
* Geometry::                Спецификации анализируемой геометрии.

Параметры Окна Фрейма

* Basic Parameters::        Параметры, которые являются фундаментальными.
* Position Parameters::     Положение фрейма на экране.
* Size Parameters::         Размер фрейма.
* Layout Parameters::       Размер частей фрейма и включение или выключение
                            некоторых частей.
* Buffer Parameters::       Какие буферы были или должны отображаться.
* Frame Interaction Parameters::  Параметры для взаимодействия с другими кадрами.
* Mouse Dragging Parameters::  Параметры для изменения размера и перемещения
                               кадров с помощью мыши.
* Management Parameters::   Общение с диспетчером окон.
* Cursor Parameters::       Управление появлением курсора.
* Font and Color Parameters:: Шрифты и цвета для текста рамки.

Положение точки

* Point::                   Специальное положение, в котором происходит редактирование.
* Motion::                  Изменение положения точки.
* Excursions::              Временное перемещение и изменение буфера.
* Narrowing::               Ограничение редактирования части буфера.

Изменение положения точки

* Character Motion::        Перемещение по символам.
* Word Motion::             Перемещение по словам.
* Buffer End Motion::       Перемещение в начало или конец буфера.
* Text Lines::              Перемещение по строкам текста.
* Screen Lines::            Перемещение по отображаемым строкам.
* List Motion::             Перемещение с помощью парсинга списков и sexps.
* Skipping Characters::     Пропуск символов, принадлежащих определенному набору.

Маркеры

* Overview of Markers::     Компоненты маркера и то, как он перемещается.
* Predicates on Markers::   Проверка того, является ли объект маркером.
* Creating Markers::        Создание пустых маркеров или маркеров в определенных местах.
* Information from Markers::Поиск буфера маркера или положение символа.
* Marker Insertion Types::  Два способа, по которым маркер может перемещаться,
                            когда вы вставляете туда, куда он указывает.
* Moving Markers::          Перемещение маркера в новый буфер или позицию.
* The Mark::                Установка метки с помощью маркера.
* The Region::              Как получить доступ к региону.

Текст

* Near Point::              Изучение текста вблизи точки.
* Buffer Contents::         Рассмотрение текста в общем виде.
* Comparing Text::          Сравнение подстрок буферов.
* Insertion::               Добавление нового текста в буфер.
* Commands for Insertion::  Команды пользовательского уровня для вставки текста.
* Deletion::                Удаление текста из буфера.
* User-Level Deletion::     Команды пользовательского уровня для удаления текста.
* The Kill Ring::           Если удаленный текст иногда сохраняется для
                            последующего использования.
* Undo::                    Отмена изменений в тексте буфера.
* Maintaining Undo::        Как включить или отключить отмену изменений. Как
                            контролировать, сколько изменений хранится.
* Filling::                 Функции для явного заполнения.
* Margins::                 Как указать поля для заполнения команд.
* Adaptive Fill::           Режим Adaptive Fill выбирает префикс
                            заполнения из контекста.
* Auto Filling::            Как реализован режим автозаполнения для разрыва строк.
* Sorting::                 Функции для сортировки частей буфера.
* Columns::                 Вычисление горизонтальных позиций и их использование.
* Indentation::             Функции для вставки или настройки отступа.
* Case Changes::            Преобразование регистра частей буфера.
* Text Properties::         Присвоение списков свойств Lisp текстовым символам.
* Substitution::            Замена заданного символа везде, где он появляется.
* Registers::               Как регистрируются регистры. Доступ к тексту или
                            позиции, хранящемучя в регистре.
* Transposition::           Перестановка двух частей буфера.
* Decompression::           Работа со сжатыми данными.
* Base 64::                 Преобразование в кодировку или из базы 64.
* Checksum/Hash::           Вычисление криптографических хэшей.
* GnuTLS Cryptography::     Криптографические алгоритмы, импортированные из GnuTLS.
* Parsing HTML/XML::        Анализ HTML и XML.
* Atomic Changes::          Устанавливает несколько изменений в буфере атомарно.
* Change Hooks::            Предоставление функций, которые будут выполняться при
                            изменении текста.

Кольцо уничтожений

* Kill Ring Concepts::      Какой текст выглядит в кольце унмчтожений.
* Kill Functions::          Функции, которые уничтожают текст.
* Yanking::                 Как функционирует.
* Yank Commands::           Команды, которые получают доступ к кольцу уничтожения.
* Low-Level Kill Ring::     Функции и переменные для доступа к кольцу.
* Internals of Kill Ring::  Переменные, которые содержат данные об удалении.

Выравнивание

* Primitive Indent::        Функции, используемые для подсчета и вставки отступа.
* Mode-Specific Indent::    Настройте отступы для разных режимов.
* Region Indent::           Отступ для всех линий в области.
* Relative Indent::         Отступ текущей строки, основанной на предыдущих строках.
* Indent Tabs::             Регулируемые отступы.
* Motion by Indent::        Перейдите к первому непустому символу.

Свойства текста

* Examining Properties::    Исследование свойств одного символа.
* Changing Properties::     Настройка свойств диапазона текста.
* Property Search::         Поиск, где свойство изменяет значение.
* Special Properties::      Особые свойства со специальными значениями.
* Format Properties::       Свойства для представления форматирования текста.
* Sticky Properties::       Как вставленный текст получает свойства из
                            соседнего текста.
* Lazy Properties::         Вычисление текстовых свойств ленивым способом
                            только при анализе текста.
* Clickable Text::          Использование свойств текста, чтобы сделать области
                            текста что-то делать, когда вы нажимаете на них.
* Fields::                  ‘field’ свойство определяет поля в буфере.
* Not Intervals::           Почему текстовые свойства не используют текстовые
                            интервалы, видимые в Lisp.

Анализ HTML и XML

* Document Object Model::   Доступ, управление и поиск DOM.

Не-ASCII Символы

* Text Representations::    Как Emacs представляет текст.
* Disabling Multibyte::     Контроль использования многобайтовых символов.
* Converting Representations::  Преобразование unibyte в multibyte и наоборот.
* Selecting a Representation::  Обработка байтовой последовательности как однобайтовой
                                или мультисети.
* Character Codes::         Как unibyte и multibyte относятся к кодам отдельных
                            символов.
* Character Properties::    Атрибуты символов, которые определяют их
                            поведение и обработку.
* Character Sets::          Диапазон возможных кодов символов делится на
                            различные наборы символов.
* Scanning Charsets::       Какие наборы символов используются в буфере?
* Translation of Characters::   Таблицы перевода используются для преобразования.
* Coding Systems::          Системы кодирования - это преобразования для сохранения файлов.
* Input Methods::           Методы ввода позволяют пользователям вводить различные
                            не ASCII символы без специальных клавиатур.
* Locales::                 Взаимодействие с языковой версией POSIX.

Система кодирования

* Coding System Basics::    Основные понятия.
* Encoding and I/O::        Как функции ввода-вывода файлов обрабатывают системы
                            кодирования.
* Lisp and Coding Systems:: Функции для работы с именами систем кодирования.
* User-Chosen Coding Systems::  Попросить пользователя выбрать систему кодирования.
* Default Coding Systems::  Управление настройками по умолчанию.
* Specifying Coding Systems::   Запрос конкретной системы кодирования для операции
                                с одним файлом.
* Explicit Encoding::       Кодирование или декодирование текста без ввода-вывода.
* Terminal I/O Encoding::   Использование кодирования для терминального ввода-вывода.

Поиск и сопоставление

* String Search::           Найдите точное сопоставление.
* Searching and Case::      Независимый и зависимый от регистра символа поиск.
* Regular Expressions::     Описание классов строк.
* Regexp Search::           Поиск соответствия регулярному выражению.
* POSIX Regexps::           Поиск POSIX-стиля для самого длинного совпадения.
* Match Data::              Выяснение, какая часть текста соответствует, после
                            поиска строки или регулярного выражения.
* Search and Replace::      Команды, которые повторяют, поиск и замена.
* Standard Regexps::        Полезные регулярные выражения для поиска предложений,
                            страниц,...

Регулярные Выражения

* Syntax of Regexps::       Правила написания регулярных выражений.
* Regexp Example::          Иллюстрирует синтаксис регулярных выражений.
* Regexp Functions::        Функции для работы с регулярными выражениями.

Синтакс Регулярных Выражений

* Regexp Special::          Специальные символы в регулярных выражениях.
* Char Classes::            Классы символов, используемые в регулярных выражениях.
* Regexp Backslash::        Обратные последовательности в регулярных выражениях.

Данные соответствия

* Replacing Match::         Замена подстроки, которая была сопоставлена.
* Simple Match Data::       Доступ к отдельным элементам данных сопоставления,
                            например, когда началось конкретное подвыражение.
* Entire Match Data::       Доступ ко всем данным сопоставления сразу, как к списку.
* Saving Match Data::       Сохранение и восстановление данных соответствия.

Синтакс Таблица

* Syntax Basics::           Основные понятия синтаксических таблиц.
* Syntax Descriptors::      Как классифицируются символы.
* Syntax Table Functions::  Как создавать, проверять и изменять таблицы синтаксиса.
* Syntax Properties::       Переопределение синтаксиса с текстовыми свойствами.
* Motion and Syntax::       Перемещение символов с определенными синтаксисами.
* Parsing Expressions::     Разбор сбалансированных выражений с использованием
                            таблицы синтаксиса.
* Syntax Table Internals::  Как хранится информация таблицы синтаксиса.
* Categories::              Другой способ классификации синтаксиса символов.

Дескрипторы синтаксиса

* Syntax Class Table::      Таблица классов синтаксиса.
* Syntax Flags::            Дополнительные флаги могут иметь каждый символ.

Разбор выражений

* Motion via Parsing::      Функции движения, которые работают при разборе.
* Position Parse::          Определение синтаксического состояния позиции.
* Parser State::            Как Emacs представляет синтаксическое состояние.
* Low-Level Parsing::       Анализ по определенному региону.
* Control Parsing::         Параметры, влияющие на синтаксический анализ.

Сокращения и сокращение Abbrev

* Abbrev Tables::           Создание и работа с таблицами сокращений.
* Defining Abbrevs::        Указание сокращений и их расширений.
* Abbrev Files::            Сохранение сокращений в файлах.
* Abbrev Expansion::        Контроль расширения; подпрограммы расширения.
* Standard Abbrev Tables::  Таблицы аббревиатуры, используемые различными
                            основными режимами.
* Abbrev Properties::       Как читать и устанавливать свойства аббревиатуры.
                            Какие свойства имеют такой эффект.
* Abbrev Table Properties:: Как читать и устанавливать свойства таблицы
                            аббревиатуры. Какие свойства имеют такой эффект.

Потоки

* Basic Thread Functions::  Основные функции потоков.
* Mutexes::                 Мьютекс разрешает эксклюзивный доступ к данным.
* Condition Variables::     Межпоточные события.

Процессы

* Subprocess Creation::     Функции, запускающие подпроцессы.
* Shell Arguments::         Цитирование аргумента, чтобы передать его оболочке.
* Synchronous Processes::   Подробная информация об использовании синхронных
                            подпроцессов.
* Asynchronous Processes::  Запуск асинхронного подпроцесса.
* Deleting Processes::      Исключение асинхронного подпроцесса.
* Process Information::     Доступ к статусу выполнения и другим атрибутам.
* Input to Processes::      Отправка ввода в асинхронный подпроцесс.
* Signals to Processes::    Остановка, продолжение или прерывание асинхронного
                            подпроцесса.
* Output from Processes::   Сбор данных из асинхронного подпроцесса.
* Sentinels::               Sentinels запускаются при изменении состояния процесса.
* Query Before Exit::       Запрашивание выхода после завершения процесса.
* System Processes::        Доступ к другим процессам в вашей системе.
* Transaction Queues::      Связь на основе транзакций с подпроцессами.
* Network::                 Открытие сетевых подключений.
* Network Servers::         Сетевые серверы позволяют Emacs принимать
                            сетевые подключения.
* Datagrams::               Сетевые подключения UDP.
* Low-Level Network::       Более низкая, но более общая функция для создания
                            соединений и серверов.
* Misc Network::            Дополнительные релевантные функции для сетевых соединений.
* Serial Ports::            Связь с последовательными портами.
* Byte Packing::            Использование bindat для упаковки и распаковки
                            двоичных данных.

Получение результатов из процессов

* Process Buffers::         По умолчанию вывод помещается в буфер.
* Filter Functions::        Функции фильтра принимают результат процесса.
* Decoding Output::         Фильтры могут получать однобайтные или
                            многобайтовые строки.
* Accepting Output::        Как дождаться выхода процесса.

Низкоуровневый доступ к сети

* Network Processes::       Использование ‘make-network-process’.
* Network Options::         Дальнейший контроль над сетевыми соединениями.
* Network Feature Testing:: Определение функций сети на используемом вами компьютере.

Упаковка и распаковка байт-массивов

* Bindat Spec::             Описание макета данных.
* Bindat Functions::        Выполнение распаковки и упаковки.
* Bindat Examples::         Образцы того, что bindat.el может сделать для вас!

Экран Emacs

* Refresh Screen::          Очистка экрана и перерисовка всего на нем.
* Forcing Redisplay::       Принудительное повторное отображение.
* Truncation::              Складывание или обтекание длинных текстовых строк.
* The Echo Area::           Отображение сообщений в нижней части экрана.
* Warnings::                Отображение предупреждающих сообщений для пользователя.
* Invisible Text::          Скрытие части текста буфера.
* Selective Display::       Скрытие части текста буфера (по-старому).
* Temporary Displays::      Дисплеи, которые автоматически исчезают.
* Overlays::                Используйте оверлеи для выделения частей буфера.
* Size of Displayed Text::  Как большой отображаемый текст.
* Line Height::             Управление высотой линий.
* Faces::                   Лицо определяет стиль графики для текстовых
                            символов: шрифт, цвет и т.д.
* Fringes::                 Управление окнами.
* Scroll Bars::             Управление полосами прокрутки.
* Window Dividers::         Разделение окон визуально.
* Display Property::        Включение специальных функций отображения.
* Images::                  Отображение изображений в буферах Emacs.
* Buttons::                 Добавление кликов в буферы Emacs.
* Abstract Display::        Виджет Emacs для коллекций объектов.
* Blinking::                Как Emacs показывает совпадающие открытые круглые скобки.
* Character Display::       Как Emacs отображает отдельные символы.
* Beeping::                 Звуковой сигнал пользователю.
* Window Systems::          Какая оконная система используется.
* Tooltips::                Отображение подсказки в Emacs.
* Bidirectional Display::   Отображение двунаправленных скриптов, таких как
                            арабский и фарси.

Эхо Область

* Displaying Messages::     Явное отображение текста в области эха.
* Progress::                Информирование пользователя о ходе длительной операции.
* Logging Messages::        Сообщения эхо-области регистрируются для пользователя.
* Echo Area Customization:: Управление эхо-областью.

Предупреждения

* Warning Basics::          Концепции и функции предупреждений.
* Warning Variables::       Программы переменных привязываются для настройки
                            своих предупреждений.
* Warning Options::         Пользователи переменными настраивают отображение
                            предупреждений.
* Delayed Warnings::        Отложить предупреждение до конца команды.

Накладки

* Managing Overlays::       Создание и перемещение накладок.
* Overlay Properties::      Как читать и устанавливать свойства. Какие свойства
                            отображаются на экране.
* Finding Overlays::        Поиск наложений.

Faces

* Face Attributes::         Что в лице?
* Defining Faces::          Как определить лицо.
* Attribute Functions::     Функции для проверки и установки атрибутов лица.
* Displaying Faces::        Как Emacs объединяет грани, заданные для символа.
* Face Remapping::          Перенос граней в альтернативные определения.
* Face Functions::          Как определить и изучить лица.
* Auto Faces::              Крюк для автоматического назначения лица.
* Basic Faces::             Лица, которые определены по умолчанию.
* Font Selection::          Поиск лучшего доступного шрифта для лица.
* Font Lookup::             Поиск имен доступных шрифтов и информации о них.
* Fontsets::                Fontset - это набор шрифтов, которые обрабатывают
                            множество наборов символов.
* Low-Level Font::          Представление Lisp для шрифтов символов.

Отображение

* Fringe Size/Pos::         Указание места размещения оконных полос.
* Fringe Indicators::       Отображение значков индикаторов в окошках окна.
* Fringe Cursors::          Отображение курсоров в правой полосе.
* Fringe Bitmaps::          Указание растровых изображений для отображения индикаторов.
* Customizing Bitmaps::     Указание собственных растровых изображений для
                            использования в полосах.
* Overlay Arrow::           Отображение стрелки для указания позиции.

‘display’ Настройка

* Replacing Specs::         Отображать спецификации, которые заменяют текст.
* Specified Space::         Отображение одного пробела с указанной шириной.
* Pixel Specification::     Указание ширины или высоты пространства в пикселях.
* Other Display Specs::     Отображение изображения; регулировка высоты, расстояния и
                            других свойств текста.
* Display Margins::         Отображение текста или изображений в сторону основного текста.

Изображения

* Image Formats::           Поддерживаемые форматы изображений.
* Image Descriptors::       Как указать изображение для использования в ‘:display’.
* XBM Images::              Особенности для формата XBM.
* XPM Images::              Особенности для формата XPM.
* ImageMagick Images::      Специальные функции доступны через ImageMagick.
* Other Image Types::       Поддерживаются различные другие форматы.
* Defining Images::         Удобные способы определения изображения для
                            последующего использования.
* Showing Images::          Удобные способы отображения изображения после его определения.
* Multi-Frame Images::      Некоторые изображения содержат более одного кадра.
* Image Cache::             Внутренние механизмы отображения изображений.

Кнопки

* Button Properties::       Свойства кнопок со специальными значениями.
* Button Types::            Определение общих свойств для классов кнопок.
* Making Buttons::          Добавление кнопок в буферы Emacs.
* Manipulating Buttons::    Получение и настройка свойств кнопок.
* Button Buffer Commands::  Буферные команды и привязки для кнопок.

Абстрактный дисплей

* Abstract Display Functions::  Функции в пакете Ewoc.
* Abstract Display Example::    Пример использования Ewoc.

Отображение символов

* Usual Display::       Обычные условные обозначения для отображения символов.
* Display Tables::      Из чего состоит экранная таблица.
* Active Display Table::  Как Emacs выбирает таблицу отображения для использования.
* Glyphs::              Как определить глиф, и что означают глифы.
* Glyphless Chars::     Как рисуются символы глифов.

Интерфейс операционной системы

* Starting Up::             Настройка обработки запуска Emacs.
* Getting Out::             Как работает (постоянный или временный).
* System Environment::      Различают название и вид системы.
* User Identification::     Поиск имени и идентификатора пользователя.
* Time of Day::             Получение текущего времени.
* Time Conversion::         Преобразование времени из числовой формы в календарные
                            данные и наоборот.
* Time Parsing::            Преобразование времени из числовой формы в текст и наоборот.
* Processor Run Time::      Получение времени выполнения, используемого Emacs.
* Time Calculations::       Добавление, вычитание, сравнение времени и т. Д.
* Timers::                  Установка таймера для вызова функции в определенное время.
* Idle Timers::             Установка таймера для вызова функции, когда Emacs
                            простаивает в течение определенного периода времени.
* Terminal Input::          Доступ к терминалу и запись на него.
* Terminal Output::         Управление и запись вывода терминала.
* Sound Output::            Воспроизведение звуков на динамике компьютера.
* X11 Keysyms::             Работа с ключевыми символами для X Windows.
* Batch Mode::              Запуск Emacs без терминального взаимодействия.
* Session Management::      Сохранение и восстановление состояния с помощью X
                            Session Management.
* Desktop Notifications::   Уведомления на рабочем столе.
* File Notifications::      Уведомления о файлах.
* Dynamic Libraries::       Загрузка библиотек поддержки по требованию.
* Security Considerations:: Запуск Emacs в недружественной среде.

Запуск Emacs

* Startup Summary::         Последовательность действий Emacs выполняется при запуске.
* Init File::               Подробности по чтению файла инициализации.
* Terminal-Specific::       Как считывается файл Lisp, специфичный для терминала.
* Command-Line Arguments::  Как обрабатываются аргументы командной строки и как их
  ‘                         можно настроить.

Выход из Emacs

* Killing Emacs::           Выход из Emacs необратимо.
* Suspending Emacs::        Выход из Emacs обратимо.

Вход терминала

* Input Modes::             Варианты обработки ввода.
* Recording Input::         Сохранение истории последних или всех входных событий.

Подготовка кода Lisp для распространения

* Packaging Basics::        Основные понятия пакетов Emacs Lisp.
* Simple Packages::         Как упаковать один файл .el.
* Multi-file Packages::     Как упаковать несколько файлов.
* Package Archives::        Ведение архивов пакетов.

Советы и соглашения

* Coding Conventions::      Конвенции для чистых и надежных программ.
* Key Binding Conventions:: Какие ключи должны быть связаны с программами.
* Programming Tips::        Копирование Emacs в Emacs гладко.
* Compilation Tips::        Выполнение скомпилированного кода выполняется быстро.
* Warning Tips::            Отключение предупреждений компилятора.
* Documentation Tips::      Написание читаемых строк документации.
* Comment Tips::            Условные обозначения для написания комментариев.
* Library Headers::         Стандартные заголовки для пакетов библиотеки.

GNU Emacs Internals

* Building Emacs::          Как производится сброс Emacs.
* Pure Storage::            Kludge, чтобы сделать предварительно загруженные функции
                            Lisp доступными.
* Garbage Collection::      Восстановление места для объектов Lisp больше не используется.
* Stack-allocated Objects:: Временные conses и строки в стеке C.
* Memory Usage::            Информация об общем размере объектов Lisp, сделанных до
                            сих пор.
* C Dialect::               В чем написано C-вариант Emacs.
* Writing Emacs Primitives::  Написание кода C для Emacs.
* Object Internals::        Форматы данных буферов, окон, процессов.
* C Integer Types::         Как C целочисленные типы используются внутри Emacs.

Object Internals

* Buffer Internals::        Компоненты буферной структуры.
* Window Internals::        Компоненты оконной структуры.
* Process Internals::       Компоненты структуры процесса.


File: elisp.info,  Node: Introduction,  Next: Lisp Data Types,  Prev: Top,  Up: Top

1 Introduction
**************

Most of the GNU Emacs text editor is written in the programming language
called Emacs Lisp.  You can write new code in Emacs Lisp and install it
as an extension to the editor.  However, Emacs Lisp is more than a mere
extension language; it is a full computer programming language in its
own right.  You can use it as you would any other programming language.

   Because Emacs Lisp is designed for use in an editor, it has special
features for scanning and parsing text as well as features for handling
files, buffers, displays, subprocesses, and so on.  Emacs Lisp is
closely integrated with the editing facilities; thus, editing commands
are functions that can also conveniently be called from Lisp programs,
and parameters for customization are ordinary Lisp variables.

   This manual attempts to be a full description of Emacs Lisp.  For a
beginner’s introduction to Emacs Lisp, see ‘An Introduction to Emacs
Lisp Programming’, by Bob Chassell, also published by the Free Software
Foundation.  This manual presumes considerable familiarity with the use
of Emacs for editing; see ‘The GNU Emacs Manual’ for this basic
information.

   Generally speaking, the earlier chapters describe features of Emacs
Lisp that have counterparts in many programming languages, and later
chapters describe features that are peculiar to Emacs Lisp or relate
specifically to editing.

   This is the ‘GNU Emacs Lisp Reference Manual’, corresponding to Emacs
version 26.1.

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from Maclisp.
* Conventions::         How the manual is formatted.
* Version Info::        Which Emacs version is running?
* Acknowledgments::     The authors, editors, and sponsors of this manual.


File: elisp.info,  Node: Caveats,  Next: Lisp History,  Up: Introduction

1.1 Caveats
===========

This manual has gone through numerous drafts.  It is nearly complete but
not flawless.  There are a few topics that are not covered, either
because we consider them secondary (such as most of the individual
modes) or because they are yet to be written.  Because we are not able
to deal with them completely, we have left out several parts
intentionally.

   The manual should be fully correct in what it does cover, and it is
therefore open to criticism on anything it says—from specific examples
and descriptive text, to the ordering of chapters and sections.  If
something is confusing, or you find that you have to look at the sources
or experiment to learn something not covered in the manual, then perhaps
the manual should be fixed.  Please let us know.

   As you use this manual, we ask that you send corrections as soon as
you find them.  If you think of a simple, real life example for a
function or group of functions, please make an effort to write it up and
send it in.  Please reference any comments to the node name and function
or variable name, as appropriate.  Also state the number of the edition
you are criticizing.

   Please send comments and corrections using ‘M-x report-emacs-bug’.


File: elisp.info,  Node: Lisp History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

1.2 Lisp History
================

Lisp (LISt Processing language) was first developed in the late 1950s at
the Massachusetts Institute of Technology for research in artificial
intelligence.  The great power of the Lisp language makes it ideal for
other purposes as well, such as writing editing commands.

   Dozens of Lisp implementations have been built over the years, each
with its own idiosyncrasies.  Many of them were inspired by Maclisp,
which was written in the 1960s at MIT’s Project MAC.  Eventually the
implementers of the descendants of Maclisp came together and developed a
standard for Lisp systems, called Common Lisp.  In the meantime, Gerry
Sussman and Guy Steele at MIT developed a simplified but very powerful
dialect of Lisp, called Scheme.

   GNU Emacs Lisp is largely inspired by Maclisp, and a little by Common
Lisp.  If you know Common Lisp, you will notice many similarities.
However, many features of Common Lisp have been omitted or simplified in
order to reduce the memory requirements of GNU Emacs.  Sometimes the
simplifications are so drastic that a Common Lisp user might be very
confused.  We will occasionally point out how GNU Emacs Lisp differs
from Common Lisp.  If you don’t know Common Lisp, don’t worry about it;
this manual is self-contained.

   A certain amount of Common Lisp emulation is available via the
‘cl-lib’ library.  *Note Overview: (cl)Top.

   Emacs Lisp is not at all influenced by Scheme; but the GNU project
has an implementation of Scheme, called Guile.  We use it in all new GNU
software that calls for extensibility.


File: elisp.info,  Node: Conventions,  Next: Version Info,  Prev: Lisp History,  Up: Introduction

1.3 Conventions
===============

This section explains the notational conventions that are used in this
manual.  You may want to skip this section and refer back to it later.

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols ‘nil’ and ‘t’ are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use when examples print text.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.


File: elisp.info,  Node: Some Terms,  Next: nil and t,  Up: Conventions

1.3.1 Some Terms
----------------

Throughout this manual, the phrases “the Lisp reader” and “the Lisp
printer” refer to those routines in Lisp that convert textual
representations of Lisp objects into actual Lisp objects, and vice
versa.  *Note Printed Representation::, for more details.  You, the
person reading this manual, are thought of as the programmer and are
addressed as “you”.  The user is the person who uses Lisp programs,
including those you write.

   Examples of Lisp code are formatted like this: ‘(list 1 2 3)’.  Names
that represent metasyntactic variables, or arguments to a function being
described, are formatted like this: FIRST-NUMBER.


File: elisp.info,  Node: nil and t,  Next: Evaluation Notation,  Prev: Some Terms,  Up: Conventions

1.3.2 ‘nil’ and ‘t’
-------------------

In Emacs Lisp, the symbol ‘nil’ has three separate meanings: it is a
symbol with the name ‘nil’; it is the logical truth value FALSE; and it
is the empty list—the list of zero elements.  When used as a variable,
‘nil’ always has the value ‘nil’.

   As far as the Lisp reader is concerned, ‘()’ and ‘nil’ are identical:
they stand for the same object, the symbol ‘nil’.  The different ways of
writing the symbol are intended entirely for human readers.  After the
Lisp reader has read either ‘()’ or ‘nil’, there is no way to determine
which representation was actually written by the programmer.

   In this manual, we write ‘()’ when we wish to emphasize that it means
the empty list, and we write ‘nil’ when we wish to emphasize that it
means the truth value FALSE.  That is a good convention to use in Lisp
programs also.

     (cons 'foo ())                ; Emphasize the empty list
     (setq foo-flag nil)           ; Emphasize the truth value FALSE

   In contexts where a truth value is expected, any non-‘nil’ value is
considered to be TRUE.  However, ‘t’ is the preferred way to represent
the truth value TRUE.  When you need to choose a value that represents
TRUE, and there is no other basis for choosing, use ‘t’.  The symbol ‘t’
always has the value ‘t’.

   In Emacs Lisp, ‘nil’ and ‘t’ are special symbols that always evaluate
to themselves.  This is so that you do not need to quote them to use
them as constants in a program.  An attempt to change their values
results in a ‘setting-constant’ error.  *Note Constant Variables::.

 -- Function: booleanp object
     Return non-‘nil’ if OBJECT is one of the two canonical boolean
     values: ‘t’ or ‘nil’.


File: elisp.info,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

1.3.3 Evaluation Notation
-------------------------

A Lisp expression that you can evaluate is called a “form”.  Evaluating
a form always produces a result, which is a Lisp object.  In the
examples in this manual, this is indicated with ‘⇒’:

     (car '(1 2))
          ⇒ 1

You can read this as “‘(car '(1 2))’ evaluates to 1”.

   When a form is a macro call, it expands into a new form for Lisp to
evaluate.  We show the result of the expansion with ‘↦’.  We may or may
not show the result of the evaluation of the expanded form.

     (third '(a b c))
          ↦ (car (cdr (cdr '(a b c))))
          ⇒ c

   To help describe one form, we sometimes show another form that
produces identical results.  The exact equivalence of two forms is
indicated with ‘≡’.

     (make-sparse-keymap) ≡ (list 'keymap)


File: elisp.info,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

1.3.4 Printing Notation
-----------------------

Many of the examples in this manual print text when they are evaluated.
If you execute example code in a Lisp Interaction buffer (such as the
buffer ‘*scratch*’), the printed text is inserted into the buffer.  If
you execute the example by other means (such as by evaluating the
function ‘eval-region’), the printed text is displayed in the echo area.

   Examples in this manual indicate printed text with ‘⊣’, irrespective
of where that text goes.  The value returned by evaluating the form
follows on a separate line with ‘⇒’.

     (progn (prin1 'foo) (princ "\n") (prin1 'bar))
          ⊣ foo
          ⊣ bar
          ⇒ bar


File: elisp.info,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

1.3.5 Error Messages
--------------------

Some examples signal errors.  This normally displays an error message in
the echo area.  We show the error message on a line starting with
‘error→’.  Note that ‘error→’ itself does not appear in the echo area.

     (+ 23 'x)
     error→ Wrong type argument: number-or-marker-p, x


File: elisp.info,  Node: Buffer Text Notation,  Next: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

1.3.6 Buffer Text Notation
--------------------------

Some examples describe modifications to the contents of a buffer, by
showing the before and after versions of the text.  These examples show
the contents of the buffer in question between two lines of dashes
containing the buffer name.  In addition, ‘★’ indicates the location of
point.  (The symbol for point, of course, is not part of the text in the
buffer; it indicates the place _between_ two characters where point is
currently located.)

     ---------- Buffer: foo ----------
     This is the ★contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          ⇒ nil
     ---------- Buffer: foo ----------
     This is the changed ★contents of foo.
     ---------- Buffer: foo ----------


File: elisp.info,  Node: Format of Descriptions,  Prev: Buffer Text Notation,  Up: Conventions

1.3.7 Format of Descriptions
----------------------------

Functions, variables, macros, commands, user options, and special forms
are described in this manual in a uniform format.  The first line of a
description contains the name of the item followed by its arguments, if
any.  The category—function, variable, or whatever—appears at the
beginning of the line.  The description follows on succeeding lines,
sometimes with examples.

* Menu:

* A Sample Function Description::       A description of an imaginary
                                          function, ‘foo’.
* A Sample Variable Description::       A description of an imaginary
                                          variable,
                                          ‘electric-future-map’.


File: elisp.info,  Node: A Sample Function Description,  Next: A Sample Variable Description,  Up: Format of Descriptions

1.3.7.1 A Sample Function Description
.....................................

In a function description, the name of the function being described
appears first.  It is followed on the same line by a list of argument
names.  These names are also used in the body of the description, to
stand for the values of the arguments.

   The appearance of the keyword ‘&optional’ in the argument list
indicates that the subsequent arguments may be omitted (omitted
arguments default to ‘nil’).  Do not write ‘&optional’ when you call the
function.

   The keyword ‘&rest’ (which must be followed by a single argument
name) indicates that any number of arguments can follow.  The single
argument name following ‘&rest’ receives, as its value, a list of all
the remaining arguments passed to the function.  Do not write ‘&rest’
when you call the function.

   Here is a description of an imaginary function ‘foo’:

 -- Function: foo integer1 &optional integer2 &rest integers
     The function ‘foo’ subtracts INTEGER1 from INTEGER2, then adds all
     the rest of the arguments to the result.  If INTEGER2 is not
     supplied, then the number 19 is used by default.

          (foo 1 5 3 9)
               ⇒ 16
          (foo 5)
               ⇒ 14

     More generally,

          (foo W X Y...)
          ≡
          (+ (- X W) Y...)

   By convention, any argument whose name contains the name of a type
(e.g., INTEGER, INTEGER1 or BUFFER) is expected to be of that type.  A
plural of a type (such as BUFFERS) often means a list of objects of that
type.  An argument named OBJECT may be of any type.  (For a list of
Emacs object types, *note Lisp Data Types::.)  An argument with any
other sort of name (e.g., NEW-FILE) is specific to the function; if the
function has a documentation string, the type of the argument should be
described there (*note Documentation::).

   *Note Lambda Expressions::, for a more complete description of
arguments modified by ‘&optional’ and ‘&rest’.

   Command, macro, and special form descriptions have the same format,
but the word ‘Function’ is replaced by ‘Command’, ‘Macro’, or ‘Special
Form’, respectively.  Commands are simply functions that may be called
interactively; macros process their arguments differently from functions
(the arguments are not evaluated), but are presented the same way.

   The descriptions of macros and special forms use a more complex
notation to specify optional and repeated arguments, because they can
break the argument list down into separate arguments in more complicated
ways.  ‘[OPTIONAL-ARG]’ means that OPTIONAL-ARG is optional and
‘REPEATED-ARGS...’ stands for zero or more arguments.  Parentheses are
used when several arguments are grouped into additional levels of list
structure.  Here is an example:

 -- Special Form: count-loop (var [from to [inc]]) body...
     This imaginary special form implements a loop that executes the
     BODY forms and then increments the variable VAR on each iteration.
     On the first iteration, the variable has the value FROM; on
     subsequent iterations, it is incremented by one (or by INC if that
     is given).  The loop exits before executing BODY if VAR equals TO.
     Here is an example:

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     If FROM and TO are omitted, VAR is bound to ‘nil’ before the loop
     begins, and the loop exits if VAR is non-‘nil’ at the beginning of
     an iteration.  Here is an example:

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     In this special form, the arguments FROM and TO are optional, but
     must both be present or both absent.  If they are present, INC may
     optionally be specified as well.  These arguments are grouped with
     the argument VAR into a list, to distinguish them from BODY, which
     includes all remaining elements of the form.


File: elisp.info,  Node: A Sample Variable Description,  Prev: A Sample Function Description,  Up: Format of Descriptions

1.3.7.2 A Sample Variable Description
.....................................

A “variable” is a name that can be “bound” (or “set”) to an object.  The
object to which a variable is bound is called a “value”; we say also
that variable holds that value.  Although nearly all variables can be
set by the user, certain variables exist specifically so that users can
change them; these are called “user options”.  Ordinary variables and
user options are described using a format like that for functions,
except that there are no arguments.

   Here is a description of the imaginary ‘electric-future-map’
variable.

 -- Variable: electric-future-map
     The value of this variable is a full keymap used by Electric
     Command Future mode.  The functions in this map allow you to edit
     commands you have not yet thought about executing.

   User option descriptions have the same format, but ‘Variable’ is
replaced by ‘User Option’.


File: elisp.info,  Node: Version Info,  Next: Acknowledgments,  Prev: Conventions,  Up: Introduction

1.4 Version Information
=======================

These facilities provide information about which version of Emacs is in
use.

 -- Command: emacs-version &optional here
     This function returns a string describing the version of Emacs that
     is running.  It is useful to include this string in bug reports.

          (emacs-version)
            ⇒ "GNU Emacs 26.1 (build 1, x86_64-unknown-linux-gnu,
                       GTK+ Version 3.16) of 2017-06-01"

     If HERE is non-‘nil’, it inserts the text in the buffer before
     point, and returns ‘nil’.  When this function is called
     interactively, it prints the same information in the echo area, but
     giving a prefix argument makes HERE non-‘nil’.

 -- Variable: emacs-build-time
     The value of this variable indicates the time at which Emacs was
     built.  It is a list of four integers, like the value of
     ‘current-time’ (*note Time of Day::), or is ‘nil’ if the
     information is not available.

          emacs-build-time
               ⇒ (20614 63694 515336 438000)

 -- Variable: emacs-version
     The value of this variable is the version of Emacs being run.  It
     is a string such as ‘"26.1"’.  A value with three numeric
     components, such as ‘"26.0.91"’, indicates an unreleased test
     version.  (Prior to Emacs 26.1, the string includes an extra final
     component with the integer that is now stored in
     ‘emacs-build-number’; e.g., ‘"25.1.1"’.)

 -- Variable: emacs-major-version
     The major version number of Emacs, as an integer.  For Emacs
     version 23.1, the value is 23.

 -- Variable: emacs-minor-version
     The minor version number of Emacs, as an integer.  For Emacs
     version 23.1, the value is 1.

 -- Variable: emacs-build-number
     An integer that increments each time Emacs is built in the same
     directory (without cleaning).  This is only of relevance when
     developing Emacs.


File: elisp.info,  Node: Acknowledgments,  Prev: Version Info,  Up: Introduction

1.5 Acknowledgments
===================

This manual was originally written by Robert Krawitz, Bil Lewis, Dan
LaLiberte, Richard M. Stallman and Chris Welty, the volunteers of the
GNU manual group, in an effort extending over several years.  Robert J.
Chassell helped to review and edit the manual, with the support of the
Defense Advanced Research Projects Agency, ARPA Order 6082, arranged by
Warren A. Hunt, Jr. of Computational Logic, Inc.  Additional sections
have since been written by Miles Bader, Lars Brinkhoff, Chong Yidong,
Kenichi Handa, Lute Kamstra, Juri Linkov, Glenn Morris, Thien-Thi
Nguyen, Dan Nicolaescu, Martin Rudalics, Kim F. Storm, Luc Teirlinck,
and Eli Zaretskii, and others.

   Corrections were supplied by Drew Adams, Juanma Barranquero, Karl
Berry, Jim Blandy, Bard Bloom, Stephane Boucher, David Boyes, Alan
Carroll, Richard Davis, Lawrence R. Dodd, Peter Doornbosch, David A.
Duff, Chris Eich, Beverly Erlebacher, David Eckelkamp, Ralf Fassel,
Eirik Fuller, Stephen Gildea, Bob Glickstein, Eric Hanchrow, Jesper
Harder, George Hartzell, Nathan Hess, Masayuki Ida, Dan Jacobson, Jak
Kirman, Bob Knighten, Frederick M. Korz, Joe Lammens, Glenn M. Lewis, K.
Richard Magill, Brian Marick, Roland McGrath, Stefan Monnier, Skip
Montanaro, John Gardiner Myers, Thomas A. Peterson, Francesco Potortì,
Friedrich Pukelsheim, Arnold D. Robbins, Raul Rockwell, Jason Rumney,
Per Starbäck, Shinichirou Sugou, Kimmo Suominen, Edward Tharp, Bill
Trost, Rickard Westman, Jean White, Eduard Wiebe, Matthew Wilding, Carl
Witty, Dale Worley, Rusty Wright, and David D. Zuhn.

   For a more complete list of contributors, please see the relevant
change log entries in the Emacs source repository.


File: elisp.info,  Node: Lisp Data Types,  Next: Numbers,  Prev: Introduction,  Up: Top

2 Lisp Data Types
*****************

A Lisp “object” is a piece of data used and manipulated by Lisp
programs.  For our purposes, a “type” or “data type” is a set of
possible objects.

   Every object belongs to at least one type.  Objects of the same type
have similar structures and may usually be used in the same contexts.
Types can overlap, and objects can belong to two or more types.
Consequently, we can ask whether an object belongs to a particular type,
but not for _the_ type of an object.

   A few fundamental object types are built into Emacs.  These, from
which all other types are constructed, are called “primitive types”.
Each object belongs to one and only one primitive type.  These types
include “integer”, “float”, “cons”, “symbol”, “string”, “vector”,
“hash-table”, “subr”, “byte-code function”, and “record”, plus several
special types, such as “buffer”, that are related to editing.  (*Note
Editing Types::.)

   Each primitive type has a corresponding Lisp function that checks
whether an object is a member of that type.

   Lisp is unlike many other languages in that its objects are
“self-typing”: the primitive type of each object is implicit in the
object itself.  For example, if an object is a vector, nothing can treat
it as a number; Lisp knows it is a vector, not a number.

   In most languages, the programmer must declare the data type of each
variable, and the type is known by the compiler but not represented in
the data.  Such type declarations do not exist in Emacs Lisp.  A Lisp
variable can have any type of value, and it remembers whatever value you
store in it, type and all.  (Actually, a small number of Emacs Lisp
variables can only take on values of a certain type.  *Note Variables
with Restricted Values::.)

   This chapter describes the purpose, printed representation, and read
syntax of each of the standard types in GNU Emacs Lisp.  Details on how
to use these types can be found in later chapters.

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Circular Objects::            Read syntax for circular structure.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.


File: elisp.info,  Node: Printed Representation,  Next: Comments,  Up: Lisp Data Types

2.1 Printed Representation and Read Syntax
==========================================

The “printed representation” of an object is the format of the output
generated by the Lisp printer (the function ‘prin1’) for that object.
Every data type has a unique printed representation.  The “read syntax”
of an object is the format of the input accepted by the Lisp reader (the
function ‘read’) for that object.  This is not necessarily unique; many
kinds of object have more than one syntax.  *Note Read and Print::.

   In most cases, an object’s printed representation is also a read
syntax for the object.  However, some types have no read syntax, since
it does not make sense to enter objects of these types as constants in a
Lisp program.  These objects are printed in “hash notation”, which
consists of the characters ‘#<’, a descriptive string (typically the
type name followed by the name of the object), and a closing ‘>’.  For
example:

     (current-buffer)
          ⇒ #<buffer objects.texi>

Hash notation cannot be read at all, so the Lisp reader signals the
error ‘invalid-read-syntax’ whenever it encounters ‘#<’.

   In other languages, an expression is text; it has no other form.  In
Lisp, an expression is primarily a Lisp object and only secondarily the
text that is the object’s read syntax.  Often there is no need to
emphasize this distinction, but you must keep it in the back of your
mind, or you will occasionally be very confused.

   When you evaluate an expression interactively, the Lisp interpreter
first reads the textual representation of it, producing a Lisp object,
and then evaluates that object (*note Evaluation::).  However,
evaluation and reading are separate activities.  Reading returns the
Lisp object represented by the text that is read; the object may or may
not be evaluated later.  *Note Input Functions::, for a description of
‘read’, the basic function for reading objects.


File: elisp.info,  Node: Comments,  Next: Programming Types,  Prev: Printed Representation,  Up: Lisp Data Types

2.2 Comments
============

A “comment” is text that is written in a program only for the sake of
humans that read the program, and that has no effect on the meaning of
the program.  In Lisp, a semicolon (‘;’) starts a comment if it is not
within a string or character constant.  The comment continues to the end
of line.  The Lisp reader discards comments; they do not become part of
the Lisp objects which represent the program within the Lisp system.

   The ‘#@COUNT’ construct, which skips the next COUNT characters, is
useful for program-generated comments containing binary data.  The Emacs
Lisp byte compiler uses this in its output files (*note Byte
Compilation::).  It isn’t meant for source files, however.

   *Note Comment Tips::, for conventions for formatting comments.


File: elisp.info,  Node: Programming Types,  Next: Editing Types,  Prev: Comments,  Up: Lisp Data Types

2.3 Programming Types
=====================

There are two general categories of types in Emacs Lisp: those having to
do with Lisp programming, and those having to do with editing.  The
former exist in many Lisp implementations, in one form or another.  The
latter are unique to Emacs Lisp.

* Menu:

* Integer Type::        Numbers without fractional parts.
* Floating-Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of ‘t’ or ‘nil’.
* Hash Table Type::     Super-fast lookup tables.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Record Type::         Compound objects with programmer-defined types.
* Type Descriptors::    Objects holding information about types.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.
* Finalizer Type::      Runs code when no longer reachable.


File: elisp.info,  Node: Integer Type,  Next: Floating-Point Type,  Up: Programming Types

2.3.1 Integer Type
------------------

The range of values for an integer depends on the machine.  The minimum
range is −536,870,912 to 536,870,911 (30 bits; i.e., −2**29 to 2**29 −
1) but many machines provide a wider range.  Emacs Lisp arithmetic
functions do not check for integer overflow.  Thus ‘(1+ 536870911)’ is
−536,870,912 if Emacs integers are 30 bits.

   The read syntax for integers is a sequence of (base ten) digits with
an optional sign at the beginning and an optional period at the end.
The printed representation produced by the Lisp interpreter never has a
leading ‘+’ or a final ‘.’.

     -1               ; The integer −1.
     1                ; The integer 1.
     1.               ; Also the integer 1.
     +1               ; Also the integer 1.

As a special exception, if a sequence of digits specifies an integer too
large or too small to be a valid integer object, the Lisp reader reads
it as a floating-point number (*note Floating-Point Type::).  For
instance, if Emacs integers are 30 bits, ‘536870912’ is read as the
floating-point number ‘536870912.0’.

   *Note Numbers::, for more information.


File: elisp.info,  Node: Floating-Point Type,  Next: Character Type,  Prev: Integer Type,  Up: Programming Types

2.3.2 Floating-Point Type
-------------------------

Floating-point numbers are the computer equivalent of scientific
notation; you can think of a floating-point number as a fraction
together with a power of ten.  The precise number of significant figures
and the range of possible exponents is machine-specific; Emacs uses the
C data type ‘double’ to store the value, and internally this records a
power of 2 rather than a power of 10.

   The printed representation for floating-point numbers requires either
a decimal point (with at least one digit following), an exponent, or
both.  For example, ‘1500.0’, ‘+15e2’, ‘15.0e+2’, ‘+1500000e-3’, and
‘.15e4’ are five ways of writing a floating-point number whose value is
1500.  They are all equivalent.

   *Note Numbers::, for more information.


File: elisp.info,  Node: Character Type,  Next: Symbol Type,  Prev: Floating-Point Type,  Up: Programming Types

2.3.3 Character Type
--------------------

A “character” in Emacs Lisp is nothing more than an integer.  In other
words, characters are represented by their character codes.  For
example, the character ‘A’ is represented as the integer 65.

   Individual characters are used occasionally in programs, but it is
more common to work with _strings_, which are sequences composed of
characters.  *Note String Type::.

   Characters in strings and buffers are currently limited to the range
of 0 to 4194303—twenty two bits (*note Character Codes::).  Codes 0
through 127 are ASCII codes; the rest are non-ASCII (*note Non-ASCII
Characters::).  Characters that represent keyboard input have a much
wider range, to encode modifier keys such as Control, Meta and Shift.

   There are special functions for producing a human-readable textual
description of a character for the sake of messages.  *Note Describing
Characters::.

* Menu:

* Basic Char Syntax::      Syntax for regular characters.
* General Escape Syntax::  How to specify characters by their codes.
* Ctl-Char Syntax::        Syntax for control characters.
* Meta-Char Syntax::       Syntax for meta-characters.
* Other Char Bits::        Syntax for hyper-, super-, and alt-characters.


File: elisp.info,  Node: Basic Char Syntax,  Next: General Escape Syntax,  Up: Character Type

2.3.3.1 Basic Char Syntax
.........................

Since characters are really integers, the printed representation of a
character is a decimal number.  This is also a possible read syntax for
a character, but writing characters that way in Lisp programs is not
clear programming.  You should _always_ use the special read syntax
formats that Emacs Lisp provides for characters.  These syntax formats
start with a question mark.

   The usual read syntax for alphanumeric characters is a question mark
followed by the character; thus, ‘?A’ for the character ‘A’, ‘?B’ for
the character ‘B’, and ‘?a’ for the character ‘a’.

   For example:

     ?Q ⇒ 81     ?q ⇒ 113

   You can use the same syntax for punctuation characters.  However, if
the punctuation character has a special syntactic meaning in Lisp, you
must quote it with a ‘\’.  For example, ‘?\(’ is the way to write the
open-paren character.  Likewise, if the character is ‘\’, you must use a
second ‘\’ to quote it: ‘?\\’.

   You can express the characters control-g, backspace, tab, newline,
vertical tab, formfeed, space, return, del, and escape as ‘?\a’, ‘?\b’,
‘?\t’, ‘?\n’, ‘?\v’, ‘?\f’, ‘?\s’, ‘?\r’, ‘?\d’, and ‘?\e’,
respectively.  (‘?\s’ followed by a dash has a different meaning—it
applies the Super modifier to the following character.)  Thus,

     ?\a ⇒ 7                 ; control-g, ‘C-g’
     ?\b ⇒ 8                 ; backspace, <BS>, ‘C-h’
     ?\t ⇒ 9                 ; tab, <TAB>, ‘C-i’
     ?\n ⇒ 10                ; newline, ‘C-j’
     ?\v ⇒ 11                ; vertical tab, ‘C-k’
     ?\f ⇒ 12                ; formfeed character, ‘C-l’
     ?\r ⇒ 13                ; carriage return, <RET>, ‘C-m’
     ?\e ⇒ 27                ; escape character, <ESC>, ‘C-[’
     ?\s ⇒ 32                ; space character, <SPC>
     ?\\ ⇒ 92                ; backslash character, ‘\’
     ?\d ⇒ 127               ; delete character, <DEL>

   These sequences which start with backslash are also known as “escape
sequences”, because backslash plays the role of an escape character;
this has nothing to do with the character <ESC>.  ‘\s’ is meant for use
in character constants; in string constants, just write the space.

   A backslash is allowed, and harmless, preceding any character without
a special escape meaning; thus, ‘?\+’ is equivalent to ‘?+’.  There is
no reason to add a backslash before most characters.  However, you must
add a backslash before any of the characters ‘()[]\;"’, and you should
add a backslash before any of the characters ‘|'`#.,’ to avoid confusing
the Emacs commands for editing Lisp code.  You can also add a backslash
before whitespace characters such as space, tab, newline and formfeed.
However, it is cleaner to use one of the easily readable escape
sequences, such as ‘\t’ or ‘\s’, instead of an actual whitespace
character such as a tab or a space.  (If you do write backslash followed
by a space, you should write an extra space after the character constant
to separate it from the following text.)


File: elisp.info,  Node: General Escape Syntax,  Next: Ctl-Char Syntax,  Prev: Basic Char Syntax,  Up: Character Type

2.3.3.2 General Escape Syntax
.............................

In addition to the specific escape sequences for special important
control characters, Emacs provides several types of escape syntax that
you can use to specify non-ASCII text characters.

  1. You can specify characters by their Unicode names, if any.
     ‘?\N{NAME}’ represents the Unicode character named NAME.  Thus,
     ‘?\N{LATIN SMALL LETTER A WITH GRAVE}’ is equivalent to ‘?à’ and
     denotes the Unicode character U+00E0.  To simplify entering
     multi-line strings, you can replace spaces in the names by
     non-empty sequences of whitespace (e.g., newlines).

  2. You can specify characters by their Unicode values.  ‘?\N{U+X}’
     represents a character with Unicode code point X, where X is a
     hexadecimal number.  Also, ‘?\uXXXX’ and ‘?\UXXXXXXXX’ represent
     code points XXXX and XXXXXXXX, respectively, where each X is a
     single hexadecimal digit.  For example, ‘?\N{U+E0}’, ‘?\u00e0’ and
     ‘?\U000000E0’ are all equivalent to ‘?à’ and to ‘?\N{LATIN SMALL
     LETTER A WITH GRAVE}’.  The Unicode Standard defines code points
     only up to ‘U+10FFFF’, so if you specify a code point higher than
     that, Emacs signals an error.

  3. You can specify characters by their hexadecimal character codes.  A
     hexadecimal escape sequence consists of a backslash, ‘x’, and the
     hexadecimal character code.  Thus, ‘?\x41’ is the character ‘A’,
     ‘?\x1’ is the character ‘C-a’, and ‘?\xe0’ is the character ‘à’
     (‘a’ with grave accent).  You can use any number of hex digits, so
     you can represent any character code in this way.

  4. You can specify characters by their character code in octal.  An
     octal escape sequence consists of a backslash followed by up to
     three octal digits; thus, ‘?\101’ for the character ‘A’, ‘?\001’
     for the character ‘C-a’, and ‘?\002’ for the character ‘C-b’.  Only
     characters up to octal code 777 can be specified this way.

   These escape sequences may also be used in strings.  *Note Non-ASCII
in Strings::.


File: elisp.info,  Node: Ctl-Char Syntax,  Next: Meta-Char Syntax,  Prev: General Escape Syntax,  Up: Character Type

2.3.3.3 Control-Character Syntax
................................

Control characters can be represented using yet another read syntax.
This consists of a question mark followed by a backslash, caret, and the
corresponding non-control character, in either upper or lower case.  For
example, both ‘?\^I’ and ‘?\^i’ are valid read syntax for the character
‘C-i’, the character whose value is 9.

   Instead of the ‘^’, you can use ‘C-’; thus, ‘?\C-i’ is equivalent to
‘?\^I’ and to ‘?\^i’:

     ?\^I ⇒ 9     ?\C-I ⇒ 9

   In strings and buffers, the only control characters allowed are those
that exist in ASCII; but for keyboard input purposes, you can turn any
character into a control character with ‘C-’.  The character codes for
these non-ASCII control characters include the 2**26 bit as well as the
code for the corresponding non-control character.  Ordinary text
terminals have no way of generating non-ASCII control characters, but
you can generate them straightforwardly using X and other window
systems.

   For historical reasons, Emacs treats the <DEL> character as the
control equivalent of ‘?’:

     ?\^? ⇒ 127     ?\C-? ⇒ 127

As a result, it is currently not possible to represent the character
‘Control-?’, which is a meaningful input character under X, using ‘\C-’.
It is not easy to change this, as various Lisp files refer to <DEL> in
this way.

   For representing control characters to be found in files or strings,
we recommend the ‘^’ syntax; for control characters in keyboard input,
we prefer the ‘C-’ syntax.  Which one you use does not affect the
meaning of the program, but may guide the understanding of people who
read it.


File: elisp.info,  Node: Meta-Char Syntax,  Next: Other Char Bits,  Prev: Ctl-Char Syntax,  Up: Character Type

2.3.3.4 Meta-Character Syntax
.............................

A “meta character” is a character typed with the <META> modifier key.
The integer that represents such a character has the 2**27 bit set.  We
use high bits for this and other modifiers to make possible a wide range
of basic character codes.

   In a string, the 2**7 bit attached to an ASCII character indicates a
meta character; thus, the meta characters that can fit in a string have
codes in the range from 128 to 255, and are the meta versions of the
ordinary ASCII characters.  *Note Strings of Events::, for details about
<META>-handling in strings.

   The read syntax for meta characters uses ‘\M-’.  For example, ‘?\M-A’
stands for ‘M-A’.  You can use ‘\M-’ together with octal character codes
(see below), with ‘\C-’, or with any other syntax for a character.
Thus, you can write ‘M-A’ as ‘?\M-A’, or as ‘?\M-\101’.  Likewise, you
can write ‘C-M-b’ as ‘?\M-\C-b’, ‘?\C-\M-b’, or ‘?\M-\002’.


File: elisp.info,  Node: Other Char Bits,  Prev: Meta-Char Syntax,  Up: Character Type

2.3.3.5 Other Character Modifier Bits
.....................................

The case of a graphic character is indicated by its character code; for
example, ASCII distinguishes between the characters ‘a’ and ‘A’.  But
ASCII has no way to represent whether a control character is upper case
or lower case.  Emacs uses the 2**25 bit to indicate that the shift key
was used in typing a control character.  This distinction is possible
only when you use X terminals or other special terminals; ordinary text
terminals do not report the distinction.  The Lisp syntax for the shift
bit is ‘\S-’; thus, ‘?\C-\S-o’ or ‘?\C-\S-O’ represents the
shifted-control-o character.

   The X Window System defines three other modifier bits that can be set
in a character: “hyper”, “super” and “alt”.  The syntaxes for these bits
are ‘\H-’, ‘\s-’ and ‘\A-’.  (Case is significant in these prefixes.)
Thus, ‘?\H-\M-\A-x’ represents ‘Alt-Hyper-Meta-x’.  (Note that ‘\s’ with
no following ‘-’ represents the space character.)  Numerically, the bit
values are 2**22 for alt, 2**23 for super and 2**24 for hyper.


File: elisp.info,  Node: Symbol Type,  Next: Sequence Type,  Prev: Character Type,  Up: Programming Types

2.3.4 Symbol Type
-----------------

A “symbol” in GNU Emacs Lisp is an object with a name.  The symbol name
serves as the printed representation of the symbol.  In ordinary Lisp
use, with one single obarray (*note Creating Symbols::), a symbol’s name
is unique—no two symbols have the same name.

   A symbol can serve as a variable, as a function name, or to hold a
property list.  Or it may serve only to be distinct from all other Lisp
objects, so that its presence in a data structure may be recognized
reliably.  In a given context, usually only one of these uses is
intended.  But you can use one symbol in all of these ways,
independently.

   A symbol whose name starts with a colon (‘:’) is called a “keyword
symbol”.  These symbols automatically act as constants, and are normally
used only by comparing an unknown symbol with a few specific
alternatives.  *Note Constant Variables::.

   A symbol name can contain any characters whatever.  Most symbol names
are written with letters, digits, and the punctuation characters
‘-+=*/’.  Such names require no special punctuation; the characters of
the name suffice as long as the name does not look like a number.  (If
it does, write a ‘\’ at the beginning of the name to force
interpretation as a symbol.)  The characters ‘_~!@$%^&:<>{}?’ are less
often used but also require no special punctuation.  Any other
characters may be included in a symbol’s name by escaping them with a
backslash.  In contrast to its use in strings, however, a backslash in
the name of a symbol simply quotes the single character that follows the
backslash.  For example, in a string, ‘\t’ represents a tab character;
in the name of a symbol, however, ‘\t’ merely quotes the letter ‘t’.  To
have a symbol with a tab character in its name, you must actually use a
tab (preceded with a backslash).  But it’s rare to do such a thing.

     Common Lisp note: In Common Lisp, lower case letters are always
     folded to upper case, unless they are explicitly escaped.  In Emacs
     Lisp, upper case and lower case letters are distinct.

   Here are several examples of symbol names.  Note that the ‘+’ in the
fourth example is escaped to prevent it from being read as a number.
This is not necessary in the sixth example because the rest of the name
makes it invalid as a number.

     foo                 ; A symbol named ‘foo’.
     FOO                 ; A symbol named ‘FOO’, different from ‘foo’.
     1+                  ; A symbol named ‘1+’
                         ;   (not ‘+1’, which is an integer).
     \+1                 ; A symbol named ‘+1’
                         ;   (not a very readable name).
     \(*\ 1\ 2\)         ; A symbol named ‘(* 1 2)’ (a worse name).
     +-*/_~!@$%^&=:<>{}  ; A symbol named ‘+-*/_~!@$%^&=:<>{}’.
                         ;   These characters need not be escaped.

   As an exception to the rule that a symbol’s name serves as its
printed representation, ‘##’ is the printed representation for an
interned symbol whose name is an empty string.  Furthermore, ‘#:FOO’ is
the printed representation for an uninterned symbol whose name is FOO.
(Normally, the Lisp reader interns all symbols; *note Creating
Symbols::.)


File: elisp.info,  Node: Sequence Type,  Next: Cons Cell Type,  Prev: Symbol Type,  Up: Programming Types

2.3.5 Sequence Types
--------------------

A “sequence” is a Lisp object that represents an ordered set of
elements.  There are two kinds of sequence in Emacs Lisp: “lists” and
“arrays”.

   Lists are the most commonly-used sequences.  A list can hold elements
of any type, and its length can be easily changed by adding or removing
elements.  See the next subsection for more about lists.

   Arrays are fixed-length sequences.  They are further subdivided into
strings, vectors, char-tables and bool-vectors.  Vectors can hold
elements of any type, whereas string elements must be characters, and
bool-vector elements must be ‘t’ or ‘nil’.  Char-tables are like vectors
except that they are indexed by any valid character code.  The
characters in a string can have text properties like characters in a
buffer (*note Text Properties::), but vectors do not support text
properties, even when their elements happen to be characters.

   Lists, strings and the other array types also share important
similarities.  For example, all have a length L, and all have elements
which can be indexed from zero to L minus one.  Several functions,
called sequence functions, accept any kind of sequence.  For example,
the function ‘length’ reports the length of any kind of sequence.  *Note
Sequences Arrays Vectors::.

   It is generally impossible to read the same sequence twice, since
sequences are always created anew upon reading.  If you read the read
syntax for a sequence twice, you get two sequences with equal contents.
There is one exception: the empty list ‘()’ always stands for the same
object, ‘nil’.


File: elisp.info,  Node: Cons Cell Type,  Next: Array Type,  Prev: Sequence Type,  Up: Programming Types

2.3.6 Cons Cell and List Types
------------------------------

A “cons cell” is an object that consists of two slots, called the CAR
slot and the CDR slot.  Each slot can “hold” any Lisp object.  We also
say that the CAR of this cons cell is whatever object its CAR slot
currently holds, and likewise for the CDR.

   A “list” is a series of cons cells, linked together so that the CDR
slot of each cons cell holds either the next cons cell or the empty
list.  The empty list is actually the symbol ‘nil’.  *Note Lists::, for
details.  Because most cons cells are used as part of lists, we refer to
any structure made out of cons cells as a “list structure”.

     A note to C programmers: a Lisp list thus works as a “linked list”
     built up of cons cells.  Because pointers in Lisp are implicit, we
     do not distinguish between a cons cell slot holding a value versus
     pointing to the value.

   Because cons cells are so central to Lisp, we also have a word for an
object which is not a cons cell.  These objects are called “atoms”.

   The read syntax and printed representation for lists are identical,
and consist of a left parenthesis, an arbitrary number of elements, and
a right parenthesis.  Here are examples of lists:

     (A 2 "A")            ; A list of three elements.
     ()                   ; A list of no elements (the empty list).
     nil                  ; A list of no elements (the empty list).
     ("A ()")             ; A list of one element: the string ‘"A ()"’.
     (A ())               ; A list of two elements: ‘A’ and the empty list.
     (A nil)              ; Equivalent to the previous.
     ((A B C))            ; A list of one element
                          ;   (which is a list of three elements).

   Upon reading, each object inside the parentheses becomes an element
of the list.  That is, a cons cell is made for each element.  The CAR
slot of the cons cell holds the element, and its CDR slot refers to the
next cons cell of the list, which holds the next element in the list.
The CDR slot of the last cons cell is set to hold ‘nil’.

   The names CAR and CDR derive from the history of Lisp.  The original
Lisp implementation ran on an IBM 704 computer which divided words into
two parts, the address and the decrement; CAR was an instruction to
extract the contents of the address part of a register, and CDR an
instruction to extract the contents of the decrement.  By contrast, cons
cells are named for the function ‘cons’ that creates them, which in turn
was named for its purpose, the construction of cells.

* Menu:

* Box Diagrams::                Drawing pictures of lists.
* Dotted Pair Notation::        A general syntax for cons cells.
* Association List Type::       A specially constructed list.


File: elisp.info,  Node: Box Diagrams,  Next: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.1 Drawing Lists as Box Diagrams
.....................................

A list can be illustrated by a diagram in which the cons cells are shown
as pairs of boxes, like dominoes.  (The Lisp reader cannot read such an
illustration; unlike the textual notation, which can be understood by
both humans and computers, the box illustrations can be understood only
by humans.)  This picture represents the three-element list ‘(rose
violet buttercup)’:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

   In this diagram, each box represents a slot that can hold or refer to
any Lisp object.  Each pair of boxes represents a cons cell.  Each arrow
represents a reference to a Lisp object, either an atom or another cons
cell.

   In this example, the first box, which holds the CAR of the first cons
cell, refers to or holds ‘rose’ (a symbol).  The second box, holding the
CDR of the first cons cell, refers to the next pair of boxes, the second
cons cell.  The CAR of the second cons cell is ‘violet’, and its CDR is
the third cons cell.  The CDR of the third (and last) cons cell is
‘nil’.

   Here is another diagram of the same list, ‘(rose violet buttercup)’,
sketched in a different manner:

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

   A list with no elements in it is the “empty list”; it is identical to
the symbol ‘nil’.  In other words, ‘nil’ is both a symbol and a list.

   Here is the list ‘(A ())’, or equivalently ‘(A nil)’, depicted with
boxes and arrows:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil

   Here is a more complex illustration, showing the three-element list,
‘((pine needles) oak maple)’, the first element of which is a
two-element list:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
                --- ---      --- ---
                 |            |
                 |            |
                  --> pine     --> needles

   The same list represented in the second box notation looks like this:

      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o------->| oak   |   o------->| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------>| pine  |   o------->| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------


File: elisp.info,  Node: Dotted Pair Notation,  Next: Association List Type,  Prev: Box Diagrams,  Up: Cons Cell Type

2.3.6.2 Dotted Pair Notation
............................

“Dotted pair notation” is a general syntax for cons cells that
represents the CAR and CDR explicitly.  In this syntax, ‘(A . B)’ stands
for a cons cell whose CAR is the object A and whose CDR is the object B.
Dotted pair notation is more general than list syntax because the CDR
does not have to be a list.  However, it is more cumbersome in cases
where list syntax would work.  In dotted pair notation, the list ‘(1 2
3)’ is written as ‘(1 . (2 . (3 . nil)))’.  For ‘nil’-terminated lists,
you can use either notation, but list notation is usually clearer and
more convenient.  When printing a list, the dotted pair notation is only
used if the CDR of a cons cell is not a list.

   Here’s an example using boxes to illustrate dotted pair notation.
This example shows the pair ‘(rose . violet)’:

         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose

   You can combine dotted pair notation with list notation to represent
conveniently a chain of cons cells with a non-‘nil’ final CDR.  You
write a dot after the last element of the list, followed by the CDR of
the final cons cell.  For example, ‘(rose violet . buttercup)’ is
equivalent to ‘(rose . (violet . buttercup))’.  The object looks like
this:

         --- ---      --- ---
        |   |   |--> |   |   |--> buttercup
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   The syntax ‘(rose . violet . buttercup)’ is invalid because there is
nothing that it could mean.  If anything, it would say to put
‘buttercup’ in the CDR of a cons cell whose CDR is already used for
‘violet’.

   The list ‘(rose violet)’ is equivalent to ‘(rose . (violet))’, and
looks like this:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   Similarly, the three-element list ‘(rose violet buttercup)’ is
equivalent to ‘(rose . (violet . (buttercup)))’.  It looks like this:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup


File: elisp.info,  Node: Association List Type,  Prev: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.3 Association List Type
.............................

An “association list” or “alist” is a specially-constructed list whose
elements are cons cells.  In each element, the CAR is considered a
“key”, and the CDR is considered an “associated value”.  (In some cases,
the associated value is stored in the CAR of the CDR.)  Association
lists are often used as stacks, since it is easy to add or remove
associations at the front of the list.

   For example,

     (setq alist-of-colors
           '((rose . red) (lily . white) (buttercup . yellow)))

sets the variable ‘alist-of-colors’ to an alist of three elements.  In
the first element, ‘rose’ is the key and ‘red’ is the value.

   *Note Association Lists::, for a further explanation of alists and
for functions that work on alists.  *Note Hash Tables::, for another
kind of lookup table, which is much faster for handling a large number
of keys.


File: elisp.info,  Node: Array Type,  Next: String Type,  Prev: Cons Cell Type,  Up: Programming Types

2.3.7 Array Type
----------------

An “array” is composed of an arbitrary number of slots for holding or
referring to other Lisp objects, arranged in a contiguous block of
memory.  Accessing any element of an array takes approximately the same
amount of time.  In contrast, accessing an element of a list requires
time proportional to the position of the element in the list.  (Elements
at the end of a list take longer to access than elements at the
beginning of a list.)

   Emacs defines four types of array: strings, vectors, bool-vectors,
and char-tables.

   A string is an array of characters and a vector is an array of
arbitrary objects.  A bool-vector can hold only ‘t’ or ‘nil’.  These
kinds of array may have any length up to the largest integer.
Char-tables are sparse arrays indexed by any valid character code; they
can hold arbitrary objects.

   The first element of an array has index zero, the second element has
index 1, and so on.  This is called “zero-origin” indexing.  For
example, an array of four elements has indices 0, 1, 2, and 3.  The
largest possible index value is one less than the length of the array.
Once an array is created, its length is fixed.

   All Emacs Lisp arrays are one-dimensional.  (Most other programming
languages support multidimensional arrays, but they are not essential;
you can get the same effect with nested one-dimensional arrays.)  Each
type of array has its own read syntax; see the following sections for
details.

   The array type is a subset of the sequence type, and contains the
string type, the vector type, the bool-vector type, and the char-table
type.


File: elisp.info,  Node: String Type,  Next: Vector Type,  Prev: Array Type,  Up: Programming Types

2.3.8 String Type
-----------------

A “string” is an array of characters.  Strings are used for many
purposes in Emacs, as can be expected in a text editor; for example, as
the names of Lisp symbols, as messages for the user, and to represent
text extracted from buffers.  Strings in Lisp are constants: evaluation
of a string returns the same string.

   *Note Strings and Characters::, for functions that operate on
strings.

* Menu:

* Syntax for Strings::      How to specify Lisp strings.
* Non-ASCII in Strings::    International characters in strings.
* Nonprinting Characters::  Literal unprintable characters in strings.
* Text Props and Strings::  Strings with text properties.


File: elisp.info,  Node: Syntax for Strings,  Next: Non-ASCII in Strings,  Up: String Type

2.3.8.1 Syntax for Strings
..........................

The read syntax for a string is a double-quote, an arbitrary number of
characters, and another double-quote, ‘"like this"’.  To include a
double-quote in a string, precede it with a backslash; thus, ‘"\""’ is a
string containing just one double-quote character.  Likewise, you can
include a backslash by preceding it with another backslash, like this:
‘"this \\ is a single embedded backslash"’.

   The newline character is not special in the read syntax for strings;
if you write a new line between the double-quotes, it becomes a
character in the string.  But an escaped newline—one that is preceded by
‘\’—does not become part of the string; i.e., the Lisp reader ignores an
escaped newline while reading a string.  An escaped space ‘\ ’ is
likewise ignored.

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          ⇒ "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."


File: elisp.info,  Node: Non-ASCII in Strings,  Next: Nonprinting Characters,  Prev: Syntax for Strings,  Up: String Type

2.3.8.2 Non-ASCII Characters in Strings
.......................................

There are two text representations for non-ASCII characters in Emacs
strings: multibyte and unibyte (*note Text Representations::).  Roughly
speaking, unibyte strings store raw bytes, while multibyte strings store
human-readable text.  Each character in a unibyte string is a byte,
i.e., its value is between 0 and 255.  By contrast, each character in a
multibyte string may have a value between 0 to 4194303 (*note Character
Type::).  In both cases, characters above 127 are non-ASCII.

   You can include a non-ASCII character in a string constant by writing
it literally.  If the string constant is read from a multibyte source,
such as a multibyte buffer or string, or a file that would be visited as
multibyte, then Emacs reads each non-ASCII character as a multibyte
character and automatically makes the string a multibyte string.  If the
string constant is read from a unibyte source, then Emacs reads the
non-ASCII character as unibyte, and makes the string unibyte.

   Instead of writing a character literally into a multibyte string, you
can write it as its character code using an escape sequence.  *Note
General Escape Syntax::, for details about escape sequences.

   If you use any Unicode-style escape sequence ‘\uNNNN’ or ‘\U00NNNNNN’
in a string constant (even for an ASCII character), Emacs automatically
assumes that it is multibyte.

   You can also use hexadecimal escape sequences (‘\xN’) and octal
escape sequences (‘\N’) in string constants.  *But beware:* If a string
constant contains hexadecimal or octal escape sequences, and these
escape sequences all specify unibyte characters (i.e., less than 256),
and there are no other literal non-ASCII characters or Unicode-style
escape sequences in the string, then Emacs automatically assumes that it
is a unibyte string.  That is to say, it assumes that all non-ASCII
characters occurring in the string are 8-bit raw bytes.

   In hexadecimal and octal escape sequences, the escaped character code
may contain a variable number of digits, so the first subsequent
character which is not a valid hexadecimal or octal digit terminates the
escape sequence.  If the next character in a string could be interpreted
as a hexadecimal or octal digit, write ‘\ ’ (backslash and space) to
terminate the escape sequence.  For example, ‘\xe0\ ’ represents one
character, ‘a’ with grave accent.  ‘\ ’ in a string constant is just
like backslash-newline; it does not contribute any character to the
string, but it does terminate any preceding hex escape.


File: elisp.info,  Node: Nonprinting Characters,  Next: Text Props and Strings,  Prev: Non-ASCII in Strings,  Up: String Type

2.3.8.3 Nonprinting Characters in Strings
.........................................

You can use the same backslash escape-sequences in a string constant as
in character literals (but do not use the question mark that begins a
character constant).  For example, you can write a string containing the
nonprinting characters tab and ‘C-a’, with commas and spaces between
them, like this: ‘"\t, \C-a"’.  *Note Character Type::, for a
description of the read syntax for characters.

   However, not all of the characters you can write with backslash
escape-sequences are valid in strings.  The only control characters that
a string can hold are the ASCII control characters.  Strings do not
distinguish case in ASCII control characters.

   Properly speaking, strings cannot hold meta characters; but when a
string is to be used as a key sequence, there is a special convention
that provides a way to represent meta versions of ASCII characters in a
string.  If you use the ‘\M-’ syntax to indicate a meta character in a
string constant, this sets the 2**7 bit of the character in the string.
If the string is used in ‘define-key’ or ‘lookup-key’, this numeric code
is translated into the equivalent meta character.  *Note Character
Type::.

   Strings cannot hold characters that have the hyper, super, or alt
modifiers.


File: elisp.info,  Node: Text Props and Strings,  Prev: Nonprinting Characters,  Up: String Type

2.3.8.4 Text Properties in Strings
..................................

A string can hold properties for the characters it contains, in addition
to the characters themselves.  This enables programs that copy text
between strings and buffers to copy the text’s properties with no
special effort.  *Note Text Properties::, for an explanation of what
text properties mean.  Strings with text properties use a special read
and print syntax:

     #("CHARACTERS" PROPERTY-DATA...)

where PROPERTY-DATA consists of zero or more elements, in groups of
three as follows:

     BEG END PLIST

The elements BEG and END are integers, and together specify a range of
indices in the string; PLIST is the property list for that range.  For
example,

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

represents a string whose textual contents are ‘foo bar’, in which the
first three characters have a ‘face’ property with value ‘bold’, and the
last three have a ‘face’ property with value ‘italic’.  (The fourth
character has no text properties, so its property list is ‘nil’.  It is
not actually necessary to mention ranges with ‘nil’ as the property
list, since any characters not mentioned in any range will default to
having no properties.)


File: elisp.info,  Node: Vector Type,  Next: Char-Table Type,  Prev: String Type,  Up: Programming Types

2.3.9 Vector Type
-----------------

A “vector” is a one-dimensional array of elements of any type.  It takes
a constant amount of time to access any element of a vector.  (In a
list, the access time of an element is proportional to the distance of
the element from the beginning of the list.)

   The printed representation of a vector consists of a left square
bracket, the elements, and a right square bracket.  This is also the
read syntax.  Like numbers and strings, vectors are considered constants
for evaluation.

     [1 "two" (three)]      ; A vector of three elements.
          ⇒ [1 "two" (three)]

   *Note Vectors::, for functions that work with vectors.


File: elisp.info,  Node: Char-Table Type,  Next: Bool-Vector Type,  Prev: Vector Type,  Up: Programming Types

2.3.10 Char-Table Type
----------------------

A “char-table” is a one-dimensional array of elements of any type,
indexed by character codes.  Char-tables have certain extra features to
make them more useful for many jobs that involve assigning information
to character codes—for example, a char-table can have a parent to
inherit from, a default value, and a small number of extra slots to use
for special purposes.  A char-table can also specify a single value for
a whole character set.

   The printed representation of a char-table is like a vector except
that there is an extra ‘#^’ at the beginning.(1)

   *Note Char-Tables::, for special functions to operate on char-tables.
Uses of char-tables include:

   • Case tables (*note Case Tables::).

   • Character category tables (*note Categories::).

   • Display tables (*note Display Tables::).

   • Syntax tables (*note Syntax Tables::).

   ---------- Footnotes ----------

   (1) You may also encounter ‘#^^’, used for sub-char-tables.


File: elisp.info,  Node: Bool-Vector Type,  Next: Hash Table Type,  Prev: Char-Table Type,  Up: Programming Types

2.3.11 Bool-Vector Type
-----------------------

A “bool-vector” is a one-dimensional array whose elements must be ‘t’ or
‘nil’.

   The printed representation of a bool-vector is like a string, except
that it begins with ‘#&’ followed by the length.  The string constant
that follows actually specifies the contents of the bool-vector as a
bitmap—each character in the string contains 8 bits, which specify the
next 8 elements of the bool-vector (1 stands for ‘t’, and 0 for ‘nil’).
The least significant bits of the character correspond to the lowest
indices in the bool-vector.

     (make-bool-vector 3 t)
          ⇒ #&3"^G"
     (make-bool-vector 3 nil)
          ⇒ #&3"^@"

These results make sense, because the binary code for ‘C-g’ is 111 and
‘C-@’ is the character with code 0.

   If the length is not a multiple of 8, the printed representation
shows extra elements, but these extras really make no difference.  For
instance, in the next example, the two bool-vectors are equal, because
only the first 3 bits are used:

     (equal #&3"\377" #&3"\007")
          ⇒ t


File: elisp.info,  Node: Hash Table Type,  Next: Function Type,  Prev: Bool-Vector Type,  Up: Programming Types

2.3.12 Hash Table Type
----------------------

A hash table is a very fast kind of lookup table, somewhat like an alist
in that it maps keys to corresponding values, but much faster.  The
printed representation of a hash table specifies its properties and
contents, like this:

     (make-hash-table)
          ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                                  rehash-threshold 0.8125 data ())

*Note Hash Tables::, for more information about hash tables.


File: elisp.info,  Node: Function Type,  Next: Macro Type,  Prev: Hash Table Type,  Up: Programming Types

2.3.13 Function Type
--------------------

Lisp functions are executable code, just like functions in other
programming languages.  In Lisp, unlike most languages, functions are
also Lisp objects.  A non-compiled function in Lisp is a lambda
expression: that is, a list whose first element is the symbol ‘lambda’
(*note Lambda Expressions::).

   In most programming languages, it is impossible to have a function
without a name.  In Lisp, a function has no intrinsic name.  A lambda
expression can be called as a function even though it has no name; to
emphasize this, we also call it an “anonymous function” (*note Anonymous
Functions::).  A named function in Lisp is just a symbol with a valid
function in its function cell (*note Defining Functions::).

   Most of the time, functions are called when their names are written
in Lisp expressions in Lisp programs.  However, you can construct or
obtain a function object at run time and then call it with the primitive
functions ‘funcall’ and ‘apply’.  *Note Calling Functions::.


File: elisp.info,  Node: Macro Type,  Next: Primitive Function Type,  Prev: Function Type,  Up: Programming Types

2.3.14 Macro Type
-----------------

A “Lisp macro” is a user-defined construct that extends the Lisp
language.  It is represented as an object much like a function, but with
different argument-passing semantics.  A Lisp macro has the form of a
list whose first element is the symbol ‘macro’ and whose CDR is a Lisp
function object, including the ‘lambda’ symbol.

   Lisp macro objects are usually defined with the built-in ‘defmacro’
macro, but any list that begins with ‘macro’ is a macro as far as Emacs
is concerned.  *Note Macros::, for an explanation of how to write a
macro.

   *Warning*: Lisp macros and keyboard macros (*note Keyboard Macros::)
are entirely different things.  When we use the word “macro” without
qualification, we mean a Lisp macro, not a keyboard macro.


File: elisp.info,  Node: Primitive Function Type,  Next: Byte-Code Type,  Prev: Macro Type,  Up: Programming Types

2.3.15 Primitive Function Type
------------------------------

A “primitive function” is a function callable from Lisp but written in
the C programming language.  Primitive functions are also called “subrs”
or “built-in functions”.  (The word “subr” is derived from
“subroutine”.)  Most primitive functions evaluate all their arguments
when they are called.  A primitive function that does not evaluate all
its arguments is called a “special form” (*note Special Forms::).

   It does not matter to the caller of a function whether the function
is primitive.  However, this does matter if you try to redefine a
primitive with a function written in Lisp.  The reason is that the
primitive function may be called directly from C code.  Calls to the
redefined function from Lisp will use the new definition, but calls from
C code may still use the built-in definition.  Therefore, *we discourage
redefinition of primitive functions*.

   The term “function” refers to all Emacs functions, whether written in
Lisp or C.  *Note Function Type::, for information about the functions
written in Lisp.

   Primitive functions have no read syntax and print in hash notation
with the name of the subroutine.

     (symbol-function 'car)          ; Access the function cell
                                     ;   of the symbol.
          ⇒ #<subr car>
     (subrp (symbol-function 'car))  ; Is this a primitive function?
          ⇒ t                       ; Yes.


File: elisp.info,  Node: Byte-Code Type,  Next: Record Type,  Prev: Primitive Function Type,  Up: Programming Types

2.3.16 Byte-Code Function Type
------------------------------

“Byte-code function objects” are produced by byte-compiling Lisp code
(*note Byte Compilation::).  Internally, a byte-code function object is
much like a vector; however, the evaluator handles this data type
specially when it appears in a function call.  *Note Byte-Code
Objects::.

   The printed representation and read syntax for a byte-code function
object is like that for a vector, with an additional ‘#’ before the
opening ‘[’.


File: elisp.info,  Node: Record Type,  Next: Type Descriptors,  Prev: Byte-Code Type,  Up: Programming Types

2.3.17 Record Type
------------------

A “record” is much like a ‘vector’.  However, the first element is used
to hold its type as returned by ‘type-of’.  The purpose of records is to
allow programmers to create objects with new types that are not built
into Emacs.

   *Note Records::, for functions that work with records.


File: elisp.info,  Node: Type Descriptors,  Next: Autoload Type,  Prev: Record Type,  Up: Programming Types

2.3.18 Type Descriptors
-----------------------

A “type descriptor” is a ‘record’ which holds information about a type.
Slot 1 in the record must be a symbol naming the type, and ‘type-of’
relies on this to return the type of ‘record’ objects.  No other type
descriptor slot is used by Emacs; they are free for use by Lisp
extensions.

   An example of a type descriptor is any instance of
‘cl-structure-class’.


File: elisp.info,  Node: Autoload Type,  Next: Finalizer Type,  Prev: Type Descriptors,  Up: Programming Types

2.3.19 Autoload Type
--------------------

An “autoload object” is a list whose first element is the symbol
‘autoload’.  It is stored as the function definition of a symbol, where
it serves as a placeholder for the real definition.  The autoload object
says that the real definition is found in a file of Lisp code that
should be loaded when necessary.  It contains the name of the file, plus
some other information about the real definition.

   After the file has been loaded, the symbol should have a new function
definition that is not an autoload object.  The new definition is then
called as if it had been there to begin with.  From the user’s point of
view, the function call works as expected, using the function definition
in the loaded file.

   An autoload object is usually created with the function ‘autoload’,
which stores the object in the function cell of a symbol.  *Note
Autoload::, for more details.


File: elisp.info,  Node: Finalizer Type,  Prev: Autoload Type,  Up: Programming Types

2.3.20 Finalizer Type
---------------------

A “finalizer object” helps Lisp code clean up after objects that are no
longer needed.  A finalizer holds a Lisp function object.  When a
finalizer object becomes unreachable after a garbage collection pass,
Emacs calls the finalizer’s associated function object.  When deciding
whether a finalizer is reachable, Emacs does not count references from
finalizer objects themselves, allowing you to use finalizers without
having to worry about accidentally capturing references to finalized
objects themselves.

   Errors in finalizers are printed to ‘*Messages*’.  Emacs runs a given
finalizer object’s associated function exactly once, even if that
function fails.

 -- Function: make-finalizer function
     Make a finalizer that will run FUNCTION.  FUNCTION will be called
     after garbage collection when the returned finalizer object becomes
     unreachable.  If the finalizer object is reachable only through
     references from finalizer objects, it does not count as reachable
     for the purpose of deciding whether to run FUNCTION.  FUNCTION will
     be run once per finalizer object.


File: elisp.info,  Node: Editing Types,  Next: Circular Objects,  Prev: Programming Types,  Up: Lisp Data Types

2.4 Editing Types
=================

The types in the previous section are used for general programming
purposes, and most of them are common to most Lisp dialects.  Emacs Lisp
provides several additional data types for purposes connected with
editing.

* Menu:

* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::          Windows subdivide frames.
* Terminal Type::       A terminal device displays frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A subprocess of Emacs running on the underlying OS.
* Thread Type::         A thread of Emacs Lisp execution.
* Mutex Type::          An exclusive lock for thread synchronization.
* Condition Variable Type::     Condition variable for thread synchronization.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.
* Font Type::           Fonts for displaying text.


File: elisp.info,  Node: Buffer Type,  Next: Marker Type,  Up: Editing Types

2.4.1 Buffer Type
-----------------

A “buffer” is an object that holds text that can be edited (*note
Buffers::).  Most buffers hold the contents of a disk file (*note
Files::) so they can be edited, but some are used for other purposes.
Most buffers are also meant to be seen by the user, and therefore
displayed, at some time, in a window (*note Windows::).  But a buffer
need not be displayed in any window.  Each buffer has a designated
position called “point” (*note Positions::); most editing commands act
on the contents of the current buffer in the neighborhood of point.  At
any time, one buffer is the “current buffer”.

   The contents of a buffer are much like a string, but buffers are not
used like strings in Emacs Lisp, and the available operations are
different.  For example, you can insert text efficiently into an
existing buffer, altering the buffer’s contents, whereas inserting text
into a string requires concatenating substrings, and the result is an
entirely new string object.

   Many of the standard Emacs functions manipulate or test the
characters in the current buffer; a whole chapter in this manual is
devoted to describing these functions (*note Text::).

   Several other data structures are associated with each buffer:

   • a local syntax table (*note Syntax Tables::);

   • a local keymap (*note Keymaps::); and,

   • a list of buffer-local variable bindings (*note Buffer-Local
     Variables::).

   • overlays (*note Overlays::).

   • text properties for the text in the buffer (*note Text
     Properties::).

The local keymap and variable list contain entries that individually
override global bindings or values.  These are used to customize the
behavior of programs in different buffers, without actually changing the
programs.

   A buffer may be “indirect”, which means it shares the text of another
buffer, but presents it differently.  *Note Indirect Buffers::.

   Buffers have no read syntax.  They print in hash notation, showing
the buffer name.

     (current-buffer)
          ⇒ #<buffer objects.texi>


File: elisp.info,  Node: Marker Type,  Next: Window Type,  Prev: Buffer Type,  Up: Editing Types

2.4.2 Marker Type
-----------------

A “marker” denotes a position in a specific buffer.  Markers therefore
have two components: one for the buffer, and one for the position.
Changes in the buffer’s text automatically relocate the position value
as necessary to ensure that the marker always points between the same
two characters in the buffer.

   Markers have no read syntax.  They print in hash notation, giving the
current character position and the name of the buffer.

     (point-marker)
          ⇒ #<marker at 10779 in objects.texi>

   *Note Markers::, for information on how to test, create, copy, and
move markers.


File: elisp.info,  Node: Window Type,  Next: Frame Type,  Prev: Marker Type,  Up: Editing Types

2.4.3 Window Type
-----------------

A “window” describes the portion of the terminal screen that Emacs uses
to display a buffer.  Every window has one associated buffer, whose
contents appear in the window.  By contrast, a given buffer may appear
in one window, no window, or several windows.

   Though many windows may exist simultaneously, at any time one window
is designated the “selected window”.  This is the window where the
cursor is (usually) displayed when Emacs is ready for a command.  The
selected window usually displays the current buffer (*note Current
Buffer::), but this is not necessarily the case.

   Windows are grouped on the screen into frames; each window belongs to
one and only one frame.  *Note Frame Type::.

   Windows have no read syntax.  They print in hash notation, giving the
window number and the name of the buffer being displayed.  The window
numbers exist to identify windows uniquely, since the buffer displayed
in any given window can change frequently.

     (selected-window)
          ⇒ #<window 1 on objects.texi>

   *Note Windows::, for a description of the functions that work on
windows.


File: elisp.info,  Node: Frame Type,  Next: Terminal Type,  Prev: Window Type,  Up: Editing Types

2.4.4 Frame Type
----------------

A “frame” is a screen area that contains one or more Emacs windows; we
also use the term “frame” to refer to the Lisp object that Emacs uses to
refer to the screen area.

   Frames have no read syntax.  They print in hash notation, giving the
frame’s title, plus its address in core (useful to identify the frame
uniquely).

     (selected-frame)
          ⇒ #<frame emacs@psilocin.gnu.org 0xdac80>

   *Note Frames::, for a description of the functions that work on
frames.


File: elisp.info,  Node: Terminal Type,  Next: Window Configuration Type,  Prev: Frame Type,  Up: Editing Types

2.4.5 Terminal Type
-------------------

A “terminal” is a device capable of displaying one or more Emacs frames
(*note Frame Type::).

   Terminals have no read syntax.  They print in hash notation giving
the terminal’s ordinal number and its TTY device file name.

     (get-device-terminal nil)
          ⇒ #<terminal 1 on /dev/tty>


File: elisp.info,  Node: Window Configuration Type,  Next: Frame Configuration Type,  Prev: Terminal Type,  Up: Editing Types

2.4.6 Window Configuration Type
-------------------------------

A “window configuration” stores information about the positions, sizes,
and contents of the windows in a frame, so you can recreate the same
arrangement of windows later.

   Window configurations do not have a read syntax; their print syntax
looks like ‘#<window-configuration>’.  *Note Window Configurations::,
for a description of several functions related to window configurations.


File: elisp.info,  Node: Frame Configuration Type,  Next: Process Type,  Prev: Window Configuration Type,  Up: Editing Types

2.4.7 Frame Configuration Type
------------------------------

A “frame configuration” stores information about the positions, sizes,
and contents of the windows in all frames.  It is not a primitive
type—it is actually a list whose CAR is ‘frame-configuration’ and whose
CDR is an alist.  Each alist element describes one frame, which appears
as the CAR of that element.

   *Note Frame Configurations::, for a description of several functions
related to frame configurations.


File: elisp.info,  Node: Process Type,  Next: Thread Type,  Prev: Frame Configuration Type,  Up: Editing Types

2.4.8 Process Type
------------------

The word “process” usually means a running program.  Emacs itself runs
in a process of this sort.  However, in Emacs Lisp, a process is a Lisp
object that designates a subprocess created by the Emacs process.
Programs such as shells, GDB, ftp, and compilers, running in
subprocesses of Emacs, extend the capabilities of Emacs.  An Emacs
subprocess takes textual input from Emacs and returns textual output to
Emacs for further manipulation.  Emacs can also send signals to the
subprocess.

   Process objects have no read syntax.  They print in hash notation,
giving the name of the process:

     (process-list)
          ⇒ (#<process shell>)

   *Note Processes::, for information about functions that create,
delete, return information about, send input or signals to, and receive
output from processes.


File: elisp.info,  Node: Thread Type,  Next: Mutex Type,  Prev: Process Type,  Up: Editing Types

2.4.9 Thread Type
-----------------

A “thread” in Emacs represents a separate thread of Emacs Lisp
execution.  It runs its own Lisp program, has its own current buffer,
and can have subprocesses locked to it, i.e. subprocesses whose output
only this thread can accept.  *Note Threads::.

   Thread objects have no read syntax.  They print in hash notation,
giving the name of the thread (if it has been given a name) or its
address in core:

     (all-threads)
         ⇒ (#<thread 0176fc40>)


File: elisp.info,  Node: Mutex Type,  Next: Condition Variable Type,  Prev: Thread Type,  Up: Editing Types

2.4.10 Mutex Type
-----------------

A “mutex” is an exclusive lock that threads can own and disown, in order
to synchronize between them.  *Note Mutexes::.

   Mutex objects have no read syntax.  They print in hash notation,
giving the name of the mutex (if it has been given a name) or its
address in core:

     (make-mutex "my-mutex")
         ⇒ #<mutex my-mutex>
     (make-mutex)
         ⇒ #<mutex 01c7e4e0>


File: elisp.info,  Node: Condition Variable Type,  Next: Stream Type,  Prev: Mutex Type,  Up: Editing Types

2.4.11 Condition Variable Type
------------------------------

A “condition variable” is a device for a more complex thread
synchronization than the one supported by a mutex.  A thread can wait on
a condition variable, to be woken up when some other thread notifies the
condition.

   Condition variable objects have no read syntax.  They print in hash
notation, giving the name of the condition variable (if it has been
given a name) or its address in core:

     (make-condition-variable (make-mutex))
         ⇒ #<condvar 01c45ae8>


File: elisp.info,  Node: Stream Type,  Next: Keymap Type,  Prev: Condition Variable Type,  Up: Editing Types

2.4.12 Stream Type
------------------

A “stream” is an object that can be used as a source or sink for
characters—either to supply characters for input or to accept them as
output.  Many different types can be used this way: markers, buffers,
strings, and functions.  Most often, input streams (character sources)
obtain characters from the keyboard, a buffer, or a file, and output
streams (character sinks) send characters to a buffer, such as a
‘*Help*’ buffer, or to the echo area.

   The object ‘nil’, in addition to its other meanings, may be used as a
stream.  It stands for the value of the variable ‘standard-input’ or
‘standard-output’.  Also, the object ‘t’ as a stream specifies input
using the minibuffer (*note Minibuffers::) or output in the echo area
(*note The Echo Area::).

   Streams have no special printed representation or read syntax, and
print as whatever primitive type they are.

   *Note Read and Print::, for a description of functions related to
streams, including parsing and printing functions.


File: elisp.info,  Node: Keymap Type,  Next: Overlay Type,  Prev: Stream Type,  Up: Editing Types

2.4.13 Keymap Type
------------------

A “keymap” maps keys typed by the user to commands.  This mapping
controls how the user’s command input is executed.  A keymap is actually
a list whose CAR is the symbol ‘keymap’.

   *Note Keymaps::, for information about creating keymaps, handling
prefix keys, local as well as global keymaps, and changing key bindings.


File: elisp.info,  Node: Overlay Type,  Next: Font Type,  Prev: Keymap Type,  Up: Editing Types

2.4.14 Overlay Type
-------------------

An “overlay” specifies properties that apply to a part of a buffer.
Each overlay applies to a specified range of the buffer, and contains a
property list (a list whose elements are alternating property names and
values).  Overlay properties are used to present parts of the buffer
temporarily in a different display style.  Overlays have no read syntax,
and print in hash notation, giving the buffer name and range of
positions.

   *Note Overlays::, for information on how you can create and use
overlays.


File: elisp.info,  Node: Font Type,  Prev: Overlay Type,  Up: Editing Types

2.4.15 Font Type
----------------

A “font” specifies how to display text on a graphical terminal.  There
are actually three separate font types—“font objects”, “font specs”, and
“font entities”—each of which has slightly different properties.  None
of them have a read syntax; their print syntax looks like
‘#<font-object>’, ‘#<font-spec>’, and ‘#<font-entity>’ respectively.
*Note Low-Level Font::, for a description of these Lisp objects.


File: elisp.info,  Node: Circular Objects,  Next: Type Predicates,  Prev: Editing Types,  Up: Lisp Data Types

2.5 Read Syntax for Circular Objects
====================================

To represent shared or circular structures within a complex of Lisp
objects, you can use the reader constructs ‘#N=’ and ‘#N#’.

   Use ‘#N=’ before an object to label it for later reference;
subsequently, you can use ‘#N#’ to refer the same object in another
place.  Here, N is some integer.  For example, here is how to make a
list in which the first element recurs as the third element:

     (#1=(a) b #1#)

This differs from ordinary syntax such as this

     ((a) b (a))

which would result in a list whose first and third elements look alike
but are not the same Lisp object.  This shows the difference:

     (prog1 nil
       (setq x '(#1=(a) b #1#)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ t
     (setq x '((a) b (a)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ nil

   You can also use the same syntax to make a circular structure, which
appears as an element within itself.  Here is an example:

     #1=(a #1#)

This makes a list whose second element is the list itself.  Here’s how
you can see that it really works:

     (prog1 nil
       (setq x '#1=(a #1#)))
     (eq x (cadr x))
          ⇒ t

   The Lisp printer can produce this syntax to record circular and
shared structure in a Lisp object, if you bind the variable
‘print-circle’ to a non-‘nil’ value.  *Note Output Variables::.


File: elisp.info,  Node: Type Predicates,  Next: Equality Predicates,  Prev: Circular Objects,  Up: Lisp Data Types

2.6 Type Predicates
===================

The Emacs Lisp interpreter itself does not perform type checking on the
actual arguments passed to functions when they are called.  It could not
do so, since function arguments in Lisp do not have declared data types,
as they do in other programming languages.  It is therefore up to the
individual function to test whether each actual argument belongs to a
type that the function can use.

   All built-in functions do check the types of their actual arguments
when appropriate, and signal a ‘wrong-type-argument’ error if an
argument is of the wrong type.  For example, here is what happens if you
pass an argument to ‘+’ that it cannot handle:

     (+ 2 'a)
          error→ Wrong type argument: number-or-marker-p, a

   If you want your program to handle different types differently, you
must do explicit type checking.  The most common way to check the type
of an object is to call a “type predicate” function.  Emacs has a type
predicate for each type, as well as some predicates for combinations of
types.

   A type predicate function takes one argument; it returns ‘t’ if the
argument belongs to the appropriate type, and ‘nil’ otherwise.
Following a general Lisp convention for predicate functions, most type
predicates’ names end with ‘p’.

   Here is an example which uses the predicates ‘listp’ to check for a
list and ‘symbolp’ to check for a symbol.

     (defun add-on (x)
       (cond ((symbolp x)
              ;; If X is a symbol, put it on LIST.
              (setq list (cons x list)))
             ((listp x)
              ;; If X is a list, add its elements to LIST.
              (setq list (append x list)))
             (t
              ;; We handle only symbols and lists.
              (error "Invalid argument %s in add-on" x))))

   Here is a table of predefined type predicates, in alphabetical order,
with references to further information.

‘atom’
     *Note atom: List-related Predicates.

‘arrayp’
     *Note arrayp: Array Functions.

‘bool-vector-p’
     *Note bool-vector-p: Bool-Vectors.

‘booleanp’
     *Note booleanp: nil and t.

‘bufferp’
     *Note bufferp: Buffer Basics.

‘byte-code-function-p’
     *Note byte-code-function-p: Byte-Code Type.

‘case-table-p’
     *Note case-table-p: Case Tables.

‘char-or-string-p’
     *Note char-or-string-p: Predicates for Strings.

‘char-table-p’
     *Note char-table-p: Char-Tables.

‘commandp’
     *Note commandp: Interactive Call.

‘condition-variable-p’
     *Note condition-variable-p: Condition Variables.

‘consp’
     *Note consp: List-related Predicates.

‘custom-variable-p’
     *Note custom-variable-p: Variable Definitions.

‘floatp’
     *Note floatp: Predicates on Numbers.

‘fontp’
     *Note Low-Level Font::.

‘frame-configuration-p’
     *Note frame-configuration-p: Frame Configurations.

‘frame-live-p’
     *Note frame-live-p: Deleting Frames.

‘framep’
     *Note framep: Frames.

‘functionp’
     *Note functionp: Functions.

‘hash-table-p’
     *Note hash-table-p: Other Hash.

‘integer-or-marker-p’
     *Note integer-or-marker-p: Predicates on Markers.

‘integerp’
     *Note integerp: Predicates on Numbers.

‘keymapp’
     *Note keymapp: Creating Keymaps.

‘keywordp’
     *Note Constant Variables::.

‘listp’
     *Note listp: List-related Predicates.

‘markerp’
     *Note markerp: Predicates on Markers.

‘mutexp’
     *Note mutexp: Mutexes.

‘nlistp’
     *Note nlistp: List-related Predicates.

‘number-or-marker-p’
     *Note number-or-marker-p: Predicates on Markers.

‘numberp’
     *Note numberp: Predicates on Numbers.

‘overlayp’
     *Note overlayp: Overlays.

‘processp’
     *Note processp: Processes.

‘recordp’
     *Note recordp: Record Type.

‘sequencep’
     *Note sequencep: Sequence Functions.

‘string-or-null-p’
     *Note string-or-null-p: Predicates for Strings.

‘stringp’
     *Note stringp: Predicates for Strings.

‘subrp’
     *Note subrp: Function Cells.

‘symbolp’
     *Note symbolp: Symbols.

‘syntax-table-p’
     *Note syntax-table-p: Syntax Tables.

‘threadp’
     *Note threadp: Basic Thread Functions.

‘vectorp’
     *Note vectorp: Vectors.

‘wholenump’
     *Note wholenump: Predicates on Numbers.

‘window-configuration-p’
     *Note window-configuration-p: Window Configurations.

‘window-live-p’
     *Note window-live-p: Deleting Windows.

‘windowp’
     *Note windowp: Basic Windows.

   The most general way to check the type of an object is to call the
function ‘type-of’.  Recall that each object belongs to one and only one
primitive type; ‘type-of’ tells you which one (*note Lisp Data Types::).
But ‘type-of’ knows nothing about non-primitive types.  In most cases,
it is more convenient to use type predicates than ‘type-of’.

 -- Function: type-of object
     This function returns a symbol naming the primitive type of OBJECT.
     The value is one of the symbols ‘bool-vector’, ‘buffer’,
     ‘char-table’, ‘compiled-function’, ‘condition-variable’, ‘cons’,
     ‘finalizer’, ‘float’, ‘font-entity’, ‘font-object’, ‘font-spec’,
     ‘frame’, ‘hash-table’, ‘integer’, ‘marker’, ‘mutex’, ‘overlay’,
     ‘process’, ‘string’, ‘subr’, ‘symbol’, ‘thread’, ‘vector’,
     ‘window’, or ‘window-configuration’.  However, if OBJECT is a
     record, the type specified by its first slot is returned; *note
     Records::.

          (type-of 1)
               ⇒ integer
          (type-of 'nil)
               ⇒ symbol
          (type-of '())    ; ‘()’ is ‘nil’.
               ⇒ symbol
          (type-of '(x))
               ⇒ cons
          (type-of (record 'foo))
               ⇒ foo


File: elisp.info,  Node: Equality Predicates,  Prev: Type Predicates,  Up: Lisp Data Types

2.7 Equality Predicates
=======================

Here we describe functions that test for equality between two objects.
Other functions test equality of contents between objects of specific
types, e.g., strings.  For these predicates, see the appropriate chapter
describing the data type.

 -- Function: eq object1 object2
     This function returns ‘t’ if OBJECT1 and OBJECT2 are the same
     object, and ‘nil’ otherwise.

     If OBJECT1 and OBJECT2 are integers with the same value, they are
     considered to be the same object (i.e., ‘eq’ returns ‘t’).  If
     OBJECT1 and OBJECT2 are symbols with the same name, they are
     normally the same object—but see *note Creating Symbols:: for
     exceptions.  For other types (e.g., lists, vectors, strings), two
     arguments with the same contents or elements are not necessarily
     ‘eq’ to each other: they are ‘eq’ only if they are the same object,
     meaning that a change in the contents of one will be reflected by
     the same change in the contents of the other.

          (eq 'foo 'foo)
               ⇒ t

          (eq 456 456)
               ⇒ t

          (eq "asdf" "asdf")
               ⇒ nil

          (eq "" "")
               ⇒ t
          ;; This exception occurs because Emacs Lisp
          ;; makes just one multibyte empty string, to save space.

          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (setq foo '(1 (2 (3))))
               ⇒ (1 (2 (3)))
          (eq foo foo)
               ⇒ t
          (eq foo '(1 (2 (3))))
               ⇒ nil

          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (eq (point-marker) (point-marker))
               ⇒ nil

     The ‘make-symbol’ function returns an uninterned symbol, distinct
     from the symbol that is used if you write the name in a Lisp
     expression.  Distinct symbols with the same name are not ‘eq’.
     *Note Creating Symbols::.

          (eq (make-symbol "foo") 'foo)
               ⇒ nil

 -- Function: equal object1 object2
     This function returns ‘t’ if OBJECT1 and OBJECT2 have equal
     components, and ‘nil’ otherwise.  Whereas ‘eq’ tests if its
     arguments are the same object, ‘equal’ looks inside nonidentical
     arguments to see if their elements or contents are the same.  So,
     if two objects are ‘eq’, they are ‘equal’, but the converse is not
     always true.

          (equal 'foo 'foo)
               ⇒ t

          (equal 456 456)
               ⇒ t

          (equal "asdf" "asdf")
               ⇒ t
          (eq "asdf" "asdf")
               ⇒ nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               ⇒ t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (equal [(1 2) 3] [(1 2) 3])
               ⇒ t
          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (equal (point-marker) (point-marker))
               ⇒ t

          (eq (point-marker) (point-marker))
               ⇒ nil

     Comparison of strings is case-sensitive, but does not take account
     of text properties—it compares only the characters in the strings.
     *Note Text Properties::.  Use ‘equal-including-properties’ to also
     compare text properties.  For technical reasons, a unibyte string
     and a multibyte string are ‘equal’ if and only if they contain the
     same sequence of character codes and all these codes are in the
     range 0 through 127 (ASCII).

          (equal "asdf" "ASDF")
               ⇒ nil

     However, two distinct buffers are never considered ‘equal’, even if
     their textual contents are the same.

   The test for equality is implemented recursively; for example, given
two cons cells X and Y, ‘(equal X Y)’ returns ‘t’ if and only if both
the expressions below return ‘t’:

     (equal (car X) (car Y))
     (equal (cdr X) (cdr Y))

   Because of this recursive method, circular lists may therefore cause
infinite recursion (leading to an error).

 -- Function: equal-including-properties object1 object2
     This function behaves like ‘equal’ in all cases but also requires
     that for two strings to be equal, they have the same text
     properties.

          (equal "asdf" (propertize "asdf" 'asdf t))
               ⇒ t
          (equal-including-properties "asdf"
                                      (propertize "asdf" 'asdf t))
               ⇒ nil


File: elisp.info,  Node: Numbers,  Next: Strings and Characters,  Prev: Lisp Data Types,  Up: Top

3 Numbers
*********

GNU Emacs supports two numeric data types: “integers” and
“floating-point numbers”.  Integers are whole numbers such as −3, 0, 7,
13, and 511.  Floating-point numbers are numbers with fractional parts,
such as −4.5, 0.0, and 2.71828.  They can also be expressed in
exponential notation: ‘1.5e2’ is the same as ‘150.0’; here, ‘e2’ stands
for ten to the second power, and that is multiplied by 1.5.  Integer
computations are exact, though they may overflow.  Floating-point
computations often involve rounding errors, as the numbers have a fixed
amount of precision.

* Menu:

* Integer Basics::            Representation and range of integers.
* Float Basics::              Representation and range of floating point.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Numeric Conversions::       Converting float to integer and vice versa.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Rounding Operations::       Explicitly rounding floating-point numbers.
* Bitwise Operations::        Logical and, or, not, shifting.
* Math Functions::            Trig, exponential and logarithmic functions.
* Random Numbers::            Obtaining random integers, predictable or not.


File: elisp.info,  Node: Integer Basics,  Next: Float Basics,  Up: Numbers

3.1 Integer Basics
==================

The range of values for an integer depends on the machine.  The minimum
range is −536,870,912 to 536,870,911 (30 bits; i.e., −2**29 to 2**29 −
1), but many machines provide a wider range.  Many examples in this
chapter assume the minimum integer width of 30 bits.

   The Lisp reader reads an integer as a sequence of digits with
optional initial sign and optional final period.  An integer that is out
of the Emacs range is treated as a floating-point number.

      1               ; The integer 1.
      1.              ; The integer 1.
     +1               ; Also the integer 1.
     -1               ; The integer −1.
      9000000000000000000
                      ; The floating-point number 9e18.
      0               ; The integer 0.
     -0               ; The integer 0.

   The syntax for integers in bases other than 10 uses ‘#’ followed by a
letter that specifies the radix: ‘b’ for binary, ‘o’ for octal, ‘x’ for
hex, or ‘RADIXr’ to specify radix RADIX.  Case is not significant for
the letter that specifies the radix.  Thus, ‘#bINTEGER’ reads INTEGER in
binary, and ‘#RADIXrINTEGER’ reads INTEGER in radix RADIX.  Allowed
values of RADIX run from 2 to 36.  For example:

     #b101100 ⇒ 44
     #o54 ⇒ 44
     #x2c ⇒ 44
     #24r1k ⇒ 44

   To understand how various functions work on integers, especially the
bitwise operators (*note Bitwise Operations::), it is often helpful to
view the numbers in their binary form.

   In 30-bit binary, the decimal integer 5 looks like this:

     0000...000101 (30 bits total)

(The ‘...’ stands for enough bits to fill out a 30-bit word; in this
case, ‘...’ stands for twenty 0 bits.  Later examples also use the ‘...’
notation to make binary integers easier to read.)

   The integer −1 looks like this:

     1111...111111 (30 bits total)

−1 is represented as 30 ones.  (This is called “two’s complement”
notation.)

   Subtracting 4 from −1 returns the negative integer −5.  In binary,
the decimal integer 4 is 100.  Consequently, −5 looks like this:

     1111...111011 (30 bits total)

   In this implementation, the largest 30-bit binary integer is
536,870,911 in decimal.  In binary, it looks like this:

     0111...111111 (30 bits total)

   Since the arithmetic functions do not check whether integers go
outside their range, when you add 1 to 536,870,911, the value is the
negative integer −536,870,912:

     (+ 1 536870911)
          ⇒ -536870912
          ⇒ 1000...000000 (30 bits total)

   Many of the functions described in this chapter accept markers for
arguments in place of numbers.  (*Note Markers::.)  Since the actual
arguments to such functions may be either numbers or markers, we often
give these arguments the name NUMBER-OR-MARKER.  When the argument value
is a marker, its position value is used and its buffer is ignored.

 -- Variable: most-positive-fixnum
     The value of this variable is the largest integer that Emacs Lisp
     can handle.  Typical values are 2**29 − 1 on 32-bit and 2**61 − 1
     on 64-bit platforms.

 -- Variable: most-negative-fixnum
     The value of this variable is the smallest integer that Emacs Lisp
     can handle.  It is negative.  Typical values are −2**29 on 32-bit
     and −2**61 on 64-bit platforms.

   In Emacs Lisp, text characters are represented by integers.  Any
integer between zero and the value of ‘(max-char)’, inclusive, is
considered to be valid as a character.  *Note Character Codes::.


File: elisp.info,  Node: Float Basics,  Next: Predicates on Numbers,  Prev: Integer Basics,  Up: Numbers

3.2 Floating-Point Basics
=========================

Floating-point numbers are useful for representing numbers that are not
integral.  The range of floating-point numbers is the same as the range
of the C data type ‘double’ on the machine you are using.  On all
computers currently supported by Emacs, this is double-precision IEEE
floating point.

   The read syntax for floating-point numbers requires either a decimal
point, an exponent, or both.  Optional signs (‘+’ or ‘-’) precede the
number and its exponent.  For example, ‘1500.0’, ‘+15e2’, ‘15.0e+2’,
‘+1500000e-3’, and ‘.15e4’ are five ways of writing a floating-point
number whose value is 1500.  They are all equivalent.  Like Common Lisp,
Emacs Lisp requires at least one digit after any decimal point in a
floating-point number; ‘1500.’ is an integer, not a floating-point
number.

   Emacs Lisp treats ‘-0.0’ as numerically equal to ordinary zero with
respect to ‘equal’ and ‘=’.  This follows the IEEE floating-point
standard, which says ‘-0.0’ and ‘0.0’ are numerically equal even though
other operations can distinguish them.

   The IEEE floating-point standard supports positive infinity and
negative infinity as floating-point values.  It also provides for a
class of values called NaN, or “not a number”; numerical functions
return such values in cases where there is no correct answer.  For
example, ‘(/ 0.0 0.0)’ returns a NaN.  Although NaN values carry a sign,
for practical purposes there is no other significant difference between
different NaN values in Emacs Lisp.

   Here are read syntaxes for these special floating-point values:

infinity
     ‘1.0e+INF’ and ‘-1.0e+INF’
not-a-number
     ‘0.0e+NaN’ and ‘-0.0e+NaN’

   The following functions are specialized for handling floating-point
numbers:

 -- Function: isnan x
     This predicate returns ‘t’ if its floating-point argument is a NaN,
     ‘nil’ otherwise.

 -- Function: frexp x
     This function returns a cons cell ‘(S . E)’, where S and E are
     respectively the significand and exponent of the floating-point
     number X.

     If X is finite, then S is a floating-point number between 0.5
     (inclusive) and 1.0 (exclusive), E is an integer, and X = S * 2**E.
     If X is zero or infinity, then S is the same as X.  If X is a NaN,
     then S is also a NaN.  If X is zero, then E is 0.

 -- Function: ldexp s e
     Given a numeric significand S and an integer exponent E, this
     function returns the floating point number S * 2**E.

 -- Function: copysign x1 x2
     This function copies the sign of X2 to the value of X1, and returns
     the result.  X1 and X2 must be floating point.

 -- Function: logb x
     This function returns the binary exponent of X.  More precisely,
     the value is the logarithm base 2 of |x|, rounded down to an
     integer.

          (logb 10)
               ⇒ 3
          (logb 10.0e20)
               ⇒ 69


File: elisp.info,  Node: Predicates on Numbers,  Next: Comparison of Numbers,  Prev: Float Basics,  Up: Numbers

3.3 Type Predicates for Numbers
===============================

The functions in this section test for numbers, or for a specific type
of number.  The functions ‘integerp’ and ‘floatp’ can take any type of
Lisp object as argument (they would not be of much use otherwise), but
the ‘zerop’ predicate requires a number as its argument.  See also
‘integer-or-marker-p’ and ‘number-or-marker-p’, in *note Predicates on
Markers::.

 -- Function: floatp object
     This predicate tests whether its argument is floating point and
     returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: integerp object
     This predicate tests whether its argument is an integer, and
     returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: numberp object
     This predicate tests whether its argument is a number (either
     integer or floating point), and returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: natnump object
     This predicate (whose name comes from the phrase “natural number”)
     tests to see whether its argument is a nonnegative integer, and
     returns ‘t’ if so, ‘nil’ otherwise.  0 is considered non-negative.

     ‘wholenump’ is a synonym for ‘natnump’.

 -- Function: zerop number
     This predicate tests whether its argument is zero, and returns ‘t’
     if so, ‘nil’ otherwise.  The argument must be a number.

     ‘(zerop x)’ is equivalent to ‘(= x 0)’.


File: elisp.info,  Node: Comparison of Numbers,  Next: Numeric Conversions,  Prev: Predicates on Numbers,  Up: Numbers

3.4 Comparison of Numbers
=========================

To test numbers for numerical equality, you should normally use ‘=’, not
‘eq’.  There can be many distinct floating-point objects with the same
numeric value.  If you use ‘eq’ to compare them, then you test whether
two values are the same _object_.  By contrast, ‘=’ compares only the
numeric values of the objects.

   In Emacs Lisp, each integer is a unique Lisp object.  Therefore, ‘eq’
is equivalent to ‘=’ where integers are concerned.  It is sometimes
convenient to use ‘eq’ for comparing an unknown value with an integer,
because ‘eq’ does not report an error if the unknown value is not a
number—it accepts arguments of any type.  By contrast, ‘=’ signals an
error if the arguments are not numbers or markers.  However, it is
better programming practice to use ‘=’ if you can, even for comparing
integers.

   Sometimes it is useful to compare numbers with ‘equal’, which treats
two numbers as equal if they have the same data type (both integers, or
both floating point) and the same value.  By contrast, ‘=’ can treat an
integer and a floating-point number as equal.  *Note Equality
Predicates::.

   There is another wrinkle: because floating-point arithmetic is not
exact, it is often a bad idea to check for equality of floating-point
values.  Usually it is better to test for approximate equality.  Here’s
a function to do this:

     (defvar fuzz-factor 1.0e-6)
     (defun approx-equal (x y)
       (or (= x y)
           (< (/ (abs (- x y))
                 (max (abs x) (abs y)))
              fuzz-factor)))

     Common Lisp note: Comparing numbers in Common Lisp always requires
     ‘=’ because Common Lisp implements multi-word integers, and two
     distinct integer objects can have the same numeric value.  Emacs
     Lisp can have just one integer object for any given value because
     it has a limited range of integers.

 -- Function: = number-or-marker &rest number-or-markers
     This function tests whether all its arguments are numerically
     equal, and returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: eql value1 value2
     This function acts like ‘eq’ except when both arguments are
     numbers.  It compares numbers by type and numeric value, so that
     ‘(eql 1.0 1)’ returns ‘nil’, but ‘(eql 1.0 1.0)’ and ‘(eql 1 1)’
     both return ‘t’.

 -- Function: /= number-or-marker1 number-or-marker2
     This function tests whether its arguments are numerically equal,
     and returns ‘t’ if they are not, and ‘nil’ if they are.

 -- Function: < number-or-marker &rest number-or-markers
     This function tests whether each argument is strictly less than the
     following argument.  It returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: <= number-or-marker &rest number-or-markers
     This function tests whether each argument is less than or equal to
     the following argument.  It returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: > number-or-marker &rest number-or-markers
     This function tests whether each argument is strictly greater than
     the following argument.  It returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: >= number-or-marker &rest number-or-markers
     This function tests whether each argument is greater than or equal
     to the following argument.  It returns ‘t’ if so, ‘nil’ otherwise.

 -- Function: max number-or-marker &rest numbers-or-markers
     This function returns the largest of its arguments.

          (max 20)
               ⇒ 20
          (max 1 2.5)
               ⇒ 2.5
          (max 1 3 2.5)
               ⇒ 3

 -- Function: min number-or-marker &rest numbers-or-markers
     This function returns the smallest of its arguments.

          (min -4 1)
               ⇒ -4

 -- Function: abs number
     This function returns the absolute value of NUMBER.


File: elisp.info,  Node: Numeric Conversions,  Next: Arithmetic Operations,  Prev: Comparison of Numbers,  Up: Numbers

3.5 Numeric Conversions
=======================

To convert an integer to floating point, use the function ‘float’.

 -- Function: float number
     This returns NUMBER converted to floating point.  If NUMBER is
     already floating point, ‘float’ returns it unchanged.

   There are four functions to convert floating-point numbers to
integers; they differ in how they round.  All accept an argument NUMBER
and an optional argument DIVISOR.  Both arguments may be integers or
floating-point numbers.  DIVISOR may also be ‘nil’.  If DIVISOR is ‘nil’
or omitted, these functions convert NUMBER to an integer, or return it
unchanged if it already is an integer.  If DIVISOR is non-‘nil’, they
divide NUMBER by DIVISOR and convert the result to an integer.  If
DIVISOR is zero (whether integer or floating point), Emacs signals an
‘arith-error’ error.

 -- Function: truncate number &optional divisor
     This returns NUMBER, converted to an integer by rounding towards
     zero.

          (truncate 1.2)
               ⇒ 1
          (truncate 1.7)
               ⇒ 1
          (truncate -1.2)
               ⇒ -1
          (truncate -1.7)
               ⇒ -1

 -- Function: floor number &optional divisor
     This returns NUMBER, converted to an integer by rounding downward
     (towards negative infinity).

     If DIVISOR is specified, this uses the kind of division operation
     that corresponds to ‘mod’, rounding downward.

          (floor 1.2)
               ⇒ 1
          (floor 1.7)
               ⇒ 1
          (floor -1.2)
               ⇒ -2
          (floor -1.7)
               ⇒ -2
          (floor 5.99 3)
               ⇒ 1

 -- Function: ceiling number &optional divisor
     This returns NUMBER, converted to an integer by rounding upward
     (towards positive infinity).

          (ceiling 1.2)
               ⇒ 2
          (ceiling 1.7)
               ⇒ 2
          (ceiling -1.2)
               ⇒ -1
          (ceiling -1.7)
               ⇒ -1

 -- Function: round number &optional divisor
     This returns NUMBER, converted to an integer by rounding towards
     the nearest integer.  Rounding a value equidistant between two
     integers returns the even integer.

          (round 1.2)
               ⇒ 1
          (round 1.7)
               ⇒ 2
          (round -1.2)
               ⇒ -1
          (round -1.7)
               ⇒ -2


File: elisp.info,  Node: Arithmetic Operations,  Next: Rounding Operations,  Prev: Numeric Conversions,  Up: Numbers

3.6 Arithmetic Operations
=========================

Emacs Lisp provides the traditional four arithmetic operations
(addition, subtraction, multiplication, and division), as well as
remainder and modulus functions, and functions to add or subtract 1.
Except for ‘%’, each of these functions accepts both integer and
floating-point arguments, and returns a floating-point number if any
argument is floating point.

   Emacs Lisp arithmetic functions do not check for integer overflow.
Thus ‘(1+ 536870911)’ may evaluate to −536870912, depending on your
hardware.

 -- Function: 1+ number-or-marker
     This function returns NUMBER-OR-MARKER plus 1.  For example,

          (setq foo 4)
               ⇒ 4
          (1+ foo)
               ⇒ 5

     This function is not analogous to the C operator ‘++’—it does not
     increment a variable.  It just computes a sum.  Thus, if we
     continue,

          foo
               ⇒ 4

     If you want to increment the variable, you must use ‘setq’, like
     this:

          (setq foo (1+ foo))
               ⇒ 5

 -- Function: 1- number-or-marker
     This function returns NUMBER-OR-MARKER minus 1.

 -- Function: + &rest numbers-or-markers
     This function adds its arguments together.  When given no
     arguments, ‘+’ returns 0.

          (+)
               ⇒ 0
          (+ 1)
               ⇒ 1
          (+ 1 2 3 4)
               ⇒ 10

 -- Function: - &optional number-or-marker &rest more-numbers-or-markers
     The ‘-’ function serves two purposes: negation and subtraction.
     When ‘-’ has a single argument, the value is the negative of the
     argument.  When there are multiple arguments, ‘-’ subtracts each of
     the MORE-NUMBERS-OR-MARKERS from NUMBER-OR-MARKER, cumulatively.
     If there are no arguments, the result is 0.

          (- 10 1 2 3 4)
               ⇒ 0
          (- 10)
               ⇒ -10
          (-)
               ⇒ 0

 -- Function: * &rest numbers-or-markers
     This function multiplies its arguments together, and returns the
     product.  When given no arguments, ‘*’ returns 1.

          (*)
               ⇒ 1
          (* 1)
               ⇒ 1
          (* 1 2 3 4)
               ⇒ 24

 -- Function: / number &rest divisors
     With one or more DIVISORS, this function divides NUMBER by each
     divisor in DIVISORS in turn, and returns the quotient.  With no
     DIVISORS, this function returns 1/NUMBER, i.e., the multiplicative
     inverse of NUMBER.  Each argument may be a number or a marker.

     If all the arguments are integers, the result is an integer,
     obtained by rounding the quotient towards zero after each division.

          (/ 6 2)
               ⇒ 3
          (/ 5 2)
               ⇒ 2
          (/ 5.0 2)
               ⇒ 2.5
          (/ 5 2.0)
               ⇒ 2.5
          (/ 5.0 2.0)
               ⇒ 2.5
          (/ 4.0)
               ⇒ 0.25
          (/ 4)
               ⇒ 0
          (/ 25 3 2)
               ⇒ 4
          (/ -17 6)
               ⇒ -2

     If you divide an integer by the integer 0, Emacs signals an
     ‘arith-error’ error (*note Errors::).  Floating-point division of a
     nonzero number by zero yields either positive or negative infinity
     (*note Float Basics::).

 -- Function: % dividend divisor
     This function returns the integer remainder after division of
     DIVIDEND by DIVISOR.  The arguments must be integers or markers.

     For any two integers DIVIDEND and DIVISOR,

          (+ (% DIVIDEND DIVISOR)
             (* (/ DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND if DIVISOR is nonzero.

          (% 9 4)
               ⇒ 1
          (% -9 4)
               ⇒ -1
          (% 9 -4)
               ⇒ 1
          (% -9 -4)
               ⇒ -1

 -- Function: mod dividend divisor
     This function returns the value of DIVIDEND modulo DIVISOR; in
     other words, the remainder after division of DIVIDEND by DIVISOR,
     but with the same sign as DIVISOR.  The arguments must be numbers
     or markers.

     Unlike ‘%’, ‘mod’ permits floating-point arguments; it rounds the
     quotient downward (towards minus infinity) to an integer, and uses
     that quotient to compute the remainder.

     If DIVISOR is zero, ‘mod’ signals an ‘arith-error’ error if both
     arguments are integers, and returns a NaN otherwise.

          (mod 9 4)
               ⇒ 1
          (mod -9 4)
               ⇒ 3
          (mod 9 -4)
               ⇒ -3
          (mod -9 -4)
               ⇒ -1
          (mod 5.5 2.5)
               ⇒ .5

     For any two numbers DIVIDEND and DIVISOR,

          (+ (mod DIVIDEND DIVISOR)
             (* (floor DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND, subject to rounding error if either
     argument is floating point and to an ‘arith-error’ if DIVIDEND is
     an integer and DIVISOR is 0.  For ‘floor’, see *note Numeric
     Conversions::.


File: elisp.info,  Node: Rounding Operations,  Next: Bitwise Operations,  Prev: Arithmetic Operations,  Up: Numbers

3.7 Rounding Operations
=======================

The functions ‘ffloor’, ‘fceiling’, ‘fround’, and ‘ftruncate’ take a
floating-point argument and return a floating-point result whose value
is a nearby integer.  ‘ffloor’ returns the nearest integer below;
‘fceiling’, the nearest integer above; ‘ftruncate’, the nearest integer
in the direction towards zero; ‘fround’, the nearest integer.

 -- Function: ffloor float
     This function rounds FLOAT to the next lower integral value, and
     returns that value as a floating-point number.

 -- Function: fceiling float
     This function rounds FLOAT to the next higher integral value, and
     returns that value as a floating-point number.

 -- Function: ftruncate float
     This function rounds FLOAT towards zero to an integral value, and
     returns that value as a floating-point number.

 -- Function: fround float
     This function rounds FLOAT to the nearest integral value, and
     returns that value as a floating-point number.  Rounding a value
     equidistant between two integers returns the even integer.


File: elisp.info,  Node: Bitwise Operations,  Next: Math Functions,  Prev: Rounding Operations,  Up: Numbers

3.8 Bitwise Operations on Integers
==================================

In a computer, an integer is represented as a binary number, a sequence
of “bits” (digits which are either zero or one).  A bitwise operation
acts on the individual bits of such a sequence.  For example, “shifting”
moves the whole sequence left or right one or more places, reproducing
the same pattern moved over.

   The bitwise operations in Emacs Lisp apply only to integers.

 -- Function: lsh integer1 count
     ‘lsh’, which is an abbreviation for “logical shift”, shifts the
     bits in INTEGER1 to the left COUNT places, or to the right if COUNT
     is negative, bringing zeros into the vacated bits.  If COUNT is
     negative, ‘lsh’ shifts zeros into the leftmost (most-significant)
     bit, producing a positive result even if INTEGER1 is negative.
     Contrast this with ‘ash’, below.

     Here are two examples of ‘lsh’, shifting a pattern of bits one
     place to the left.  We show only the low-order eight bits of the
     binary pattern; the rest are all zero.

          (lsh 5 1)
               ⇒ 10
          ;; Decimal 5 becomes decimal 10.
          00000101 ⇒ 00001010

          (lsh 7 1)
               ⇒ 14
          ;; Decimal 7 becomes decimal 14.
          00000111 ⇒ 00001110

     As the examples illustrate, shifting the pattern of bits one place
     to the left produces a number that is twice the value of the
     previous number.

     Shifting a pattern of bits two places to the left produces results
     like this (with 8-bit binary numbers):

          (lsh 3 2)
               ⇒ 12
          ;; Decimal 3 becomes decimal 12.
          00000011 ⇒ 00001100

     On the other hand, shifting one place to the right looks like this:

          (lsh 6 -1)
               ⇒ 3
          ;; Decimal 6 becomes decimal 3.
          00000110 ⇒ 00000011

          (lsh 5 -1)
               ⇒ 2
          ;; Decimal 5 becomes decimal 2.
          00000101 ⇒ 00000010

     As the example illustrates, shifting one place to the right divides
     the value of a positive integer by two, rounding downward.

     The function ‘lsh’, like all Emacs Lisp arithmetic functions, does
     not check for overflow, so shifting left can discard significant
     bits and change the sign of the number.  For example, left shifting
     536,870,911 produces −2 in the 30-bit implementation:

          (lsh 536870911 1)          ; left shift
               ⇒ -2

     In binary, the argument looks like this:

          ;; Decimal 536,870,911
          0111...111111 (30 bits total)

     which becomes the following when left shifted:

          ;; Decimal −2
          1111...111110 (30 bits total)

 -- Function: ash integer1 count
     ‘ash’ (“arithmetic shift”) shifts the bits in INTEGER1 to the left
     COUNT places, or to the right if COUNT is negative.

     ‘ash’ gives the same results as ‘lsh’ except when INTEGER1 and
     COUNT are both negative.  In that case, ‘ash’ puts ones in the
     empty bit positions on the left, while ‘lsh’ puts zeros in those
     bit positions.

     Thus, with ‘ash’, shifting the pattern of bits one place to the
     right looks like this:

          (ash -6 -1) ⇒ -3
          ;; Decimal −6 becomes decimal −3.
          1111...111010 (30 bits total)
               ⇒
          1111...111101 (30 bits total)

     In contrast, shifting the pattern of bits one place to the right
     with ‘lsh’ looks like this:

          (lsh -6 -1) ⇒ 536870909
          ;; Decimal −6 becomes decimal 536,870,909.
          1111...111010 (30 bits total)
               ⇒
          0111...111101 (30 bits total)

     Here are other examples:

                             ;         30-bit binary values

          (lsh 5 2)          ;   5  =  0000...000101
               ⇒ 20         ;      =  0000...010100
          (ash 5 2)
               ⇒ 20
          (lsh -5 2)         ;  -5  =  1111...111011
               ⇒ -20        ;      =  1111...101100
          (ash -5 2)
               ⇒ -20
          (lsh 5 -2)         ;   5  =  0000...000101
               ⇒ 1          ;      =  0000...000001
          (ash 5 -2)
               ⇒ 1
          (lsh -5 -2)        ;  -5  =  1111...111011
               ⇒ 268435454
                             ;      =  0011...111110
          (ash -5 -2)        ;  -5  =  1111...111011
               ⇒ -2         ;      =  1111...111110

 -- Function: logand &rest ints-or-markers
     This function returns the bitwise AND of the arguments: the Nth bit
     is 1 in the result if, and only if, the Nth bit is 1 in all the
     arguments.

     For example, using 4-bit binary numbers, the bitwise AND of 13 and
     12 is 12: 1101 combined with 1100 produces 1100.  In both the
     binary numbers, the leftmost two bits are both 1 so the leftmost
     two bits of the returned value are both 1.  However, for the
     rightmost two bits, each is 0 in at least one of the arguments, so
     the rightmost two bits of the returned value are both 0.

     Therefore,

          (logand 13 12)
               ⇒ 12

     If ‘logand’ is not passed any argument, it returns a value of −1.
     This number is an identity element for ‘logand’ because its binary
     representation consists entirely of ones.  If ‘logand’ is passed
     just one argument, it returns that argument.

                             ;        30-bit binary values

          (logand 14 13)     ; 14  =  0000...001110
                             ; 13  =  0000...001101
               ⇒ 12         ; 12  =  0000...001100

          (logand 14 13 4)   ; 14  =  0000...001110
                             ; 13  =  0000...001101
                             ;  4  =  0000...000100
               ⇒ 4          ;  4  =  0000...000100

          (logand)
               ⇒ -1         ; -1  =  1111...111111

 -- Function: logior &rest ints-or-markers
     This function returns the bitwise inclusive OR of its arguments:
     the Nth bit is 1 in the result if, and only if, the Nth bit is 1 in
     at least one of the arguments.  If there are no arguments, the
     result is 0, which is an identity element for this operation.  If
     ‘logior’ is passed just one argument, it returns that argument.

                             ;        30-bit binary values

          (logior 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               ⇒ 13         ; 13  =  0000...001101

          (logior 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               ⇒ 15         ; 15  =  0000...001111

 -- Function: logxor &rest ints-or-markers
     This function returns the bitwise exclusive OR of its arguments:
     the Nth bit is 1 in the result if, and only if, the Nth bit is 1 in
     an odd number of the arguments.  If there are no arguments, the
     result is 0, which is an identity element for this operation.  If
     ‘logxor’ is passed just one argument, it returns that argument.

                             ;        30-bit binary values

          (logxor 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               ⇒ 9          ;  9  =  0000...001001

          (logxor 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               ⇒ 14         ; 14  =  0000...001110

 -- Function: lognot integer
     This function returns the bitwise complement of its argument: the
     Nth bit is one in the result if, and only if, the Nth bit is zero
     in INTEGER, and vice-versa.

          (lognot 5)
               ⇒ -6
          ;;  5  =  0000...000101 (30 bits total)
          ;; becomes
          ;; -6  =  1111...111010 (30 bits total)


File: elisp.info,  Node: Math Functions,  Next: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

3.9 Standard Mathematical Functions
===================================

These mathematical functions allow integers as well as floating-point
numbers as arguments.

 -- Function: sin arg
 -- Function: cos arg
 -- Function: tan arg
     These are the basic trigonometric functions, with argument ARG
     measured in radians.

 -- Function: asin arg
     The value of ‘(asin ARG)’ is a number between −pi/2 and pi/2
     (inclusive) whose sine is ARG.  If ARG is out of range (outside
     [−1, 1]), ‘asin’ returns a NaN.

 -- Function: acos arg
     The value of ‘(acos ARG)’ is a number between 0 and pi (inclusive)
     whose cosine is ARG.  If ARG is out of range (outside [−1, 1]),
     ‘acos’ returns a NaN.

 -- Function: atan y &optional x
     The value of ‘(atan Y)’ is a number between −pi/2 and pi/2
     (exclusive) whose tangent is Y.  If the optional second argument X
     is given, the value of ‘(atan y x)’ is the angle in radians between
     the vector ‘[X, Y]’ and the ‘X’ axis.

 -- Function: exp arg
     This is the exponential function; it returns e to the power ARG.

 -- Function: log arg &optional base
     This function returns the logarithm of ARG, with base BASE.  If you
     don’t specify BASE, the natural base e is used.  If ARG or BASE is
     negative, ‘log’ returns a NaN.

 -- Function: expt x y
     This function returns X raised to power Y.  If both arguments are
     integers and Y is positive, the result is an integer; in this case,
     overflow causes truncation, so watch out.  If X is a finite
     negative number and Y is a finite non-integer, ‘expt’ returns a
     NaN.

 -- Function: sqrt arg
     This returns the square root of ARG.  If ARG is finite and less
     than zero, ‘sqrt’ returns a NaN.

   In addition, Emacs defines the following common mathematical
constants:

 -- Variable: float-e
     The mathematical constant e (2.71828...).

 -- Variable: float-pi
     The mathematical constant pi (3.14159...).


File: elisp.info,  Node: Random Numbers,  Prev: Math Functions,  Up: Numbers

3.10 Random Numbers
===================

A deterministic computer program cannot generate true random numbers.
For most purposes, “pseudo-random numbers” suffice.  A series of
pseudo-random numbers is generated in a deterministic fashion.  The
numbers are not truly random, but they have certain properties that
mimic a random series.  For example, all possible values occur equally
often in a pseudo-random series.

   Pseudo-random numbers are generated from a “seed value”.  Starting
from any given seed, the ‘random’ function always generates the same
sequence of numbers.  By default, Emacs initializes the random seed at
startup, in such a way that the sequence of values of ‘random’ (with
overwhelming likelihood) differs in each Emacs run.

   Sometimes you want the random number sequence to be repeatable.  For
example, when debugging a program whose behavior depends on the random
number sequence, it is helpful to get the same behavior in each program
run.  To make the sequence repeat, execute ‘(random "")’.  This sets the
seed to a constant value for your particular Emacs executable (though it
may differ for other Emacs builds).  You can use other strings to choose
various seed values.

 -- Function: random &optional limit
     This function returns a pseudo-random integer.  Repeated calls
     return a series of pseudo-random integers.

     If LIMIT is a positive integer, the value is chosen to be
     nonnegative and less than LIMIT.  Otherwise, the value might be any
     integer representable in Lisp, i.e., an integer between
     ‘most-negative-fixnum’ and ‘most-positive-fixnum’ (*note Integer
     Basics::).

     If LIMIT is ‘t’, it means to choose a new seed as if Emacs were
     restarting, typically from the system entropy.  On systems lacking
     entropy pools, choose the seed from less-random volatile data such
     as the current time.

     If LIMIT is a string, it means to choose a new seed based on the
     string’s contents.


File: elisp.info,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

4 Strings and Characters
************************

A string in Emacs Lisp is an array that contains an ordered sequence of
characters.  Strings are used as names of symbols, buffers, and files;
to send messages to users; to hold text being copied between buffers;
and for many other purposes.  Because strings are so important, Emacs
Lisp has many functions expressly for manipulating them.  Emacs Lisp
programs use strings more often than individual characters.

   *Note Strings of Events::, for special considerations for strings of
keyboard character events.

* Menu:

* Basics: String Basics.      Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Modifying Strings::         Altering the contents of an existing string.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting to and from characters and strings.
* Formatting Strings::        ‘format’: Emacs’s analogue of ‘printf’.
* Case Conversion::           Case conversion functions.
* Case Tables::               Customizing case conversion.


File: elisp.info,  Node: String Basics,  Next: Predicates for Strings,  Up: Strings and Characters

4.1 String and Character Basics
===============================

A character is a Lisp object which represents a single character of
text.  In Emacs Lisp, characters are simply integers; whether an integer
is a character or not is determined only by how it is used.  *Note
Character Codes::, for details about character representation in Emacs.

   A string is a fixed sequence of characters.  It is a type of sequence
called a “array”, meaning that its length is fixed and cannot be altered
once it is created (*note Sequences Arrays Vectors::).  Unlike in C,
Emacs Lisp strings are _not_ terminated by a distinguished character
code.

   Since strings are arrays, and therefore sequences as well, you can
operate on them with the general array and sequence functions documented
in *note Sequences Arrays Vectors::.  For example, you can access or
change individual characters in a string using the functions ‘aref’ and
‘aset’ (*note Array Functions::).  However, note that ‘length’ should
_not_ be used for computing the width of a string on display; use
‘string-width’ (*note Size of Displayed Text::) instead.

   There are two text representations for non-ASCII characters in Emacs
strings (and in buffers): unibyte and multibyte.  For most Lisp
programming, you don’t need to be concerned with these two
representations.  *Note Text Representations::, for details.

   Sometimes key sequences are represented as unibyte strings.  When a
unibyte string is a key sequence, string elements in the range 128 to
255 represent meta characters (which are large integers) rather than
character codes in the range 128 to 255.  Strings cannot hold characters
that have the hyper, super or alt modifiers; they can hold ASCII control
characters, but no other control characters.  They do not distinguish
case in ASCII control characters.  If you want to store such characters
in a sequence, such as a key sequence, you must use a vector instead of
a string.  *Note Character Type::, for more information about keyboard
input characters.

   Strings are useful for holding regular expressions.  You can also
match regular expressions against strings with ‘string-match’ (*note
Regexp Search::).  The functions ‘match-string’ (*note Simple Match
Data::) and ‘replace-match’ (*note Replacing Match::) are useful for
decomposing and modifying strings after matching regular expressions
against them.

   Like a buffer, a string can contain text properties for the
characters in it, as well as the characters themselves.  *Note Text
Properties::.  All the Lisp primitives that copy text from strings to
buffers or other strings also copy the properties of the characters
being copied.

   *Note Text::, for information about functions that display strings or
copy them into buffers.  *Note Character Type::, and *note String
Type::, for information about the syntax of characters and strings.
*Note Non-ASCII Characters::, for functions to convert between text
representations and to encode and decode character codes.


File: elisp.info,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: String Basics,  Up: Strings and Characters

4.2 Predicates for Strings
==========================

For more information about general sequence and array predicates, see
*note Sequences Arrays Vectors::, and *note Arrays::.

 -- Function: stringp object
     This function returns ‘t’ if OBJECT is a string, ‘nil’ otherwise.

 -- Function: string-or-null-p object
     This function returns ‘t’ if OBJECT is a string or ‘nil’.  It
     returns ‘nil’ otherwise.

 -- Function: char-or-string-p object
     This function returns ‘t’ if OBJECT is a string or a character
     (i.e., an integer), ‘nil’ otherwise.


File: elisp.info,  Node: Creating Strings,  Next: Modifying Strings,  Prev: Predicates for Strings,  Up: Strings and Characters

4.3 Creating Strings
====================

The following functions create strings, either from scratch, or by
putting strings together, or by taking them apart.

 -- Function: make-string count character
     This function returns a string made up of COUNT repetitions of
     CHARACTER.  If COUNT is negative, an error is signaled.

          (make-string 5 ?x)
               ⇒ "xxxxx"
          (make-string 0 ?x)
               ⇒ ""

     Other functions to compare with this one include ‘make-vector’
     (*note Vectors::) and ‘make-list’ (*note Building Lists::).

 -- Function: string &rest characters
     This returns a string containing the characters CHARACTERS.

          (string ?a ?b ?c)
               ⇒ "abc"

 -- Function: substring string &optional start end
     This function returns a new string which consists of those
     characters from STRING in the range from (and including) the
     character at the index START up to (but excluding) the character at
     the index END.  The first character is at index zero.  With one
     argument, this function just copies STRING.

          (substring "abcdefg" 0 3)
               ⇒ "abc"

     In the above example, the index for ‘a’ is 0, the index for ‘b’ is
     1, and the index for ‘c’ is 2.  The index 3—which is the fourth
     character in the string—marks the character position up to which
     the substring is copied.  Thus, ‘abc’ is copied from the string
     ‘"abcdefg"’.

     A negative number counts from the end of the string, so that −1
     signifies the index of the last character of the string.  For
     example:

          (substring "abcdefg" -3 -1)
               ⇒ "ef"

     In this example, the index for ‘e’ is −3, the index for ‘f’ is −2,
     and the index for ‘g’ is −1.  Therefore, ‘e’ and ‘f’ are included,
     and ‘g’ is excluded.

     When ‘nil’ is used for END, it stands for the length of the string.
     Thus,

          (substring "abcdefg" -3 nil)
               ⇒ "efg"

     Omitting the argument END is equivalent to specifying ‘nil’.  It
     follows that ‘(substring STRING 0)’ returns a copy of all of
     STRING.

          (substring "abcdefg" 0)
               ⇒ "abcdefg"

     But we recommend ‘copy-sequence’ for this purpose (*note Sequence
     Functions::).

     If the characters copied from STRING have text properties, the
     properties are copied into the new string also.  *Note Text
     Properties::.

     ‘substring’ also accepts a vector for the first argument.  For
     example:

          (substring [a b (c) "d"] 1 3)
               ⇒ [b (c)]

     A ‘wrong-type-argument’ error is signaled if START is not an
     integer or if END is neither an integer nor ‘nil’.  An
     ‘args-out-of-range’ error is signaled if START indicates a
     character following END, or if either integer is out of range for
     STRING.

     Contrast this function with ‘buffer-substring’ (*note Buffer
     Contents::), which returns a string containing a portion of the
     text in the current buffer.  The beginning of a string is at index
     0, but the beginning of a buffer is at index 1.

 -- Function: substring-no-properties string &optional start end
     This works like ‘substring’ but discards all text properties from
     the value.  Also, START may be omitted or ‘nil’, which is
     equivalent to 0.  Thus, ‘(substring-no-properties STRING)’ returns
     a copy of STRING, with all text properties removed.

 -- Function: concat &rest sequences
     This function returns a new string consisting of the characters in
     the arguments passed to it (along with their text properties, if
     any).  The arguments may be strings, lists of numbers, or vectors
     of numbers; they are not themselves changed.  If ‘concat’ receives
     no arguments, it returns an empty string.

          (concat "abc" "-def")
               ⇒ "abc-def"
          (concat "abc" (list 120 121) [122])
               ⇒ "abcxyz"
          ;; ‘nil’ is an empty sequence.
          (concat "abc" nil "-def")
               ⇒ "abc-def"
          (concat "The " "quick brown " "fox.")
               ⇒ "The quick brown fox."
          (concat)
               ⇒ ""

     This function always constructs a new string that is not ‘eq’ to
     any existing string, except when the result is the empty string (to
     save space, Emacs makes only one empty multibyte string).

     For information about other concatenation functions, see the
     description of ‘mapconcat’ in *note Mapping Functions::, ‘vconcat’
     in *note Vector Functions::, and ‘append’ in *note Building
     Lists::.  For concatenating individual command-line arguments into
     a string to be used as a shell command, see *note
     combine-and-quote-strings: Shell Arguments.

 -- Function: split-string string &optional separators omit-nulls trim
     This function splits STRING into substrings based on the regular
     expression SEPARATORS (*note Regular Expressions::).  Each match
     for SEPARATORS defines a splitting point; the substrings between
     splitting points are made into a list, which is returned.

     If SEPARATORS is ‘nil’ (or omitted), the default is the value of
     ‘split-string-default-separators’ and the function behaves as if
     OMIT-NULLS were ‘t’.

     If OMIT-NULLS is ‘nil’ (or omitted), the result contains null
     strings whenever there are two consecutive matches for SEPARATORS,
     or a match is adjacent to the beginning or end of STRING.  If
     OMIT-NULLS is ‘t’, these null strings are omitted from the result.

     If the optional argument TRIM is non-‘nil’, it should be a regular
     expression to match text to trim from the beginning and end of each
     substring.  If trimming makes the substring empty, it is treated as
     null.

     If you need to split a string into a list of individual
     command-line arguments suitable for ‘call-process’ or
     ‘start-process’, see *note split-string-and-unquote: Shell
     Arguments.

     Examples:

          (split-string "  two words ")
               ⇒ ("two" "words")

     The result is not ‘("" "two" "words" "")’, which would rarely be
     useful.  If you need such a result, use an explicit value for
     SEPARATORS:

          (split-string "  two words "
                        split-string-default-separators)
               ⇒ ("" "two" "words" "")

          (split-string "Soup is good food" "o")
               ⇒ ("S" "up is g" "" "d f" "" "d")
          (split-string "Soup is good food" "o" t)
               ⇒ ("S" "up is g" "d f" "d")
          (split-string "Soup is good food" "o+")
               ⇒ ("S" "up is g" "d f" "d")

     Empty matches do count, except that ‘split-string’ will not look
     for a final empty match when it already reached the end of the
     string using a non-empty match or when STRING is empty:

          (split-string "aooob" "o*")
               ⇒ ("" "a" "" "b" "")
          (split-string "ooaboo" "o*")
               ⇒ ("" "" "a" "b" "")
          (split-string "" "")
               ⇒ ("")

     However, when SEPARATORS can match the empty string, OMIT-NULLS is
     usually ‘t’, so that the subtleties in the three previous examples
     are rarely relevant:

          (split-string "Soup is good food" "o*" t)
               ⇒ ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
          (split-string "Nice doggy!" "" t)
               ⇒ ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
          (split-string "" "" t)
               ⇒ nil

     Somewhat odd, but predictable, behavior can occur for certain
     “non-greedy” values of SEPARATORS that can prefer empty matches
     over non-empty matches.  Again, such values rarely occur in
     practice:

          (split-string "ooo" "o*" t)
               ⇒ nil
          (split-string "ooo" "\\|o+" t)
               ⇒ ("o" "o" "o")

 -- Variable: split-string-default-separators
     The default value of SEPARATORS for ‘split-string’.  Its usual
     value is ‘"[ \f\t\n\r\v]+"’.


File: elisp.info,  Node: Modifying Strings,  Next: Text Comparison,  Prev: Creating Strings,  Up: Strings and Characters

4.4 Modifying Strings
=====================

The most basic way to alter the contents of an existing string is with
‘aset’ (*note Array Functions::).  ‘(aset STRING IDX CHAR)’ stores CHAR
into STRING at index IDX.  Each character occupies one or more bytes,
and if CHAR needs a different number of bytes from the character already
present at that index, ‘aset’ signals an error.

   A more powerful function is ‘store-substring’:

 -- Function: store-substring string idx obj
     This function alters part of the contents of the string STRING, by
     storing OBJ starting at index IDX.  The argument OBJ may be either
     a character or a (smaller) string.

     Since it is impossible to change the length of an existing string,
     it is an error if OBJ doesn’t fit within STRING’s actual length, or
     if any new character requires a different number of bytes from the
     character currently present at that point in STRING.

   To clear out a string that contained a password, use ‘clear-string’:

 -- Function: clear-string string
     This makes STRING a unibyte string and clears its contents to
     zeros.  It may also change STRING’s length.


File: elisp.info,  Node: Text Comparison,  Next: String Conversion,  Prev: Modifying Strings,  Up: Strings and Characters

4.5 Comparison of Characters and Strings
========================================

 -- Function: char-equal character1 character2
     This function returns ‘t’ if the arguments represent the same
     character, ‘nil’ otherwise.  This function ignores differences in
     case if ‘case-fold-search’ is non-‘nil’.

          (char-equal ?x ?x)
               ⇒ t
          (let ((case-fold-search nil))
            (char-equal ?x ?X))
               ⇒ nil

 -- Function: string= string1 string2
     This function returns ‘t’ if the characters of the two strings
     match exactly.  Symbols are also allowed as arguments, in which
     case the symbol names are used.  Case is always significant,
     regardless of ‘case-fold-search’.

     This function is equivalent to ‘equal’ for comparing two strings
     (*note Equality Predicates::).  In particular, the text properties
     of the two strings are ignored; use ‘equal-including-properties’ if
     you need to distinguish between strings that differ only in their
     text properties.  However, unlike ‘equal’, if either argument is
     not a string or symbol, ‘string=’ signals an error.

          (string= "abc" "abc")
               ⇒ t
          (string= "abc" "ABC")
               ⇒ nil
          (string= "ab" "ABC")
               ⇒ nil

     For technical reasons, a unibyte and a multibyte string are ‘equal’
     if and only if they contain the same sequence of character codes
     and all these codes are either in the range 0 through 127 (ASCII)
     or 160 through 255 (‘eight-bit-graphic’).  However, when a unibyte
     string is converted to a multibyte string, all characters with
     codes in the range 160 through 255 are converted to characters with
     higher codes, whereas ASCII characters remain unchanged.  Thus, a
     unibyte string and its conversion to multibyte are only ‘equal’ if
     the string is all ASCII.  Character codes 160 through 255 are not
     entirely proper in multibyte text, even though they can occur.  As
     a consequence, the situation where a unibyte and a multibyte string
     are ‘equal’ without both being all ASCII is a technical oddity that
     very few Emacs Lisp programmers ever get confronted with.  *Note
     Text Representations::.

 -- Function: string-equal string1 string2
     ‘string-equal’ is another name for ‘string=’.

 -- Function: string-collate-equalp string1 string2 &optional locale
          ignore-case
     This function returns ‘t’ if STRING1 and STRING2 are equal with
     respect to collation rules.  A collation rule is not only
     determined by the lexicographic order of the characters contained
     in STRING1 and STRING2, but also further rules about relations
     between these characters.  Usually, it is defined by the LOCALE
     environment Emacs is running with.

     For example, characters with different coding points but the same
     meaning might be considered as equal, like different grave accent
     Unicode characters:

          (string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
               ⇒ t

     The optional argument LOCALE, a string, overrides the setting of
     your current locale identifier for collation.  The value is system
     dependent; a LOCALE ‘"en_US.UTF-8"’ is applicable on POSIX systems,
     while it would be, e.g., ‘"enu_USA.1252"’ on MS-Windows systems.

     If IGNORE-CASE is non-‘nil’, characters are converted to lower-case
     before comparing them.

     To emulate Unicode-compliant collation on MS-Windows systems, bind
     ‘w32-collate-ignore-punctuation’ to a non-‘nil’ value, since the
     codeset part of the locale cannot be ‘"UTF-8"’ on MS-Windows.

     If your system does not support a locale environment, this function
     behaves like ‘string-equal’.

     Do _not_ use this function to compare file names for equality, as
     filesystems generally don’t honor linguistic equivalence of strings
     that collation implements.

 -- Function: string< string1 string2
     This function compares two strings a character at a time.  It scans
     both the strings at the same time to find the first pair of
     corresponding characters that do not match.  If the lesser
     character of these two is the character from STRING1, then STRING1
     is less, and this function returns ‘t’.  If the lesser character is
     the one from STRING2, then STRING1 is greater, and this function
     returns ‘nil’.  If the two strings match entirely, the value is
     ‘nil’.

     Pairs of characters are compared according to their character
     codes.  Keep in mind that lower case letters have higher numeric
     values in the ASCII character set than their upper case
     counterparts; digits and many punctuation characters have a lower
     numeric value than upper case letters.  An ASCII character is less
     than any non-ASCII character; a unibyte non-ASCII character is
     always less than any multibyte non-ASCII character (*note Text
     Representations::).

          (string< "abc" "abd")
               ⇒ t
          (string< "abd" "abc")
               ⇒ nil
          (string< "123" "abc")
               ⇒ t

     When the strings have different lengths, and they match up to the
     length of STRING1, then the result is ‘t’.  If they match up to the
     length of STRING2, the result is ‘nil’.  A string of no characters
     is less than any other string.

          (string< "" "abc")
               ⇒ t
          (string< "ab" "abc")
               ⇒ t
          (string< "abc" "")
               ⇒ nil
          (string< "abc" "ab")
               ⇒ nil
          (string< "" "")
               ⇒ nil

     Symbols are also allowed as arguments, in which case their print
     names are compared.

 -- Function: string-lessp string1 string2
     ‘string-lessp’ is another name for ‘string<’.

 -- Function: string-greaterp string1 string2
     This function returns the result of comparing STRING1 and STRING2
     in the opposite order, i.e., it is equivalent to calling
     ‘(string-lessp STRING2 STRING1)’.

 -- Function: string-collate-lessp string1 string2 &optional locale
          ignore-case
     This function returns ‘t’ if STRING1 is less than STRING2 in
     collation order.  A collation order is not only determined by the
     lexicographic order of the characters contained in STRING1 and
     STRING2, but also further rules about relations between these
     characters.  Usually, it is defined by the LOCALE environment Emacs
     is running with.

     For example, punctuation and whitespace characters might be ignored
     for sorting (*note Sequence Functions::):

          (sort '("11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
               ⇒ ("11" "1 1" "1.1" "12" "1 2" "1.2")

     This behavior is system-dependent; e.g., punctuation and whitespace
     are never ignored on Cygwin, regardless of locale.

     The optional argument LOCALE, a string, overrides the setting of
     your current locale identifier for collation.  The value is system
     dependent; a LOCALE ‘"en_US.UTF-8"’ is applicable on POSIX systems,
     while it would be, e.g., ‘"enu_USA.1252"’ on MS-Windows systems.
     The LOCALE value of ‘"POSIX"’ or ‘"C"’ lets ‘string-collate-lessp’
     behave like ‘string-lessp’:

          (sort '("11" "12" "1 1" "1 2" "1.1" "1.2")
                (lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
               ⇒ ("1 1" "1 2" "1.1" "1.2" "11" "12")

     If IGNORE-CASE is non-‘nil’, characters are converted to lower-case
     before comparing them.

     To emulate Unicode-compliant collation on MS-Windows systems, bind
     ‘w32-collate-ignore-punctuation’ to a non-‘nil’ value, since the
     codeset part of the locale cannot be ‘"UTF-8"’ on MS-Windows.

     If your system does not support a locale environment, this function
     behaves like ‘string-lessp’.

 -- Function: string-version-lessp string1 string2
     This function compares strings lexicographically, except it treats
     sequences of numerical characters as if they comprised a base-ten
     number, and then compares the numbers.  So ‘foo2.png’ is “smaller”
     than ‘foo12.png’ according to this predicate, even if ‘12’ is
     lexicographically “smaller” than ‘2’.

 -- Function: string-prefix-p string1 string2 &optional ignore-case
     This function returns non-‘nil’ if STRING1 is a prefix of STRING2;
     i.e., if STRING2 starts with STRING1.  If the optional argument
     IGNORE-CASE is non-‘nil’, the comparison ignores case differences.

 -- Function: string-suffix-p suffix string &optional ignore-case
     This function returns non-‘nil’ if SUFFIX is a suffix of STRING;
     i.e., if STRING ends with SUFFIX.  If the optional argument
     IGNORE-CASE is non-‘nil’, the comparison ignores case differences.

 -- Function: compare-strings string1 start1 end1 string2 start2 end2
          &optional ignore-case
     This function compares a specified part of STRING1 with a specified
     part of STRING2.  The specified part of STRING1 runs from index
     START1 (inclusive) up to index END1 (exclusive); ‘nil’ for START1
     means the start of the string, while ‘nil’ for END1 means the
     length of the string.  Likewise, the specified part of STRING2 runs
     from index START2 up to index END2.

     The strings are compared by the numeric values of their characters.
     For instance, STR1 is considered less than STR2 if its first
     differing character has a smaller numeric value.  If IGNORE-CASE is
     non-‘nil’, characters are converted to upper-case before comparing
     them.  Unibyte strings are converted to multibyte for comparison
     (*note Text Representations::), so that a unibyte string and its
     conversion to multibyte are always regarded as equal.

     If the specified portions of the two strings match, the value is
     ‘t’.  Otherwise, the value is an integer which indicates how many
     leading characters agree, and which string is less.  Its absolute
     value is one plus the number of characters that agree at the
     beginning of the two strings.  The sign is negative if STRING1 (or
     its specified portion) is less.

 -- Function: assoc-string key alist &optional case-fold
     This function works like ‘assoc’, except that KEY must be a string
     or symbol, and comparison is done using ‘compare-strings’.  Symbols
     are converted to strings before testing.  If CASE-FOLD is
     non-‘nil’, KEY and the elements of ALIST are converted to
     upper-case before comparison.  Unlike ‘assoc’, this function can
     also match elements of the alist that are strings or symbols rather
     than conses.  In particular, ALIST can be a list of strings or
     symbols rather than an actual alist.  *Note Association Lists::.

   See also the function ‘compare-buffer-substrings’ in *note Comparing
Text::, for a way to compare text in buffers.  The function
‘string-match’, which matches a regular expression against a string, can
be used for a kind of string comparison; see *note Regexp Search::.


File: elisp.info,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

4.6 Conversion of Characters and Strings
========================================

This section describes functions for converting between characters,
strings and integers.  ‘format’ (*note Formatting Strings::) and
‘prin1-to-string’ (*note Output Functions::) can also convert Lisp
objects into strings.  ‘read-from-string’ (*note Input Functions::) can
convert a string representation of a Lisp object into an object.  The
functions ‘string-to-multibyte’ and ‘string-to-unibyte’ convert the text
representation of a string (*note Converting Representations::).

   *Note Documentation::, for functions that produce textual
descriptions of text characters and general input events
(‘single-key-description’ and ‘text-char-description’).  These are used
primarily for making help messages.

 -- Function: number-to-string number
     This function returns a string consisting of the printed base-ten
     representation of NUMBER.  The returned value starts with a minus
     sign if the argument is negative.

          (number-to-string 256)
               ⇒ "256"
          (number-to-string -23)
               ⇒ "-23"
          (number-to-string -23.5)
               ⇒ "-23.5"

     ‘int-to-string’ is a semi-obsolete alias for this function.

     See also the function ‘format’ in *note Formatting Strings::.

 -- Function: string-to-number string &optional base
     This function returns the numeric value of the characters in
     STRING.  If BASE is non-‘nil’, it must be an integer between 2 and
     16 (inclusive), and integers are converted in that base.  If BASE
     is ‘nil’, then base ten is used.  Floating-point conversion only
     works in base ten; we have not implemented other radices for
     floating-point numbers, because that would be much more work and
     does not seem useful.  If STRING looks like an integer but its
     value is too large to fit into a Lisp integer, ‘string-to-number’
     returns a floating-point result.

     The parsing skips spaces and tabs at the beginning of STRING, then
     reads as much of STRING as it can interpret as a number in the
     given base.  (On some systems it ignores other whitespace at the
     beginning, not just spaces and tabs.)  If STRING cannot be
     interpreted as a number, this function returns 0.

          (string-to-number "256")
               ⇒ 256
          (string-to-number "25 is a perfect square.")
               ⇒ 25
          (string-to-number "X256")
               ⇒ 0
          (string-to-number "-4.5")
               ⇒ -4.5
          (string-to-number "1e5")
               ⇒ 100000.0

     ‘string-to-int’ is an obsolete alias for this function.

 -- Function: char-to-string character
     This function returns a new string containing one character,
     CHARACTER.  This function is semi-obsolete because the function
     ‘string’ is more general.  *Note Creating Strings::.

 -- Function: string-to-char string
     This function returns the first character in STRING.  This mostly
     identical to ‘(aref string 0)’, except that it returns 0 if the
     string is empty.  (The value is also 0 when the first character of
     STRING is the null character, ASCII code 0.)  This function may be
     eliminated in the future if it does not seem useful enough to
     retain.

   Here are some other functions that can convert to or from a string:

‘concat’
     This function converts a vector or a list into a string.  *Note
     Creating Strings::.

‘vconcat’
     This function converts a string into a vector.  *Note Vector
     Functions::.

‘append’
     This function converts a string into a list.  *Note Building
     Lists::.

‘byte-to-string’
     This function converts a byte of character data into a unibyte
     string.  *Note Converting Representations::.


File: elisp.info,  Node: Formatting Strings,  Next: Case Conversion,  Prev: String Conversion,  Up: Strings and Characters

4.7 Formatting Strings
======================

“Formatting” means constructing a string by substituting computed values
at various places in a constant string.  This constant string controls
how the other values are printed, as well as where they appear; it is
called a “format string”.

   Formatting is often useful for computing messages to be displayed.
In fact, the functions ‘message’ and ‘error’ provide the same formatting
feature described here; they differ from ‘format-message’ only in how
they use the result of formatting.

 -- Function: format string &rest objects
     This function returns a string equal to STRING, replacing any
     format specifications with encodings of the corresponding OBJECTS.
     The arguments OBJECTS are the computed values to be formatted.

     The characters in STRING, other than the format specifications, are
     copied directly into the output, including their text properties,
     if any.  Any text properties of the format specifications are
     copied to the produced string representations of the argument
     OBJECTS.

     The output string need not be newly-allocated.  For example, if ‘x’
     is the string ‘"foo"’, the expressions ‘(eq x (format x))’ and ‘(eq
     x (format "%s" x))’ might both yield ‘t’.

 -- Function: format-message string &rest objects
     This function acts like ‘format’, except it also converts any grave
     accents (`) and apostrophes (') in STRING as per the value of
     ‘text-quoting-style’.

     Typically grave accent and apostrophe in the format translate to
     matching curved quotes, e.g., "Missing `%s'" might result in
     "Missing ‘foo’".  *Note Text Quoting Style::, for how to influence
     or inhibit this translation.

   A format specification is a sequence of characters beginning with a
‘%’.  Thus, if there is a ‘%d’ in STRING, the ‘format’ function replaces
it with the printed representation of one of the values to be formatted
(one of the arguments OBJECTS).  For example:

     (format "The value of fill-column is %d." fill-column)
          ⇒ "The value of fill-column is 72."

   Since ‘format’ interprets ‘%’ characters as format specifications,
you should _never_ pass an arbitrary string as the first argument.  This
is particularly true when the string is generated by some Lisp code.
Unless the string is _known_ to never include any ‘%’ characters, pass
‘"%s"’, described below, as the first argument, and the string as the
second, like this:

       (format "%s" ARBITRARY-STRING)

   Certain format specifications require values of particular types.  If
you supply a value that doesn’t fit the requirements, an error is
signaled.

   Here is a table of valid format specifications:

‘%s’
     Replace the specification with the printed representation of the
     object, made without quoting (that is, using ‘princ’, not
     ‘prin1’—*note Output Functions::).  Thus, strings are represented
     by their contents alone, with no ‘"’ characters, and symbols appear
     without ‘\’ characters.

     If the object is a string, its text properties are copied into the
     output.  The text properties of the ‘%s’ itself are also copied,
     but those of the object take priority.

‘%S’
     Replace the specification with the printed representation of the
     object, made with quoting (that is, using ‘prin1’—*note Output
     Functions::).  Thus, strings are enclosed in ‘"’ characters, and
     ‘\’ characters appear where necessary before special characters.

‘%o’
     Replace the specification with the base-eight representation of an
     unsigned integer.

‘%d’
     Replace the specification with the base-ten representation of a
     signed integer.

‘%x’
‘%X’
     Replace the specification with the base-sixteen representation of
     an unsigned integer.  ‘%x’ uses lower case and ‘%X’ uses upper
     case.

‘%c’
     Replace the specification with the character which is the value
     given.

‘%e’
     Replace the specification with the exponential notation for a
     floating-point number.

‘%f’
     Replace the specification with the decimal-point notation for a
     floating-point number.

‘%g’
     Replace the specification with notation for a floating-point
     number, using either exponential notation or decimal-point
     notation.  The exponential notation is used if the exponent would
     be less than −4 or greater than or equal to the precision (default:
     6).  By default, trailing zeros are removed from the fractional
     portion of the result and a decimal-point character appears only if
     it is followed by a digit.

‘%%’
     Replace the specification with a single ‘%’.  This format
     specification is unusual in that its only form is plain ‘%%’ and
     that it does not use a value.  For example, ‘(format "%% %d" 30)’
     returns ‘"% 30"’.

   Any other format character results in an ‘Invalid format operation’
error.

   Here are several examples, which assume the typical
‘text-quoting-style’ settings:

     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          ⇒ "The octal value of 18 is 22,
              and the hex value is 12."

     (format-message
      "The name of this buffer is ‘%s’." (buffer-name))
          ⇒ "The name of this buffer is ‘strings.texi’."

     (format-message
      "The buffer object prints as `%s'." (current-buffer))
          ⇒ "The buffer object prints as ‘strings.texi’."

   By default, format specifications correspond to successive values
from OBJECTS.  Thus, the first format specification in STRING uses the
first such value, the second format specification uses the second such
value, and so on.  Any extra format specifications (those for which
there are no corresponding values) cause an error.  Any extra values to
be formatted are ignored.

   A format specification can have a “field number”, which is a decimal
number immediately after the initial ‘%’, followed by a literal dollar
sign ‘$’.  It causes the format specification to convert the argument
with the given number instead of the next argument.  Field numbers start
at 1.  A format can contain either numbered or unnumbered format
specifications but not both, except that ‘%%’ can be mixed with numbered
specifications.

     (format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
          ⇒ "y, z, %, x"

   After the ‘%’ and any field number, you can put certain “flag
characters”.

   The flag ‘+’ inserts a plus sign before a positive number, so that it
always has a sign.  A space character as flag inserts a space before a
positive number.  (Otherwise, positive numbers start with the first
digit.)  These flags are useful for ensuring that positive numbers and
negative numbers use the same number of columns.  They are ignored
except for ‘%d’, ‘%e’, ‘%f’, ‘%g’, and if both flags are used, ‘+’ takes
precedence.

   The flag ‘#’ specifies an alternate form which depends on the format
in use.  For ‘%o’, it ensures that the result begins with a ‘0’.  For
‘%x’ and ‘%X’, it prefixes the result with ‘0x’ or ‘0X’.  For ‘%e’ and
‘%f’, the ‘#’ flag means include a decimal point even if the precision
is zero.  For ‘%g’, it always includes a decimal point, and also forces
any trailing zeros after the decimal point to be left in place where
they would otherwise be removed.

   The flag ‘0’ ensures that the padding consists of ‘0’ characters
instead of spaces.  This flag is ignored for non-numerical specification
characters like ‘%s’, ‘%S’ and ‘%c’.  These specification characters
accept the ‘0’ flag, but still pad with _spaces_.

   The flag ‘-’ causes any padding inserted by the width, if specified,
to be inserted on the right rather than the left.  If both ‘-’ and ‘0’
are present, the ‘0’ flag is ignored.

     (format "%06d is padded on the left with zeros" 123)
          ⇒ "000123 is padded on the left with zeros"

     (format "'%-6d' is padded on the right" 123)
          ⇒ "'123   ' is padded on the right"

     (format "The word '%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          ⇒ "The word 'foo    ' actually has 3 letters in it."

   A specification can have a “width”, which is a decimal number that
appears after any field number and flags.  If the printed representation
of the object contains fewer characters than this width, ‘format’
extends it with padding.  Any padding introduced by the width normally
consists of spaces inserted on the left:

     (format "%5d is padded on the left with spaces" 123)
          ⇒ "  123 is padded on the left with spaces"

If the width is too small, ‘format’ does not truncate the object’s
printed representation.  Thus, you can use a width to specify a minimum
spacing between columns with no risk of losing information.  In the
following two examples, ‘%7s’ specifies a minimum width of 7.  In the
first case, the string inserted in place of ‘%7s’ has only 3 letters,
and needs 4 blank spaces as padding.  In the second case, the string
‘"specification"’ is 13 letters wide but is not truncated.

     (format "The word '%7s' has %d letters in it."
             "foo" (length "foo"))
          ⇒ "The word '    foo' has 3 letters in it."
     (format "The word '%7s' has %d letters in it."
             "specification" (length "specification"))
          ⇒ "The word 'specification' has 13 letters in it."

   All the specification characters allow an optional “precision” after
the field number, flags and width, if present.  The precision is a
decimal-point ‘.’ followed by a digit-string.  For the floating-point
specifications (‘%e’ and ‘%f’), the precision specifies how many digits
following the decimal point to show; if zero, the decimal-point itself
is also omitted.  For ‘%g’, the precision specifies how many significant
digits to show (significant digits are the first digit before the
decimal point and all the digits after it).  If the precision of %g is
zero or unspecified, it is treated as 1.  For ‘%s’ and ‘%S’, the
precision truncates the string to the given width, so ‘%.3s’ shows only
the first three characters of the representation for OBJECT.  For other
specification characters, the effect of precision is what the local
library functions of the ‘printf’ family produce.


File: elisp.info,  Node: Case Conversion,  Next: Case Tables,  Prev: Formatting Strings,  Up: Strings and Characters

4.8 Case Conversion in Lisp
===========================

The character case functions change the case of single characters or of
the contents of strings.  The functions normally convert only alphabetic
characters (the letters ‘A’ through ‘Z’ and ‘a’ through ‘z’, as well as
non-ASCII letters); other characters are not altered.  You can specify a
different case conversion mapping by specifying a case table (*note Case
Tables::).

   These functions do not modify the strings that are passed to them as
arguments.

   The examples below use the characters ‘X’ and ‘x’ which have ASCII
codes 88 and 120 respectively.

 -- Function: downcase string-or-char
     This function converts STRING-OR-CHAR, which should be either a
     character or a string, to lower case.

     When STRING-OR-CHAR is a string, this function returns a new string
     in which each letter in the argument that is upper case is
     converted to lower case.  When STRING-OR-CHAR is a character, this
     function returns the corresponding lower case character (an
     integer); if the original character is lower case, or is not a
     letter, the return value is equal to the original character.

          (downcase "The cat in the hat")
               ⇒ "the cat in the hat"

          (downcase ?X)
               ⇒ 120

 -- Function: upcase string-or-char
     This function converts STRING-OR-CHAR, which should be either a
     character or a string, to upper case.

     When STRING-OR-CHAR is a string, this function returns a new string
     in which each letter in the argument that is lower case is
     converted to upper case.  When STRING-OR-CHAR is a character, this
     function returns the corresponding upper case character (an
     integer); if the original character is upper case, or is not a
     letter, the return value is equal to the original character.

          (upcase "The cat in the hat")
               ⇒ "THE CAT IN THE HAT"

          (upcase ?x)
               ⇒ 88

 -- Function: capitalize string-or-char
     This function capitalizes strings or characters.  If STRING-OR-CHAR
     is a string, the function returns a new string whose contents are a
     copy of STRING-OR-CHAR in which each word has been capitalized.
     This means that the first character of each word is converted to
     upper case, and the rest are converted to lower case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

     When STRING-OR-CHAR is a character, this function does the same
     thing as ‘upcase’.

          (capitalize "The cat in the hat")
               ⇒ "The Cat In The Hat"

          (capitalize "THE 77TH-HATTED CAT")
               ⇒ "The 77th-Hatted Cat"

          (capitalize ?x)
               ⇒ 88

 -- Function: upcase-initials string-or-char
     If STRING-OR-CHAR is a string, this function capitalizes the
     initials of the words in STRING-OR-CHAR, without altering any
     letters other than the initials.  It returns a new string whose
     contents are a copy of STRING-OR-CHAR, in which each word has had
     its initial letter converted to upper case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

     When the argument to ‘upcase-initials’ is a character,
     ‘upcase-initials’ has the same result as ‘upcase’.

          (upcase-initials "The CAT in the hAt")
               ⇒ "The CAT In The HAt"

   Note that case conversion is not a one-to-one mapping of codepoints
and length of the result may differ from length of the argument.
Furthermore, because passing a character forces return type to be a
character, functions are unable to perform proper substitution and
result may differ compared to treating a one-character string.  For
example:

     (upcase "ﬁ")  ; note: single character, ligature "fi"
          ⇒ "FI"
     (upcase ?ﬁ)
          ⇒ 64257  ; i.e. ?ﬁ

   To avoid this, a character must first be converted into a string,
using ‘string’ function, before being passed to one of the casing
functions.  Of course, no assumptions on the length of the result may be
made.

   Mapping for such special cases are taken from ‘special-uppercase’,
‘special-lowercase’ and ‘special-titlecase’ *Note Character
Properties::.

   *Note Text Comparison::, for functions that compare strings; some of
them ignore case differences, or can optionally ignore case differences.


File: elisp.info,  Node: Case Tables,  Prev: Case Conversion,  Up: Strings and Characters

4.9 The Case Table
==================

You can customize case conversion by installing a special “case table”.
A case table specifies the mapping between upper case and lower case
letters.  It affects both the case conversion functions for Lisp objects
(see the previous section) and those that apply to text in the buffer
(*note Case Changes::).  Each buffer has a case table; there is also a
standard case table which is used to initialize the case table of new
buffers.

   A case table is a char-table (*note Char-Tables::) whose subtype is
‘case-table’.  This char-table maps each character into the
corresponding lower case character.  It has three extra slots, which
hold related tables:

UPCASE
     The upcase table maps each character into the corresponding upper
     case character.
CANONICALIZE
     The canonicalize table maps all of a set of case-related characters
     into a particular member of that set.
EQUIVALENCES
     The equivalences table maps each one of a set of case-related
     characters into the next character in that set.

   In simple cases, all you need to specify is the mapping to
lower-case; the three related tables will be calculated automatically
from that one.

   For some languages, upper and lower case letters are not in
one-to-one correspondence.  There may be two different lower case
letters with the same upper case equivalent.  In these cases, you need
to specify the maps for both lower case and upper case.

   The extra table CANONICALIZE maps each character to a canonical
equivalent; any two characters that are related by case-conversion have
the same canonical equivalent character.  For example, since ‘a’ and ‘A’
are related by case-conversion, they should have the same canonical
equivalent character (which should be either ‘a’ for both of them, or
‘A’ for both of them).

   The extra table EQUIVALENCES is a map that cyclically permutes each
equivalence class (of characters with the same canonical equivalent).
(For ordinary ASCII, this would map ‘a’ into ‘A’ and ‘A’ into ‘a’, and
likewise for each set of equivalent characters.)

   When constructing a case table, you can provide ‘nil’ for
CANONICALIZE; then Emacs fills in this slot from the lower case and
upper case mappings.  You can also provide ‘nil’ for EQUIVALENCES; then
Emacs fills in this slot from CANONICALIZE.  In a case table that is
actually in use, those components are non-‘nil’.  Do not try to specify
EQUIVALENCES without also specifying CANONICALIZE.

   Here are the functions for working with case tables:

 -- Function: case-table-p object
     This predicate returns non-‘nil’ if OBJECT is a valid case table.

 -- Function: set-standard-case-table table
     This function makes TABLE the standard case table, so that it will
     be used in any buffers created subsequently.

 -- Function: standard-case-table
     This returns the standard case table.

 -- Function: current-case-table
     This function returns the current buffer’s case table.

 -- Function: set-case-table table
     This sets the current buffer’s case table to TABLE.

 -- Macro: with-case-table table body...
     The ‘with-case-table’ macro saves the current case table, makes
     TABLE the current case table, evaluates the BODY forms, and finally
     restores the case table.  The return value is the value of the last
     form in BODY.  The case table is restored even in case of an
     abnormal exit via ‘throw’ or error (*note Nonlocal Exits::).

   Some language environments modify the case conversions of ASCII
characters; for example, in the Turkish language environment, the ASCII
capital I is downcased into a Turkish dotless i (‘ı’).  This can
interfere with code that requires ordinary ASCII case conversion, such
as implementations of ASCII-based network protocols.  In that case, use
the ‘with-case-table’ macro with the variable ASCII-CASE-TABLE, which
stores the unmodified case table for the ASCII character set.

 -- Variable: ascii-case-table
     The case table for the ASCII character set.  This should not be
     modified by any language environment settings.

   The following three functions are convenient subroutines for packages
that define non-ASCII character sets.  They modify the specified case
table CASE-TABLE; they also modify the standard syntax table.  *Note
Syntax Tables::.  Normally you would use these functions to change the
standard case table.

 -- Function: set-case-syntax-pair uc lc case-table
     This function specifies a pair of corresponding letters, one upper
     case and one lower case.

 -- Function: set-case-syntax-delims l r case-table
     This function makes characters L and R a matching pair of
     case-invariant delimiters.

 -- Function: set-case-syntax char syntax case-table
     This function makes CHAR case-invariant, with syntax SYNTAX.

 -- Command: describe-buffer-case-table
     This command displays a description of the contents of the current
     buffer’s case table.

