Вступление SSH - базовая настройка

Когда-то давным-давно в месте, не слишком далеко, родился Интернет. В первые дни люди
использовали базовые протоколы для взаимодействия друг с другом и обмена информацией. Одна
партия этих протоколов позволяла людям удаленно подключаться к другому компьютеру и входить
в систему для интерактивной оболочки или передавать удаленные команды для обработки. Это
были telnet, rsh и rlogin. Были также rcp и ftp для передачи файлов. Все это было
замечательно, пока людям не нужно было запирать свои двери ночью, потому что соседи стали
слишком любопытными. Безопасность стала проблемой, и SSH родился.

Сегодня большинство людей считают OpenSSH де-факто программным обеспечением для служб
SSH. Он содержит как серверный компонент (sshd), так и подсистему sftp (для замены FTP) и
несколько клиентов для обработки удаленных входов в систему и передачи файлов (ssh и scp).
Правда в том, что существует множество пакетов на выбор, для обоих связь на стороне
сервера и на стороне клиента с этими новыми протоколами. Я могу рассказать о некоторых из
них, но эта серия будет начинаться с OpenSSH, потому что он наиболее популярен в настоящее
время. Мы начнем с базовой настройки, а затем перейдем к более сложным настройкам, чтобы
покрыть различные потребности в зависимости от масштаба операции, требующей такого типа
организации доступа.

Первоначальное объяснение того, как это работает, заключается в том, что пользователь на
рабочей станции A хочет иметь возможность удаленного входа на сервер B для выполнения
некоторой рабочей нагрузки. Помните, что каждый сеанс SSH состоит из фрагментов информации
на самом базовом уровне. Пользователь (User_A) на рабочей станции или сервере
(Workstation_A) хочет удаленно подключиться к серверу (Server_B) как некоторый пользователь
(User_B) для выполнения рабочей нагрузки. Мы будем использовать эти метки в дальнейшем,
чтобы описать, как настроить программное обеспечение для каждого типа сценария, который мы
хотим охватить. В конце концов будет задействована третья система (либо LDAP,
либо Certificate Authority, либо и то и другое), поэтому мы добавим метку _C, когда
дойдем до этого. На данный момент, просто помните, что “_A” будет представлять
“coming from” (приходящий из), а “_B” будет представлять “going to” (собирается в) для
направленности каждого потока сеанса.

Таким образом, прежде чем User_A сможет подключиться к Server_B с SSH, Server_B должен
иметь запущенную службу SSH. Программное обеспечение может быть установлено из исходного
кода или из любой системы управления пакетами, которую поддерживает ваш сервер OS.
RPM/yum и DPKG/apt-get являются общими для систем на базе RedHat и Debian, соответственно.
В AIX есть installp/RPM. HP-UX имеет Swinstall. Просто используйте соответствующее
программное обеспечение для системы, которую вы поддерживаете, но помните, что для
некоторых из более продвинутых функций потребуются более новые версии OpenSSH, поэтому,
если вы попробуете что-то, и это не сработает, проверьте версию вашего сервера.

Теперь, когда OpenSSH sshd был установлен с помощью любых средств, которые вы выбрали,
User_A требуется клиентское программное обеспечение. Здесь должно быть то же самое дело,
как раньше. Используйте любое программное обеспечение для управления пакетами, которое
вы выберете. Существует клиент OpenSSH через проект Cygwin для Windows для “follow along”,
когда ваша рабочая станция - Windows, но другие клиенты могут работать лучше для
большинства этих сценариев. PuTTy и его производные, WinSCP, MobaXTerm - отличные клиенты
для Windows. Однако когда мы добираемся до соединений на основе сертификатов, их может быть
недостаточно. Просто установите клиент OpenSSH сейчас на любой платформе, с которой вы
работаете, и давайте двигаться дальше.

Теперь у Workstation_A и Server_B есть программное обеспечение, необходимое для
установления соединения. Если User_A хочет подключиться к Server_B как User_B,
учетная запись “User_B” должна существовать на сервере или, по крайней мере, быть
пользователем, который может проходить аутентификацию (LDAP или аналогичный). Пока мы
будем предполагать, что используются локальные учетные записи. Таким образом, чтобы
установить соединение, User_A на Workstation_A необходимо знать пароль для User_B на
Server_B. Затем введите следующее, чтобы установить соединение (при условии, что
учетная запись активна и не заблокирована).

Как User_A из терминальной подсказки:
ssh User_B@@Server_B

Это так просто. Это почти не стоит освещать, я знаю. Тем не менее, каждая публикация
в этой серии будет делать шаг к тому, чтобы все работало более гладко с точки зрения
эксплуатации и безопасности, так что оставайтесь со мной. Далее мы рассмотрим
настройку пар открытого и закрытого ключей для аутентификации без пароля.

SSH Начало от начала до конца - Основы центра сертификации

Принцип работы OpenSSH Certificate Authority зависит от нескольких компонентов.
Во-первых, должен быть один доверенный подписывающий орган. Это может быть любая
система, и для этого необходимо, чтобы было ИСКЛЮЧЕНО активное подключение к сети,
этой системы и рукопожатие client/server происходило с использованием подписанных
ключей CA. Должен также быть Key Revocation List, а также средство для обновления
KRL. Правильная Identity и платформа Access Management (IAM) могли бы справиться
с этим. Быстродействие можно достигнуть с помощью подходящего инструментария
Configuration Management/Server Automation, таким как Puppet, Chef, Salt, или Ansible.
Мы не будем рассматривать использование любого из этих инструментов в этой серии,
но мы (скорее всего) рассмотрим альтернативное решение, когда ни одна из предыдущих
рекомендаций не доступна. Сейчас мы только представим основные понятия и основы
работы OpenSSH Certificate Authority.

Давайте настроим участников. Есть человек (User_A), которому нужно войти на целевую
машину (Server_A) под своим именем. Он делает вход со своего ноутбука (Workstation_A.)
Обычно User_A генерирует свою пару ключей, регистрируется в Server_A под своим именем
и помещает открытый ключ в файл author_keys в своей домашней директории. Вместо этого
мы собираемся привлечь нового участника, который действует как доверенная третья
сторона. Это будет Certificate Authority (CA). CA должен запускаться
непривилегированным пользователем на сервере, который либо не подключен напрямую к сети,
либо защищен. Практическая возможность подписи также должна быть ограничена небольшой
группой людей. Для нашего примера предположим, что он изолирован от сети.

Мы предполагаем, что CA уже настроен, но вот шаги, которые нужно было сделать для этого.
Создайте непривилегированного пользователя (и группу) для подписи. Переключитесь на
этого пользователя и создайте структуру каталогов подписи CA. Используйте ssh-keygen,
чтобы создать ключ(и) подписи сертификата.

Есть два типа сертификатов, которые могут быть подписаны. Сертификат пользователя
аутентифицирует пользователей на серверах. Сертификат хоста аутентифицирует хосты
для пользователей. Зачем нам оба?

Сертификат хоста дает нам возможность установить новый сервер в нашей среде, подписать
его ключи хоста центром сертификации, и тогда клиент узнает, что новый ключ в порядке,
не предлагая пользователю сначала доверять ключу. Это уменьшает некоторые проблемы с
управлением файлом known_hosts.

Пользовательский сертификат дает нам возможность сообщить серверу, что с нашим ключом
все в порядке, без необходимости сначала помещать ключ на сервер. Это устраняет некоторые
проблемы с управлением распределением ключей.

Подписанный сертификат пользователя может накладывать ограничения на подписанный открытый
ключ, включая все ограничения, которые мы обсуждали в разделе pre-amble для записей
authorized_keys.

Давайте посмотрим на общий обзор рабочего процесса сейчас. Далее мы рассмотрим команды,
необходимые для поддержки вышеупомянутой структуры центра сертификации, а также команды
для подписи сертификатов хоста и пользователя.

Сценарий рабочего процесса:

   Используется новая машина.

   Ключи хоста регенерируются (если, например, это клонированная виртуальная машина)
   и подписываются Certificate Authority. Этот подписанный сертификат помещается
   обратно на новый компьютер, и это все, что нужно, если клиенты настроены правильно.

   Чтобы клиент мог воспользоваться этим, ему нужна специальная запись known_hosts,
   которая начинается с @@cert-authority и сопровождается открытым ключом для
   подписанных сертификатов хоста. Когда пользователь входит в систему на новом
   компьютере, поток подключения будет включать в себя сервер, представляющий
   сертификат хоста клиенту, который затем проверяет, что запись known_hosts
   “@@cert-authority” может расшифровать сертификат хоста, и затем соединение
   успешно принимается. Это помогает предотвратить путаницу в специально созданных
   системах, когда IP или имена хостов регулярно меняются.

Сценарий рабочего процесса: новому пользователю необходим доступ к системе. Пользователь
генерирует свой ключ, отправляет открытый ключ для подписи и, когда сертификат получен,
помещает его в свой каталог .ssh вместе с остальными файлами, связанными с ключом.
Хост-машины уже настроены на доверие к центру сертификации в файле sshd_config. Когда
пользователь подключается к ssh, клиент представляет подписанный сертификат целевому
компьютеру. Sshd целевой машины открывает запись TrustedUserCAKeys, чтобы открыть
соответствующий открытый ключ для декодирования сертификата. При удачном декодировании,
соединение определяется как доверенное, как если бы ключ был в authorized_keys для
этого пользователя. Это помогает снизить нагрузку на управление несколькими файлами
authorized_keys для каждого пользователя.

Конечно, в этом есть нечто большее, но мы рассмотрим более тонкие детали в течение
следующих разделов. В следующем разделе будет объяснение команд, необходимых для
настройки CA (включая списки отзыва и почему они важны).

SSH начало, чтобы закончить архитектуру - поддерживая CA

Прежде чем мы перейдем к сути обсуждения, нам нужно установить некоторые
определения. На прошлой неделе мы упоминали, что центр сертификации может
создавать сертификаты как для хостов, так и для пользователей. Мы собираемся
охватить оба сегодня. Если кажется, что мы повторяемся, то на самом деле
это не так. Обратите внимание, в каком разделе вы находитесь, когда будете
следовать, так как флаги будут отличаться.

    Определения:

    Certificate Authority (CA) – Доверенная третья сторона, которая подписывает
       ключи для производства сертификатов.
    User Key – Открытый ключ пользователя, который будет подписан CA для создания
       пользовательского сертификата.
    Host Key – Открытый ключ хоста, который будет подписан CA для создания
       сертификата хоста.
    User Certificate – Сертификат, сгенерированный CA из предоставленного ключа
       пользователя. Это уменьшает потребность в AuthorizedKeysFile или
       AuthorizedKeysCommand.
    Host Certificate – Сертификат, сгенерированный CA из предоставленного ключа
       хоста. Это упрощает управление known_hosts и делает этот процесс более
       безопасным.
    Principal – Средство ограничения действия сертификата определенным набором имен
       user/host. По умолчанию сгенерированные сертификаты действительны для всех
       пользователей или хостов.
    Trust – Для того чтобы выданный сертификат CA работал, серверу необходимо
       указать, чтобы он доверял CA, прежде чем он будет принимать пользовательские
       сертификаты, а клиенту нужно сказать, что он должен доверять CA, прежде
       чем он примет сертификаты хоста.
    Key Revocation List – Средство отзыва ключей и сертификатов, когда они больше
       не действительны.
    Validity Lifetime – Средство ограничения срока действия сертификата. Если
       сертификат становится недействительным после ограниченного периода времени,
       его необходимо будет повторно выдать с новым сроком действия. Это позволяет
       автоматически отзывать сертификаты в случае, если управление
       Key Revocation List упускает из виду предполагаемое удаление.
    Additional Limitations – Дополнительные ограничения могут быть применены к
       сертификатам в том же ключе, что и параметры префикса открытого ключа,
       описанные в предыдущем сообщении в блоге.

Первое, что нам нужно сделать после того, как вы настроете и защитите машину, на
которой будет установленн CA, - это добавить непривилегированного пользователя,
который будет использоваться для подписи ключей для выдачи сертификатов.

sudo groupadd -g 3000 sshca
useradd -m -u 3000 -g sshca -G sshca -c "SSH Certificate Authority Signing User" \
-s /bin/bash -d /home/sshca sshca

Теперь нам нужно построить структуру каталогов.

sudo -i -u sshca
mkdir -p {hostca,userca}

Далее нам нужно создать ключ, который будет использоваться для выдачи
сертификатов HOST.

cd hostca
ssh-keygen -t rsa -b 4096 -f host_ca -C "Host Certificate Signing Key"

Нам также необходимо создать ключ, который будет использоваться для
выдачи сертификатов USER.

cd ../userca
ssh-keygen -t rsa -b 4096 -f user_ca -C "User Certificate Signing Key"

На данный момент в каждом каталоге есть два файла. Файл закрытого ключа не
будет иметь расширения, а файл открытого ключа будет иметь расширение “.pub”.
Все сертификаты будут подписаны с использованием файла закрытого ключа, но
нам также нужен этот файл открытого ключа, поэтому не удаляйте его.

Чтобы создать TRUST, необходимый серверу для распознавания USER CERTIFICATES,
подписанного нашим CA, нам нужно отправить этот открытый ключ USER CA на каждый
хост и установить параметр конфигурации. Вы можете разместить его где угодно,
но я рекомендую создать подкаталог в каталоге /etc/ssh для хранения этих ключей.

sudo mkdir -p /etc/ssh/sshca

Затем скопируйте файл pub из CA и вставьте его в этот каталог. Отредактируйте
файл /etc/ssh/sshd_config, чтобы включить эту директиву:

TrustedUserCAKeys /etc/ssh/sshca/user_ca.pub

Перезапустите sshd (или заставьте его перезагрузить файл конфигурации), и это
доверие должно быть создано.

Чтобы воспользоваться этим доверием, для входа пользователя на сервер необходимо,
чтобы его открытый ключ был подписан USER CA. Это выдает сертификат, который
необходимо будет вернуть пользователю.

Синтаксис для подписи ключа выглядит следующим образом:

ssh-keygen -s <ca_key> -I <certificate_identity> [-h] -n <principals> -O <options> \
-V <validity_interval> -z <serial_number> <public_key_to_be_signed>

“ca_key” - это закрытый ключ для USER CA при подписании открытых ключей пользователя
   или закрытый ключ для HOST CA при подписании открытых ключей хоста.

“certificate_identity” - это “key identifier”, который регистрируется сервером,
   когда сертификат используется для аутентификации. Рекомендуется использовать
   для этого уникальный идентификатор, который распознается вашей организацией,
   поскольку вы можете настроить доверие для нескольких CAs. Для нашего примера,
   certificate_identity будет “unixseclab”.

Если это подпись HOST KEY, убедитесь, что вы включили флаг “-h”.

“principals” - это список пользователей, которые могут быть аутентифицированы с
   помощью этого USER CERTIFICATE. Кроме того, это список хостов, которые могут
   быть аутентифицированы с помощью этого HOST CERTIFICATE. Можно указать
   несколько принципалов, разделенных запятыми. Настоятельно рекомендуется
   установить в качестве субъекта имя пользователя или имя хоста сервера, для
   которого он выдан. Полная аутентификация может создать проблемы с
   криминалистикой.

“options” - это список ограничений, которые могут быть применены. Это как префиксы,
   которые мы упоминали ранее. Имейте в виду, что новейшие версии OpenSSH изменили
   одно поведение в отношении принудительных команд. Также обратите внимание, что
   “options” действительны только для USER CERTIFICATES. Вы должны были бы
   отключить “-O <options>” при выдаче HOST CERTIFICATES.

От неожиданностей:

    Начиная с OpenSSH 7.4, когда принудительная команда появляется как в сертификате,
    так и в разрешении “command=” для авторизованных ключей/принципалов, sshd теперь
    откажется принимать сертификат, если они не идентичны. Предыдущее
    (задокументированное) поведение, связанное с принудительным изменением команды
    сертификата над другим, может быть немного запутанным и подверженным ошибкам.

“validity_interval” используется для установки не только даты истечения срока действия
    выданного сертификата, но также для установки даты начала в случае, если он станет
    действительным только в будущем.

Наконец, “serial_number” - это произвольное число, которое можно назначить, чтобы
    упростить KEY REVOCATION.

Выпускаемое HOST CERTIFICATE должно находиться в том же каталоге, что и HOST KEYS.
Файл sshd_config необходимо изменить, чтобы включить новый “HostCertificate” для
каждого нового выпущенного HOST CERTIFICATE. Ключ HOST также должен все еще
существовать и иметь собственную запись “HostKey” в файле sshd_config. Не удаляйте
их в обмен на записи сертификата.

HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
HostCertificate /etc/ssh//etc/ssh/ssh_host_ecdsa_key-cert.pub

Когда сервер настроен для предоставления HOST CERTIFICATE, клиентская сторона
также должна быть настроена для TRUST CA, который его подписал. Для этого нам
нужно добавить следующую запись в пользовательский файл “known_hosts”:

@@cert-authority *.example.com <public key of the HOST CA that signed the host keys>

Может потребоваться удалить существующие записи ключей хоста в файле known_hosts
для этого хоста, если он был недавно перенесен для использования сертификатов.
Чистый способ справиться с этим - создать резервную копию ваших known_hosts,
обнулить файл и добавить только строки сертификата (вручную). Затем каждый раз,
когда вы сталкиваетесь с хостом без сертификата, вы можете сравнить предложенное
введите ваш заведомо исправный ключ в резервную копию и примите, если он подходит
для хостов, которые еще не используют сертификаты.

В следующем разделе мы рассмотрим Key Revocation Lists, проверку сертификатов и
запустим реальный пример генерации нашего исходного CA, подписи ключа хоста и
подписи ключа пользователя, а затем их использования, чтобы позволить клиенту
подключиться на сервер. 


SSH Продолжение - поддерживая CA пункт 2

На прошлой неделе мы рассмотрели большинство объяснений и команд для поддержки
SSH CA. На этой неделе мы рассмотрим Key Revocation List (KRL) и как проверить
сгенерированные сертификаты. Мы также включим демонстрацию asciinema процесса.
Давайте начнем.

Когда вы генерируете сертификат, один из флагов позволяет вам создать 'область' действия
сертификата. Это больше, чем срок действия, потому что он также включает в себя дату,
когда сертификат впервые становится действительным. Это отличный способ создания
определенных пользовательских сертификатов, поскольку вам может потребоваться
предоставить пользователю доступ только на четыре часа в выходные дни, и вы можете
выдать сертификат в течение рабочей недели, но он будет работать только тогда, когда
начальная дата/время достигнуто и перестает работать, когда достигнута дата/время
окончания.

Теперь давайте предположим, что вы выпускаете сертификаты на срок один год для
постоянных сотрудников. Сотруднику выдается свидетельство, которое вступает в силу
с первого февраля этого года, что означает, что его необходимо будет переиздать к
следующему февралю. Если сотрудник меняет рабочее место и больше не нуждается в
доступе к тем же наборам серверов, этот сертификат теперь является проблемой. У
них есть доступ к системам, которым они обладать  не должны, и необходимо отозвать
этот доступ. Для этого мы должны использовать Key Revocation List.

В нашем примере KRL создается USER CA и должен распространяться на каждый хост
при каждом обновлении. Это средство распространения очень похоже на управление
файлами authorized_keys, и означает, что оно может быть громоздким. Это, по
крайней мере, управление одним файлом, хотя это еще на один файл больше от
идеала.

Со страницы руководства sshd_config:

    RevokedKeys
    Указывает отозванный файл открытых ключей или ни один, чтобы не использовать
    его. Ключи, перечисленные в этом файле, будут отклонены для аутентификации
    с открытым ключом. Обратите внимание, что если этот файл недоступен для чтения,
    аутентификация с открытым ключом будет отклонена для всех пользователей. Ключи
    могут быть указаны в виде текстового файла с указанием одного открытого ключа
    в строке или в виде OpenSSH Key Revocation List (KRL), сгенерированного
    ssh-keygen(1). Для получения дополнительной информации об KRLs см. Раздел
    KEY REVOCATION LISTS в ssh-keygen(1).

Хорошо.  Теперь, проверим справочную страницу ssh-keygen:

    ssh-keygen умеет управлять OpenSSH format Key Revocation Lists (KRLs). В этих
       двоичных файлах указываются ключи или сертификаты, которые должны быть
       отозваны в компактном формате; для каждого сертификата требуется всего
       один бит, если они аннулируются по серийному номеру.

    serial: serial_number[–serial_number]
       Аннулирует сертификат с указанным серийным номером. Серийные числа являются
       64-битными значениями, не включая ноль, и могут быть выражены в десятичном,
       шестнадцатеричном или восьмеричном виде. Если заданы два серийных номера,
       разделенных дефисом, то анулируется весь диапазон серийных номеров, включая
       каждый из них. Ключ CA должен быть указан в командной строке ssh-keygen
       с использованием параметра -s.

Раньше мы говорили, что для KRL нужен серийный номер? Вот почему. Пользователь
генерирует свои ключи. Они посылают вам свой открытый ключ для подписи. Вы
подписываете ключ для генерации сертификата и отправляете ему сертификат. На этом
этапе нужно правильно удалить свою копию открытого ключа AND выданного сертификата.

Теперь когда у этого человек был взломана рабочая станция, ключу больше нельзя
доверять. Вы, естественно, не можете просто дождаться истечению срока действия
сертификата. У этого человека была привилегированная роль, и вы хотите, чтобы
SURE аутентификация была полностью отменена, но только для этого одного
сертификата, который был выпущен. Вам необходимо выполнить оператор KRL, но
у вас нет копии действующего сертификата или открытого ключа, который нужно
отозвать. В этом случае вам нужно отозвать по серийному номеру.

Предполагается, что серийный номер является уникальным, поэтому рекомендуется
создавать серийные номера по схеме. Вы могли бы рассмотреть что-то вроде
“a UID number + some base range” (номер UID + некоторый базовый диапазон).
Если UID пользователя равен 2352, и вы устанавливаете базовый диапазон из
четырех цифр, например, первый серийный номер будет 235320001. Этот номер будет
увеличиваться при каждой выдаче сертификата для этого пользователя. Либо
зарегистрируйте серийный номер в базе данных для каждого выданного сертификата,
чтобы его можно было быстро найти. Это, работает лучше всего.

Когда приходит время отозвать все сертификаты, которыми может обладать
пользователь (в случае нескольких действительных сертификатов), вы также
можете отозвать их с помощью ID.

Помните, что при создании сертификата флаг “-z” предназначен для установки
серийного номера, а флаг “-I” - для идентификатора. При отзыве сертификата
вы будете использовать флаг “-k”, как показано ниже:

ssh-keygen -s <ca_key> -I <certificate_identity> -u -k
ssh-keygen -s <ca_key> -z <serial_number> -u -k

Причина, по которой мы указываем флаг “-u”, заключается в том, что он заставит
обновить KRL, а не заменить его новым. Это означает, что мы случайно не удалим
другие аннулирования, которые все еще должны присутствовать.

Каковы некоторые проблемы с этим решением?

Если мы укажем серверу использовать KRL, файл должен существовать, иначе sshd
не запустится. Это означает, что там должен быть пустой файл, если сервер настроен
для указания на файл KRL, и нет пока ключей для фактического отзыва. Если системный
администратор, незнакомый с этим, удаляет файл, потому что он пуст, при попытке
очистить файлы нулевой длины в системе, sshd при следующем перезапуске не запустится.

KRL должен управляться для каждого конечного сервера. Это очень похоже на проблему
обработки отдельных файлов author_keys для каждого сервера. Причина, по которой я
специально упомянул проблему с серийным номером, состоит в том, чтобы точно
определить сценарий, в котором мы не отменяем доступ для определенного пользователя,
поскольку его больше нет, но отозвали сертификат ONE для этого пользователя из-за
нарушения.

Есть несколько способов справиться с ситуацией KRL. Вы можете создать скрипт, который
извлекает KRL с одного сайта и вставляет его в задание cron. Вы можете использовать
процесс rsync, чтобы выдавать его нескольким конечным точкам каждый раз, когда файл
обновляется. Ни один из них не идеален, но я рекомендую NOT сделать что-то, что
кажется легким, но может вызвать кошмары в крошечные часы утра в один из выходных
для какого-нибудь неудачного инженера по вызову. Обязательно укажите конфигурацию
на общий сетевой ресурс с поддержкой сети. Если бы общий ресурс выпадал, файл больше
не был бы там в глазах sshd, и, если никто не заметил, при следующем перезапуске
службы (скажем, поздним ночным автоматическим обновлением ОС) sshd отказался бы
запускаться. Вы можете рассмотреть возможность использования общего сетевого ресурса,
но используйте сценарий, который регулярно проверяет наличие файла для обновления,
прежде чем копировать его на место локально. Что бы вы ни выбрали, решение не будет
красивым.

Еще одна заметка об KRLs. Вы можете проверить наличие сертификата или ключа в
списке отзыва с флагом “-Q” для ssh-keygen.

ssh-keygen -Q -f <KRL_file> <key_or_certificate_file>

Пришло время для перехода к проверке сертификатов. Для проверки сертификата
используйте флаг ssh-keygen “-L”.

ssh-keygen -L -f <key_or_certificate_file>

Вот как выглядит пример файла:

$ ssh-keygen -Lf ./.ssh/id_rsa-cert.pub
./.ssh/id_rsa-cert.pub:
Type: ssh-rsa-cert-v01@@openssh.com user certificate
Public key: RSA-CERT 04:29:a8:fd:55:04:db:8f:1e:0d:45:18:a7:8e:a7:a6
Signing CA: RSA 27:cc:19:a3:67:1b:5e:2e:6a:48:a9:25:25:6d:64:6c
Key ID: "root"
Serial: 1234
Valid: forever
Principals:
root
Critical Options: (none)
Extensions:
permit-X11-forwarding
permit-agent-forwarding
permit-port-forwarding
permit-pty
permit-user-rc

Генерация списка отзыва ключей (KRL)

KRL - это компактный двоичный формат, который позволяет отзывать подписанные
          сертификаты SSH.

    Создать пустой список отзыва:

❯ touch /etc/ssh/revoked_keys

    Обновите /etc/ssh/sshd_config, чтобы включить новый список отзыва ключей:

❯ RevokedKeys /etc/ssh/revoked_keys

    При необходимости отозвать первый подписанный сертификат:

❯ ssh-keygen -k -f revoked_keys -s sshuser.root.ca.pub foo-cert.pub

    При необходимости добавьте больше отозванных сертификатов (используя -u):

❯ ssh-keygen -k -f revoked_keys -s sshuser.root.ca.pub -u bar-cert.pub

    Проверка, что отзыв сработал:

❯ ssh-keygen -Qf revoked_keys foo-cert.pub

    Распространите обновленный revoked_keys на каждый хост (/etc/ssh/revoked_keys)
          с помощью rsync, scp  или другой утилиты.

ПРИМЕЧАНИЕ: ssh-keygen не должен требовать подписанный публичный сертификат для
его отзыва. Вместо этого следует использовать только серийный номер. Тем не менее,
в настоящее время это не работает на OpenSSH 7.2p2 (Ubuntu).

Аутентификация SSH через пользовательские сертификаты (сервер)

Сложным аспектом безопасности является надежность и гарантия согласованности всех
мер безопасности. Вместо того чтобы полагаться на центральный орган аутентификации,
такой как LDAP или Kerberos, мы можем использовать преимущества SSH или, в частности,
OpenSSH, для обеспечения обоих составляющих.

В дополнение к аутентификации доступа клиента SSH с помощью PIV и PKCS # 11, можно
повысить безопасность удаленной аутентификации SSH. Facebook и Yahoo перешли на
SSH User Certificates, чтобы избежать блокировки, если центральная система
аутентификации выходит из строя. Это также помогает поддерживать файл author_keys,
так как это плохо масштабируется (требуется соответствие 1:1).

Центр сертификации пользователей SSH может подписывать и, таким образом, безопасно
проверять подлинность каждого клиента, подключающегося к серверу.

Подписанный сертификат также обозначает участников (учетные данные), которые можно
использовать с этим сертификатом. Для каждого пользователя принципы могут быть
описаны в файле:

❯ mkdir /etc/ssh/auth_principals
❯ echo -e 'access-root' > /etc/ssh/auth_principals/root
❯ echo -e 'access-databases' > /etc/ssh/auth_principals/foobar

В этом примере любой подписанный сертификат с принципалом 'access-root' будет разрешен
SSH вход на этот хост под именем корневого пользователя, и любой подписанный сертификат
с субъектом 'access-databases'сможет войти в систему под именем пользователя foobar.

Теперь давайте создадим центр сертификации пользователей SSH.

    Используя компьютер ,без доступа к сети, создайте центр сертификации пользователя:

❯ ssh-keygen -C "SSH User Certificate Authority" -f sshuser.root.ca

    Распространите открытый ключ (sshuser.root.ca.pub) на /etc/ssh/ на каждом хосте.
    Убедитесь, что файл chmod 644.

    Обновите /etc/ssh/sshd_config, чтобы включить новый файл CA и принципалов:

TrustedUserCAKeys /etc/ssh/sshuser.root.ca.pub
AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u

    Попросите пользователя/клиента извлечь открытый ключ из своего Yubikey, чтобы он мог
    быть подписан новым ЦС на компьютере отключенном от сети:

ssh-keygen -D /usr/local/opt/opensc/lib/pkcs11/opensc-pkcs11.so -e

    Подпишите сертификат пользователя на отключеном от сети компьютере, уделяя особое
    внимание имени пользователя (<user>), принципалам, на которые этот сертификат сможет
    претендовать (<principals>,, разделенных запятыми), сроку действия сертификата
    (+52w) и серийному номеру (<serial>,, целому числу, которое следует отслеживать):

❯ ssh-keygen -s sshuser.root.ca -I <user> -n <principals> -V +52w -z <serial> <user>.pub

Подписанный ключ пользователя foobar-cert.pub: id "foobar" serial 1928121 для access-root
действует с 2016-12-10T00:10:00 по 2017-12-09T00:10:10

    Подтвердите, что сертификат пользователя выглядит хорошо:

❯ ssh-keygen -Lf <user>-cert.pub

user-cert.pub:
    Type: ssh-rsa-cert-v01@@openssh.com user certificate
    Public key: RSA-CERT SHA256:NWmw3siRlxn3bsIhzaFrCsh66KKIWapFuZsNiDXhRLw
    Signing CA: RSA SHA256:HLD1Eb4XiCoyXew23skyisJt+3P02MOsrHHbK/DmlgY
    Key ID: "foobar"
    Serial: 1928121
    Valid: from 2016-12-10T00:10:00 to 2017-12-09T00:10:10
    Principals:
            access-root
    Critical Options: (none)
    Extensions:
            permit-X11-forwarding
            permit-agent-forwarding
            permit-port-forwarding
            permit-pty
            permit-user-rc

    Скопируйте <user>-cert.pub в каталог клиента ~/.ssh и назовите его
    id_rsa-cert.pub. Название довольно специфично, так как кажется, что
    opensc-pkcs11 имеет ограничение для обнаружения сертификата,
    отличного от id_rsa-cert.pub.
@c****************************************
SSH от начала до конца - Основы центра сертификации	
SSH Start to Finish Architecture – AuthorizedKeysCommand

В прошлом разделе мы кратко остановились на этом, но в этом разработан сценарий
для углубления в детали.

Итак, чтобы установить это, в настоящее время задействованы три системы.
1) Ноутбук Windows 10 с опцией “ubuntu on windows 10 on crack”. Используя оболочку
   bash, я создал пару ключей ssh ​​и остановился там, пока все остальное не было готово.
2) Система “target” для входа в систему. Это сервер OpenBSD, на котором я поиграл с
   asciinema ранее в эти выходные и решил использовать его для этой конкретной лаборатории.
   Это машина, которая будет настроена на использование AuthorizedKeysCommand и
   AuthorizedKeysCommandUser вместо AuthorizedKeysFile. На этом сервере я создал две
   новые группы и двух новых пользователей:
groupadd testgrp
groupadd sshpub
useradd -m -g testgrp -G testgrp -c “Test User” -s /bin/ksh -d /home/testuser testuser
useradd -m -g sshpub -G sshpub -c “SSH Public Key Provider” \
-s /bin/ksh -d /home/sshpub sshpub

Я также создал новый скрипт: /usr/local/bin/query_ssh_pub.ksh с разрешениями 750 и
принадлежащий root:sshpub.
##############################################################################
#!/bin/ksh

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
HOSTNAME=$(hostname -s)
USER=${1}
ssh -i ~sshpub/.ssh/id_rsa sshpub@192.168.0.89 “/usr/local/bin/query_ssh_pub_keys.ksh \
${USER} ${HOSTNAME}”
##############################################################################

3) Система “query server” будет центральным хранилищем ключей ssh ​​для системных
учетных записей и/или пользователей (гипотетически). Я создал того же пользователя
и группу sshpub в этой системе, но добавил новый скрипт:
/usr/local/bin/query_ssh_pub_keys.ksh с разрешениями 750 и также принадлежащий
root:sshpub.
##############################################################################
#!/bin/ksh
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

if [ $# -ne 2 ]; then
exit 255
fi

USER=${1}
TARGET=${2}

echo ${USER} | grep -q -E -e ‘^[a-zA-Z0-9]+$’ || exit 255
echo ${TARGET} | grep -q -E -e ‘^[a-zA-Z0-9]+$’ || exit 255

ls /home/sshpub/key-store/ | grep -q “^${TARGET}\.${USER}\.pub\$” || exit 255
cat /home/sshpub/key-store/${TARGET}.${USER}.pub
##############################################################################

Я сгенерировал пару ключей ssh ​​из sshpub на сервере “TARGET”, а затем скопировал
файл открытого ключа на сервер “QUERY”, чтобы он мог выполнять удаленный вызов ssh. Если
бы я собирался использовать систему, подобную этой, в производстве, я бы применил еще
несколько проверок работоспособности ко всем входам, а также рассмотрел бы принудительную
команду для этого пользователя либо с помощью sshd_config, либо путем изменения файла
открытого ключа, но это ни тут ни там не используется. Это не идеальный способ получения
ключей, но он демонстрирует, как это работает простым способом.

Когда все было готово, я поместил копию открытого ключа с ноутбука “CLIENT” в файл
/home/sshpub/key-store/asciicast.testuser.pub на сервере “QUERY”, а затем проверил, что
все команды работают должным образом.

Наконец, я обновил sshd_config, чтобы использовать следующие записи на сервере “TARGET”,
и перезапустил sshd:
AuthorizedKeysCommand /usr/local/bin/query_ssh_pub.ksh
AuthorizedKeysCommandUser sshpub

После того, как все это было сделано, я смог проверить, могу ли я войти в систему как
“testuser” на машину “TARGET”, и он успешно получил открытый ключ с машины “QUERY”,
разрешив вход в систему, как и ожидалось.

Сценарий запроса может вызвать любую службу, правда. Вы можете вызывать ключи,
хранящиеся в LDAP, SQL или любой другой базе данных. Окончательный результат,
возвращаемый скриптом, должен содержать ноль или более открытых ключей, и ничего
более. Чаще всего это делается для запроса к LDAP, и есть примеры файла LDIF для
OpenLDAP, свободно распространяющегося в Интернете, если вы решите пойти по этому пути.
Просто убедитесь, что ваш LDIF работает для вашей конкретной службы LDAP, и что вы
можете санировать вывод, чтобы только представить ключи в конце, когда вы запрашиваете.

SSH Start to Finish Architecture – Работа с распределением ключей

Это будет краткий пост с не таким большим содержанием, но он объяснит,
куда мы идем отсюда.

Одним из самых больших преимуществ SSH является дополнительный уровень шифрования,
который он обеспечивает. Вторым важным преимуществом является отсутствие необходимости
в пароле. Пароли могут быть заменены парольными фразами, что помогает сделать его еще
более безопасным. Однако существует риск, связанный с типом файлов vanilla
authorized_keys.

Открытые ключи должны быть управляемыми. Что это значит? Открытый ключ должен быть
предоставлен соответствующим файлам authorized_keys вручную для каждого пользователя,
который использует преимущества этой системы. Когда пользователю требуется отозвать
доступ, файлы authorized_keys также должны быть проанализированы, чтобы убедиться,
в отсутствии записи ключа, к которому у этого пользователя больше нет доступа. Когда
вы удаляете пользователя из рабочей среды, его собственные файлы учетной записи
пользователя authorized_keys удаляются вместе с домашним каталогом, если вы используете
стандартную команду “userdel -r ”. Однако, если у них есть ключи для доступа к общей
учетной записи службы, такой как www, apache или аналогичная, необходимо выполнить
дополнительные шаги для проверки каждой системы, где может существовать этот ключ.

Это может быть выполнено с помощью чего-то вроде puppet, chef или одного из других
распространенных инструментов управления типами обеспечения и конфигурации, или это
может быть сделано с помощью чего-то такого же простого, как распределенная проверка
ssh (dsh), но наличие нескольких файлов является кошмаром обеспечения , Предположим,
что система отключена, когда пользователь отключен. Без решения по управлению
конфигурацией/управлению доступом к учетным записям ваши ручные проверки могут
пропустить единственный ключ, всплывающий в файле author_keys.

Так как мы справимся с этим? Есть несколько способов, и они не все включают инструменты
управления конфигурацией. Один из способов справиться с этим - использовать опцию
“AuthorizedKeysCommand” в sshd_config. Для его использования требуется второй параметр
(“AuthorizedKeysCommandUser”). Они позволяют вам установить скрипт, вызываемый
(мы надеемся) непривилегированным пользователем, который может запросить некоторую
службу для получения ключа для данного пользователя. Это может быть LDAP, SQL, плоский
файл на удаленной машине ... все, что возвращает ожидаемые результаты. Мы рассмотрим
это более подробно в следующем разделе.

Другой вариант - настроить Certificate Authority для OpenSSH и подписать открытые
ключи вашего пользователя. Для обеспечения, это не требует инструмента управления
конфигурацией/управления доступом, но для отмены подготовки, это может произойти.
Тем не менее, вы можете автоматизировать это удаление по расписанию, чтобы избежать
решения CF/IAM, и мы рассмотрим такие настройки, когда перейдем к обзору
Certificate Authority через несколько разделов.

В идеале вы могли бы рассмотреть возможность объединения этих методов в конце,
но мы сначала представим их как отдельные принципы и методы управления ключами.


SSH Start to Finish Architecture – Работа с запаздывающими сетями

Один из аспектов серверов и клиентов, которые общаются друг с другом по сети, которая
иногда требует обработки, - как сохранить соединение открытым. Иногда сеть ненадежна
из-за отсутствия лучшего термина, и это означает, что пакеты могут быть отброшены.
OpenSSH не является исключением, и у него есть несколько опций, которые можно установить
в файлах sshd_config, ssh_config, и локальных ~/.ssh/config, чтобы помочь определить,
как обрабатывать такие случаи.

И сервер, и клиент совместно используют опцию “TCPKeepAlive”. Этот параметр определяет,
следует ли отправлять сообщения поддержки активности TCP. Это помогает завершить
соединение в случае сбоя клиента или сервера, но может быть проблематичным в сети,
которая имеет значительную задержку. Однако, если он не установлен, это может означать,
что в пуле подключений к серверу может быть много пользователей-призраков, поэтому
рекомендуется включить его, если сеть не очень плохая. Возможные варианты: “yes” или
“no”, в зависимости от того, включен он или нет.

Есть также “ClientAliveCountMax” (sshd_config) и “ServerAliveCountMax”
(ssh_config and ~/.ssh/config). Они устанавливают количество живых сообщений,
которые могут быть отправлены без получения клиентом или сервером ответа от
кореспондента. Эти сообщения отличаются от сообщений TCPKeepAlive. Живые сообщения
отправляются через зашифрованный канал и, следовательно, не могут быть подделаны. С
другой стороны, сообщения поддержки активности TCP могут быть подделаны, так что это
может быть лучшим вариантом в более (потенциально) враждебной среде. Этот параметр
является числом, и по умолчанию используется значение “3”. Помните, что это COUNT,
который считает количество раз, когда сообщение будет отправлено до завершения
сеанса из-за отсутствия ответа на другом конце.

Другая переменная, необходимая для работы вышеупомянутого, - это
“ClientAliveInterval” (sshd_config) и
“ServerAliveInterval” (ssh_config and ~/.ssh/config.). Они определяют количество
секунд между отправляемыми сообщениями. По умолчанию используется “0”, что означает,
что ничего не отправлено, поэтому вы должны задать для этого значение больше 0,
чтобы включить эту опцию. Если для этого значения установлено значение “5” на
обоих концах, а для максимального числа активных пользователей по умолчанию
установлено значение “3,”, то соединение будет прервано через 15 секунд, если
сообщения не получат ответ.

Помимо параметров TCPKeepAlive и *AliveCountMax и *AliveInterval, есть также
параметр, определяющий, как долго ждать успешного входа пользователя. Чтобы люди
не могли выполнить первоначальное рукопожатие по ssh-запросу, но не входить и не
связывать сокет. , это может быть установлено, и этот пользователь будет удален
через указанное количество времени. Значение по умолчанию составляет 120 секунд,
но если вам это вообще не нужно, вы можете изменить его на 0, чтобы отключить его,
как и параметры *AliveInterval.

SSH Start to Finish Architecture – X11 Forwarding

X11 - это протокол client/server, который означает, что вы можете запускать программное
обеспечение на одном компьютере и отображать его графический вывод на другом. Он также
имеет некоторые риски для безопасности, поэтому распространенным способом снижения
некоторых из этих рисков является предоставление SSH возможности пересылать клиентское
соединение X11 на локальный сервер X11 при запуске клиента в удаленной системе.

Для некоторых это кажется обратным, но вы запускаете сервер на своей рабочей станции
и запускаете удаленную графическую команду как клиент, который обращается к вашему
серверу. Сервер генерирует графику от имени клиента. Если вы работаете на рабочей
станции с Linux, производной BSD или чем-то вроде одной из вилок OpenSolaris, вы,
вероятно, уже используете X11 для своих настольных ПК. Мы сделаем предположение,
что вы используете этот процесс.

Чтобы выполнить пересылку X11, необходимо настроить удаленный сервер, чтобы разрешить
такую ​​пересылку. Имеют значение следующие параметры: “X11Forwarding yes” для включения
пересылки, “X11DisplayOffset 10” (default) для определения смещения для дисплея, который
будет использоваться, “X11UseLocalhost loopback” (default) для указания sshd связать
сервер пересылки с устройством обратной связи и
“XAuthLocation /usr/X11R6/bin/xauth” (default), если необходимо указать путь к
программе xauth, потому что она не находится по умолчанию в вашей системе.

Может случиться так, что единственной настройкой, которую вам нужно настроить,
является “X11Forwarding” от “no” до “yes” в вашей целевой системе.

После этого вы можете подключиться к целевой системе, передав флаги -X или -Y
клиенту ssh. Флаг -X применяет параметры ForwardX11Trusted для клиента ssh, которые
устанавливают более строгие ограничения на использование пересылки X11, а также
устанавливает 20-минутный таймер истечения срока действия для токена xauth. Флаг -Y
не устанавливает эти ограничения. Вам решать, какой флаг вы хотите использовать.

После подключения вы можете проверить, правильно ли настроена ваша среда. У вас должен
быть файл “.Xauthority” в вашем домашнем каталоге, и у вас должна быть уже установлена 
переменная окружения под названием ${DISPLAY}, которая, вероятно, должна отображать
“localhost:10.0”, когда вы выводите его.
ls -ld .Xauthority
echo ${DISPLAY}

После того как вы подтвердите это, вы можете проверить свою переадресацию с помощью
чего-то простого, например, xeyes или xclock, если они установлены на целевой машине.
Если нет, попробуйте любую программу X11, которую вы намеревались запустить. Вы должны
увидеть, как программа появится на вашем рабочем столе, как только вы это сделаете.

Наконец, если вам нужно запустить программу X11 от имени другого пользователя, вы
можете использовать команду xauth, чтобы объединить ваши токены .Xauthority с
окружением другого пользователя, а затем переключиться на этого пользователя для
запуска вашей команды. Вам нужно будет извлечь токен xauth для вашего DISPLAY и
объединить его для среды другого пользователя. Стандартный способ сделать это с
помощью “xauth extract”, переданного по каналу «xauth merge», как показано в полном
примере сеанса ниже.

ssh -Y User_A@Server_B
ls -ld .Xauthority
echo ${DISPLAY}
xclock
xauth extract – ${DISPLAY} | sudo -i -u User_B xauth merge –
#OR xauth extract – ${DISPLAY} | sudo su – User_B xauth merge –
sudo -i -u User_B #(или sudo su – User_B)
echo ${DISPLAY} #(Может потребоваться вручную установить это на то, что вы дали при входе в систему)
xclock

Конфигурация клиента имеет несколько настроек, чтобы всегда или никогда не устанавливать
это для вас. Вероятно, они должны быть установлены в блоках Match только для серверов,
на которых вам нужно регулярно запускать программы X, и не устанавливаться вообще.

ForwardX11 yes/no
ForwardX11Trusted yes/no
ForwardX11Timeout
XAuthLocation #как sshd_config

Формат времени будет числом, за которым следует блок модификатора. “S” или “s” для секунд.
“M” или “m” для минут и так далее вплоть до недель. По умолчанию если не указана ни одна
единица подразумевает секунды.

Вы можете использовать команды xauth, чтобы удалить свои токены вручную, когда вы
закончите, выполнив “xauth remove ${DISPLAY}”, если пожелаете.

Надеюсь, это помогло пролить некоторый свет на то, как заставить X11 Forwarding работать
от простого к сложному сценарию. Это один из наиболее часто задаваемых вопросов, которые
у меня были в прошлом, и я сожалею, что он не был рассмотрен раньше.

SSH Start to Finish Architecture – Принудительные команды

В прошлых разделах мы рассмотрели параметры ключа SSH, которые могут ограничивать
использование закрытого ключа для подключения к серверу. Одной из этих опций была
опция “command=”, которая позволяет ограничить ключ вызовом только одной команды,
независимо от команды, выданной как часть попытки соединения ssh. Есть несколько
способов обеспечить это.

Вы можете использовать опцию открытого ключа “command=”, которую мы уже рассмотрели.
Вы также можете использовать настройки sshd_config для применения опции ForceCommand.
Это наиболее полезно для применения того же сценария принудительной команды, который мы
описали в прошлом разделе с помощью директивы “Match User”. Это также полезно для
применения ситуации только с sftp к данному пользователю, так что единственное, что может
сделать пользователь, - это передать файлы. Опция будет выглядеть так, если это ваша цель:

ForceCommand internal-sftp

Оболочка пользователя должна быть действительной, чтобы это работало, поскольку
принудительная команда вызывается через “ -c”. Это означает, что оболочка
/bin/false или /bin/nologin не нужна. Поскольку вы заставляете команду, это
должно быть меньшей проблемой.

Наконец, есть также способ заставить эту команду с помощью параметров ssh-keygen при
подписании ключа через систему центра сертификации для OpenSSH, но мы более подробно
расскажем об этом, когда перейдем к материалу CA.

Параметры принудительной команды не позволяют запускать пользовательский ~/.ssh/rc, так
что это не будет обходной путь, который пользователь может использовать для взлома этой
системы. ControlMaster переопределяет команду принудительного использования открытого
ключа, если опция установлена ​​после того, как основной сеанс уже установлен, поэтому вам
может потребоваться прервать все соединения ssh для этого пользователя после внесения
изменений, которые вводят ограничения, и двигаться вперед.

Многие люди ворчат о параметрах принудительных команд, потому что считают, что для
каждой передаваемой команды необходим один ключ, но на самом деле есть средства для
обработки этого. Существует переменная окружения, которая устанавливается, когда сеанс
ssh, который хочет вызвать удаленную команду, используется для подключения, пока для
пользователя используется принудительная команда. Эта переменная окружения -
SSH_ORIGINAL_COMMAND, и она сохраняет запрошенную команду. Это означает, что у вас
может быть скрипт-обертка, который является вашей принудительной командой, он должен
проверить эту переменную среды на предмет работоспособности (все ли команды в списке
представлены в нашем белом списке или нет? Если нет, запишите отклонение и прекратите
работу. Если так , зарегистрируйте вызов и выполните.) Переменная сбрасывается, если
пользователь просто пытается войти в ssh, не вызывая удаленную команду, поэтому
обязательно проверьте это, если вы идете по этому пути. Предположим, что переменная
unset/empty (не установлена ​​/ пуста), что они пытались войти в систему для интерактивного
сеанса, и обработать, как вы считаете, лучше. Я бы предположил, что
“log a rejection and terminate” (зарегистрируйте отклонение и завершение) лучше,
хотя, поскольку интерактивный сеанс не может быть должным образом ограничен без
ограниченной оболочки, который все равно может быть поврежден из-за джейла в случае
неправильной настройки. Ваши собственные потребности могут отличаться. Просто будьте
очень тщательны в своем дизайне и убедитесь, что все входные данные очищены перед
выполнением, и все будет в порядке.

Начало работы SSH до завершения архитектуры - параметры открытого ключа

Поскольку мы представили несколько способов туннелирования, я подумал, что сейчас
самое время рассказать о некоторых способах ограничения действий пользователя в случае,
если у него есть доступ к закрытому ключу, которого быть не должно.

Мы уже говорили об установке парольной фразы на стороне закрытого ключа, но все еще
существует вероятность того, что пользователь смог это сделать грубо, поэтому предположим,
что у него есть доступ к этому секретному ключу. Какие у нас есть варианты для обеспечения
безопасности?

Для начала, мы можем ограничить, из каких исходных имен IP/DNS может прийти пользователь,
используя этот ключ. Если мы изменим запись открытого ключа в файле author_keys для
включения директивы “from” до запуска ключа, мы можем предоставить список
IP addresses/hostnames, от которого мы ожидаем. Это предотвращает атаку с рабочей
станции пользователя, например. Одним из предостережений этого является то, что вы не
можете использовать источник NAT, так как это снизит эффективность этого ограничения.
Каждый, кто входит в коробку из источника NAT VLAN или подсети, выглядит так, как будто
он пришел из одного места.

Чтобы установить эту директиву, нам нужно изменить открытый ключ вручную. Лучше
изменить открытый ключ перед добавлением его в файл authorized_keys, но вы можете
изменить запись файла authorized_keys для этого ключа, если хотите.

To use this directive, we need to put the a ##@“from”@## option with all of its values, comma separated, ##@BEFORE@## the key starts. An example of how this might look follows:

   from=”172.16.84.1,lanturtle,lanturtle.mydomain” ssh-rsa AAAA User_A@@lanturtle

Теперь предположим, что вы также хотите запретить проксирование с помощью этого ключа.
Чтобы ограничить это, нам нужно установить несколько параметров:

no-X11-forwarding – Предотвращает пересылку сеансов X11 обратно на X-сервер через
   туннель SSH.
no-port-forwarding – Предотвращает переадресацию портов через устройства TCP, TUN и
   прямое проксирование через stdin.
no-agent-forwarding – Предотвращает “forwarding” ssh-агента для обработки закрытого ключа.

Чтобы добавить их в приведенный выше пример, мы будем использовать список параметров,
разделенных запятыми:
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding, \
    no-port-forwarding,no-agent-forwarding ssh-rsa AAAA User_A@@lanturtle

Мы можем дополнительно ограничить это только разрешением использования этого конкретного
ключа для выполнения определенной команды. Это игнорирует любые команды, переданные
пользователем при подключении, и не дает пользователю получить полную оболочку входа
(если это не принудительная команда).
command=”/usr/local/bin/ssh-restricted-command.sh” (где
   “/usr/local/bin/ssh-restricted-command.sh” это команда, которую вы хотите запустить.
   Введите фактическую команду, которую вы хотите использовать, здесь.)
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding,no-port-forwarding, \
   no-agent-forwarding,command=”/usr/local/bin/ssh-restricted-command.sh” ssh-rsa  \
   AAAA User_A@@lanturtle

Наконец, если мы хотим быть уверены, что в файле .ssh/rc пользователя нет наземной
мины, мы можем запретить ее чтение, используя следующую опцию:
no-user-rc
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding,no-port-forwarding, \
   no-agent-forwarding,no-user-rc,command=”/usr/local/bin/ssh-restricted-command.sh” \
   ssh-rsa AAAA User_A@@lanturtle

Когда мы перейдем к управлению центром сертификации, вы обнаружите, что ssh-keygen может
установить эти параметры для ключей, связанных с сертификатами, но имена параметров
немного отличаются. К сожалению, использование ssh-keygen для генерации начального
открытого/закрытого ключа с этими параметрами не работает. Работает только на
сертификатах. Однако изменение записи открытого ключа вручную ограничивает это.

Начало SSH до завершения архитектуры - туннелирование IP с устройством TUN

Мы рассмотрели различные  tunneling/proxy  (туннелирование/прокси) возможности OpenSSH
для туннелирования TCP и настройки прокси портов, но флаг “-w” может позволить вам
пересылать IP-трафик. Это происходит путем создания временного устройства “tun” при
подключении по SSH, которое можно настроить как любой сетевой интерфейс с помощью
стандартных инструментов, таких как “ifconfig”. Должно произойти некоторое последующее
установление соединения, включая изменение информации таблицы маршрутов, поэтому
относитесь к этому как к нормальному и правильному решению VPN. Вот что это значит.
Решение VPN, встроенное в клиентское и серверное программное обеспечение SSH. Я сделаю
правильную запись с лабораторией и примерами позже. А пока знайте, что на сервере
должна быть установлена ​​опция “PermitTunnel”, и для нее должно быть установлено
значение, отличное от “no”, которое является значением по умолчанию.

Варианты:
point-to-point – Это позволяет настраивать туннельное устройство уровня 3.
ethernet – Это позволяет настроить туннельное устройство уровня 2.
yes – Это позволяет настроить любой тип устройства.

При подключении к серверу необходимо передать флаг “-w” и указать идентификатор
устройства tun. Вы также можете указать идентификатор устройства удаленной настройки.
Если вы не предоставляете удаленный идентификатор, по умолчанию используется “any”,
который предоставляет следующий доступный. Вы также можете указать “any” для
идентификатора локального устройства настройки.

В следующем примере настраивается определенный “tun0” как на локальной, так и на
удаленной стороне.
ssh -w 0:0 User_B@@Server_B

Далее будет настроено устройство “tun” с использованием следующего доступного ID как
на локальной, так и на удаленной сторонах.
ssh -w any:any User_B@@Server_B

Следующие действия сделают то же, что и в примере выше, но сохранят значение,
необходимое для ввода 4 символов.
ssh -w any User_B@@Server_B

Просто настроить их будет недостаточно. Разумеется, вам также потребуется настроить
информацию routes/interface (маршруты/интерфейс). Вам также нужно будет настроить
все правила трафика для бастионного хоста (локального брандмауэра), если вы его
используете. Лучшее объяснение этому я нашел здесь:
Daemon Forums

SSH Start to Finish Architecture – TCP Forwarding of STDIN/STDOUT

В предыдущем разделе мы рассмотрели стандартные флаги перенаправления TCP: -L, -R, и -D.

Я явно воздержался от показа -W и -w, потому что чувствовал, что они заслуживают
отдельного освещения.

Мы рассмотрим -w (работа с туннельными устройствами) в следующем разделе. Сейчас все о -W.
Прежде чем мы продолжим, вы должны заметить, что одна из моих публикаций в среду была
кратким обзором семейства инструментов netcat. Если вы думаете о “-W :” как о встроенном
netcat для ssh, вы довольно быстро поймете силу этого флага. Наиболее распространенный
пример использования этого флага - использование опции ProxyCommand для вызова SSH с
использованием Jumphost и передачи этого флага этому хосту. Старый способ использования
ProxyCommand таким способом заключался в том, чтобы фактически вызывать netcat в качестве
команды удаленного прокси-сервера, например так:

ssh -o ProxyCommand=’ssh jumphost netcat target_server 22′ target_server

Или, если “Server_B” является нашим прыжковым хостом, и мы действительно хотим
использовать “Server_A”, используя “Server_B” в качестве прокси, мы сделаем это
следующим образом:
ssh -o ProxyCommand=’ssh Server_B netcat Server_A 22′ Server_A

Это было все хорошо, если netcat был фактически установлен, но иногда это не так. К
счастью, SSH имеет свой собственный встроенный тип netcat через флаг -W. Чтобы сделать
то же самое, что и выше, мы бы сделали это вместо этого:
ssh -o ProxyCommand=”ssh -W %h:%p Server_B” Server_A

Это короче, чище и не зависит от netcat в прокси-сервере перехода. Теперь давайте
сделаем еще один шаг вперед. Предположим, вы хотите перетащить страницу вниз с помощью
командной строки и хотите прокси через Server_B, чтобы получить эту страницу из Server_A.

echo “GET /some/page.html” | ssh -W Server_A:80 Server_B >page.html

Почему вы можете захотеть сделать это? Если у вас нет прямого маршрута к Server_A на
этом порту, но вы можете получить доступ к Server_B через SSH, и ИТ-отдел имеет доступ к
Server_A на этом порту, у вас есть быстрый и грязный временный прокси.

Давайте на минуту отложим этот мыслительный процесс и подумаем о том, сколько людей
пытаются заблокировать локальные учетные записи (хранящиеся в /etc/passwd.) Многие люди
будут предоставлять учетную запись процесса “/bin/false” как “shell”, чтобы предотвратить
вход в оболочку. Однако, если вы никогда не пытаетесь получить оболочку с этой учетной
записью, вы можете использовать эту учетную запись для прокси в течение всего дня с
настройками по умолчанию sshd_config. Если вы хотите отключить эту функцию (и вы должны
учитывать ее по причинам, указанным выше), вы должны установить для AllowTCPForwarding
значение “no” в файле sshd_config и перезапустить sshd.

Сейчас в социальных сетях витает разговор о ботнете Internet of Things, который недавно
снял блог Кребса. Один из поставщиков безопасности предположил, что атака, которую они
называют “SSHowDowN”, и этот вид функциональности - именно то, на что они ссылаются.

Подобные вещи действительно хороши, когда используются правильно, но они также опасны
для того, чтобы пробить дыры в списках контроля доступа маршрутизатора и
межсетевого экрана.

SSH - начало до конца архитектуры - туннелирование TCP

Одним из значительных преимуществ SSH является возможность создания перенаправлений
переадресации портов для временного доступа к системе, которая в противном случае не
смогла бы получить доступ к машине. Это действительно легко настроить, и он работает
довольно хорошо для многих сценариев, но недостатком этого является то, что… это
действительно легко настроить и работает довольно хорошо для многих сценариев, для
которых вы можете не использовать его. Это можно использовать, чтобы пробить дыры в
правилах брандмауэра, и это может привести вас к горячим отношениям с не теми людьми,
поэтому убедитесь, что вы понимаете свою корпоративную политику, прежде чем пытаться
использовать что-то подобное на работе.

SSH обеспечивает несколько видов переадресации портов TCP, поэтому мы рассмотрим их
по одному. На этот раз мы НЕ будем рассматривать туннелирование устройств “TUN” через
флаг -w. Это будет рассмотрено позже.
В этот раз мы также НЕ будем рассматривать стандартную переадресацию ввода/вывода через
флаг -W. Это будет только охватывать пересылку TCP.

Первый тип пересылки TCP, который мы рассмотрим, это Dynamic Port Forwarding
(используя SOCKS4/SOCKS5 протокол). Флаг для этого - -D и принимает необязательный
“bind_address” и требуемый “port”, который будет передан ему.
-D [bind_address:]port

Это создает прослушивающий сокет локально на предоставленном порту и, необязательно,
заданный адрес bind_address, который будет действовать как прокси-сервер уровня
приложения SOCKS4 / SOCKS5. Лучше всего настроить это на привязку к localhost, а затем
использовать один из других параметров туннелирования, чтобы указать на него, чтобы
защитить прокси от пользователей, которым вы не хотите его использовать. Конечно, любой,
кто может получить доступ к машине через ssh, сможет использовать это, так что будьте
внимательны с тем, где вы его настроили. Любое приложение, поддерживающее SOCKS, может
воспользоваться этим, если оно может подключаться к порту прослушивания.

Следующие два параметра на самом деле одно и то же, но один настраивает порт прослушивания
на локальном (клиентском) компьютере, а другой настраивает порт прослушивания на удаленном
(серверном) компьютере. Флаги -L и -R соответственно.

-L [bind_address:]port:host:hostport
-R [bind_address:]port:host:hostport

Если вы хотите перенаправить локальный (клиентский) прослушивающий порт на удаленный
компьютер, используйте “L” для “local”.
Если вы хотите перенаправить удаленный (серверный) прослушивающий порт на клиентский
компьютер, используйте “R” для “remote”.

Другими словами, этот “listening port” связан локально или удаленно и является одним
концом туннеля. “host” и “hostport” не обязательно совпадают с целевым сервером, к
которому вы подключаетесь через SSH. Они просто должны быть хостом и портом, к
которому удаленная система может фактически добраться.

“-L 8080:example.com:80” связывает локальный порт 8080 с клиентом, когда он устанавливает
соединение с удаленным ssh-сервером. Затем удаленный ssh-сервер связывает соединение с
портом 80 на example.com на его конце. Оттуда вы сможете локально подключиться к порту
8080 на своей клиентской машине и подключиться к этому удаленному серверу example.com
через его порт 80, все через туннель через ssh на сервер ssh.

“-R 2222:localhost:22” создаст прослушивающую привязку “localhost” к порту 2222 на
удаленном сервере, который указывает на порт 22 на локальном клиенте. Если вы
подключитесь к этому вне вашей сети, это позволит людям вне сети подключаться по ssh с
этой удаленной машины, если они имеют правильные учетные данные.

Все эти опции, как указано, создают оболочку при входе в систему. Вы можете установить
JUST туннель, используя опции “-N” “-T” и “-f”.

“-N” говорит не вызывать удаленную команду, просто установить туннели.
“-T” говорит не устанавливать псевдо-TTY (PTY) терминал, что подходит, так как вы
     не передаете никаких команд.
“-f” говорит SSH работать в фоне, так как вы, вероятно, хотите сделать больше работы
     после установления сеанса.

ssh -fNT -L localhost:8080:google.com:80 User_B@@jumphost

Это говорит фоновому SSH после установки туннеля и не выделяет PTY. Установите
туннель с локально связанным портом 8080, и пусть удаленный ssh-сервер “jumphost”
установит туннель к “google.com” на порту 80. Подключитесь как User_B к ssh-серверу.

Вы можете проверить с помощью “netstat -an | grep LISTEN”, есть ли у вас прослушивающий
порт 8080 после установки этого. Вы можете протестировать туннель с помощью netcat или
telnet к localhost через порт 8080 и ввести “GET /”, а затем нажать Enter. Возможно, вам
придется нажать Enter дважды, в некоторых случаях. Вам придется заменить “User_B” и
“jumphost” на реальную систему, к которой у вас есть доступ, которая также имеет доступ
к Интернету, конечно.

SSH - начало до конца архитектуры - поток подключения

Прежде чем мы перейдем к более сложным вещам с настройкой SSH, я подумал, что нам
следует взглянуть на то, что на самом деле происходит, когда клиент подключается к
серверу OpenSSH, и что такое дерево решений для предоставления или не предоставления
доступа.

Со страниц руководства sshd:
Когда пользователь успешно входит в систему, sshd делает следующее:
1. Если для входа используется tty, а команда не указана, печатается время последнего
   входа и /etc/motd (если это не запрещено в файле конфигурации или с помощью
   ~/.hushlogin; см. Раздел FILES).
~/.hushlogin
   Этот файл используется для подавления печати времени последнего входа в систему и
   /etc/motd, если PrintLastLog и PrintMotd, соответственно, включены. Он не подавляет
   печать баннера, указанного в Banner.
2. Если логин на tty, записывает время входа.
3. Проверяет /etc/nologin; если он существует, печатает содержимое и выходит (если не root).
4. Изменения для запуска с правами обычного пользователя.
5. Устанавливает основную среду.
6. Читает файл ~/.ssh/environment, если он существует, и пользователям разрешено
   изменять свою среду. Смотрите опцию PermitUserEnvironment в sshd_config(5).
~/.ssh/environment
   Этот файл считывается в среду при входе в систему (если он существует). Он может
   содержать только пустые строки, строки комментариев (начинающиеся с ‘#’) и строки
   присваивания в форме name=value (name = value). Файл должен быть доступен для записи
   только пользователю; это не должно быть доступно для чтения кем-либо еще. Обработка
   среды по умолчанию отключена и управляется с помощью опции PermitUserEnvironment.
7. Изменения в домашнем каталоге пользователя.
8. Если ~/.ssh/rc существует, запускает его; иначе, если /etc/ssh/sshrc существует,
   запускает его; в противном случае работает Xauth. Файлы “rc” получают протокол
   аутентификации X11 и cookie при стандартном вводе. Смотрите SSHRC ниже.
~/.ssh/rc
   Содержит процедуры инициализации, которые должны быть выполнены до того, как домашний
   каталог пользователя станет доступным. Этот файл должен быть доступен для записи только
   пользователю, и не должен быть доступен для чтения кем-либо еще.
9. Запускает пользовательскую оболочку или команду.

Итак, из вышесказанного мы можем увидеть еще несколько способов управления нашим
клиентским подключением и что он выводит при подключении. Раньше мы рассмотрели
“LogLevel QUIET” в файле ~/.ssh/config, но мы также можем воспользоваться файлом
“.hushlogin” для подавления некоторой информации.

Мы также видим, что логин регистрируется, только если есть связанный TTY. Это важно
помнить для судебно-медицинской экспертизы.

Мы можем временно отключить вход в систему с SSH (отличным от root), создав файл
/etc/nologin, и содержимое этого файла будет отображаться при отклонении попытки
подключения. Это опасно, если у вас нет доступа к консоли, поэтому будьте осторожны с этим.

Служба отбрасывает привилегии и устанавливает базовую среду, затем настраивает ее из
файла ~/.ssh/environment, если он существует, и пользователям разрешается изменять свою
среду. Поведение по умолчанию запрещает это, но это нужно проверить при блокировке ваших
систем. Наконец, он переходит в домашний каталог пользователя, чтобы завершить подготовку
среды.

Затем он читает и автоматически запускает файл ~/.ssh/rc, если он существует. Это также
важно знать для судебной экспертизы и для блокировки вашей системы. Это отличное место
для того, чтобы отказаться от постоянного недостоверного сценария, поэтому его стоит
поискать и просмотреть.

Наконец, он запускает оболочку или любую команду, которая была запрошена. Кажется
довольно просто, верно? Ну, man-страницы на этом заканчиваются.

Таким образом, с точки зрения защиты, мы хотим рассмотреть больше, чем просто файлы
~/.ssh/{config,authorized_keys,authorized_keys2,known_hosts}. Мы также хотим посмотреть
на любые файлы rc и environment в этом каталоге. Это особенно верно для пользователя root.

SSH - Начало до конца Архитектура - Клиент Config Pt. 1

На этой неделе мы сосредоточимся на файлах конфигурации на стороне клиента и на том, как
их использовать, чтобы сделать ssh более приятным. В конфигурационных файлах много опций,
поэтому мы собираемся разбить это на разные части. Мы рассмотрим некоторые общие настройки,
с которыми люди могут захотеть поиграть, чтобы сделать обработку сессий более эффективной,
а затем, после того, как мы обсудим некоторые более сложные темы в течение следующих
нескольких разделов, мы выполним вторую часть, чтобы рассмотреть некоторые из более
продвинутых параметров конфигурации, связанные с этими ранее затронутыми темами Это
означает, что вторая часть не будет в следующем разделе.

Есть два файла по умолчанию, которые обрабатывают конфигурацию ssh на стороне клиента
в OpenSSH. Глобальный файл обычно находится по адресу /etc/ssh/ssh_config и содержит
все настройки по умолчанию для всех пользователей системы. Пользователь также может
написать параметры конфигурации, которые переопределяют глобальный файл конфигурации,
включив файл “config” в каталог .ssh этого пользователя. Когда вызывается ssh-клиент,
порядок приоритета при разборе параметров покрывается следующим образом:

1. опции командной строки
2. пользовательский конфигурационный файл (~/.ssh/config)
3. общесистемный конфигурационный файл (/etc/ssh/ssh_config)

Все, что указано в командной строке, превосходит все остальное. Конфигурация пользователя
превосходит общесистемную конфигурацию. Общесистемный конфиг охватывает все, что не было
явно переопределено двумя другими. Это имеет смысл, но важно знать, каков приоритет
синтаксического анализа при устранении неполадок.

Сейчас акцент будет сделан на файле ~/.ssh/config, который должен содержать
пользовательские настройки.

Одним из первых параметров, которые я установил в своем собственном конфиге, является
настройка “LogLevel”. Я предпочитаю подавлять постороннюю информацию (например, баннеры),
потому что мне нравится обрабатывать отчеты с нескольких серверов, и я хочу получать
информацию только из команд, которые я запускаю, а не что-нибудь еще. Для подавления этих
сообщений я использую:

LogLevel QUIET

Вы можете настроить его на любой уровень шума, который вы предпочитаете, вплоть до
DEBUG3, что эквивалентно “ssh -vvv” для “verbose debugging”. Однако я не рекомендую
использовать для этого конфигурацию пользователя. Просто используйте флаги для
переопределения и используйте конфигурацию для подавления, как указано выше.

Следующий набор опций, которые люди часто используют, - это настройки “Match,” “User,”
“Host,” и “HostName”.
Параметр “User” используется для установки того, какое целевое имя пользователя должно
использоваться при входе в в систему. Это похоже на переход от сценария
User_A@@Workstation_A к сценарию User_B@@Server_B, который мы создали ранее. В этом
случае установка “User User_B” будет означать, что вы можете набрать “ssh Server_B”,
и он будет знать, что в качестве цели будет использоваться “User_B” вместо значения
по умолчанию “User_A”.

Опция “Host” устанавливает блок для опций, которые применяются к данному имени хоста до
следующего блока “Host” или “Match”. Имя может соответствовать шаблону с подстановочными
знаками и может включать отрицание начинающееся с “!”, если это необходимо.

“Host !*.web.com”

    сказал бы, что “the following settings up to and not including the next Match or Host
    block apply to all systems that are NOT like *.web.com” (следующие настройки вплоть
    до следующего блока Match или Host и без него применяются ко всем системам, которые
    НЕ являются *.web.com).

Предыдущий пример плохой, но в нем есть смысл. Чтобы установить глобальное содержимое
внизу, используйте параметр “Host *”, чтобы соответствовать всему, и более ранние блоки
Match/Host будут переопределять это по мере необходимости, так как они уже установили
значения, если что-то соответствует им.

Опция “Match” используется для точной настройки соответствия различных объектов. Она
может сопоставить имя пользователя с “Match user” или адрес с “Match address” и так
далее. Вы можете сделать “Match host”, но использование “Host” в качестве опции блока,
вероятно, лучше для почти всех случаев.

Опция “HostName” позволяет вам устанавливать псевдонимы в вашей конфигурации. Обычно это
устанавливается как опция после совпадения “Host”. Вы можете использовать “%h”, чтобы
указать имя хоста, которое было передано ssh в командной строке, прежде чем изменять его
с помощью “HostName”, так что “HostName” добавляется к нему по мере необходимости. Вы
также можете установить для этого адреса переопределение, например, всего, что
возвратил бы DNS.

Используя то, что мы узнали, давайте предположим, что User_A хочет войти в систему как
User_B почти во всех случаях. Однако User_A является системным администратором AIX,
поэтому для виртуальной установки IO может потребоваться войти на сервер VIO, что
означает, что целевой пользователь, скорее всего, является “padmin”, а не User_A или
User_B. Кроме того, AIX управляется Hardware Management Console (HMC) (аппаратные
средства консоли управления), который часто использует пользователя “hscroot”, а не
локальные учетные записи. Конечно, каждый набор отличается, но это стандартная практика,
поэтому мы пойдем этим путем. Организация использует стандартную схему именования,
согласно которой все серверы VIO имеют имя, которое начинается с “vio”, за которым
следует некоторый уникальный идентификатор. Объект HMCs аналогичным образом называется
“hmc”, за которым следует некоторый уникальный идентификатор. Серверы VIO также находятся
в другом домене, отличном от стандартного, который называется ‘internal.net’. Мы также
знаем, что если пользователь входит в систему как root, ключ никогда не будет
использоваться, поэтому мы хотим пропустить обмен ключами и вместо этого ввести пароль для
root. Вооружившись этими знаниями, мы можем упростить жизнь в User_A’s, если создадим
конфигурацию, которая выглядит следующим образом:

LogLevel QUIET
Host vio*
   HostName “%h.internal.net”
   User padmin
Host hmc*
   User hscroot
Match user root
   PubkeyAuthentication no
   PasswordAuthentication yes
   PreferredAuthentications password
Match user User_B
   PreferredAuthentications publickey,password
Host *
   User User_B

Параметры, которые мы установили для блока “Match user root”, должны быть достаточно
понятными на данный момент. Вариантов намного больше, чем это, и мы рассмотрим их в конце
концов, но это неплохой общий обзор того, как со временем создать конфигурацию. Не
забудьте поставить свои глобальные элементы внизу, так как они читаются сверху вниз
до первого совпадения, которое и используется для установки.

SSH - начало до конца архитектуры - защита закрытого ключа

В нашем предыдущем посте было показано, как сгенерировать пару ключей public/private без
использования пароля. Иногда это желаемая конфигурация, но лучше заблокировать закрытый
ключ с помощью ключевой фразы. Когда вы генерируете пару ключей, вы можете добавить
фразу-пароль в ответ на приглашение, также вы можете изменить существующую фразу-пароль
или добавить фразу-пароль для ключа, у которого её еще нет. Средства для этого показаны
ниже:

ssh-keygen -f ~/.ssh/id_rsa -p

Если существующая фраза пуста, это сразу же попросит вас ввести новую фразу-пароль. Если
существует фраза-пароль, она сначала запросит ввести её, прежде чем запрашивать новую.
Установка пароля на закрытый ключ является важным шагом для защиты этого ключа. Если
кому-то, не имеющему права использовать этот ключ, каким-либо образом удалось получить
его копию, он не сможет использовать ключ, пока не выяснит для него ключевую фразу. Хотя
можно грубо взломать ключ, если вы используете прилично длинную фразу, которая не является
чем-то обычно произносимым или написанным, шансы ее взлома снижаются. Также обратите
внимание, что ключевые фразы SSH допускают пробелы, так что вы можете буквально писать
бессмысленные предложения, пробелы и все остальное. Существует еще многое, что можно
сделать, чтобы снизить риск того, что кто-то использует украденный закрытый ключ для
причинения вреда, но это на стороне клиента, и есть предостережения.

Теперь, когда у нас есть парольная фраза, защищающая наш закрытый ключ, что изменилось в
том, как работает ssh? Для начала, если вы не используете Агента для загрузки ваших ключей,
каждый раз, когда вы заходите на сервер, используя этот ключ, вам будет предложено ввести
пароль. Это делает удобство хуже, а не лучше. Чтобы использовать агент, запустите ssh-add.
Если вы используете стандартное имя ключа, такое как id_rsa, id_dsa, или id_ecdsa, он
автоматически найдет и загрузит этот ключ для вас. Для каждого ключа со стандартным именем,
которое он находит, он запросит пароль. Вы даете ему фразу, а остальное он обрабатывает.
Он действует от вашего имени до тех пор, пока не получит указание выгрузить ключ или не
будет остановлен. Когда вы войдете в систему, клиент SSH увидит, что агент работает, и
когда сервер запросит ключ, он передаст этот запрос агенту, который предоставит
подтверждение того, что он знает ключ, и, таким образом, вам не будет предложено ввести
пароль. Это похоже на быстрый SSH, но сначала требуется дополнительный шаг загрузки агента.

Если вы получаете сообщение об ошибке при запуске ssh-add, есть вероятность, что
ssh-agent еще не запущен. Если это так, вы можете сначала запустить ssh-agent, взять
полученный вывод и экспортировать эти переменные. Например:

ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-w8iG9Aq6KWLR/agent.1070; export SSH_AUTH_SOCK;
SSH_AGENT_PID=1071; export SSH_AGENT_PID;

Если у вас есть ключ с пользовательским именем, например id_rsa_2016, вы можете загрузить
его, передав его имя, например, так:
ssh-add /home/User_A/.ssh/id_rsa_2016

Использование агента опасно в общей среде, где другие люди имеют повышенные привилегии.
Любой пользователь с правами root может извлечь приватный ключ из памяти, пока агент
работает от вашего имени. Вы можете выгрузить ключи перед блокировкой вашей рабочей
станции, если вы параноик, используя -D или -d, как показано ниже:

ssh-add -D #Delete all identities
ssh-add -d /home/User_A/.ssh/id_rsa_2016 #Удаляет только ключ id_rsa из списка агента

Вы также можете заблокировать и разблокировать свой агент, используя флаги “-x” и “-X”
соответственно, если вы не хотите полностью выгружать из соображений безопасности. Они
предложат вам ввести пароль для блокировки и разблокировки агента, если вы решите
использовать их.

Если вы хотите увидеть, какие ключи загружены, вы можете перечислить их с помощью
“ssh-add -l”. И если вам необходимо убедиться, какой открытый ключ соответствует
загруженному закрытому ключу, вы можете использовать “ssh-add -L”.

Наконец, если вы хотите установить ограничение по времени для загружаемого ключа, вы
можете использовать флаг -t, чтобы сделать его временным. Требуется число указывающее
(в секундах), как долго ключ должен оставаться загруженным агентом.

Остальные флаги предназначены для более продвинутых вещей, о которых я расскажу отдельно,
поэтому это все, что мы расскажем на сегодня. Если вы до сих пор не отставали, то на
данный момент вы в значительной степени находитесь на уровне среднего пользователя SSH.
(И это еще не все.) Далее мы рассмотрим некоторые параметры конфигурации клиента,
чтобы упростить управление сеансами.

SSH - начало заканчивать архитектуру - наши первые ключи

Раннее мы подготовили почву для установки и настройки SSH для входа в систему с паролем.
Это работает для многих людей, но не очень гибко. Что если пользователю необходимо
удаленно запустить рабочую нагрузку из сценария? Сценарию будет предложено ввести пароль,
и он не будет корректно обрабатываться без какого-либо помощника, такого как оболочка
Expect. Вызов perl для Expect.pm, или необработанное ожидание, основанное на TCL, или
одного из множества других языков с модулем Expect, добавит раздувание к тому, что
потенциально может быть скудным и средним сценарием оболочки, в итоге. Кроме того,
пароли часто легко взламываются, если целевая система (Server_B) плохо настроена для
обработки повторных попыток ввода пароля. Попытки грубой силы все время случаются на
машинах, обращенных к интернету. Так как же нам избавиться от необходимости пароля?
Мы будем использовать пару открытый/закрытый ключ для обработки аутентификации для нас.

Помните, что лучшее место для генерации вашей пары открытых/закрытых ключей - это
пользователь на машине, к которой вы подключаетесь FROM. В нашем примере сценария это
будет User_A на Workstation_A. Генерация ключа может быть сложной, но сейчас мы просто
сгенерируем ключ без ключевой фразы. Далее мы расскажем об использовании ключевой фразы
на ключе, почему это важно сделать и как справиться с возможностью использовать сценарии
без запроса.

Для генерации нашего начального набора ключей мы будем использовать утилиту ssh-keygen,
поставляемую OpenSSH.

ssh-keygen -t rsa -b 4096 -C “User_A@@Workstation_A initial key”

Это должно запросить путь и имя (обычно home_directory/.ssh/id_rsa), где будет
сгенерирован ключ.
Она также должна запрашивать парольную фразу, но мы пока оставляем это поле пустым,
поэтому просто нажимайте “Enter”, чтобы двигаться дальше.
Наконец, она выполнит некоторые вычисления, выведет вывод “bubble babble” и завершит
работу. Как только это будет сделано, вы должны увидеть два новых ключа в каталоге,
созданные ей. Сделайте “ls -l ~/.ssh” и посмотрите, есть ли у вас файлы “id_rsa” и
“id_rsa.pub”, сейчас (при условии, что вы не меняли путь или имя при появлении запроса).

Хорошо, с этой командой происходит несколько вещей. Во-первых, флаг “-t rsa” указывает
команде на создание ключей с использованием алгоритма шифрования RSA. “-b 4096” говорит,
чтобы сделать это алгоритм 4096 бит RSA. Флаг “-C” помещает в файл комментарий, который
помогает определить назначение ключа и того, кому он принадлежит. Этот комментарий
появляется в открытом ключе из пары. Если вы отследите этот файл, вы должны увидеть тег
комментария в конце ключа.

Получив пару ключей, поймите, что файл “id_rsa” - это ваш закрытый ключ. Это должно быть
заблокировано (обычно с 600 разрешениями) и не должно копироваться ни в какие другие
системы (за исключением некоторых очень редких исключений.) Открытый ключ - “id_rsa.pub” и
это то, что вам нужно отправить для User_B на Server_B. Содержимое этого файла открытого
ключа фактически помещается в другой файл для этого пользователя. Они должны быть помещены
в файл ~User_B/.ssh/authorized_keys. Есть несколько способов избавиться от этого. Многие
люди предпочитают использовать команду “ssh-copy-id”, чтобы вытолкнуть это, но мне не
нравится, как она обычно обрабатывает файл authorized_keys. Она просто слепо добавляет
к нему. Я предпочитаю написать функцию, которая обрабатывает передачу содержимого на
удаленный сервер, а также выводит файл author_keys удаленного сервера, выводит выходные
данные и записывает их обратно в файл authorized_keys. Эта процедура гарантирует, что
только одна копия открытого ключа когда-либо будет отправлена, независимо от того, сколько
раз вы делаете это. Детали функции находятся в моем продукте
“DSH – Distributed/Dancer’s Shell”. Если вы еще не видите ссылку для этого, это потому,
что продукт проходит тестирование Alpha и скоро будет запущен как Beta. Я опубликую
ссылку, когда она выйдет в эфир, для тех, кто заинтересован.

Как только открытый ключ окажется на удаленном сервере, убедитесь, что права доступа к
файлу авторизованному файлу также равны 600. Каталог .ssh должен быть 700. Домашний
каталог не должен быть доступен для чтения всем. Затем проверьте подключение от
User_A@@Workstation_A к User_B@@Server_B. Он должен “just work” и вывести вас в
командной строке. Если это не так, вы можете проверить журналы на удаленном сервере
(обычно /var/log/secure.log или /var/log/sshd.log или аналогичные) на наличие подсказок,
и вы можете повторить попытку соединения с “ssh -vvv”, чтобы получить подробный вывод для
других подсказок. Часто это ошибка прав доступа, поэтому дважды проверьте права доступа
к файлам.

Теперь это позволит User_A на рабочей станции_A писать сценарии, которые могут вызывать
“ssh User_B@@Server_B ” для запуска удаленных рабочих нагрузок, без запроса пароля.

Однако это не самый лучший способ справиться с этим, поэтому мы рассмотрим, как защитить
личный ключ с помощью ключевой фразы в следующем разделе, и все же сможем сделать это,
не запрашивая при каждом соединении.



How to Harden SSH with Identities and Certificates

    The Source Fantastic
    Blog Archive
    About

    2014-August-07
    Dublin Maker 2014
    New column: The Source Fantastic!

Introduction

Whether you just need to feel in power or you actually use shells for day-to-day tasks, the Secure Shell [SSH] is probably the most important administrative access tool to your servers. It's also one of the least secured mission-critical services on most UNIX servers. Why? Because for some reason people are still using mere passwords to protect their root accounts. That's not quite as bad as using telnet, but not by too much. You might as well be using plain FTP to transfer data to your server... oh, wait, that's another article.

Using passwords for your remote servers exposes you to a whole class of unnecessary security risks, which are easily avoided by either switching to SSH identities or SSH certificates. This article will cover both, since they're conceptually very similar. We'll be working very closely with OpenSSH's configuration files, hopefully explaining some of the more intimidating options you might encounter.
Why Passwords are Bad for You

I'll have a hard time explaining the entropy part any better than this xkcd, but I would like to hook into the part where you have people guessing your passwords. If you've recently set up a new server with SSH, you've probably found a whole lot of noise in your syslog about authentication failures. The majority of these will be caused by bots, which are trying to guess common user name and password combinations - and oftentimes will also try to exploit known vulnerabilities in certain versions of OpenSSH. You can mitigate the former of these issues with programmes like Fail2Ban, however you should remember that hope is not a strategy, and bandaids like these only delay the inevitable: the bot getting enough guesses in to guess your password.
(Re-)Introducing SSH Identities

Fortunately, SSH includes a feature to vastly increase the security aspect - and potentially make things more convenient for you, as well. This little bit of magic is called an SSH identity - or, more commonly, SSH keys. The keys work like this: instead of authenticating to a server by supplying a password, you generate a pair of public/private keys, much like in PGP/GPG. You keep your private key safe while uploading the public key to your server. The advantage? You increase the entropy from something under 50 bits to your key's length: typically 4096 bits or more. That's about two orders of magnitude.
Preparing the Client

Using SSH keys is very, very easy. Here's how: you generate a new key on the client machine using a command like this:

$ ssh-keygen -b 4096 -t rsa -f ~/.ssh/id_rsa

This will create two files: Your private key ~/.ssh/id_rsa, and your public key ~/.ssh/id_rsa.pub. The command will ask you for a password to secure your private key with - it's up to you whether you feel comfortable that this file won't get into the wrong hands, so choose carefully if you set a password or not. The options we used so far are the following:

-b 4096
    This instructs ssh-keygen to generate a 4096-bit key. Feel free to increase this to your desired key length - remember to use powers of two.
-t rsa
    Makes ssh-keygen generate RSA keys. According to the man page, valid algorithms are rsa, dsa, ecdsa and ed25519. ed25519 is a new, elliptic-curve based algorithm that was introduced in OpenSSH 6.5, whereas ecdsa is the old elliptic-curve DSA implementation that is known to have severe vulnerabilites. Elliptic-curve cryptography relies on the infeasibility of finding the discrete logarithm to a random elliptic curve element and is thought to be mathematically harder than the prime factorisation that RSA relies on, so in theory it should be more secure even at significantly lower key strengths. However the only implementation of this available in SSH - until very recently - was flawed the same way DSA was, and ed25519 may not be available on a lot of the machines you might want to use the key on. Finally, dsa - the standard, non-elliptic-curve variant of DSA - has many known attack vectors, so you should avoid that.
-f ~/.ssh/id_rsa
    The -f option sets the output file name for your new private key. .ssh/id_rsa in your home directory is the default for SSH RSA identities, so it will be used automatically. You're free to use any location you choose, however you must make sure that your private key file is only readable by your own user account or OpenSSH will refuse to use it. Also, the public key is placed alongside this file with a .pub extension.

After your key is generated you will be presented with a small ASCII randomart image. Feel free to remember this image, as you can use it at a later point to visually identify a suspect key. To retrieve this image later, use this command:

$ ssh-keygen -lv -f .ssh/id_rsa.pub 
2048 fa:86:25:1d:9c:c9:89:58:b2:dd:a5:5c:17:5b:f1:5f  user@some-host.example.com (RSA)
+--[ RSA 2048]----+
|            ..o. |
|    . .   o .o . |
|     * * B ..   E|
|    o o @       o|
|       .S.      .|
|      ..o        |
|      .+         |
|      ...        |
|       ..        |
+-----------------+

The generated randomart is fairly distinct - this one in particular kinda of looks like a palm tree with a coconut falling off on the right side there, doesn't it? You will probably be able to pick yours out after seeing it a few times. You'll rarely be identifying public keys like this, however. The option is rather intended for identifying host keys, by virtue of the VisualHostKey setting in SSH's config file. You should enable this setting in your ~/.ssh/config file - or the system-wide /etc/ssh/ssh_config if you have write access to it - by adding the following line at the beginning:

VisualHostKey yes

This will present the remote system's randomart picture every time you log in - and if you were using a password, it would do so before you would enter it, which would allow you to visually compare the remote host's key to what it usually looks like and see if something is wrong before giving away any sensitive passwords. This works by SSH host keys pretty much just being a private/public key pair like the one you just generated, unique to each machine.
Preparing the Server

Now that you have your identity file, you will need to log in on the server and add the contents of the ~/.ssh/id_rsa.pub file to your server's ~/.ssh/authorized_keys list. If there is no ~/.ssh directory on the remote host, create it. Your public key will just be a single line - albeit a long one - and this list of authorised keys will take as many public keys as you want. You're supposed to create a new private/public key pair on each host, by the way - not too many people seem to actually do that, mind you, but if you were to do so you could very easily revoke access from specific, compromised machines by removing the corresponding entry in the list of authorised keys. Note also that the list of keys is user-specific, meaning that any user where your public key is in the user's ~/.ssh/authorized_keys file is a user you can log in as, also implying that you can easily give someone else access to your account on a foreign machine without ever giving out any passwords or being root.

Once the key has been appended you can simply log into the machine using the ssh command line tool as normal. If your key requires a password you will be prompted to enter one - otherwise simply having the private key file will be enough to log in. To make sure that the key was actually used and to verify which key was used, you can use OpenSSH's -v flag, like so:

$ ssh -v magnus@stinger.becquerel.org
[...]
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Trying private key: /Users/magnusdeininger/.ssh/id_rsa
debug1: read PEM private key done: type RSA
debug1: Authentication succeeded (publickey).
Authenticated to stinger.becquerel.org ([46.226.106.4]:22).
[...]
magnus@stinger:~$ 

In this example I logged onto my web server. I cut away a few lines of output as they're not relevant. The highlighted debug1 messages indicate which private key file OpenSSH tried to use and more importantly that it tried - and succeeded - to log on using the publickey authentication method. Scan your debug output for lines like these to make sure it's working before heading to the next section.
Disabling Password-based Authentication

Now that you can log on with an SSH identity as opposed to a plain password, you should disable password-based authentication altogether. Make sure to only do this once you have verified that you can log in with an account that can escalate to root - or that you have an alternate way of getting back onto your machine. To lock down your server, edit your /etc/sshd/sshd_config and set the following options:

Protocol 2
PermitRootLogin without-password
PubkeyAuthentication yes
ChallengeResponseAuthentication no
PasswordAuthentication no
UsePAM yes

This sets a fairly strict set of defaults that should make most bots give up right after connecting. The options we used were:

Protocol
    Verify that only protocol version 2 is allowed. There's no point in supporting the rather dated version 1 and you're only opening yourself up to ye olde bugs of old. If this reads 1 or 1,2, change it to just 2.
PermitRootLogin
    The setting without-password is a bit of a misnomer. What that does is it enables root logins, but only if the mechanism to authenticate was not a password - i.e. it enables root logins, but only for public key authentication. This is good. Never set this to yes.
PubkeyAuthentication
    Make sure this is set to yes, otherwise you won't be able to log in once you disable passwords.
ChallengeResponseAuthentication
    Set this to no to disable non-pubkey logins that could otherwise be handled through PAM.
PasswordAuthentication
    This is what we were here for: set this to no to disable tunneled clear text passwords.
UsePAM
    If your system has PAM set up, it'll still be a good idea to keep this enabled even if you disabled password-based authentication. This is because PAM also provides session and account management, so set this to yes.

All you need to do now is restart the SSH server, like so:

# /etc/init.d/ssh restart

Note that restarting SSH will not kill your active session, so you should verify that the new settings will actually let you log in before closing your current session - and revert and restart SSH again if they don't.

For maximum effect, make sure that SSH is the only way to log on to your server. At the very least make really certain that you don't have telnet enabled! There, now you're all set and can be very confident that bots won't be able to access your machines through SSH. But wait, there's more!
SSH certificates

SSH certificates are the latest and greatest enhancement to the public and private key authentication SSH has to offer. They work by introducing a new certificate authority that signs your host or user keys, which adds a few significant improvements to the concept, such as:

Central Authority
    You probably have more than one server and more than one user account - like, root and your favourite non-root user account for normal, day-to-day work. If you generate a new key or try to give a new user access to your machines, you would have to add that key to a lot of authorized_keys files, which is a slow and error-prone, annoying process. By using SSH certificates, you can cut down on this by simply signing allowed keys once and then you're done with it.
Key Expiration
    Ever created a PGP/GPG key and lost the private key afterwards while people are still sending you messages using your old public key? Yeah, that's why you're supposed to set an expiration date for your keys. Unfortunately you can't do that with ordinary public/private key pairs in SSH - but you can with signed keys.
Signed Host Keys
    Notice how whenever you set up a new machine and connect to it for the first time, SSH asks you to accept or reject its host key? If you were paranoid enough, you were actually supposed to distribute the host key through some kind of physical medium and be very, very scared of accepting new host keys. Since that is kind of impractical, SSH certificates also let you sign host keys, so that you only need to trust the certificate authority for a domain and then you won't see any warnings about unknown host keys when connecting to new machines on that network.

SSH certificates are a relatively new feature. As such they're not used nearly enough. Now that you know why they're a good thing, let's get 'em set up, starting with the root certificate.
Creating a Root Certificate

To sign anything, you need a certificate authority to sign them with. SSH does not use the more common X.509 certificates used in SSL as they're basically just an extension to the identity concept already in place in SSH. As such you don't need to mess around with obscure OpenSSL commands; like with identities, ssh-keygen is your friend! To create a new root certificate, create a new pair of keys first:

$ ssh-keygen -b 4096 -t rsa -f example-com-ca -C "CA key for example.com"

The options we used are pretty much the same, except that this time we didn't place certificates in your ~/.ssh/ folder. Why? Because those keys are not meant to be used as identities. There is one new option we didn't use last time:

-C "CA key for example.com"
    The -C option sets a comment in your key file. The default is user@host, but since you'll be dealing with a lot of keys at a time now it might be better to give the keys moe descriptive names.

Oh, and please note that most other guides will tell you to do these steps as root. There's no real need to generate keys as root - any ordinary user will do fine. So it's probably best if you do use an ordinary user account. Also, it doesn't matter where you generate the key pair - do it on your workstation if you can, not your server. Just remember to keep the signing keys safe - this one is probably one of those that you should use a password with, because this key is really powerful and you don't need to use it very often.
Signing Host Keys

The most straightforward use of your new signing key is to sign host keys. In SSH there is no real distinction between user and host keys, and as usual we'll use ssh-keygen for this. The command is as follows:

$ ssh-keygen -s example-com-ca -h -n host.example.com -V +52w -I host.example.com-key host-key.pub

This command contains quite a few new flags, so let's have a look at those:

-s example-com-ca
    Tells ssh-keygen to sign a public key with the private key example-com-ca. Substitute example-com-ca with whatever signing key you'd like to use.
-h
    Sign a host key. Without this flag you'd be signing a user certificate. We'll get to that later.
-n host.example.com
    Sets the host name for this new signed key to host.example.com. Replace with the host name of whatever machine the host key is intended to be used for. You could specify multiple host names by separating them with commas, e.g. -n host.example.com,ssh.example.com.
-V +52w
    For how long the certificate will be valid. +52w means that the certificate will expire 52 weeks in the future, i.e. one year from now. You can also specify a range, e.g. +2w,+52w for a key that will become valid in two weeks and will expire in a year. The standard SSH date format applies, so you can use additional suffixes other than w and you can also specify explicit dates. See the Time Formats section of the sshd_config man page for further details on this.
-I host.example.com-key
    Set an identifier for the signed key, which is used in logging (and revoking the certificate later, see below).

The final argument, host-key.pub, is the public key to sign. You always sign public keys, never private keys! The certificate will be placed in a new file host-key-cert.pub. For example, if you were to sign the RSA host key of the machine you're on right now, you could do that like this:

# ssh-keygen -s example-com-ca -h -n host.example.com -V +52w -I host.example.com-key /etc/ssh/ssh_host_rsa_key.pub

Note how you would have to do this as root, as the command will try to write a new file /etc/ssh/ssh_host_rsa_key-cert.pub and that directory is hopefully only writable by root.
Using Signed Host Keys

No matter where you signed the key, copy the certificate to the appropriate location on your SSH host; i.e. copy it to /etc/ssh/ssh_host_rsa_key-cert.pub if it's an RSA key and substitute the rsa part with the correct algorithm if you signed a different type of key. Next you need to tell the OpenSSH daemon on your SSH server to use the shiny new certificate by editing /etc/ssh/sshd_config:

HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub

Note how you don't need to tell the OpenSSH daemon anything about the CA - this is not necessary as it is the client side that verifies a server's host key, so the server just needs to know where its signature is.

This is all there is to do on the server side. On the client side, you need to add the signing public key to your user's ~/.ssh/known_hosts file. Add a new line like the following:

@cert-authority *.example.com contents-of-public-key-file

All of this needs to be on a single line, like always in the known_hosts file. The individual parts of the line are as follows:

@cert-authority
    Tells SSH that the following key is not the key for a single host, but rather is the expected signing key for a set of hosts.
*.example.com
    A comma-separated set of of host name patterns for which this signing key is valid. This has the usual pattern format employed by SSH, where asterisks denote arbitrary character strings. IP adresses are also valid.
contents-of-public-key-file
    This is literally the public key in your signing key pair.

Remember that all of this has to be on a single line. For example, the bottom of our Public Keys page lists the line to add for the becquerel.org network where this site is hosted. If you were to add this particular line and test it...

$ ssh stinger.becquerel.org
Host key fingerprint is 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
+--[RSA-CERT 819--+
|                 |
|         . . .   |
|        + o E    |
|         * o     |
|      o S *      |
|   . = o + .     |
|  . * * + .      |
|   o *   +       |
|         .o      |
+-----------------+

Permission denied (publickey).

You wouldn't see the last line if you had my private key, of course. Notice how ssh doesn't ask you to add a new host key - that's because it's verified against the signing public key. To verify that it's actually doing this, the -v flag is your fried:

$ ssh -v stinger.becquerel.org
[...]
debug1: ssh_rsa_verify: signature correct
debug1: Server host key: RSA-CERT 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
debug1: Host 'stinger.becquerel.org' is known and matches the RSA-CERT host certificate.
debug1: Found CA key in /Users/mdeininger/.ssh/known_hosts:11
[...]

Notice how it says that the signature is correct and that it found [the] CA key in [the known_hosts file]. That's how you verify that it was using certificates; if it didn't know about the signing public key, it would instead say:

$ ssh -v stinger.becquerel.org
[...]
debug1: ssh_rsa_verify: signature correct
debug1: Server host key: RSA-CERT 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
debug1: No matching CA found. Retry with plain key
[...]

Output like that means you didn't add the right CA key to your ~/.ssh/known_hosts, or that the host pattern was incorrect.
Signing User Keys

This final step is conceptually very similar to the host certificates: user certificates. Again we use ssh-keygen, like so:

$ ssh-keygen -s example-com-ca -n user -V +52w -I example.com-user id_rsa.pub

Note how this command is very similar to the one we used to sign host keys. The only differences are that the -n flag now specifies users and not host names, and this time you need to feed it your user identity's public key. Like last time it will produce a file called id_rsa-cert.pub. If you were to sign your own user key, the command would be this:

$ ssh-keygen -s example-com-ca -n user -V +52w -I example.com-user ~/.ssh/id_rsa.pub

And that's all there is to signing user keys. If your server were set up to allow you to log in with keys signed by this certificate, you'd be all set without any need to manually populate any authorized_keys files. So that's what you'll do next.
Using Signed User Keys

On the client side all you need to do is make sure that the id_rsa-cert.pub sits alongside your id_rsa.pub file, so we're done with this part. We still need to tell the server to accept keys signed by your CA, however. To do so, you need to copy your example-com-ca.pub to your server - /etc/ssh would be a good location, so I'll assume that's where you copied it to. You then need to edit your /etc/ssh/sshd_config file again and add an option like this:

TrustedUserCAKeys /etc/ssh/example-com-ca.pub

You could place multiple public keys in the file referenced to by TrustedUserCAKeys - one per CA that is allowed to sign user keys that you trust. As usual, restart your SSH server to have this option take effect. And that's everything you needed to do, you can now log on using your signed key, without needing to update the authorized_keys file for each user you want to log on as. Of course you can still do that, in addition to using the CA.
Separate User and Host CAs

It is often a good idea to use separate user and host certificate authorities. This is not strictly necessary, but it could increase security if either of the private keys were compromised or if users and hosts were managed by different departments. Feel free to just generate a second CA for your users like you did before creating your host keys and substitute the signing key as appropriate.
Revoking Identities and Certificates

The final thing to know about using identities and certificates is that you can revoke them. To do so, you would again need to edit your /etc/ssh/sshd_config and add the following option:

RevokedKeys /etc/ssh/revoked-keys

Make sure that the file listed here exists and is readable, otherwise public key authentication will be refused altogether! Depending on whether you used straight identities or certificates, you can either populate this file with a list of revoked public keys, or you can use ssh-keygen to populate this file with an OpenSSH Key Revocation List, or KRL for short. Any keys listed either way in this file will be refused access when trying to authenticate. It's like an inverse authorized_keys file. This is not particularly useful to force key rotation, but it is useful if you have a very specific key that got astray - or for blocking keys that are known to suffer from the old RNG bug and are inherently insecure.

If you want to use a KRL instead of a straight list of revoked public keys, OpenSSH's swiss army knife ssh-keygen is your friend, as usual. To generate or update a KRL, use the following command:

$ ssh-keygen -k -f revoked-keys -u -s example-com-ca public-key-or-file(s)

This usage has a couple of new options, so let's have a look at those:

-k
    This flag puts ssh-keygen in KRL mode, telling it to create or update a Key Revocation List. The new KRL is placed in the file specified by the -f flag, so in this example it would be placed in the revoked-keys file.
-u
    If you specify this flag, the output KRL is appended to instead of being overriden with only the contents of the specified files. You should use this if you already have a KRL and just want to quickly revoke another public key. Note that if you specify this flag and the output file does not exist then ssh-keygen will fail with an error, so for your first run you should drop this flag.

The -s flag is optional and you only need to use it if you want to revoke a certificate by serial or id. If you only want to revoke public keys that you have then there's no need to specify the CA. The public-key-or-file(s) are the list of files that either contain public keys - one key per line - or revocation specifications. So, if you wanted to create a KRL with your own public key, you would invoke the following command:

$ ssh-keygen -k -f revoked-keys ~/.ssh/id_rsa.pub

... and now you have a new file revoked-keys in your current directory that contains this key. If you wanted to revoke an OpenSSH certificate by ID, you would create a new file ids-to-revoke with the following contents:

id: example.com-user

And the command to turn that into a KRL would be:

$ ssh-keygen -k -f revoked-keys -s example-com-ca ids-to-revoke

This usage lets you revoke keys without actually having the literal certificate or identity file on hand. You can specify multiple lines in your ids-to-revoke file with multiple id: commands. Instead of id: you can also use serial:, key: or sha1: to specify the key's serial, a plain public key or a key's SHA1 hash instead.

Remember to use the -u flag when updating a KRL and to actually distribute the KRL to the servers. scp and rsync are your friends, as usual.
Further Security Improvements

Now that you're an expert with certificates, there's a few additional things you can do to increase the security of your servers. Starting with their host keys.
Disable Unused Host Key Types

In your servers' /etc/ssh/sshd_config file, you will notice several HostKey directives. You should disable all of the host keys with algorithms that you don't use or which you don't trust. For instance on my servers, the block with host keys looks like this:

HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_dsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key

As you can see the DSA and ECDSA keys are commented out, meaning the SSH server will not use them. You could - and should - also remove these other private keys along with their public keys from /etc/ssh, as they serve no purpose. Although some distribution scripts may re-generate these upon restarting SSH.

Remember: the fewer features you enable, the fewer features can be exploited if it turns out there's a bug lurking somewhere.
Strengthen the Remaining Keys

The default host keys tend to be mere 1024 bits. There's no reason for that, so if you're paranoid you should create new host keys that are stronger:

# ssh-keygen -b 8192 -t rsa /etc/ssh/ssh_host_rsa_key

You should also regenerate your host keys if you suspect your host keys were generated when the weak RNG bug was in effect or if you suspect the private key has been compromised. Also remember to sign the public key anew and upload the certificate when you generate a new key, otherwise things will not work as intended.

Be advised that using keys stronger than 8192 bits with certificates will cause some versions of OpenSSH to ignore keys and fail. Some older versions may even be limited to 4096 bits. You will get very strange error messages citing that your certificate was not a valid certificate at all. So, best to hold off on those really strong keys for now. Also note that you should not assign a password to these keys, as you want your server to boot up automatically with SSH enabled and working.
Do not Keep Copies of the Certificates You Signed

Some guides will tell you to keep copies of the certificates you signed, or even to generate the public/private key pair for your user and hand the private key and certificate to them via a secure channel and to keep the files around so you can revoke them later.

This is not necessary, and is in fact a security concern. You do not need to have access to your users' private keys and you actually shouldn't in the first place, since it would allow you to impersonate them. Make your users generate their own key pairs and only ask them for the public key - which is the only thing you need to sign. There is also no need to keep a copy of the certificate; as long as you have the CA private key and the ID of the key which you assigned you can revoke the key using a KRL. Since you need not have the other information it is thus best to delete the public key file and the certificate once you've issued them.
Further Reading

Congratulations, you now have a tinfoil-hat level SSH server set up.

For further information on things you can configure in OpenSSH, read the following man pages:

$ man 5 ssh_config
$ man 5 sshd_config
$ man 1 ssh-keygen
