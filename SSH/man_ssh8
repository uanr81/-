SSH(1) 	General Commands Manual 	SSH(1)
NAME
ssh — OpenSSH SSH client (программа удаленного входа)
SYNOPSIS
ssh 	[-46AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile]
[-I pkcs11] [-i identity_file] [-J destination] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option]
[-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] destination [command]
DESCRIPTION
ssh (SSH client) это программа для входа в удаленную машину и для выполнения команд на удаленном компьютере. Она предназначена для обеспечения
защищенной зашифрованной связи между двумя ненадежными узлами по небезопасной сети. Соединения X11, произвольные TCP-порты и сокеты UNIX-домена
также могут быть перенаправлены по защищенному каналу.
ssh подключается и записывается в указанный адрес назначения, который может быть указан как [user@]hostname или же URI формы
ssh:// [user@]hostname[:port].Пользователь должен подтвердить свою личность на удаленном компьютере, используя один из нескольких методов
(см. Ниже). Если задана команда, она выполняется на удаленном хосте вместо оболочки входа.
Возможные варианты::

-4
    Заставляет ssh использовать только адреса IPv4.
-6
    Заставляет ssh использовать только адреса IPv6.
-A
    Включает пересылку соединения агента аутентификации. Это также можно указать для каждого узла в файле конфигурации.
    Переадресацию агента следует активировать с осторожностью. Пользователи с возможностью обойти права доступа к файлу на удаленном хосте (для
    сокета UNIX-домена агента) могут получить доступ к локальному агенту через перенаправленное соединение. Злоумышленник не может получить
    ключевой материал от агента, однако он может выполнять операции над ключами, которые позволяют им аутентифицироваться, используя
    идентификаторы, загруженные в агент.
-a
    Отключает пересылку соединения агента аутентификации.
-b bind_address
    Испольет bind_address на локальном компьютере в качестве исходного адреса соединения. Полезен только для систем с более чем одним адресом.
-C
    Запросит сжатие всех данных (включая stdin, stdout, stderr и данные для переадресованных соединений X11, TCP и UNIX). Алгоритм сжатия тот же,
    что и в gzip (1). Сжатие желательно на модемных линиях и других медленных соединениях, но только замедляет работу в быстрых сетях. Значение по
    умолчанию может быть установлено на основе хоста по ходу в файлах конфигурации; см. параметр «Сжатие».
-c cipher_spec
    Выбирает спецификацию шифрования для шифрования сеанса. cipher_spec представляет собой список шифров, разделенных запятыми, перечисленных в
    порядке предпочтения. Для получения дополнительной информации см. Ключевое слово Ciphers в ssh_config (5).
-D [bind_address:]port
    Задает локальную «динамическую» перенаправление портов на уровне приложения. Это работает путем выделения сокета для прослушивания порта на
    локальной стороне, необязательно связанного с указанным bind_address. Всякий раз, когда происходит соединение с этим портом, соединение
    пересылается по защищенному каналу, а затем протокол приложения используется для определения, где подключиться к удаленному компьютеру. В
    настоящее время поддерживаются протоколы SOCKS4 и SOCKS5, а ssh будет действовать как сервер SOCKS. Только root может перенаправлять
    привилегированные порты. Динамические переадресации портов также могут быть указаны в файле конфигурации.
    Адреса IPv6 могут быть указаны путем помещения адреса в квадратные скобки. Только суперпользователь может пересылать привилегированные порты.
    По умолчанию локальный порт привязан в соответствии с настройкой GatewayPorts. Однако для привязки соединения к определенному адресу может
    использоваться явный bind_address. Ссылка bind_address «localhost» указывает, что порт прослушивания должен быть привязан только для
    локального использования, а пустой адрес или «*» означает, что порт должен быть доступен со всех интерфейсов.
-E log_file
    Добавить отладочные журналы в log_file вместо стандартной ошибки.
-e escape_char
    Устанавливает escape-символ для сеансов с pty (по умолчанию: '~'). Эквивалентный символ распознается только в начале строки. Символ escape, за
    которым следует точка ('.'), Закрывает соединение; а затем control-Z приостанавливает соединение; и после этого сам отправляет escape-символ
    один раз. Установка символа в «none» отключает любые экраны и делает сеанс полностью прозрачным.
-F configfile
    Указывает альтернативный файл конфигурации для каждого пользователя. Если в командной строке указан конфигурационный файл, системный файл
    конфигурации (/ etc / ssh / ssh_config) будет проигнорирован. По умолчанию для конфигурационного файла для каждого пользователя
    является ~ / .ssh / config.
-f
    Запрашивает ssh для перехода к фону непосредственно перед выполнением команды. Это полезно, если ssh собирается запросить пароли или кодовые
    фразы, но пользователь хочет это в фоновом режиме. Отсюда следует -n. Рекомендуемый способ запуска X11-программ на удаленном сайте - это
    что-то вроде ssh -f host xterm. Если для параметра конфигурации ExitOnForwardFailure установлено значение «да», тогда клиент, начинающийся с
    -f, будет ждать, пока все удаленные удаленные порты будут успешно установлены, прежде чем поместить себя в фоновом режиме.
-G
    Заставляет ssh печатать свою конфигурацию после оценки блоков Host и Match и выхода.
-g
    Позволяет удаленным хостам подключаться к локальным пересылаемым портам. Если используется в мультиплексированном соединении, эта опция должна
    быть указана в основном процессе.
-I pkcs11
    Укажите общую библиотеку PKCS # 11, которую ssh должен использовать для связи с маркером PKCS # 11, предоставляющим закрытый ключ RSA
    пользователя.
-i identity_file
    Выбирает файл, из которого считывается идентификатор (закрытый ключ) для проверки подлинности с открытым ключом. По умолчанию используется
    ~ / .ssh / id_dsa, ~ / .ssh / id_ecdsa, ~ / .ssh / id_ed25519 и ~ / .ssh / id_rsa. Файлы идентификаторов также могут быть указаны для каждого
    узла в файле конфигурации. Возможно иметь несколько опций -i (и несколько идентификаторов, указанных в файлах конфигурации). Если сертификаты
    явно не указаны директивой CertificateFile, ssh также попытается загрузить информацию сертификата из файла, полученного путем добавления
    -cert.pub к идентификационным файлам имен.
-J destination
    Подключитесь к целевому хосту, сначала сделав ssh-соединение с узлом перехода, описанным в пункте назначения, и затем установите TCP-пересылку
    в конечный пункт назначения оттуда. Можно указать несколько прыжковых прыжков, разделенных запятыми. Это ярлык для указания директивы
    конфигурации ProxyJump.
-K
    Включает проверку подлинности GSSAPI и пересылку (делегирование) учетных данных GSSAPI на сервер.
-k
    Отключает отправку (делегирование) учетных данных GSSAPI на сервер.
-L [bind_address:]port:host:hostport
     
-L [bind_address:]port:remote_socket
     
-L local_socket:host:hostport
     
-L local_socket:remote_socket
    Указывает, что соединения с данным портом TCP или Unix на локальном (клиентском) хосте должны быть перенаправлены на данный хост и порт или на
    Unix-сокет на удаленную сторону. Это работает путем выделения сокета для прослушивания TCP-порта на локальной стороне, необязательно связанного
    с указанным bind_address или с Unix-сокетом. Всякий раз, когда происходит соединение с локальным портом или сокетом, соединение пересылается по
    защищенному каналу, и соединение выполняется с хостом порта хоста или с разъемом Unix remote_socket с удаленной машины.
    Перенаправления портов также могут быть указаны в файле конфигурации. Только суперпользователь может пересылать привилегированные порты. Адреса
    IPv6 могут быть указаны путем помещения адреса в квадратные скобки.
    По умолчанию локальный порт привязан в соответствии с настройкой GatewayPorts. Однако для привязки соединения к определенному адресу может
    использоваться явный bind_address. Ссылка bind_address «localhost» указывает, что порт прослушивания должен быть привязан только для локального
    использования, а пустой адрес или «*» означает, что порт должен быть доступен со всех интерфейсов.
-l login_name
    Задает пользователя для входа в систему, как на удаленном компьютере. Это также может быть указано для каждого узла в файле конфигурации.
-M
    Помещает клиент ssh в режим «мастер» для совместного использования соединений. Множественные опции -M помещают ssh в «главный» режим с
    подтверждением, которое требуется, прежде чем подчиненные соединения будут приняты. Подробнее см. Описание ControlMaster в ssh_config (5).
-m mac_spec
    Список разделенных запятыми алгоритмов MAC (код аутентификации сообщений), указанных в порядке предпочтения. Для получения дополнительной
    информации см. Ключевое слово MAC.
-N
    Не выполняйте удаленную команду. Это полезно только для пересылки портов.
-n
    Переадресовывает stdin из / dev / null (фактически, предотвращает чтение из stdin). Это необходимо использовать, когда ssh запускается в
    фоновом режиме. Общим трюком является использование этого для запуска программ X11 на удаленной машине. Например, ssh -n shadows.cs.hut.fi
    emacs & запустит emacs на shadows.cs.hut.fi, а соединение X11 будет автоматически перенаправлено по зашифрованному каналу. Программа ssh будет
    помещена в фоновом режиме. (Это не работает, если ssh необходимо запросить пароль или кодовую фразу, см. Также опцию -f.)
-O ctl_cmd
    Управление основным процессом мультиплексирования соединения. Когда задана опция -O, аргумент ctl_cmd интерпретируется и передается
    мастер-процессу. Допустимые команды: «проверить» (проверьте, что мастер-процесс запущен), «переслать» (запросить пересылку без выполнения
    команды), «отменить» (отменить пересылку), «выйти» (попросить мастера выйти) и «остановить "(Попросите мастера перестать принимать дальнейшие
    запросы мультиплексирования).
-o option
    Может использоваться для предоставления опций в формате, используемом в файле конфигурации. Это полезно для указания параметров, для которых
    нет отдельного флага командной строки. Полную информацию о параметрах, перечисленных ниже, и их возможные значения см. раздел ssh_config (5).

    AddKeysToAgent
         
    AddressFamily
         
    BatchMode
         
    BindAddress
         
    CanonicalDomains
         
    CanonicalizeFallbackLocal
         
    CanonicalizeHostname
         
    CanonicalizeMaxDots
         
    CanonicalizePermittedCNAMEs
         
    CertificateFile
         
    ChallengeResponseAuthentication
         
    CheckHostIP
         
    Ciphers
         
    ClearAllForwardings
         
    Compression
         
    ConnectionAttempts
         
    ConnectTimeout
         
    ControlMaster
         
    ControlPath
         
    ControlPersist
         
    DynamicForward
         
    EscapeChar
         
    ExitOnForwardFailure
         
    FingerprintHash
         
    ForwardAgent
         
    ForwardX11
         
    ForwardX11Timeout
         
    ForwardX11Trusted
         
    GatewayPorts
         
    GlobalKnownHostsFile
         
    GSSAPIAuthentication
         
    GSSAPIDelegateCredentials
         
    HashKnownHosts
         
    Host
         
    HostbasedAuthentication
         
    HostbasedKeyTypes
         
    HostKeyAlgorithms
         
    HostKeyAlias
         
    HostName
         
    IdentitiesOnly
         
    IdentityAgent
         
    IdentityFile
         
    Include
         
    IPQoS
         
    KbdInteractiveAuthentication
         
    KbdInteractiveDevices
         
    KexAlgorithms
         
    LocalCommand
         
    LocalForward
         
    LogLevel
         
    MACs
         
    Match
         
    NoHostAuthenticationForLocalhost
         
    NumberOfPasswordPrompts
         
    PasswordAuthentication
         
    PermitLocalCommand
         
    PKCS11Provider
         
    Port
         
    PreferredAuthentications
         
    ProxyCommand
         
    ProxyJump
         
    ProxyUseFdpass
         
    PubkeyAcceptedKeyTypes
         
    PubkeyAuthentication
         
    RekeyLimit
         
    RemoteCommand
         
    RemoteForward
         
    RequestTTY
         
    SendEnv
         
    ServerAliveInterval
         
    ServerAliveCountMax
         
    StreamLocalBindMask
         
    StreamLocalBindUnlink
         
    StrictHostKeyChecking
         
    TCPKeepAlive
         
    Tunnel
         
    TunnelDevice
         
    UpdateHostKeys
         
    UsePrivilegedPort
         
    User
         
    UserKnownHostsFile
         
    VerifyHostKeyDNS
         
    VisualHostKey
         
    XAuthLocation
         

-p port
    Порт для подключения к удаленному хосту. Это можно указать для каждого узла в файле конфигурации.
-Q query_option
    Запросы ssh для алгоритмов, поддерживаемых для указанной версии 2. Доступными функциями являются: шифр (поддерживаемые симметричные шифры),
    шифр-auth (поддерживаемые симметричные шифры, которые поддерживают аутентифицированное шифрование), mac (поддерживаемые коды целостности
    сообщений), kex (алгоритмы обмена ключами ), ключ (типы ключей), ключ-cert (типы ключей сертификатов), key-plain (типы ключей без сертификата)
    и версия протокола (поддерживаемые версии протокола SSH).
-q
    Тихий режим. Вызывает подавление большинства предупреждающих и диагностических сообщений.
-R [bind_address:]port:host:hostport
     
-R [bind_address:]port:local_socket
     
-R remote_socket:host:hostport
     
-R remote_socket:local_socket
     
-R [bind_address:]port
    Указывает, что соединения с данным TCP-портом или сокет Unix на удаленном (серверном) хосте должны быть перенаправлены на локальную сторону.
    Это работает, выделяя сокет для прослушивания либо TCP-порта, либо разъема Unix на удаленной стороне. Всякий раз, когда происходит соединение
    с этим портом или сокет Unix, соединение пересылается по защищенному каналу, а соединение выполняется с локального компьютера на явный адрес
    назначения, указанный хостом порта хоста, или local_socket или, если нет явного адресата был указан, ssh будет выступать в качестве
    прокси-сервера SOCKS 4/5 и перенаправлять соединения к получателям, запрошенным удаленным клиентом SOCKS.
    Перенаправления портов также могут быть указаны в файле конфигурации. Привилегированные порты могут быть перенаправлены только при входе в
    систему с правами администратора на удаленном компьютере. Адреса IPv6 могут быть указаны путем помещения адреса в квадратные скобки.
    По умолчанию прослушивающие сокеты TCP на сервере будут привязаны только к интерфейсу loopback. Это можно переопределить, указав bind_address.
    Пустой адрес bind_address или адрес '*' указывает, что удаленный сокет должен прослушивать все интерфейсы. Указание удаленного
    связывания_данных будет успешным только в том случае, если включена опция GatewayPorts сервера (см. Sshd_config (5)).
    Если аргумент порта равен «0», порт прослушивания будет динамически распределяться на сервере и сообщаться клиенту во время выполнения. При
    использовании вместе с -O пересылка выделенного порта будет напечатана на стандартный вывод.
-S ctl_path
    Указывает местоположение гнезда управления для совместного использования соединений или строку «none», чтобы отключить совместное
    использование. Подробнее см. Описание ControlPath и ControlMaster в ssh_config (5).
-s
    Может использоваться для запроса вызова подсистемы на удаленной системе. Подсистемы облегчают использование SSH в качестве безопасного
    транспорта для других приложений (например, sftp (1)). Подсистема указана как удаленная команда.
-T
    Отключить псевдотерминальное распределение.
-t
    Принудительное псевдотерминальное распределение. Это может быть использовано для выполнения произвольных программ на основе экрана на удаленной
    машине, что может быть очень полезно, например. при реализации услуг меню. Множественные опции tt выделяют tty, даже если ssh не имеет
    локального tty.
-V
    Отобразите номер версии и выйдите из нее.
-v
    Подробный режим. Заставляет ssh печатать отладочные сообщения о его прогрессе. Это полезно при отладке проблем подключения, проверки
    подлинности и конфигурации. Множественные -v опции увеличивают многословие. Максимум равен 3.
-W host:port
    Просит, чтобы стандартный ввод и вывод на клиенте отправлялся на хост на порту по защищенному каналу. Имплицирует -N, -T, ExitOnForwardFailure
    и ClearAllForwardings, хотя они могут быть переопределены в файле конфигурации или с использованием параметров командной строки -o.
-w local_tun[:remote_tun]
    Запросы переадресации туннельного устройства с указанными туннельными (4) устройствами между клиентом (local_tun) и сервером (remote_tun).
    Устройства могут быть указаны с помощью числового идентификатора или ключевого слова «любое», которое использует следующее доступное туннельное
    устройство. Если remote_tun не указан, по умолчанию используется значение «any». См. Также директивы Tunnel и TunnelDevice в ssh_config (5).
    Если директива Tunnel не установлена, устанавливается режим туннеля по умолчанию, который является «точка-точка».
-X
    Включает переадресацию X11. Это также можно указать для каждого узла в файле конфигурации. Пересылку X11 следует активировать с осторожностью.
    Пользователи, имеющие возможность обойти права доступа к файлам на удаленном хосте (для базы данных разрешения X пользователя), могут
    обращаться к локальному дисплею X11 через перенаправленное соединение. Затем злоумышленник может выполнять такие действия, как мониторинг
    нажатия клавиш. По этой причине пересылка X11 по умолчанию ограничена расширением X11 SECURITY. Для получения дополнительной информации см.
    Опцию ssh -Y и директиву ForwardX11Trusted в ssh_config (5).
-x
    Отключает пересылку X11.
-Y
    Включает надежную пересылку X11. Надежные пересылки X11 не подвергаются элементам управления расширения X11 SECURITY.
-y
    Отправляйте данные журнала с помощью системного модуля syslog (3). По умолчанию эта информация отправляется в stderr.

ssh может дополнительно получать данные конфигурации из конфигурационного файла для каждого пользователя и общесистемного файла конфигурации.
Формат файла и параметры конфигурации описаны в ssh_config (5).

АУТЕНТИФИКАЦИЯ

Клиент SSSS OpenSSH поддерживает протокол SSH 2.
Доступными для аутентификации методами являются: аутентификация на основе GSSAPI, аутентификация на основе хоста, аутентификация с открытым ключом,
аутентификация с запросом и ответ и аутентификация пароля. Методы проверки подлинности проверяются в порядке, указанном выше, хотя
PreferredAuthentications могут использоваться для изменения порядка по умолчанию.
Аутентификация на основе хоста работает следующим образом: если машина, с которой пользователь входит в систему, указан в /etc/hosts.equiv или
/etc/shosts.equiv на удаленном компьютере, а имена пользователей одинаковы с обеих сторон, или если файлы ~ / .rhosts или ~ / .shosts существуют в
домашнем каталоге пользователя на удаленном компьютере и содержат строку, содержащую имя клиентской машины и имя пользователя на этом компьютере,
пользователь считается для входа в систему. Кроме того, сервер должен иметь возможность проверить ключ хоста клиента (см. Описание
/ etc / ssh / ssh_known_hosts и ~ / .ssh / known_hosts, ниже), чтобы логин был разрешен. Этот метод проверки подлинности закрывает дыры
безопасности из-за IP-спуфинга, подмены DNS и спуфинга маршрутизации. [Примечание для администратора: /etc/hosts.equiv, ~ / .rhosts и
протокол rlogin / rsh в целом, по своей сути небезопасны и должны быть отключены, если требуется безопасность.]
Аутентификация открытого ключа работает следующим образом: схема основана на криптографии с открытым ключом, используя криптосистемы, где
шифрование и дешифрование выполняются с использованием отдельных ключей, и невозможно извлечь ключ дешифрования из ключа шифрования. Идея состоит
в том, что каждый пользователь создает пару открытых / закрытых ключей для целей аутентификации. Сервер знает открытый ключ, и только пользователь
знает закрытый ключ. ssh автоматически использует протокол аутентификации открытого ключа, используя один из алгоритмов DSA, ECDSA, Ed25519 или
RSA. Раздел ИСТОРИЯ ssl (8) содержит краткое описание алгоритмов DSA и RSA.
В файле ~ / .ssh / authorized_keys перечислены открытые ключи, которые разрешены для входа в систему. Когда пользователь входит в систему,
программа ssh сообщает серверу, какую пару ключей он хотел бы использовать для аутентификации. Клиент доказывает, что у него есть доступ к
закрытому ключу, и сервер проверяет, разрешен ли соответствующий открытый ключ для учетной записи.
Сервер может информировать клиента об ошибках, которые препятствовали успешной проверке подлинности открытого ключа после завершения проверки
подлинности с использованием другого метода. Их можно просмотреть, увеличив LogLevel до DEBUG или выше (например, используя флаг -v).
Пользователь создает свою пару ключей, запустив ssh-keygen (1). Это хранит закрытый ключ в ~ / .ssh / id_dsa (DSA), ~ / .ssh / id_ecdsa (ECDSA),
~ / .ssh / id_ed25519 (Ed25519) или ~ / .ssh / id_rsa (RSA) и сохраняет публичный ключ в ~ / .ssh / id_dsa.pub (DSA),
~ / .ssh / id_ecdsa.pub (ECDSA), ~ / .ssh / id_ed25519.pub (Ed25519) или ~ / .ssh / id_rsa.pub (RSA) в домашнем каталоге пользователя. Затем
пользователь должен скопировать открытый ключ в ~ / .ssh / authorized_keys в своем домашнем каталоге на удаленном компьютере. Файл authorized_keys
соответствует обычному файлу ~ / .rhosts и имеет по одному ключу в строке, хотя строки могут быть очень длинными. После этого пользователь может
войти в систему, не указывая пароль.
Вариант проверки подлинности с открытым ключом доступен в форме проверки подлинности сертификата: вместо набора открытых / закрытых ключей
используются подписанные сертификаты. Это имеет то преимущество, что один доверенный центр сертификации может использоваться вместо многих открытых
/закрытых ключей. Дополнительную информацию см. В разделе СЕРТИФИКАТЫ ssh-keygen (1).
Самый удобный способ использования открытого ключа или проверки подлинности сертификата может быть с агентом проверки подлинности. Для получения
дополнительной информации см. Ssh-agent (1) и (необязательно) директиву AddKeysToAgent в ssh_config (5).
Аутентификация запроса-ответа работает следующим образом: сервер отправляет произвольный текст «запрос» и запрашивает ответ. Примеры
аутентификации запроса-ответа включают аутентификацию BSD (см. Login.conf (5)) и PAM (некоторые системы, отличные от OpenBSD).
Наконец, если другие методы проверки не работают, ssh запрашивает у пользователя пароль. Пароль отправляется на удаленный хост для проверки;
однако, поскольку все сообщения зашифрованы, пароль не может быть замечен кем-то, кто прослушивает сеть.
ssh автоматически поддерживает и проверяет базу данных, содержащую идентификацию для всех хостов, с которыми она когда-либо использовалась. Ключи
хоста хранятся в ~ / .ssh / known_hosts в домашнем каталоге пользователя. Кроме того, файл / etc / ssh / ssh_known_hosts автоматически проверяется
на наличие известных хостов. Любые новые хосты автоматически добавляются в файл пользователя. Если идентификация хоста изменяется, ssh
предупреждает об этом и отключает аутентификацию паролей, чтобы предотвратить спуфинг сервера или атаки типа «человек-в-середине», которые в
противном случае могли бы использоваться для обхода шифрования. Параметр StrictHostKeyChecking может использоваться для управления входами в
машины, чей ключ хоста неизвестен или изменился.
Когда идентификатор пользователя был принят сервером, сервер либо выполняет указанную команду в неинтерактивном сеансе, либо, если команда не
указана, регистрируется на компьютере и предоставляет пользователю обычную оболочку в качестве интерактивного сеанса. Вся связь с удаленной
командой или оболочкой будет автоматически зашифрована.
Если запрашивается интерактивный сеанс, ssh по умолчанию запрашивает только псевдотерминал (pty) для интерактивных сеансов, когда клиент имеет его.
Флаги -T и -t могут использоваться для переопределения этого поведения.
Если псевдотерминал был выделен, пользователь может использовать escape-символы, указанные ниже.
Если псевдо-терминал не был выделен, сеанс является прозрачным и может использоваться для надежной передачи двоичных данных. В большинстве систем
установка escape-символа в «none» также сделает сеанс прозрачным, даже если используется tty.
Сеанс завершается, когда команда или оболочка удаленной машины завершается, и все соединения X11 и TCP были закрыты.

ESCAPE CHARACTERS
Когда запрашивается псевдотерминал, ssh поддерживает ряд функций с помощью escape-символа.
Один символ тильды может быть отправлен как ~~ или, следуя тильде символом, отличным от описанных ниже. Эвакуационный символ всегда должен
следовать за новой строкой, которая будет интерпретироваться как специальная. Эквивалентный символ может быть изменен в файлах конфигурации с
помощью директивы конфигурации EscapeChar или в командной строке с параметром -e.
Поддерживаемые escape-последовательности (в предположении по умолчанию «~»):

 
     
~.
    Отключить.
 
     
~^Z
    Фон ssh.
 
     
~#
    Перечислите перенаправленные соединения.
 
     
~&
    Фон ssh при выходе из системы при ожидании переадресованного соединения / сеансов X11 для завершения.
 
     
~?
    Отобразить список escape-символов.
 
     
~B
    Отправьте BREAK на удаленную систему (полезно только в том случае, если партнер поддерживает ее).
 
     
~C
    Откройте командную строку. В настоящее время это позволяет добавлять пересылки портов с использованием опций -L, -R и -D (см. Выше). Он также
    позволяет отменить существующие портовые пересылки с портом -KL [bind_address:] для локального порта -KR [bind_address:] для удаленных портов и
    -KD [bind_address:] для динамических переадресаций портов. ! позволяет пользователю выполнить локальную команду, если опция разрешить
    PermitLocalCommand включена в ssh_config (5). Доступна базовая помощь с использованием опции -h.
 
     
~R
    Запросить переключение соединения (полезно только в том случае, если партнер поддерживает его).
 
     
~V
    Уменьшите количество слов (LogLevel), когда ошибки записываются в stderr.
 
     
~v
    Увеличьте количество слов (LogLevel), когда ошибки записываются в stderr.

TCP FORWARDING

Пересылка произвольных TCP-соединений по защищенному каналу может быть указана либо в командной строке, либо в файле конфигурации. Одним из
возможных применений переадресации TCP является безопасное соединение с почтовым сервером; другой идет через брандмауэры.
В приведенном ниже примере мы рассмотрим шифрование связи между клиентом и сервером IRC, хотя IRC-сервер не поддерживает прямую поддержку
зашифрованных сообщений. Это работает следующим образом: пользователь подключается к удаленному хосту с помощью ssh, указывая порт, который будет
использоваться для переадресации соединений на удаленный сервер. После этого можно запустить службу, которая должна быть зашифрована на клиентской
машине, подключившись к одному и тому же локальному порту, а ssh зашифрует и переадресует соединение.
Следующий пример туннелирует сеанс IRC с клиентского компьютера «127.0.0.1» (localhost) на удаленный сервер «server.example.com»:

$ ssh -f -L 1234:localhost:6667 server.example.com sleep 10 
$ irc -c '#users' -p 1234 pinky 127.0.0.1

Это туннелирует соединение с IRC-сервером «server.example.com», соединяющим канал «#users», псевдоним «pinky», используя порт 1234. Неважно, какой
порт используется, если он больше 1023 (помните , только root может открывать сокеты в привилегированных портах) и не конфликтует с портами,
которые уже используются. Соединение перенаправляется на порт 6667 на удаленном сервере, поскольку это стандартный порт для IRC-сервисов.
Параметры фона -f ssh и удаленная команда «sleep 10» указаны для разрешения времени (10 секунд, в примере) для запуска службы, которая должна быть
туннелирована. Если в течение указанного времени соединения не выполняются, ssh выйдет.

X11 FORWARDING
Если для переменной ForwardX11 установлено значение «да» (или см. Описание опций -X, -x и -Y выше), и пользователь использует X11 (задана
переменная среды DISPLAY), соединение с дисплеем X11 автоматически пересылается на удаленную сторону таким образом, что любые программы X11,
запущенные из оболочки (или команды), будут проходить через зашифрованный канал, а соединение с реальным X-сервером будет производиться с локальной
машины. Пользователь не должен вручную устанавливать DISPLAY. Пересылка соединений X11 может быть настроена в командной строке или в файлах
конфигурации.
Значение DISPLAY, заданное ssh, будет указывать на серверный компьютер, но с номером дисплея больше нуля. Это нормально и происходит потому, что
ssh создает на сервере сервер «прокси» X для пересылки соединений по зашифрованному каналу.
ssh также автоматически настроит данные Xauthority на сервере. Для этого он будет генерировать произвольный файл cookie авторизации, сохранить его
в Xauthority на сервере и убедиться, что любые пересылаемые соединения несут этот файл cookie и заменяют его реальным файлом cookie при открытии
соединения. Настоящий cookie-аутентификатор никогда не отправляется на серверную машину (и никакие файлы cookie не отправляются на равнине).
Если для параметра ForwardAgent установлено значение «да» (или см. Описание опций -A и -a выше), и пользователь использует агент проверки
подлинности, соединение с агентом автоматически перенаправляется на удаленную сторону.

VERIFYING HOST KEYS
При первом подключении к серверу пользователю предоставляется отпечаток открытого ключа сервера (если параметр StrictHostKeyChecking не отключен).
Отпечатки пальцев можно определить с помощью ssh-keygen (1):

$ ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key

Если отпечаток уже известен, его можно сопоставить, и ключ можно принять или отклонить. Если доступны только устаревшие (MD5) отпечатки пальцев
для сервера, опция ssh-keygen (1) -E может использоваться для понижения алгоритма отпечатка пальца для соответствия.
Из-за трудности сравнения ключей хоста, просто глядя на строки отпечатков пальцев, существует также возможность визуально сравнивать ключи хоста,
используя случайное искусство. Установив параметр VisualHostKey на «да», маленький малый ASCII-рисунок будет отображаться при каждом подключении к
серверу, независимо от того, является ли сам сеанс интерактивным или нет. Изучая шаблон, созданный известным сервером, пользователь может легко
узнать, что ключ хоста изменился при отображении совершенно другого шаблона. Однако, поскольку эти шаблоны не однозначны, шаблон, который похож на
запомненный шаблон, дает хорошую вероятность, что ключ хоста является одним и тем же, а не гарантированным доказательством.
Чтобы получить список отпечатков пальцев вместе со своим случайным искусством для всех известных хостов, можно использовать следующую командную
строку:

$ ssh-keygen -lv -f ~/.ssh/known_hosts

Если отпечаток неизвестен, доступен альтернативный метод проверки: SSH-отпечатки, проверенные DNS. В файл зоны добавляется дополнительная запись
ресурса (RR), SSHFP, и клиент-подключитель может сопоставить отпечаток пальца с идентификатором ключа.
В этом примере мы подключаем клиента к серверу «host.example.com». Записи ресурсов SSHFP следует сначала добавить в файл зоны для host.example.com:

$ ssh-keygen -r host.example.com.

Выходные строки должны быть добавлены в файл зоны. Чтобы проверить, что зона отвечает на запросы отпечатков пальцев:

$ dig -t SSHFP host.example.com

Наконец, клиент подключается:

$ ssh -o "VerifyHostKeyDNS ask" host.example.com 
[...] 
Matching host key fingerprint found in DNS. 
Are you sure you want to continue connecting (yes/no)?

Дополнительную информацию см. В параметре VerifyHostKeyDNS в ssh_config (5).

SSH-BASED VIRTUAL PRIVATE NETWORKS
ssh содержит поддержку туннелирования виртуальной частной сети (VPN) с использованием псевдо-устройства сети tun (4), позволяющее надежно
подключать две сети. Параметр конфигурации sshd_config (5) PermitTunnel определяет, поддерживает ли сервер этот и на каком уровне (трафик уровня
2 или 3).
В следующем примере будет подключаться клиентская сеть 10.0.50.0/24 с удаленной сетью 10.0.99.0/24 с использованием двухточечного соединения от
10.1.1.1 до 10.1.1.2 при условии, что сервер SSH, работающий на шлюзе, в удаленную сеть , в 192.168.1.15, позволяет это.
На клиенте:

# ssh -f -w 0:1 192.168.1.15 true 
# ifconfig tun0 10.1.1.1 10.1.1.2 netmask 255.255.255.252 
# route add 10.0.99.0/24 10.1.1.2

На сервере:

# ifconfig tun1 10.1.1.2 10.1.1.1 netmask 255.255.255.252 
# route add 10.0.50.0/24 10.1.1.1

Клиентский доступ может быть более точно настроен через файл /root/.ssh/authorized_keys (см. Ниже) и параметр PermitRootLogin server. Следующая
запись разрешает соединения на устройстве tun (4) 1 от пользователя «jane» и на устройстве 2 от пользователя «john», если PermitRootLogin
установлен на 'forced-commands-only':

tunnel="1",command="sh /etc/netstart tun1" ssh-rsa ... jane 
tunnel="2",command="sh /etc/netstart tun2" ssh-rsa ... john

Поскольку установка на основе SSH влечет за собой достаточное количество накладных расходов, она может быть более подходящей для временных
настроек, например для беспроводных VPN. Более постоянные VPN лучше обеспечивают такие инструменты, как ipsecctl (8) и isakmpd (8).

ENVIRONMENT
Обычно ssh задает следующие переменные среды:

 
     
DISPLAY
    Переменная DISPLAY указывает местоположение сервера X11. Он автоматически устанавливает ssh, чтобы указать значение формы «hostname: n», где
    «имя хоста» указывает хост, где работает оболочка, а «n» - целое число ≥ 1. ssh использует это специальное значение для пересылки X11
    соединения по защищенному каналу. Пользователь должен нормально не устанавливать DISPLAY явно, так как это приведет к тому, что соединение X11
    небезопасно (и потребуется, чтобы пользователь вручную скопировал все необходимые файлы cookie авторизации).
     
HOME
    Установите путь к домашнему каталогу пользователя.
 
     
LOGNAME
    Синоним USER; для совместимости с системами, использующими эту переменную.
 
     
MAIL
    Установите путь к почтовому ящику пользователя.
 
     
PATH
    Установите значение PATH по умолчанию, как указано при компиляции ssh.
 
     
SSH_ASKPASS
    Если ssh требует кодовую фразу, он будет считывать кодовую фразу из текущего терминала, если он был запущен с терминала. Если ssh не имеет
    связанного с ним терминала, но установлены DISPLAY и SSH_ASKPASS, он выполнит программу, указанную SSH_ASKPASS, и откройте окно X11 для чтения
    парольной фразы. Это особенно полезно при вызове ssh из .xsession или связанного с ним скрипта. (Обратите внимание, что на некоторых машинах
    может потребоваться перенаправить вход из / dev / null, чтобы эта работа работала.)
 
     
SSH_AUTH_SOCK
    Определяет путь к сокету UNIX-домена, используемому для связи с агентом.
 
     
SSH_CONNECTION
    Определяет клиентский и серверный концы соединения. Переменная содержит четыре значения, разделенные пробелами: IP-адрес клиента, номер порта
    клиента, IP-адрес сервера и номер порта сервера.
 
     
SSH_ORIGINAL_COMMAND
    Эта переменная содержит исходную командную строку, если выполняется принудительная команда. Его можно использовать для извлечения исходных
    аргументов.
 
     
SSH_TTY
    Устанавливается имя tty (путь к устройству), связанный с текущей оболочкой или командой. Если текущий сеанс не имеет tty, эта переменная не
    задана.
 
     
SSH_TUNNEL
    Необязательно устанавливается sshd (8), чтобы содержать имена интерфейсов, назначенные, если клиентский запрос был запрошен туннельной
    пересылкой.
 
     
SSH_USER_AUTH
    При желании с помощью sshd (8) эта переменная может содержать путь к файлу, в котором перечислены методы проверки подлинности, успешно
    используемые при установлении сеанса, включая любые открытые ключи, которые были использованы.
 
     
TZ
    Эта переменная установлена ​​для указания текущего часового пояса, если она была установлена ​​при запуске демона (т. Е. Демон передает значение
    на новые соединения).
 
     
USER
    Задайте имя входа пользователя в систему.

Кроме того, ssh читает ~ / .ssh / environment и добавляет строки формата «VARNAME = значение» в среду, если файл существует, и пользователям
разрешено изменять их среду. Для получения дополнительной информации см. Параметр PermitUserEnvironment в sshd_config (5).

FILES

~/.rhosts
    Этот файл используется для аутентификации на основе хоста (см. Выше). На некоторых машинах этот файл может потребоваться для чтения в мире,
    если домашний каталог пользователя находится в разделе NFS, потому что sshd (8) читает его как root. Кроме того, этот файл должен принадлежать
    пользователю и не должен иметь права на запись для кого-либо еще. Рекомендуемое разрешение для большинства машин - чтение / запись для
    пользователя и недоступное для других.
~/.shosts
    Этот файл используется точно так же, как и .rhosts, но позволяет аутентификацию на основе хоста без разрешения входа в rlogin / rsh.
~/.ssh/
    Этот каталог является местоположением по умолчанию для всех пользовательских данных конфигурации и проверки подлинности. Не существует общего
    требования хранить все содержимое этого каталога в секрете, но рекомендуемые разрешения читаются / записываются / выполняются для пользователя
    и недоступны другим.
~/.ssh/authorized_keys
    Перечисляет открытые ключи (DSA, ECDSA, Ed25519, RSA), которые могут использоваться для входа в систему как этот пользователь. Формат этого
    файла описан на странице руководства sshd (8). Этот файл не очень чувствителен, но рекомендуемые разрешения читаются / записываются для
    пользователя и недоступны другим.
~/.ssh/config
    Это файл конфигурации для каждого пользователя. Формат файла и параметры конфигурации описаны в ssh_config (5). Из-за возможности
    злоупотребления этот файл должен иметь строгие разрешения: читать / писать для пользователя и не записываться другими.
~/.ssh/environment
    Содержит дополнительные определения для переменных среды; см. ENVIRONMENT, выше.
~/.ssh/id_dsa
     
~/.ssh/id_ecdsa
     
~/.ssh/id_ed25519
     
~/.ssh/id_rsa
    Содержит закрытый ключ для аутентификации. Эти файлы содержат конфиденциальные данные и должны читаться пользователем, но недоступны другим
    (чтение / запись / выполнение). ssh просто игнорирует файл закрытого ключа, если он доступен другим. При генерации ключа, который будет
    использоваться для шифрования чувствительной части этого файла с помощью AES-128, можно указать кодовую фразу.
~/.ssh/id_dsa.pub
     
~/.ssh/id_ecdsa.pub
     
~/.ssh/id_ed25519.pub
     
~/.ssh/id_rsa.pub
    Содержит открытый ключ для аутентификации. Эти файлы не чувствительны и могут (но не обязательно) быть удобочитаемыми кем угодно.
~/.ssh/known_hosts
    Содержит список ключей хоста для всех хостов, к которым пользователь вошел в систему, которые еще не включены в общий список известных ключей
    хоста. См. Sshd (8) для получения дополнительной информации о формате этого файла.
~/.ssh/rc
    Команды в этом файле выполняются ssh, когда пользователь входит в систему, непосредственно перед запуском оболочки (или команды) пользователя.
    Дополнительную информацию см. На странице руководства sshd (8).
/etc/hosts.equiv
    Этот файл предназначен для аутентификации на основе хоста (см. Выше). Его следует записывать только с помощью root.
/etc/shosts.equiv
    Этот файл используется точно так же, как и hosts.equiv, но позволяет аутентификацию на основе хоста без разрешения входа в rlogin / rsh.
/etc/ssh/ssh_config
    Системный файл конфигурации. Формат файла и параметры конфигурации описаны в ssh_config (5).
/etc/ssh/ssh_host_key
     
/etc/ssh/ssh_host_dsa_key
     
/etc/ssh/ssh_host_ecdsa_key
     
/etc/ssh/ssh_host_ed25519_key
     
/etc/ssh/ssh_host_rsa_key
    Эти файлы содержат частные части ключей хоста и используются для аутентификации на основе хоста.
/etc/ssh/ssh_known_hosts
    Системный список известных ключей хоста. Этот файл должен быть подготовлен системным администратором для хранения общедоступных ключей хоста
    всех компьютеров в организации. Он должен быть читаемым в мире. См. Sshd (8) для получения дополнительной информации о формате этого файла.
/etc/ssh/sshrc
    Команды в этом файле выполняются ssh, когда пользователь входит в систему, непосредственно перед запуском оболочки (или команды) пользователя.
    Дополнительную информацию см. На странице руководства sshd (8).

EXIT STATUS
ssh выходы с статусом выхода удаленной команды или 255, если произошла ошибка.
SEE ALSO
scp(1), sftp(1), ssh-add(1), ssh-agent(1), ssh-keygen(1), ssh-keyscan(1), tun(4), ssh_config(5), ssh-keysign(8), sshd(8)
STANDARDS
S. Lehtinen and C. Lonvick, The Secure Shell (SSH) Protocol Assigned Numbers, RFC 4250, January 2006.
T. Ylonen and C. Lonvick, The Secure Shell (SSH) Protocol Architecture, RFC 4251, January 2006.
T. Ylonen and C. Lonvick, The Secure Shell (SSH) Authentication Protocol, RFC 4252, January 2006.
T. Ylonen and C. Lonvick, The Secure Shell (SSH) Transport Layer Protocol, RFC 4253, January 2006.
T. Ylonen and C. Lonvick, The Secure Shell (SSH) Connection Protocol, RFC 4254, January 2006.
J. Schlyter and W. Griffin, Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints, RFC 4255, January 2006.
F. Cusack and M. Forssen, Generic Message Exchange Authentication for the Secure Shell Protocol (SSH), RFC 4256, January 2006.
J. Galbraith and P. Remaker, The Secure Shell (SSH) Session Channel Break Extension, RFC 4335, January 2006.
M. Bellare, T. Kohno, and C. Namprempre, The Secure Shell (SSH) Transport Layer Encryption Modes, RFC 4344, January 2006.
B. Harris, Improved Arcfour Modes for the Secure Shell (SSH) Transport Layer Protocol, RFC 4345, January 2006.
M. Friedl, N. Provos, and W. Simpson, Diffie-Hellman Group Exchange for the Secure Shell (SSH) Transport Layer Protocol, RFC 4419, March 2006.
J. Galbraith and R. Thayer, The Secure Shell (SSH) Public Key File Format, RFC 4716, November 2006.
D. Stebila and J. Green, Elliptic Curve Algorithm Integration in the Secure Shell Transport Layer, RFC 5656, December 2009.
A. Perrig and D. Song, Hash Visualization: a New Technique to improve Real-World Security, 1999, International Workshop on Cryptographic Techniques
and E-Commerce (CrypTEC '99).
AUTHORS
OpenSSH is a derivative of the original and free ssh 1.2.12 release by Tatu Ylonen. Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo de Raadt and Dug Song removed many bugs, re-added newer features and created OpenSSH. Markus Friedl contributed the support for SSH protocol versions 1.5 and 2.0.
