SUDO_PLUGIN(5)              BSD File Formats Manual             SUDO_PLUGIN(5)

NAME
     sudo_plugin — Sudo Plugin API

DESCRIPTION
     Начиная с версии 1.8, sudo поддерживает API-плагин для ведения журнала политики и
     сессии. Плагины могут быть скомпилированы как динамические общие объекты (по умолчанию
     в системах, которые их поддерживают) или статически скомпилированы в сам двоичный
     файл sudo. По умолчанию используются плагин политики sudoers и связанный плагин
     ввода-вывода. С помощью API плагинов можно настроить sudo на использование
     альтернативных плагинов политики и/или журналов ввода/вывода, предоставляемых третьими
     сторонами. Используемые плагины указаны в файле sudo.conf(5).

     Версия API имеет старший и младший номер. Дополнительный номер версии увеличивается
     при добавлении. Основной номер увеличивается при несовместимых изменениях. Плагин
     должен проверить переданную ему версию и убедиться, что основная версия совпадает.

     API плагина определяется заголовочным файлом sudo_plugin.h.

   Policy plugin API
     Плагин политики должен объявить и заполнить структуру policy_plugin в глобальной
     области видимости. Эта структура содержит указатели на функции, которые реализуют
     проверки политики sudo. Имя символа должно быть указано в sudo.conf(5) вместе с
     путем к плагину, чтобы sudo мог его загрузить.

     struct policy_plugin {
     #define SUDO_POLICY_PLUGIN     1
         unsigned int type; /* always SUDO_POLICY_PLUGIN */
         unsigned int version; /* always SUDO_API_VERSION */
         int (*open)(unsigned int version, sudo_conv_t conversation,
                     sudo_printf_t plugin_printf, char * const settings[],
                     char * const user_info[], char * const user_env[],
                     char * const plugin_options[]);
         void (*close)(int exit_status, int error);
         int (*show_version)(int verbose);
         int (*check_policy)(int argc, char * const argv[],
                             char *env_add[], char **command_info[],
                             char **argv_out[], char **user_env_out[]);
         int (*list)(int argc, char * const argv[], int verbose,
                     const char *list_user);
         int (*validate)(void);
         void (*invalidate)(int remove);
         int (*init_session)(struct passwd *pwd, char **user_env[]);
         void (*register_hooks)(int version,
            int (*register_hook)(struct sudo_hook *hook));
         void (*deregister_hooks)(int version,
            int (*deregister_hook)(struct sudo_hook *hook));
     };

     Структура policy_plugin имеет следующие поля:

     type  Поле типа всегда должно быть установлено SUDO_POLICY_PLUGIN.

     version
           Поле версии должно быть установлено в SUDO_API_VERSION.

           Это позволяет sudo определить версию API, для которой был построен плагин.

     open
           int (*open)(unsigned int version, sudo_conv_t conversation,
                       sudo_printf_t plugin_printf, char * const settings[],
                       char * const user_info[], char * const user_env[],
                       char * const plugin_options[]);

           Возвращает 1 при успехе, 0 при ошибке, -1, если произошла общая ошибка,
           или -2, если произошла ошибка использования. В последнем случае sudo напечатает
           сообщение об использовании до его выхода. Если возникает ошибка, плагин может
           дополнительно вызвать функцию conversation() или plugin_printf() с
           SUDO_CONF_ERROR_MSG, чтобы предоставить пользователю дополнительную информацию
           об ошибке.

           Аргументы функции следующие:

           version
                 Версия, передаваемая sudo, позволяет плагину определять основной
                 и вспомогательный номер версии API плагина, поддерживаемого sudo.

           conversation
                 Указатель на функцию conversation(), которая может использоваться
                 плагином для взаимодействия с пользователем (см. Ниже). Возвращает
                 0 при успехе и -1 при ошибке.

           plugin_printf
                 Указатель на функцию printf()-style, которая может использоваться для
                 отображения информационных сообщений или сообщений об ошибках (см. Ниже).
                 Возвращает количество символов, напечатанных в случае успеха, и -1 в
                 случае ошибки.

           settings
                 Вектор пользовательских настроек sudo в виде строк “name=value”. Вектор
                 завершается указателем NULL. Эти настройки соответствуют флагам, указанным
                 пользователем при запуске sudo. Таким образом, они будут присутствовать
                 только тогда, когда соответствующий флаг был указан в командной строке.

                 При разборе настроек плагин должен разделяться на первый знак равенства
                 (‘=’), так как поле имени никогда не будет включать в себя один, но
                 значение может.

                 bsdauth_type=string
                       Тип аутентификации, если он указан флагом -a, для использования
                       в системах, где поддерживается аутентификация BSD.

                 closefrom=number
                       Если указан, пользователь запрашивает через флаг -C, что sudo
                       закрывает все файловые дескрипторы со значением число или выше.
                       Плагин может при желании передать это или другое значение обратно
                       в список command_info.

                 debug_flags=string
                       Путь к файлу отладки, за которым следуют пробел и разделенный
                       запятыми список флагов отладки, соответствующих записи отладки
                       плагина в sudo.conf(5), если таковая имеется. Флаги передаются
                       плагину именно так, как они отображаются в sudo.conf(5). Синтаксис,
                       используемый sudo и плагином sudoers, - это subsystem@@priority, но
                       плагин может использовать другой формат, если он не содержит запятую
                       (‘,’). До sudo 1.8.12 не было никакого способа указать специфичный
                       для плагина debug_flags, так что значение всегда было таким же, как
                       использовалось внешним интерфейсом sudo и не включало имя пути,
                       только сами флаги. Начиная с версии 1.7 интерфейса плагина, sudo
                       передаст debug_flags, только если sudo.conf(5) содержит
                       специфическую для плагина запись Debug.

                 debug_level=number
                       Этот параметр устарел в пользу debug_flags.

                 ignore_ticket=bool
                       Установите в значение true, если пользователь указал флаг -k вместе
                       с командой, указывающей, что пользователь хочет игнорировать любые
                       кэшированные учетные данные аутентификации. implied_shell к истине.
                       Это позволяет использовать sudo без аргументов аналогично su(1).
                       Если плагин не поддерживает это использование, он может вернуть
                       значение -2 из функции check_policy(), что заставит sudo напечатать
                       сообщение об использовании и выйти.

                 implied_shell=bool
                       Если пользователь не указывает программу в командной строке, sudo
                       передаст плагину путь к оболочке пользователя и установит

                 login_class=string
                       Класс входа в BSD для использования при установке ограничений
                       ресурсов и значения nice, если оно указано флагом -c.

                 login_shell=bool
                       Установите в значение true, если пользователь указал флаг -i,
                       указывающий, что пользователь желает запустить оболочку входа в
                       систему.

                 max_groups=int
                       Максимальное количество групп, к которым может принадлежать
                       пользователь. Это будет присутствовать только при наличии
                       соответствующей настройки в sudo.conf(5).

                 network_addrs=list
                       Разделенный пробелами список сетевых IP-адресов и сетевых масок в
                       форме “addr/netmask”, например, “192.168.1.2/255.255.255.0”. Пары
                       адреса и маски сети могут быть либо IPv4 или IPv6, в зависимости от
                       того, что поддерживает операционная система. Если адрес содержит
                       двоеточие (‘:’), это адрес IPv6, иначе это IPv4.

                 noninteractive=bool
                       Установите в значение true, если пользователь указал флаг -n,
                       указывающий, что sudo должен работать в неинтерактивном режиме.
                       Плагин может отклонить команду, запущенную в неинтерактивном режиме,
                       если требуется взаимодействие с пользователем.

                 plugin_dir=string
                       Каталог плагинов по умолчанию, используемый интерфейсом sudo. Это
                       каталог по умолчанию, установленный во время компиляции и может не
                       соответствовать каталогу, из которого был загружен работающий плагин.
                       Может использоваться плагином для поиска файлов поддержки.

                 plugin_path=string
                       Путь к плагину, загружаемому интерфейсом sudo. Путь будет полностью
                       определенным, если плагин не был статически скомпилирован в sudo.

                 preserve_environment=bool
                       Установите в значение true, если пользователь указал флаг -E,
                       указывающий, что пользователь желает сохранить среду.

                 preserve_groups=bool
                       Установите в значение true, если пользователь указал флаг -P,
                       указывающий, что пользователь желает сохранить групповой вектор
                       вместо его установки на основе пользователя runas.

                 progname=string
                       Имя команды, под которой запускался sudo, обычно “sudo” или
                       “sudoedit”.

                 prompt=string
                       Подсказка для использования при запросе пароля, если она указана
                       с помощью флага -p.

                 remote_host=string
                       Имя удаленного хоста, на котором будет выполняться команда, если
                       оно указано с помощью параметра -h. Поддержка запуска команды на
                       удаленном хосте должна быть реализована с помощью вспомогательной
                       программы, которая выполняется вместо указанной пользователем
                       команды. Внешний интерфейс sudo способен выполнять команды только
                       на локальном хосте. Доступно только начиная с версии API 1.4.

                 run_shell=bool
                       Установите значение true, если пользователь указал флаг -s,
                       указывающий, что пользователь желает запустить оболочку.

                 runas_group=string
                       Имя группы или gid для запуска команды, как это указано
                       в флаге -g.

                 runas_user=string
                       Имя пользователя или uid для запуска команды, как
                       указано в флаге -u.

                 selinux_role=string
                       Правило SELinux для использования при выполнении команды, если
                       она указана флагом -r.

                 selinux_type=string
                       Тип SELinux, используемый при выполнении команды, если он указан
                       флагом -t.

                 set_home=bool
                       Установите в значение true, если пользователь указал флаг -H.
                       Если true, установите переменную среды HOME в домашний каталог
                       целевого пользователя.

                 sudoedit=bool
                       Устанавливается в true, когда установлен флаг -e или если он
                       вызывается как sudoedit. Плагин должен заменить редактор в argv в
                       функции check_policy() или вернуть -2 с ошибкой использования, если
                       плагин не поддерживает sudoedit. Для получения дополнительной
                       информации см. Раздел check_policy.

                 В будущем могут быть добавлены дополнительные настройки, поэтому плагин
                 должен молча игнорировать настройки, которые он не распознает.

           user_info
                 Вектор информации о пользователе, выполняющем команду в виде строк
                 “name=value”. Вектор завершается указателем NULL.

                 При синтаксическом анализе user_info плагин должен разбиваться на первый
                 знак равенства (‘=’), поскольку поле имени никогда не будет включать его
                 в себя, а значение может.

                 cols=int
                       Количество столбцов, поддерживаемых пользовательским терминалом.
                       Если нет доступных терминальных устройств, используется значение по
                       умолчанию 80.

                 cwd=string
                       Текущий рабочий каталог пользователя.

                 egid=gid_t
                       Эффективный групповой ID пользователя, вызывающего sudo.

                 euid=uid_t
                       Эффективный пользовательский ID пользователя, вызывающего sudo.

                 gid=gid_t
                       Реальный групповой ID пользователя, вызывающего sudo.

                 groups=list
                       Список дополнительных групп пользователя, отформатированный в
                       виде строки разделенной запятыми IDs групп.

                 host=string
                       Имя хоста локальной машины, возвращаемое системным вызовом
                       gethostname(2).

                 lines=int
                       Количество строк, поддерживаемых пользовательским терминалом.
                       Если нет доступного терминального устройства, используется
                       значение по умолчанию 24.

                 pgid=int
                       ID группы процессов, членом которой является запущенный процесс
                       sudo. Доступно только начиная с версии API 1.2.

                 pid=int
                      ID запущенного процесса sudo. Доступно только начиная с версии
                      API 1.2.

                 plugin_options
                       Любые (не комментирующие) строки сразу после пути к плагину
                       передаются плагину в качестве аргументов. Эти аргументы разбиваются
                       пробелами и передаются плагину в виде массива строк с нулевым
                       символом в конце. Если аргументы не указаны, plugin_options
                       будет указателем NULL.

                       ПРИМЕЧАНИЕ: параметр plugin_options доступен только начиная с
                       версии API 1.2. Плагин должен проверить версию API, указанную
                       интерфейсом sudo, перед использованием plugin_options. Невыполнение
                       этого требования может привести к сбою.

                 ppid=int
                       Идентификатор родительского процесса запущенного процесса sudo.
                       Доступно только начиная с версии API 1.2.

                 sid=int
                       Идентификатор сеанса запущенного процесса sudo или 0, если sudo не
                       является частью сеанса управления заданиями POSIX. Доступно только
                       начиная с версии API 1.2.

                 tcpgid=int
                       Идентификатор группы процессов переднего плана, связанной с
                       терминальным устройством, связанным с процессом sudo, или -1, если
                       нет терминала. Доступно только начиная с версии API 1.2.

                 tty=string
                       Путь к терминальному устройству пользователя. Если у пользователя
                       нет терминального устройства, связанного с сеансом, значение будет
                       пустым, как в “tty=”.

                 uid=uid_t
                       Реальный идентификатор пользователя, вызывающего sudo.

                 user=string
                       Имя пользователя, вызывающего sudo.

           user_env
                 Среда пользователя в форме NULL-завершенного вектора строк
                 “name=value”.

                 При синтаксическом анализе user_env плагин должен разделяться на первый
                 знак равенства (‘=’), так как поле имени никогда не будет включать в
                 себя один, но значение может.

     close
           void (*close)(int exit_status, int error);

           Функция close() вызывается, когда завершается команда, запускаемая sudo.

           Аргументы функции следующие:

           exit_status
                 Статус завершения команды, возвращаемый системным вызовом wait(2).
                 Значение exit_status не определено, если ошибка не равна нулю.

           error
                 Если команда не может быть выполнена, для нее устанавливается значение
                 errno, установленное системным вызовом execve(2). Плагин отвечает за
                 отображение информации об ошибках с помощью функции conversation() или
                 plugin_printf(). Если команда была успешно выполнена, значение ошибки
                 равно 0.

           Если функция close() не определена, плагины ведения журнала ввода-вывода не
           загружены, и в списке command_info не заданы параметры timeout и use_pty,
           внешний интерфейс sudo может выполнить команду напрямую, а не запускать ее как
           дочерний процесс.

     show_version
           int (*show_version)(int verbose);

           Функция show_version() вызывается sudo, когда пользователь указывает опцию -V.
           Плагин может отображать информацию о своей версии пользователю через функцию
           conversation() или plugin_printf(), используя SUDO_CONV_INFO_MSG. Если
           пользователь запрашивает подробную информацию о версии, будет установлен
           подробный флаг.

     check_policy
           int (*check_policy)(int argc, char * const argv[]
                               char *env_add[], char **command_info[],
                               char **argv_out[], char **user_env_out[]);

           sudo вызывает функцию check_policy(), чтобы определить, разрешено ли
           пользователю запускать указанные команды.

           Если опция sudoedit была включена в массиве настроек, переданном функции
           open(), пользователь запросил режим sudoedit. sudoedit - это механизм
           редактирования одного или нескольких файлов, в которых редактор запускается с
           учетными данными пользователя, а не с повышенными привилегиями. sudo достигает
           этого, создавая доступные для записи временные копии файлов для редактирования,
           а затем перезаписывая оригиналы временными копиями после завершения
           редактирования.  Если плагин поддерживает sudoedit, он должен выбрать
           редактор, который будет использоваться, потенциально из переменной среды
           пользователя, такой как EDITOR, и включить его в argv_out (обратите внимание,
           что переменные среды могут включать флаги командной строки). Файлы для
           редактирования должны быть скопированы из argv в argv_out, отделены от редактора
           и его аргументов элементом “--”. “--” будет удален с помощью sudo до запуска
           редактора. Плагин также должен установить sudoedit=true в списке command_info.

           Функция check_policy() возвращает 1, если команда разрешена, 0, если не
           разрешена, -1 для общей ошибки или -2 для ошибки использования или если был
           указан sudoedit, но не поддерживается плагином. В последнем случае sudo
           напечатает сообщение об использовании до его выхода. Если возникает ошибка,
           плагин может дополнительно вызвать функцию conversation() или plugin_printf()
           с помощью SUDO_CONF_ERROR_MSG, чтобы предоставить пользователю дополнительную
           информацию об ошибке.

           Аргументы функции следующие:

           argc  Количество элементов в argv, не считая конечного указателя NULL.

           argv  Вектор аргумента, описывающий команду, которую пользователь хочет
                 выполнить, в той же форме, что и передаваемый системному вызову
                 execve(2). Вектор завершается указателем NULL.

           env_add
                 Дополнительные переменные окружения, указанные пользователем в командной
                 строке в виде NULL-концевого вектора строк “name=value”. Плагин может
                 отклонить команду, если одна или несколько переменных не могут быть
                 установлены, или он может молча игнорировать такие переменные.

                 При синтаксическом анализе env_add плагин должен разбиваться на первый
                 знак равенства (‘=’), поскольку поле имени никогда не будет включать его
                 в себя, а значение может.

           command_info
                 Информация о команде, выполняемой в виде строк “name=value”. Эти значения
                 используются sudo для установки среды выполнения при запуске команды.
                 Плагин отвечает за создание и заполнение вектора, который должен
                 заканчиваться указателем NULL. Следующие значения распознаются sudo:

                 chroot=string
                       Корневой каталог, используемый при запуске команды.

                 closefrom=number
                       Если указано, sudo закроет все файловые дескрипторы со
                       значением число или выше.

                 command=string
                       Полноценный путь к команде, которая будет выполнена.

                 cwd=string
                       Текущий рабочий каталог, который нужно изменить при выполнении
                       команды.

                 exec_background=bool
                       По умолчанию sudo запускает команду в качестве процесса переднего
                       плана, пока само sudo работает на переднем плане. Когда функция
                       exec_background включена и команда выполняется в pty (из-за записи
                       в журнал ввода-вывода или установки use_pty), команда будет
                       выполняться как фоновый процесс. Попытки чтения с управляющего
                       терминала (или изменения настроек терминала) приведут к приостановке
                       команды с помощью сигнала SIGTTIN (или SIGTTOU в случае настроек
                       терминала). Если это происходит, когда sudo является процессом
                       переднего плана, команда будет предоставлена ​​управляющему терминалу
                       и возобновлена ​​на переднем плане без вмешательства пользователя.
                       Преимущество первоначального запуска команды в фоновом режиме
                       заключается в том, что sudo не нужно читать с терминала, если только
                       команда явно не запрашивает ее. В противном случае любой ввод с
                       терминала должен быть передан команде, независимо от того, требовала
                       она этого или нет (ядро буферизует терминалы, поэтому невозможно
                       определить, действительно ли команда хочет ввод). Это отличается от
                       исторического поведения sudo или когда команда не запускается в pty.

                       Чтобы это работало без проблем, операционная система должна
                       поддерживать автоматический перезапуск системных вызовов. К
                       сожалению, не все операционные системы делают это по умолчанию, и
                       даже те, которые имеют, могут иметь ошибки. Например, Mac OS X не
                       может перезапустить системные вызовы tcgetattr() и tcsetattr() (это
                       ошибка в Mac OS X). Кроме того, поскольку это поведение зависит от
                       остановки команды с помощью сигналов SIGTTIN или SIGTTOU, программы,
                       которые улавливают эти сигналы и приостанавливают себя другим
                       сигналом (обычно SIGTOP), не будут автоматически предопределены.
                       Некоторые версии команды linux su(1) ведут себя таким образом.
                       Из-за этого плагин не должен устанавливать exec_background, если
                       он явно не включен администратором, и должен быть способ включить
                       или отключить его на индивидуальной основе.

                       Этот параметр не действует, если не включено ведение журнала
                       ввода-вывода или включен use_pty.

                 execfd=number
                       Если указано, sudo будет использовать системный вызов fexecve(2)
                       для выполнения команды вместо execve(2). Указанный номер должен
                       ссылаться на дескриптор открытого файла.

                 iolog_compress=bool
                       Установите значение true, если подключаемые модули журналов
                       ввода-вывода, если таковые имеются, должны сжимать данные журнала.
                       Это подсказка для плагина ввода-вывода, который может игнорировать
                       его.

                 iolog_path=string
                       Полный путь к файлу или каталогу, в котором должен храниться
                       журнал ввода/вывода. Это подсказка для плагина ввода/вывода, который
                       может игнорировать его. Если плагин регистрации ввода/вывода не
                       загружен, этот параметр не действует.

                 iolog_stdin=bool
                       Установите в значение true, если плагины ввода/вывода, если таковые
                       имеются, должны регистрировать стандартный вход, если он не
                       подключен к оконечному устройству. Это подсказка для плагина
                       ввода/вывода, который может игнорировать его.

                 iolog_stdout=bool
                       Установите в значение true, если подключаемые модули регистрации
                       входов/выходов, если таковые имеются, должны регистрировать
                       стандартный вывод, если он не подключен к терминальному устройству.
                       Это подсказка для плагина ввода/вывода, который может игнорировать
                       его.

                 iolog_stderr=bool
                       Установите в значение true, если подключаемые модули регистрации
                       входов/выходов, если таковые имеются, должны регистрировать
                       стандартную ошибку, если она не подключена к оконечному устройству.
                       Это подсказка для плагина ввода/вывода, который может игнорировать
                       его.

                 iolog_ttyin=bool
                       Установите в значение true, если подключаемые модули регистрации
                       входов/выходов, если таковые имеются, должны регистрировать все
                       входные данные терминала. Это включает только ввод, введенный
                       пользователем, а не из канала или перенаправленный из файла. Это
                       подсказка для плагина ввода/вывода, который может игнорировать его.

                 iolog_ttyout=bool
                       Установите в значение true, если подключаемые модули регистрации
                       ввода/вывода, если таковые имеются, должны регистрировать все
                       выходные данные терминала. Это включает в себя только вывод на
                       экран, а не вывод в канал или файл. Это подсказка для плагина
                       ввода/вывода, который может игнорировать его.

                 login_class=string
                       Класс входа в BSD для использования при установке ограничений
                       ресурса и значения nice (необязательно). Эта опция установлена ​​
                       только в системах, которые поддерживают классы входа в систему.

                 nice=int
                       Хорошее значение (приоритет) для использования при выполнении
                       команды. Значение nice, если оно указано, переопределяет приоритет,
                       связанный с login_class в системах BSD.

                 noexec=bool
                       Если установлено, не позволяйте команде выполнять другие программы.

                 preserve_fds=list
                       Разделенный запятыми список файловых дескрипторов, которые должны
                       быть сохранены, независимо от значения параметра closefrom. Доступно
                       только начиная с версии API 1.5.

                 preserve_groups=bool
                       Если установлено, sudo будет сохранять вектор группы пользователя
                       вместо инициализации вектора группы на основе runas_user.

                 runas_egid=gid
                       Эффективный идентификатор группы для запуска команды. Если не
                       указано, используется значение runas_gid.

                 runas_euid=uid
                       Эффективный идентификатор пользователя для запуска команды. Если
                       не указано, используется значение runas_uid.

                 runas_gid=gid
                       Идентификатор группы от имени которой запуск команды.

                 runas_groups=list
                       Вектор дополнительной группы, используемый для команды в виде
                       списка идентификаторов групп, разделенных запятыми. Если установлено
                       preserve_groups, эта опция игнорируется.

                 runas_uid=uid
                       Идентификатор пользователя от имени которого запуск команды.

                 selinux_role=string
                       Правила SELinux для использования при выполнении команды.

                 selinux_type=string
                       Тип SELinux для использования при выполнении команды.

                 set_utmp=bool
                       Создайте запись utmp (или utmpx), когда выделяется псевдо-tty.
                       По умолчанию новая запись будет копией существующей записи
                       пользователя utmp (если есть) с обновленными полями tty,
                       time, type и pid.

                 sudoedit=bool
                       Установите в true в режиме sudoedit. Плагин может включить режим
                       sudoedit, даже если sudo не вызывался как sudoedit. Это позволяет
                       плагину выполнять подстановку команд и прозрачно включать sudoedit,
                       когда пользователь пытается запустить редактор.

                 sudoedit_checkdir=bool
                       Установите в false, чтобы отключить проверку на доступность
                       каталога в sudoedit. По умолчанию sudoedit 1.8.16 и выше проверит
                       все компоненты каталога пути, который будет отредактирован для
                       возможности записи вызывающим пользователем.Символьные ссылки не
                       будут использоваться в директориях для записи, и sudoedit откажется
                       редактировать файл, расположенный в директории для записи. Эти
                       ограничения не применяются, когда sudoedit запускается пользователем
                       root. Параметр sudoedit_follow может быть установлен в false, чтобы
                       отключить эту проверку. Доступно только начиная с версии API 1.8.

                 sudoedit_follow=bool
                       Установите в true, чтобы разрешить sudoedit редактировать файлы,
                       которые являются символическими ссылками. По умолчанию sudoedit
                       1.8.15 и выше не будет открывать символическую ссылку. Параметр
                       sudoedit_follow можно использовать для восстановления старого
                       поведения и разрешения sudoedit открывать символические ссылки.
                       Доступно только начиная с версии API 1.8.

                 timeout=int
                       Тайм-аут команды. Если не ноль, то по истечении времени ожидания
                       команда будет убита.

                 umask=octal
                       Маска создания файла, используемая при выполнении команды.

                 use_pty=bool
                       Выделите псевдо-tty для запуска команды, независимо от того,
                       используется ли ведение журнала ввода-вывода. По умолчанию
                       команда sudo запускает команду в pty только тогда, когда загружен
                       плагин журнала ввода-вывода.

                 utmp_user=string
                       Имя пользователя для использования при создании новой записи utmp
                       (или utmpx), когда set_utmp включен. Эта опция может использоваться
                       для установки пользовательского поля в записи utmp для пользователя,
                       от которого запускается команда, а не от вызывающего пользователя.
                       Если не установлен, sudo будет основывать новую запись на
                       существующей записи вызывающего пользователя.

                 Неподдерживаемые значения будут игнорироваться.

           argv_out
                 Вектор аргумента с нулевым символом в конце для передачи системному
                 вызову execve(2) при выполнении команды. Плагин отвечает за выделение
                 и заполнение вектора.

           user_env_out
                 Вектор среды с нулевым символом в конце, который будет использоваться
                 при выполнении команды. Плагин отвечает за выделение и заполнение вектора.

     list
           int (*list)(int verbose, const char *list_user,
                       int argc, char * const argv[]);

           Перечислите доступные привилегии для вызывающего пользователя. Возвращает 1
           при успехе, 0 при ошибке и -1 при ошибке. В случае ошибки плагин может
           дополнительно вызвать функцию conversation() или plugin_printf() с помощью
           SUDO_CONF_ERROR_MSG, чтобы предоставить пользователю дополнительную
           информацию об ошибке.

           Привилегии должны выводиться через функцию conversation() или plugin_printf()
           с использованием SUDO_CONV_INFO_MSG,

           verbose
                 Флаг, указывающий, будет ли список в подробном режиме или нет.

           list_user
                 Имя другого пользователя для списка привилегий, если политика это
                 позволяет. Если NULL, плагин должен перечислить привилегии вызывающего
                 пользователя.

           argc  Количество элементов в argv, не считая конечного указателя NULL.

           argv  Если не NULL, вектор аргумента, описывающий команду, которую
                 пользователь хочет проверить на соответствие политике в той же форме,
                 что и то, что будет передано системному вызову execve(2). Если команда
                 разрешена политикой, должен быть отображен полный путь к команде вместе
                 с аргументами командной строки.

     validate
           int (*validate)(void);

           Функция validate() вызывается, когда sudo запускается с флагом -v. Для
           плагинов политики, таких как sudoers, которые кэшируют учетные данные
           аутентификации, эта функция будет проверять и кэшировать учетные данные.

           Функция validate() должна быть NULL, если плагин не поддерживает
           кэширование учетных данных.

           Возвращает 1 при успехе, 0 при ошибке и -1 при ошибке. В случае ошибки
           плагин может дополнительно вызвать функцию conversation() или plugin_printf()
           с помощью SUDO_CONF_ERROR_MSG, чтобы предоставить пользователю дополнительную
           информацию об ошибке.

     invalidate
           void (*invalidate)(int remove);

           Функция invalidate() вызывается, когда sudo вызывается с флагом -k или -K. Для
           плагинов политики, таких как sudoers, которые кэшируют учетные данные
           аутентификации, эта функция аннулирует учетные данные. Если установлен флаг
           удаления, плагин может удалить учетные данные, а не просто сделать их
           недействительными.

           Функция invalidate() должна быть NULL, если плагин не поддерживает
           кэширование учетных данных.

     init_session
           int (*init_session)(struct passwd *pwd, char **user_envp[);

           Функция init_session() вызывается перед тем, как sudo устанавливает среду
           выполнения для команды. Она запускается в родительском процессе sudo и до
           любых изменений uid или gid. Это можно использовать для настройки сеанса,
           которая не поддерживается command_info, например, для открытия сеанса PAM.
           Функцию close() можно использовать для срыва сеанса, который был открыт
           init_session.

           Аргумент pwd указывает на структуру passwd для пользователя, команда будет
           выполняться так, как если бы uid команды выполнялся так, как было найдено в
           базе данных паролей, в противном случае это будет NULL.

           Аргумент user_env указывает на среду, в которой будет выполняться команда,
           в виде вектора NULL-terminated строк “name=value”. Это та же самая строка,
           которая передается обратно во внешний интерфейс через параметр user_env_out
           плагина политики. Если функция init_session() должна изменить пользовательскую
           среду, она должна обновить указатель, хранящийся в user_env. Ожидаемый вариант
           использования - объединить содержимое среды PAM (если есть) с содержимым
           user_env. ПРИМЕЧАНИЕ. Параметр user_env доступен только начиная с версии API 1.2.
           Плагин должен проверять версию API, указанную интерфейсом sudo, перед
           использованием user_env. Невыполнение этого требования может привести к сбою.

           Возвращает 1 при успехе, 0 при ошибке и -1 при ошибке. В случае ошибки плагин
           может дополнительно вызвать функцию dialog () или plugin_printf () с
           SUDO_CONF_ERROR_MSG, чтобы предоставить пользователю дополнительную
           информацию об ошибке.

     register_hooks
           void (*register_hooks)(int version,
              int (*register_hook)(struct sudo_hook *hook));

           Функция register_hooks () вызывается внешним интерфейсом sudo для регистрации
           любых хуков, которые нужны плагину. Если плагин не поддерживает хуки, то для
           register_hooks должен быть установлен указатель NULL.

           Аргумент version описывает версию API ловушек, поддерживаемую внешним
           интерфейсом sudo.

           Функция register_hook() должна использоваться для регистрации любых
           поддерживаемых ловушек, которые нужны плагину. В случае успеха возвращается 0,
           1, если тип ловушки не поддерживается, и -1, если основная версия в структурном
           хуке не совпадает с основной версией API внешнего обработчика.

           См. Раздел API функции Hook ниже для получения дополнительной информации
           о хуках.

           ПРИМЕЧАНИЕ: функция register_hooks() доступна только начиная с версии API 1.2.
           Если интерфейс sudo не поддерживает API версии 1.2 или выше, register_hooks
           не будет вызываться.

     deregister_hooks
           void (*deregister_hooks)(int version,
              int (*deregister_hook)(struct sudo_hook *hook));

           Функция deregister_hooks() вызывается внешним интерфейсом sudo для отмены
           регистрации всех хуков, зарегистрированных плагином. Если плагин не поддерживает
           хуки, для deregister_hooks должен быть установлен указатель NULL.

           Аргумент version описывает версию API ловушек, поддерживаемую внешним
           интерфейсом sudo.

           Функция deregister_hook() должна использоваться для отмены регистрации всех
           хуков, которые были установлены на месте функцией register_hook(). Если плагин
           пытается отменить регистрацию хука, который не поддерживает внешний интерфейс,
           deregister_hook выдаст ошибку.

           См. Раздел API функции Hook ниже для получения дополнительной информации
           о хуках.

           ПРИМЕЧАНИЕ: функция deregister_hooks() доступна только начиная с версии API 1.2.
           Если внешний интерфейс sudo не поддерживает API версии 1.2 или выше,
           deregister_hooks вызываться не будет.

     Policy Plugin Version Macros

     /* Версия API плагина мажор/минор. */
     #define SUDO_API_VERSION_MAJOR 1
     #define SUDO_API_VERSION_MINOR 2
     #define SUDO_API_MKVERSION(x, y) ((x << 16) | y)
     #define SUDO_API_VERSION SUDO_API_MKVERSION(SUDO_API_VERSION_MAJOR,\
                                                 SUDO_API_VERSION_MINOR)

     /* Получатели и установщики для версии API */
     #define SUDO_API_VERSION_GET_MAJOR(v) ((v) >> 16)
     #define SUDO_API_VERSION_GET_MINOR(v) ((v) & 0xffff)
     #define SUDO_API_VERSION_SET_MAJOR(vp, n) do { \
         *(vp) = (*(vp) & 0x0000ffff) | ((n) << 16); \
     } while(0)
     #define SUDO_API_VERSION_SET_MINOR(vp, n) do { \
         *(vp) = (*(vp) & 0xffff0000) | (n); \
     } while(0)

   I/O plugin API
     struct io_plugin {
     #define SUDO_IO_PLUGIN 2
         unsigned int type; /* always SUDO_IO_PLUGIN */
         unsigned int version; /* always SUDO_API_VERSION */
         int (*open)(unsigned int version, sudo_conv_t conversation,
                     sudo_printf_t plugin_printf, char * const settings[],
                     char * const user_info[], char * const command_info[],
                     int argc, char * const argv[], char * const user_env[],
                     char * const plugin_options[]);
         void (*close)(int exit_status, int error); /* wait status or error */
         int (*show_version)(int verbose);
         int (*log_ttyin)(const char *buf, unsigned int len);
         int (*log_ttyout)(const char *buf, unsigned int len);
         int (*log_stdin)(const char *buf, unsigned int len);
         int (*log_stdout)(const char *buf, unsigned int len);
         int (*log_stderr)(const char *buf, unsigned int len);
         void (*register_hooks)(int version,
            int (*register_hook)(struct sudo_hook *hook));
         void (*deregister_hooks)(int version,
            int (*deregister_hook)(struct sudo_hook *hook));
     };

     Когда подключаемый модуль ввода/вывода загружен, sudo запускает команду в псевдо-tty.
     Это позволяет регистрировать ввод и вывод с сессии пользователя. Если какой-либо из
     стандартных входных данных, стандартных выходных данных или стандартной ошибки не
     соответствует tty, sudo откроет канал для захвата ввода / вывода для регистрации
     перед передачей.

     Функция log_ttyin получает необработанный пользовательский ввод от терминального
     устройства (обратите внимание, что он будет включать в себя ввод, даже когда эхо
     отключено, например, когда пароль читается). Функция log_ttyout получает выход от
     псевдотерминала, который подходит для воспроизведения сеанса пользователя в более
     позднее время. Функции log_stdin(), log_stdout() и log_stderr() вызываются только в
     том случае, если стандартный ввод, стандартный вывод или стандартная ошибка
     соответственно соответствуют чему-то другому, чем tty.

     Любая из функций ведения журнала может быть установлена ​​в нулевой указатель, если
     запись не производится. Если функция открытия возвращает 0, плагин не будет отправлять
     ввод-вывод.

     Если функция регистрации возвращает ошибку (-1), рабочая команда будет прервана и
     все функции регистрации плагина будут отключены. Другие плагины ввода/вывода
     по-прежнему будут получать любые оставшиеся входные или выходные данные, которые еще
     не были обработаны.

     Если функция регистрации входных данных отклоняет данные, возвращая 0, команда будет
     прервана, и данные не будут переданы команде, хотя все равно будут отправлены любым
     другим подключаемым модулям ввода-вывода. Если функция регистрации выходных данных
     отклоняет данные, возвращая 0, команда будет прервана, и данные не будут записаны на
     терминал, хотя все равно будут отправлены на другие плагины ввода-вывода.

     Структура io_plugin имеет следующие поля:

     type  Поле типа всегда должно быть установлено в SUDO_IO_PLUGIN.

     version
           Поле версии должно быть установлено в SUDO_API_VERSION.

           Это позволяет sudo определить версию API, против которой был
           построен плагин.

     open
           int (*open)(unsigned int version, sudo_conv_t conversation,
                       sudo_printf_t plugin_printf, char * const settings[],
                       char * const user_info[], int argc, char * const argv[],
                       char * const user_env[], char * const plugin_options[]);

           Функция open() запускается до вызова функций log_ttyin(), log_ttyout(),
           log_stdin(), log_stdout(), log_stderr(), или show_version(). Она вызывается
           только в том случае, если запрашивается версия или если функция check_policy()
           плагина политики вернулась успешно. Возвращает 1 в случае успеха, 0 в случае
           ошибки, -1 в случае общей ошибки или -2 в случае ошибки использования. В
           последнем случае sudo напечатает сообщение об использовании до его выхода. В
           случае возникновения ошибки плагин может дополнительно вызвать функцию
           conversation() или plugin_printf() с помощью SUDO_CONF_ERROR_MSG, чтобы
           предоставить пользователю дополнительную информацию об ошибке.

           Аргументы функции следующие:

           version
                 Версия, передаваемая sudo, позволяет плагину определять основной и
                 вспомогательный номер версии API плагина, поддерживаемого sudo.

           conversation
                 Указатель на функцию conversation(), которая может использоваться функцией
                 show_version() для отображения информации о версии (смотри show_version()
                 ниже).  Функция conversation() также может использоваться для отображения
                 дополнительного сообщения об ошибке пользователю. Функция conversation()
                 возвращает 0 в случае успеха и -1 в случае неудачи.

           plugin_printf
                 Указатель на функцию printf()-style, которая может использоваться функцией
                 show_version() для отображения информации о версии (см. Show_version ниже).
                 Функция plugin_printf() может также использоваться для отображения
                 дополнительного сообщения об ошибке пользователю. Функция plugin_printf()
                 возвращает количество символов, напечатанных в случае успеха, и -1 при
                 ошибке.

           settings
                 Вектор пользовательских настроек sudo в виде строк “name=value”. Вектор
                 заканчивается нулевым указателем. Эти настройки соответствуют флагам,
                 указанным пользователем при запуске sudo. Таким образом, они будут
                 присутствовать только тогда, когда соответствующий флаг был указан в
                 командной строке.

                 При разборе настроек плагин должен разделяться на первый знак
                 равенства (‘=’), так как поле имени никогда не будет включать в себя
                 один, но значение может.

                 См. Раздел API плагина Policy для получения списка всех возможных
                 настроек.

           user_info
                 Вектор информации о пользователе, выполняющем команду в виде строк
                 “name=value”. Вектор завершается указателем NULL.

                 При синтаксическом анализе user_info плагин должен делиться на первый
                 знак равенства (‘=’), так как поле имени никогда не будет включать в
                 себя один, но значение может.

                 См. Раздел API плагина Policy для получения списка всех
                 возможных строк.

           argc  Количество элементов в argv, не считая конечного указателя NULL.

           argv  Если не-NULL, вектор аргумента, описывающий команду, которую
           пользователь желает выполнить в той же форме, что и передаваемый системному
           вызову execve(2).

           user_env
                 Среда пользователя в форме NULL-концевого вектора строк
                 “name=value”.

                 При синтаксическом анализе user_env плагин должен разделяться на первый
                 знак равенства (‘=’), так как поле имени никогда не будет включать в
                 себя один, но значение может.

           plugin_options
                 Любые (без комментариев) строки сразу после пути к плагину рассматриваются
                 как аргументы для плагина. Эти аргументы разбиваются на границе пустого
                 пространства и передаются плагину в виде массива строк, оканчивающегося
                 на NULL. Если аргументы не указаны, plugin_options будет указателем NULL.

                 NOTE: the plugin_options parameter is only available starting
                 with API version 1.2.  A plugin must check the API version
                 specified by the sudo front end before using plugin_options.
                 Failure to do so may result in a crash.

     close
           void (*close)(int exit_status, int error);

           The close() function is called when the command being run by sudo
           finishes.

           The function arguments are as follows:

           exit_status
                 The command's exit status, as returned by the wait(2) system
                 call.  The value of exit_status is undefined if error is non-
                 zero.

           error
                 If the command could not be executed, this is set to the
                 value of errno set by the execve(2) system call.  If the com‐
                 mand was successfully executed, the value of error is 0.

     show_version
           int (*show_version)(int verbose);

           The show_version() function is called by sudo when the user speci‐
           fies the -V option.  The plugin may display its version information
           to the user via the conversation() or plugin_printf() function
           using SUDO_CONV_INFO_MSG.  If the user requests detailed version
           information, the verbose flag will be set.

     log_ttyin
           int (*log_ttyin)(const char *buf, unsigned int len);

           The log_ttyin() function is called whenever data can be read from
           the user but before it is passed to the running command.  This
           allows the plugin to reject data if it chooses to (for instance if
           the input contains banned content).  Returns 1 if the data should
           be passed to the command, 0 if the data is rejected (which will
           terminate the running command) or -1 if an error occurred.

           The function arguments are as follows:

           buf   The buffer containing user input.

           len   The length of buf in bytes.

     log_ttyout
           int (*log_ttyout)(const char *buf, unsigned int len);

           The log_ttyout() function is called whenever data can be read from
           the command but before it is written to the user's terminal.  This
           allows the plugin to reject data if it chooses to (for instance if
           the output contains banned content).  Returns 1 if the data should
           be passed to the user, 0 if the data is rejected (which will termi‐
           nate the running command) or -1 if an error occurred.

           The function arguments are as follows:

           buf   The buffer containing command output.

           len   The length of buf in bytes.

     log_stdin
           int (*log_stdin)(const char *buf, unsigned int len);

           The log_stdin() function is only used if the standard input does
           not correspond to a tty device.  It is called whenever data can be
           read from the standard input but before it is passed to the running
           command.  This allows the plugin to reject data if it chooses to
           (for instance if the input contains banned content).  Returns 1 if
           the data should be passed to the command, 0 if the data is rejected
           (which will terminate the running command) or -1 if an error
           occurred.

           The function arguments are as follows:

           buf   The buffer containing user input.

           len   The length of buf in bytes.

     log_stdout
           int (*log_stdout)(const char *buf, unsigned int len);

           The log_stdout() function is only used if the standard output does
           not correspond to a tty device.  It is called whenever data can be
           read from the command but before it is written to the standard out‐
           put.  This allows the plugin to reject data if it chooses to (for
           instance if the output contains banned content).  Returns 1 if the
           data should be passed to the user, 0 if the data is rejected (which
           will terminate the running command) or -1 if an error occurred.

           The function arguments are as follows:

           buf   The buffer containing command output.

           len   The length of buf in bytes.

     log_stderr
           int (*log_stderr)(const char *buf, unsigned int len);

           The log_stderr() function is only used if the standard error does
           not correspond to a tty device.  It is called whenever data can be
           read from the command but before it is written to the standard
           error.  This allows the plugin to reject data if it chooses to (for
           instance if the output contains banned content).  Returns 1 if the
           data should be passed to the user, 0 if the data is rejected (which
           will terminate the running command) or -1 if an error occurred.

           The function arguments are as follows:

           buf   The buffer containing command output.

           len   The length of buf in bytes.

     register_hooks
           See the Policy plugin API section for a description of
           register_hooks.

     deregister_hooks
           See the Policy plugin API section for a description of
           deregister_hooks.

     I/O Plugin Version Macros

     Same as for the Policy plugin API.

   Signal handlers
     The sudo front end installs default signal handlers to trap common sig‐
     nals while the plugin functions are run.  The following signals are
     trapped by default before the command is executed:

     ·   SIGALRM
     ·   SIGHUP
     ·   SIGINT
     ·   SIGQUIT
     ·   SIGTERM
     ·   SIGTSTP
     ·   SIGUSR1
     ·   SIGUSR2

     If a fatal signal is received before the command is executed, sudo will
     call the plugin's close() function with an exit status of 128 plus the
     value of the signal that was received.  This allows for consistent log‐
     ging of commands killed by a signal for plugins that log such information
     in their close() function.

     A plugin may temporarily install its own signal handlers but must restore
     the original handler before the plugin function returns.

   Hook function API
     Beginning with plugin API version 1.2, it is possible to install hooks
     for certain functions called by the sudo front end.

     Currently, the only supported hooks relate to the handling of environment
     variables.  Hooks can be used to intercept attempts to get, set, or
     remove environment variables so that these changes can be reflected in
     the version of the environment that is used to execute a command.  A
     future version of the API will support hooking internal sudo front end
     functions as well.

     Hook structure

     Hooks in sudo are described by the following structure:

     typedef int (*sudo_hook_fn_t)();

     struct sudo_hook {
         unsigned int hook_version;
         unsigned int hook_type;
         sudo_hook_fn_t hook_fn;
         void *closure;
     };

     The sudo_hook structure has the following fields:

     hook_version
           The hook_version field should be set to SUDO_HOOK_VERSION.

     hook_type
           The hook_type field may be one of the following supported hook
           types:

           SUDO_HOOK_SETENV
                 The C library setenv(3) function.  Any registered hooks will
                 run before the C library implementation.  The hook_fn field
                 should be a function that matches the following typedef:

                 typedef int (*sudo_hook_fn_setenv_t)(const char *name,
                    const char *value, int overwrite, void *closure);

                 If the registered hook does not match the typedef the results
                 are unspecified.

           SUDO_HOOK_UNSETENV
                 The C library unsetenv(3) function.  Any registered hooks
                 will run before the C library implementation.  The hook_fn
                 field should be a function that matches the following type‐
                 def:

                 typedef int (*sudo_hook_fn_unsetenv_t)(const char *name,
                    void *closure);

           SUDO_HOOK_GETENV
                 The C library getenv(3) function.  Any registered hooks will
                 run before the C library implementation.  The hook_fn field
                 should be a function that matches the following typedef:

                 typedef int (*sudo_hook_fn_getenv_t)(const char *name,
                    char **value, void *closure);

                 If the registered hook does not match the typedef the results
                 are unspecified.

           SUDO_HOOK_PUTENV
                 The C library putenv(3) function.  Any registered hooks will
                 run before the C library implementation.  The hook_fn field
                 should be a function that matches the following typedef:

                 typedef int (*sudo_hook_fn_putenv_t)(char *string,
                    void *closure);

                 If the registered hook does not match the typedef the results
                 are unspecified.

     hook_fn
           sudo_hook_fn_t hook_fn;

           The hook_fn field should be set to the plugin's hook implementa‐
           tion.  The actual function arguments will vary depending on the
           hook_type (see hook_type above).  In all cases, the closure field
           of struct sudo_hook is passed as the last function parameter.  This
           can be used to pass arbitrary data to the plugin's hook implementa‐
           tion.

           The function return value may be one of the following:

           SUDO_HOOK_RET_ERROR
                 The hook function encountered an error.

           SUDO_HOOK_RET_NEXT
                 The hook completed without error, go on to the next hook
                 (including the native implementation if applicable).  For
                 example, a getenv(3) hook might return SUDO_HOOK_RET_NEXT if
                 the specified variable was not found in the private copy of
                 the environment.

           SUDO_HOOK_RET_STOP
                 The hook completed without error, stop processing hooks for
                 this invocation.  This can be used to replace the native
                 implementation.  For example, a setenv hook that operates on
                 a private copy of the environment but leaves environ
                 unchanged.

     Note that it is very easy to create an infinite loop when hooking C
     library functions.  For example, a getenv(3) hook that calls the
     snprintf(3) function may create a loop if the snprintf(3) implementation
     calls getenv(3) to check the locale.  To prevent this, you may wish to
     use a static variable in the hook function to guard against nested calls.
     For example:

     static int in_progress = 0; /* avoid recursion */
     if (in_progress)
         return SUDO_HOOK_RET_NEXT;
     in_progress = 1;
     ...
     in_progress = 0;
     return SUDO_HOOK_RET_STOP;

     Hook API Version Macros

     /* Hook API version major/minor */
     #define SUDO_HOOK_VERSION_MAJOR 1
     #define SUDO_HOOK_VERSION_MINOR 0
     #define SUDO_HOOK_VERSION SUDO_API_MKVERSION(SUDO_HOOK_VERSION_MAJOR,\
                                                   SUDO_HOOK_VERSION_MINOR)

     For getters and setters see the Policy plugin API.

   Remote command execution
     The sudo front end does not have native support for running remote com‐
     mands.  However, starting with sudo 1.8.8, the -h option may be used to
     specify a remote host that is passed to the policy plugin.  A plugin may
     also accept a runas_user in the form of “user@hostname” which will work
     with older versions of sudo.  It is anticipated that remote commands will
     be supported by executing a “helper” program.  The policy plugin should
     setup the execution environment such that the sudo front end will run the
     helper which, in turn, will connect to the remote host and run the com‐
     mand.

     For example, the policy plugin could utilize ssh to perform remote com‐
     mand execution.  The helper program would be responsible for running ssh
     with the proper options to use a private key or certificate that the
     remote host will accept and run a program on the remote host that would
     setup the execution environment accordingly.

     Note that remote sudoedit functionality must be handled by the policy
     plugin, not sudo itself as the front end has no knowledge that a remote
     command is being executed.  This may be addressed in a future revision of
     the plugin API.

   Conversation API
     If the plugin needs to interact with the user, it may do so via the
     conversation() function.  A plugin should not attempt to read directly
     from the standard input or the user's tty (neither of which are guaran‐
     teed to exist).  The caller must include a trailing newline in msg if one
     is to be printed.

     A printf()-style function is also available that can be used to display
     informational or error messages to the user, which is usually more conve‐
     nient for simple messages where no use input is required.

     Conversation function structures

     The conversation function takes as arguments pointers to the following
     structures:

     struct sudo_conv_message {
     #define SUDO_CONV_PROMPT_ECHO_OFF  0x0001 /* do not echo user input */
     #define SUDO_CONV_PROMPT_ECHO_ON   0x0002 /* echo user input */
     #define SUDO_CONV_ERROR_MSG        0x0003 /* error message */
     #define SUDO_CONV_INFO_MSG         0x0004 /* informational message */
     #define SUDO_CONV_PROMPT_MASK      0x0005 /* mask user input */
     #define SUDO_CONV_PROMPT_ECHO_OK   0x1000 /* flag: allow echo if no tty */
         int msg_type;
         int timeout;
         const char *msg;
     };

     #define SUDO_CONV_REPL_MAX      255

     struct sudo_conv_reply {
         char *reply;
     };

     typedef int (*sudo_conv_callback_fn_t)(int signo, void *closure);
     struct sudo_conv_callback {
         unsigned int version;
         void *closure;
         sudo_conv_callback_fn_t on_suspend;
         sudo_conv_callback_fn_t on_resume;
     };

     Pointers to the conversation() and printf()-style functions are passed in
     to the plugin's open() function when the plugin is initialized.  The fol‐
     lowing type definitions can be used in the declaration of the open()
     function:

     typedef int (*sudo_conv_t)(int num_msgs,
                  const struct sudo_conv_message msgs[],
                  struct sudo_conv_reply replies[],
                  struct sudo_conv_callback *callback);

     typedef int (*sudo_printf_t)(int msg_type, const char *fmt, ...);

     To use the conversation() function, the plugin must pass an array of
     sudo_conv_message and sudo_conv_reply structures.  There must be a struct
     sudo_conv_message and struct sudo_conv_reply for each message in the con‐
     versation.  The struct sudo_conv_callback pointer, if not NULL, should
     contain function pointers to be called when the sudo process is suspended
     and/or resumed during conversation input.  The on_suspend and on_resume
     functions are called with the signal that caused sudo to be suspended and
     the closure pointer from the struct sudo_conv_callback.  These functions
     should return 0 on success and -1 on error.  On error, the conversation
     will end and the conversation function will return a value of -1.  The
     intended use is to allow the plugin to release resources, such as locks,
     that should not be held indefinitely while suspended and then reacquire
     them when the process is resumed.  Note that the functions are not actu‐
     ally invoked from within a signal handler.

     The plugin is responsible for freeing the reply buffer located in each
     struct sudo_conv_reply, if it is not NULL.  SUDO_CONV_REPL_MAX represents
     the maximum length of the reply buffer (not including the trailing NUL
     character).  In practical terms, this is the longest password sudo will
     support.  It is also useful as a maximum value for the memset_s() func‐
     tion when clearing passwords filled in by the conversation function.

     The printf()-style function uses the same underlying mechanism as the
     conversation() function but only supports SUDO_CONV_INFO_MSG and
     SUDO_CONV_ERROR_MSG for the msg_type parameter.  It can be more conve‐
     nient than using the conversation() function if no user reply is needed
     and supports standard printf() escape sequences.

     See the sample plugin for an example of the conversation() function
     usage.

   Sudoers group plugin API
     The sudoers plugin supports its own plugin interface to allow non-Unix
     group lookups.  This can be used to query a group source other than the
     standard Unix group database.  Two sample group plugins are bundled with
     sudo, group_file and system_group, are detailed in sudoers(5).  Third
     party group plugins include a QAS AD plugin available from Quest Soft‐
     ware.

     A group plugin must declare and populate a sudoers_group_plugin struct in
     the global scope.  This structure contains pointers to the functions that
     implement plugin initialization, cleanup and group lookup.

     struct sudoers_group_plugin {
        unsigned int version;
        int (*init)(int version, sudo_printf_t sudo_printf,
                    char *const argv[]);
        void (*cleanup)(void);
        int (*query)(const char *user, const char *group,
                     const struct passwd *pwd);
     };

     The sudoers_group_plugin struct has the following fields:

     version
           The version field should be set to GROUP_API_VERSION.

           This allows sudoers to determine the API version the group plugin
           was built against.

     init
           int (*init)(int version, sudo_printf_t plugin_printf,
                       char *const argv[]);

           The init() function is called after sudoers has been parsed but
           before any policy checks.  It returns 1 on success, 0 on failure
           (or if the plugin is not configured), and -1 if a error occurred.
           If an error occurs, the plugin may call the plugin_printf() func‐
           tion with SUDO_CONF_ERROR_MSG to present additional error informa‐
           tion to the user.

           The function arguments are as follows:

           version
                 The version passed in by sudoers allows the plugin to deter‐
                 mine the major and minor version number of the group plugin
                 API supported by sudoers.

           plugin_printf
                 A pointer to a printf()-style function that may be used to
                 display informational or error message to the user.  Returns
                 the number of characters printed on success and -1 on fail‐
                 ure.

           argv  A NULL-terminated array of arguments generated from the
                 group_plugin option in sudoers.  If no arguments were given,
                 argv will be NULL.

     cleanup
           void (*cleanup)();

           The cleanup() function is called when sudoers has finished its
           group checks.  The plugin should free any memory it has allocated
           and close open file handles.

     query
           int (*query)(const char *user, const char *group,
                        const struct passwd *pwd);

           The query() function is used to ask the group plugin whether user
           is a member of group.

           The function arguments are as follows:

           user  The name of the user being looked up in the external group
                 database.

           group
                 The name of the group being queried.

           pwd   The password database entry for user, if any.  If user is not
                 present in the password database, pwd will be NULL.

     Group API Version Macros

     /* Sudoers group plugin version major/minor */
     #define GROUP_API_VERSION_MAJOR 1
     #define GROUP_API_VERSION_MINOR 0
     #define GROUP_API_VERSION ((GROUP_API_VERSION_MAJOR << 16) | \
                                GROUP_API_VERSION_MINOR)
     For getters and setters see the Policy plugin API.

PLUGIN API CHANGELOG
     The following revisions have been made to the Sudo Plugin API.

     Version 1.0
           Initial API version.

     Version 1.1 (sudo 1.8.0)
           The I/O logging plugin's open() function was modified to take the
           command_info list as an argument.

     Version 1.2 (sudo 1.8.5)
           The Policy and I/O logging plugins' open() functions are now passed
           a list of plugin parameters if any are specified in sudo.conf(5).

           A simple hooks API has been introduced to allow plugins to hook in
           to the system's environment handling functions.

           The init_session Policy plugin function is now passed a pointer to
           the user environment which can be updated as needed.  This can be
           used to merge in environment variables stored in the PAM handle
           before a command is run.

     Version 1.3 (sudo 1.8.7)
           Support for the exec_background entry has been added to the
           command_info list.

           The max_groups and plugin_dir entries were added to the settings
           list.

           The version() and close() functions are now optional.  Previously,
           a missing version() or close() function would result in a crash.
           If no policy plugin close() function is defined, a default close()
           function will be provided by the sudo front end that displays a
           warning if the command could not be executed.

           The sudo front end now installs default signal handlers to trap
           common signals while the plugin functions are run.

     Version 1.4 (sudo 1.8.8)
           The remote_host entry was added to the settings list.

     Version 1.5 (sudo 1.8.9)
           The preserve_fds entry was added to the command_info list.

     Version 1.6 (sudo 1.8.11)
           The behavior when an I/O logging plugin returns an error (-1) has
           changed.  Previously, the sudo front end took no action when the
           log_ttyin(), log_ttyout(), log_stdin(), log_stdout(), or
           log_stderr() function returned an error.

           The behavior when an I/O logging plugin returns 0 has changed.
           Previously, output from the command would be displayed to the ter‐
           minal even if an output logging function returned 0.

     Version 1.7 (sudo 1.8.12)
           The plugin_path entry was added to the settings list.

           The debug_flags entry now starts with a debug file path name and
           may occur multiple times if there are multiple plugin-specific
           Debug lines in the sudo.conf(5) file.

     Version 1.8 (sudo 1.8.15)
           The sudoedit_checkdir and sudoedit_follow entries were added to the
           command_info list.  The default value of sudoedit_checkdir was
           changed to true in sudo 1.8.16.

           The sudo conversation function now takes a pointer to a struct
           sudo_conv_callback as its fourth argument.  The sudo_conv_t defini‐
           tion has been updated to match.  The plugin must specify that it
           supports plugin API version 1.8 or higher to receive a conversation
           function pointer that supports this argument.

     Version 1.9 (sudo 1.8.16)
           The execfd entry was added to the command_info list.

SEE ALSO
     sudo.conf(5), sudoers(5), sudo(8)

AUTHORS
     Many people have worked on sudo over the years; this version consists of
     code written primarily by:

           Todd C. Miller

     See the CONTRIBUTORS file in the sudo distribution
     (https://www.sudo.ws/contributors.html) for an exhaustive list of people
     who have contributed to sudo.

BUGS
     If you feel you have found a bug in sudo, please submit a bug report at
     https://bugzilla.sudo.ws/

SUPPORT
     Limited free support is available via the sudo-users mailing list, see
     https://www.sudo.ws/mailman/listinfo/sudo-users to subscribe or search
     the archives.

DISCLAIMER
     sudo is provided “AS IS” and any express or implied warranties, includ‐
     ing, but not limited to, the implied warranties of merchantability and
     fitness for a particular purpose are disclaimed.  See the LICENSE file
     distributed with sudo or https://www.sudo.ws/license.html for complete
     details.

Sudo 1.8.16                    January 20, 2016                    Sudo 1.8.16
